// deno-fmt-ignore-file
// deno-lint-ignore-file
// This code was bundled using `deno bundle` and it's not recommended to edit it manually

var getGlobal = function() {
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global1 !== "undefined") {
        return global1;
    }
    throw new Error("unable to locate global object");
};
var global1 = getGlobal();
var index = global1.fetch.bind(global1);
global1.Headers;
global1.Request;
global1.Response;
function createCommonjsModule(fn) {
    var module = {
        exports: {}
    };
    return fn(module, module.exports), module.exports;
}
var __VIRTUAL_FILE = createCommonjsModule(function(module, exports) {
    const realFetch = index.default || index;
    const fetch1 = function(url1, options) {
        if (/^\/\//.test(url1)) {
            url1 = "https:" + url1;
        }
        return realFetch.call(this, url1, options);
    };
    fetch1.ponyfill = true;
    module.exports = exports = fetch1;
    exports.fetch = fetch1;
    exports.Headers = index.Headers;
    exports.Request = index.Request;
    exports.Response = index.Response;
    exports.default = fetch1;
});
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const fetch2 = __VIRTUAL_FILE.fetch.bind({});
fetch2.polyfill = true;
if (!commonjsGlobal.fetch) {
    commonjsGlobal.fetch = fetch2;
    commonjsGlobal.Response = __VIRTUAL_FILE.Response;
    commonjsGlobal.Headers = __VIRTUAL_FILE.Headers;
    commonjsGlobal.Request = __VIRTUAL_FILE.Request;
}
function addSignalListener(...args) {
    if (typeof Deno.addSignalListener == "function") {
        return Deno.addSignalListener(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function createHttpClient(...args) {
    if (typeof Deno.createHttpClient == "function") {
        return Deno.createHttpClient(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function consoleSize(...args) {
    if (typeof Deno.consoleSize == "function") {
        return Deno.consoleSize(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function futime(...args) {
    if (typeof Deno.futime == "function") {
        return Deno.futime(...args);
    } else {
        return Promise.reject(new TypeError("Requires --unstable"));
    }
}
function futimeSync(...args) {
    if (typeof Deno.futimeSync == "function") {
        return Deno.futimeSync(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function getUid(...args) {
    if (typeof Deno.getUid == "function") {
        return Deno.getUid(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function hostname(...args) {
    if (typeof Deno.hostname == "function") {
        return Deno.hostname(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function loadavg(...args) {
    if (typeof Deno.loadavg == "function") {
        return Deno.loadavg(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function osRelease(...args) {
    if (typeof Deno.osRelease == "function") {
        return Deno.osRelease(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function removeSignalListener(...args) {
    if (typeof Deno.removeSignalListener == "function") {
        return Deno.removeSignalListener(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function setRaw(...args) {
    if (typeof Deno.setRaw == "function") {
        return Deno.setRaw(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function systemMemoryInfo(...args) {
    if (typeof Deno.systemMemoryInfo == "function") {
        return Deno.systemMemoryInfo(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function utime(...args) {
    if (typeof Deno.utime == "function") {
        return Deno.utime(...args);
    } else {
        return Promise.reject(new TypeError("Requires --unstable"));
    }
}
function utimeSync(...args) {
    if (typeof Deno.utimeSync == "function") {
        return Deno.utimeSync(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function networkInterfaces(...args) {
    if (typeof Deno.networkInterfaces == "function") {
        return Deno.networkInterfaces(...args);
    } else {
        throw new TypeError("Requires --unstable");
    }
}
function deferred() {
    let methods1;
    let state1 = "pending";
    const promise = new Promise((resolve7, reject)=>{
        methods1 = {
            async resolve (value) {
                await value;
                state1 = "fulfilled";
                resolve7(value);
            },
            reject (reason) {
                state1 = "rejected";
                reject(reason);
            }
        };
    });
    Object.defineProperty(promise, "state", {
        get: ()=>state1
    });
    return Object.assign(promise, methods1);
}
function delay(ms, options = {}) {
    const { signal  } = options;
    if (signal?.aborted) {
        return Promise.reject(new DOMException("Delay was aborted.", "AbortError"));
    }
    return new Promise((resolve8, reject)=>{
        const abort = ()=>{
            clearTimeout(i3);
            reject(new DOMException("Delay was aborted.", "AbortError"));
        };
        const done = ()=>{
            signal?.removeEventListener("abort", abort);
            resolve8();
        };
        const i3 = setTimeout(done, ms);
        signal?.addEventListener("abort", abort, {
            once: true
        });
    });
}
const { Deno: Deno1  } = globalThis;
const noColor = typeof Deno1?.noColor === "boolean" ? Deno1.noColor : true;
let enabled = !noColor;
function code(open2, close2) {
    return {
        open: `\x1b[${open2.join(";")}m`,
        close: `\x1b[${close2}m`,
        regexp: new RegExp(`\\x1b\\[${close2}m`, "g")
    };
}
function run(str, code1) {
    return enabled ? `${code1.open}${str.replace(code1.regexp, code1.open)}${code1.close}` : str;
}
function bold(str) {
    return run(str, code([
        1
    ], 22));
}
function red(str) {
    return run(str, code([
        31
    ], 39));
}
function green(str) {
    return run(str, code([
        32
    ], 39));
}
function white(str) {
    return run(str, code([
        37
    ], 39));
}
function gray(str) {
    return brightBlack(str);
}
function brightBlack(str) {
    return run(str, code([
        90
    ], 39));
}
function bgRed(str) {
    return run(str, code([
        41
    ], 49));
}
function bgGreen(str) {
    return run(str, code([
        42
    ], 49));
}
const ANSI_PATTERN = new RegExp([
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))", 
].join("|"), "g");
function stripColor(string) {
    return string.replace(ANSI_PATTERN, "");
}
var DiffType;
(function(DiffType1) {
    DiffType1["removed"] = "removed";
    DiffType1["common"] = "common";
    DiffType1["added"] = "added";
})(DiffType || (DiffType = {}));
const REMOVED = 1;
const COMMON = 2;
const ADDED = 3;
function createCommon(A, B, reverse1) {
    const common2 = [];
    if (A.length === 0 || B.length === 0) return [];
    for(let i4 = 0; i4 < Math.min(A.length, B.length); i4 += 1){
        if (A[reverse1 ? A.length - i4 - 1 : i4] === B[reverse1 ? B.length - i4 - 1 : i4]) {
            common2.push(A[reverse1 ? A.length - i4 - 1 : i4]);
        } else {
            return common2;
        }
    }
    return common2;
}
function diff(A1, B1) {
    const prefixCommon = createCommon(A1, B1);
    const suffixCommon = createCommon(A1.slice(prefixCommon.length), B1.slice(prefixCommon.length), true).reverse();
    A1 = suffixCommon.length ? A1.slice(prefixCommon.length, -suffixCommon.length) : A1.slice(prefixCommon.length);
    B1 = suffixCommon.length ? B1.slice(prefixCommon.length, -suffixCommon.length) : B1.slice(prefixCommon.length);
    const swapped1 = B1.length > A1.length;
    [A1, B1] = swapped1 ? [
        B1,
        A1
    ] : [
        A1,
        B1
    ];
    const M1 = A1.length;
    const N1 = B1.length;
    if (!M1 && !N1 && !suffixCommon.length && !prefixCommon.length) return [];
    if (!N1) {
        return [
            ...prefixCommon.map((c1)=>({
                    type: DiffType.common,
                    value: c1
                })
            ),
            ...A1.map((a1)=>({
                    type: swapped1 ? DiffType.added : DiffType.removed,
                    value: a1
                })
            ),
            ...suffixCommon.map((c2)=>({
                    type: DiffType.common,
                    value: c2
                })
            ), 
        ];
    }
    const offset = N1;
    const delta = M1 - N1;
    const size = M1 + N1 + 1;
    const fp1 = Array.from({
        length: size
    }, ()=>({
            y: -1,
            id: -1
        })
    );
    const routes = new Uint32Array((M1 * N1 + size + 1) * 2);
    const diffTypesPtrOffset = routes.length / 2;
    let ptr = 0;
    let p1 = -1;
    function backTrace(A, B, current, swapped) {
        const M = A.length;
        const N = B.length;
        const result = [];
        let a2 = M - 1;
        let b1 = N - 1;
        let j = routes[current.id];
        let type1 = routes[current.id + diffTypesPtrOffset];
        while(true){
            if (!j && !type1) break;
            const prev = j;
            if (type1 === 1) {
                result.unshift({
                    type: swapped ? DiffType.removed : DiffType.added,
                    value: B[b1]
                });
                b1 -= 1;
            } else if (type1 === 3) {
                result.unshift({
                    type: swapped ? DiffType.added : DiffType.removed,
                    value: A[a2]
                });
                a2 -= 1;
            } else {
                result.unshift({
                    type: DiffType.common,
                    value: A[a2]
                });
                a2 -= 1;
                b1 -= 1;
            }
            j = routes[prev];
            type1 = routes[prev + diffTypesPtrOffset];
        }
        return result;
    }
    function createFP(slide, down, k1, M) {
        if (slide && slide.y === -1 && down && down.y === -1) {
            return {
                y: 0,
                id: 0
            };
        }
        if (down && down.y === -1 || k1 === M || (slide && slide.y) > (down && down.y) + 1) {
            const prev = slide.id;
            ptr++;
            routes[ptr] = prev;
            routes[ptr + diffTypesPtrOffset] = ADDED;
            return {
                y: slide.y,
                id: ptr
            };
        } else {
            const prev = down.id;
            ptr++;
            routes[ptr] = prev;
            routes[ptr + diffTypesPtrOffset] = REMOVED;
            return {
                y: down.y + 1,
                id: ptr
            };
        }
    }
    function snake(k2, slide, down, _offset, A, B) {
        const M = A.length;
        const N = B.length;
        if (k2 < -N || M < k2) return {
            y: -1,
            id: -1
        };
        const fp = createFP(slide, down, k2, M);
        while(fp.y + k2 < M && fp.y < N && A[fp.y + k2] === B[fp.y]){
            const prev = fp.id;
            ptr++;
            fp.id = ptr;
            fp.y += 1;
            routes[ptr] = prev;
            routes[ptr + diffTypesPtrOffset] = COMMON;
        }
        return fp;
    }
    while(fp1[delta + offset].y < N1){
        p1 = p1 + 1;
        for(let k3 = -p1; k3 < delta; ++k3){
            fp1[k3 + offset] = snake(k3, fp1[k3 - 1 + offset], fp1[k3 + 1 + offset], offset, A1, B1);
        }
        for(let k1 = delta + p1; k1 > delta; --k1){
            fp1[k1 + offset] = snake(k1, fp1[k1 - 1 + offset], fp1[k1 + 1 + offset], offset, A1, B1);
        }
        fp1[delta + offset] = snake(delta, fp1[delta - 1 + offset], fp1[delta + 1 + offset], offset, A1, B1);
    }
    return [
        ...prefixCommon.map((c3)=>({
                type: DiffType.common,
                value: c3
            })
        ),
        ...backTrace(A1, B1, fp1[delta + offset], swapped1),
        ...suffixCommon.map((c4)=>({
                type: DiffType.common,
                value: c4
            })
        ), 
    ];
}
function diffstr(A, B) {
    function unescape1(string) {
        return string.replaceAll("\b", "\\b").replaceAll("\f", "\\f").replaceAll("\t", "\\t").replaceAll("\v", "\\v").replaceAll(/\r\n|\r|\n/g, (str)=>str === "\r" ? "\\r" : str === "\n" ? "\\n\n" : "\\r\\n\r\n"
        );
    }
    function tokenize(string, { wordDiff =false  } = {}) {
        if (wordDiff) {
            const tokens = string.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
            const words = /^[a-zA-Z\u{C0}-\u{FF}\u{D8}-\u{F6}\u{F8}-\u{2C6}\u{2C8}-\u{2D7}\u{2DE}-\u{2FF}\u{1E00}-\u{1EFF}]+$/u;
            for(let i5 = 0; i5 < tokens.length - 1; i5++){
                if (!tokens[i5 + 1] && tokens[i5 + 2] && words.test(tokens[i5]) && words.test(tokens[i5 + 2])) {
                    tokens[i5] += tokens[i5 + 2];
                    tokens.splice(i5 + 1, 2);
                    i5--;
                }
            }
            return tokens.filter((token)=>token
            );
        } else {
            const tokens = [], lines = string.split(/(\n|\r\n)/);
            if (!lines[lines.length - 1]) {
                lines.pop();
            }
            for(let i6 = 0; i6 < lines.length; i6++){
                if (i6 % 2) {
                    tokens[tokens.length - 1] += lines[i6];
                } else {
                    tokens.push(lines[i6]);
                }
            }
            return tokens;
        }
    }
    function createDetails(line, tokens) {
        return tokens.filter(({ type: type2  })=>type2 === line.type || type2 === DiffType.common
        ).map((result, i7, t1)=>{
            if (result.type === DiffType.common && t1[i7 - 1] && t1[i7 - 1]?.type === t1[i7 + 1]?.type && /\s+/.test(result.value)) {
                result.type = t1[i7 - 1].type;
            }
            return result;
        });
    }
    const diffResult = diff(tokenize(`${unescape1(A)}\n`), tokenize(`${unescape1(B)}\n`));
    const added = [], removed = [];
    for (const result1 of diffResult){
        if (result1.type === DiffType.added) {
            added.push(result1);
        }
        if (result1.type === DiffType.removed) {
            removed.push(result1);
        }
    }
    const aLines = added.length < removed.length ? added : removed;
    const bLines = aLines === removed ? added : removed;
    for (const a3 of aLines){
        let tokens = [], b2;
        while(bLines.length){
            b2 = bLines.shift();
            tokens = diff(tokenize(a3.value, {
                wordDiff: true
            }), tokenize(b2?.value ?? "", {
                wordDiff: true
            }));
            if (tokens.some(({ type: type3 , value  })=>type3 === DiffType.common && value.trim().length
            )) {
                break;
            }
        }
        a3.details = createDetails(a3, tokens);
        if (b2) {
            b2.details = createDetails(b2, tokens);
        }
    }
    return diffResult;
}
const CAN_NOT_DISPLAY = "[Cannot display]";
class AssertionError extends Error {
    name = "AssertionError";
    constructor(message){
        super(message);
    }
}
function _format(v1) {
    const { Deno  } = globalThis;
    return typeof Deno?.inspect === "function" ? Deno.inspect(v1, {
        depth: Infinity,
        sorted: true,
        trailingComma: true,
        compact: false,
        iterableLimit: Infinity
    }) : `"${String(v1).replace(/(?=["\\])/g, "\\")}"`;
}
function createColor(diffType, { background =false  } = {}) {
    switch(diffType){
        case DiffType.added:
            return (s1)=>background ? bgGreen(white(s1)) : green(bold(s1))
            ;
        case DiffType.removed:
            return (s2)=>background ? bgRed(white(s2)) : red(bold(s2))
            ;
        default:
            return white;
    }
}
function createSign(diffType) {
    switch(diffType){
        case DiffType.added:
            return "+   ";
        case DiffType.removed:
            return "-   ";
        default:
            return "    ";
    }
}
function buildMessage(diffResult, { stringDiff =false  } = {}) {
    const messages1 = [], diffMessages = [];
    messages1.push("");
    messages1.push("");
    messages1.push(`    ${gray(bold("[Diff]"))} ${red(bold("Actual"))} / ${green(bold("Expected"))}`);
    messages1.push("");
    messages1.push("");
    diffResult.forEach((result)=>{
        const c5 = createColor(result.type);
        const line = result.details?.map((detail)=>detail.type !== DiffType.common ? createColor(detail.type, {
                background: true
            })(detail.value) : detail.value
        ).join("") ?? result.value;
        diffMessages.push(c5(`${createSign(result.type)}${line}`));
    });
    messages1.push(...stringDiff ? [
        diffMessages.join("")
    ] : diffMessages);
    messages1.push("");
    return messages1;
}
function isKeyedCollection(x1) {
    return [
        Symbol.iterator,
        "size"
    ].every((k4)=>k4 in x1
    );
}
function equal(c6, d1) {
    const seen = new Map();
    return (function compare1(a4, b3) {
        if (a4 && b3 && (a4 instanceof RegExp && b3 instanceof RegExp || a4 instanceof URL && b3 instanceof URL)) {
            return String(a4) === String(b3);
        }
        if (a4 instanceof Date && b3 instanceof Date) {
            const aTime = a4.getTime();
            const bTime = b3.getTime();
            if (Number.isNaN(aTime) && Number.isNaN(bTime)) {
                return true;
            }
            return aTime === bTime;
        }
        if (typeof a4 === "number" && typeof b3 === "number") {
            return Number.isNaN(a4) && Number.isNaN(b3) || a4 === b3;
        }
        if (Object.is(a4, b3)) {
            return true;
        }
        if (a4 && typeof a4 === "object" && b3 && typeof b3 === "object") {
            if (a4 && b3 && !constructorsEqual(a4, b3)) {
                return false;
            }
            if (a4 instanceof WeakMap || b3 instanceof WeakMap) {
                if (!(a4 instanceof WeakMap && b3 instanceof WeakMap)) return false;
                throw new TypeError("cannot compare WeakMap instances");
            }
            if (a4 instanceof WeakSet || b3 instanceof WeakSet) {
                if (!(a4 instanceof WeakSet && b3 instanceof WeakSet)) return false;
                throw new TypeError("cannot compare WeakSet instances");
            }
            if (seen.get(a4) === b3) {
                return true;
            }
            if (Object.keys(a4 || {}).length !== Object.keys(b3 || {}).length) {
                return false;
            }
            if (isKeyedCollection(a4) && isKeyedCollection(b3)) {
                if (a4.size !== b3.size) {
                    return false;
                }
                let unmatchedEntries = a4.size;
                for (const [aKey, aValue] of a4.entries()){
                    for (const [bKey, bValue] of b3.entries()){
                        if (aKey === aValue && bKey === bValue && compare1(aKey, bKey) || compare1(aKey, bKey) && compare1(aValue, bValue)) {
                            unmatchedEntries--;
                        }
                    }
                }
                return unmatchedEntries === 0;
            }
            const merged = {
                ...a4,
                ...b3
            };
            for (const key of [
                ...Object.getOwnPropertyNames(merged),
                ...Object.getOwnPropertySymbols(merged), 
            ]){
                if (!compare1(a4 && a4[key], b3 && b3[key])) {
                    return false;
                }
                if (key in a4 && !(key in b3) || key in b3 && !(key in a4)) {
                    return false;
                }
            }
            seen.set(a4, b3);
            if (a4 instanceof WeakRef || b3 instanceof WeakRef) {
                if (!(a4 instanceof WeakRef && b3 instanceof WeakRef)) return false;
                return compare1(a4.deref(), b3.deref());
            }
            return true;
        }
        return false;
    })(c6, d1);
}
function constructorsEqual(a5, b4) {
    return a5.constructor === b4.constructor || a5.constructor === Object && !b4.constructor || !a5.constructor && b4.constructor === Object;
}
function assert(expr, msg = "") {
    if (!expr) {
        throw new AssertionError(msg);
    }
}
function assertEquals(actual, expected, msg) {
    if (equal(actual, expected)) {
        return;
    }
    let message = "";
    const actualString = _format(actual);
    const expectedString = _format(expected);
    try {
        const stringDiff = typeof actual === "string" && typeof expected === "string";
        const diffResult = stringDiff ? diffstr(actual, expected) : diff(actualString.split("\n"), expectedString.split("\n"));
        const diffMsg = buildMessage(diffResult, {
            stringDiff
        }).join("\n");
        message = `Values are not equal:\n${diffMsg}`;
    } catch  {
        message = `\n${red(CAN_NOT_DISPLAY)} + \n\n`;
    }
    if (msg) {
        message = msg;
    }
    throw new AssertionError(message);
}
function assertNotEquals(actual, expected, msg) {
    if (!equal(actual, expected)) {
        return;
    }
    let actualString;
    let expectedString;
    try {
        actualString = String(actual);
    } catch  {
        actualString = "[Cannot display]";
    }
    try {
        expectedString = String(expected);
    } catch  {
        expectedString = "[Cannot display]";
    }
    if (!msg) {
        msg = `actual: ${actualString} expected not to be: ${expectedString}`;
    }
    throw new AssertionError(msg);
}
function assertStrictEquals(actual, expected, msg) {
    if (actual === expected) {
        return;
    }
    let message;
    if (msg) {
        message = msg;
    } else {
        const actualString = _format(actual);
        const expectedString = _format(expected);
        if (actualString === expectedString) {
            const withOffset = actualString.split("\n").map((l1)=>`    ${l1}`
            ).join("\n");
            message = `Values have the same structure but are not reference-equal:\n\n${red(withOffset)}\n`;
        } else {
            try {
                const stringDiff = typeof actual === "string" && typeof expected === "string";
                const diffResult = stringDiff ? diffstr(actual, expected) : diff(actualString.split("\n"), expectedString.split("\n"));
                const diffMsg = buildMessage(diffResult, {
                    stringDiff
                }).join("\n");
                message = `Values are not strictly equal:\n${diffMsg}`;
            } catch  {
                message = `\n${red(CAN_NOT_DISPLAY)} + \n\n`;
            }
        }
    }
    throw new AssertionError(message);
}
function assertNotStrictEquals(actual, expected, msg) {
    if (actual !== expected) {
        return;
    }
    throw new AssertionError(msg ?? `Expected "actual" to be strictly unequal to: ${_format(actual)}\n`);
}
function assertMatch(actual, expected, msg) {
    if (!expected.test(actual)) {
        if (!msg) {
            msg = `actual: "${actual}" expected to match: "${expected}"`;
        }
        throw new AssertionError(msg);
    }
}
function assertNotMatch(actual, expected, msg) {
    if (expected.test(actual)) {
        if (!msg) {
            msg = `actual: "${actual}" expected to not match: "${expected}"`;
        }
        throw new AssertionError(msg);
    }
}
function unreachable() {
    throw new AssertionError("unreachable");
}
class DenoStdInternalError extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert1(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError(msg);
    }
}
function indexOf(source, pattern, fromIndex = 0) {
    if (fromIndex >= source.length) {
        return -1;
    }
    if (fromIndex < 0) {
        fromIndex = Math.max(0, source.length + fromIndex);
    }
    const s3 = pattern[0];
    for(let i8 = fromIndex; i8 < source.length; i8++){
        if (source[i8] !== s3) continue;
        const pin = i8;
        let matched = 1;
        let j = i8;
        while(matched < pattern.length){
            j++;
            if (source[j] !== pattern[j - pin]) {
                break;
            }
            matched++;
        }
        if (matched === pattern.length) {
            return pin;
        }
    }
    return -1;
}
function copy(src, dst, off = 0) {
    off = Math.max(0, Math.min(off, dst.byteLength));
    const dstBytesAvailable = dst.byteLength - off;
    if (src.byteLength > dstBytesAvailable) {
        src = src.subarray(0, dstBytesAvailable);
    }
    dst.set(src, off);
    return src.byteLength;
}
const MIN_BUF_SIZE = 16;
const CR = "\r".charCodeAt(0);
const LF = "\n".charCodeAt(0);
class BufferFullError extends Error {
    partial;
    name = "BufferFullError";
    constructor(partial){
        super("Buffer full");
        this.partial = partial;
    }
}
class PartialReadError extends Error {
    name = "PartialReadError";
    partial;
    constructor(){
        super("Encountered UnexpectedEof, data only partially read");
    }
}
class BufReader {
    #buf;
    #rd;
    #r = 0;
    #w = 0;
    #eof = false;
    static create(r1, size = 4096) {
        return r1 instanceof BufReader ? r1 : new BufReader(r1, size);
    }
    constructor(rd, size = 4096){
        if (size < 16) {
            size = MIN_BUF_SIZE;
        }
        this.#reset(new Uint8Array(size), rd);
    }
    size() {
        return this.#buf.byteLength;
    }
    buffered() {
        return this.#w - this.#r;
    }
    #fill = async ()=>{
        if (this.#r > 0) {
            this.#buf.copyWithin(0, this.#r, this.#w);
            this.#w -= this.#r;
            this.#r = 0;
        }
        if (this.#w >= this.#buf.byteLength) {
            throw Error("bufio: tried to fill full buffer");
        }
        for(let i9 = 100; i9 > 0; i9--){
            const rr = await this.#rd.read(this.#buf.subarray(this.#w));
            if (rr === null) {
                this.#eof = true;
                return;
            }
            assert1(rr >= 0, "negative read");
            this.#w += rr;
            if (rr > 0) {
                return;
            }
        }
        throw new Error(`No progress after ${100} read() calls`);
    };
    reset(r2) {
        this.#reset(this.#buf, r2);
    }
    #reset = (buf, rd)=>{
        this.#buf = buf;
        this.#rd = rd;
        this.#eof = false;
    };
    async read(p2) {
        let rr = p2.byteLength;
        if (p2.byteLength === 0) return rr;
        if (this.#r === this.#w) {
            if (p2.byteLength >= this.#buf.byteLength) {
                const rr = await this.#rd.read(p2);
                const nread = rr ?? 0;
                assert1(nread >= 0, "negative read");
                return rr;
            }
            this.#r = 0;
            this.#w = 0;
            rr = await this.#rd.read(this.#buf);
            if (rr === 0 || rr === null) return rr;
            assert1(rr >= 0, "negative read");
            this.#w += rr;
        }
        const copied = copy(this.#buf.subarray(this.#r, this.#w), p2, 0);
        this.#r += copied;
        return copied;
    }
    async readFull(p3) {
        let bytesRead = 0;
        while(bytesRead < p3.length){
            try {
                const rr = await this.read(p3.subarray(bytesRead));
                if (rr === null) {
                    if (bytesRead === 0) {
                        return null;
                    } else {
                        throw new PartialReadError();
                    }
                }
                bytesRead += rr;
            } catch (err1) {
                if (err1 instanceof PartialReadError) {
                    err1.partial = p3.subarray(0, bytesRead);
                } else if (err1 instanceof Error) {
                    const e1 = new PartialReadError();
                    e1.partial = p3.subarray(0, bytesRead);
                    e1.stack = err1.stack;
                    e1.message = err1.message;
                    e1.cause = err1.cause;
                    throw err1;
                }
                throw err1;
            }
        }
        return p3;
    }
    async readByte() {
        while(this.#r === this.#w){
            if (this.#eof) return null;
            await this.#fill();
        }
        const c7 = this.#buf[this.#r];
        this.#r++;
        return c7;
    }
    async readString(delim) {
        if (delim.length !== 1) {
            throw new Error("Delimiter should be a single character");
        }
        const buffer1 = await this.readSlice(delim.charCodeAt(0));
        if (buffer1 === null) return null;
        return new TextDecoder().decode(buffer1);
    }
    async readLine() {
        let line = null;
        try {
            line = await this.readSlice(LF);
        } catch (err2) {
            if (err2 instanceof Deno.errors.BadResource) {
                throw err2;
            }
            let partial;
            if (err2 instanceof PartialReadError) {
                partial = err2.partial;
                assert1(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
            }
            if (!(err2 instanceof BufferFullError)) {
                throw err2;
            }
            partial = err2.partial;
            if (!this.#eof && partial && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR) {
                assert1(this.#r > 0, "bufio: tried to rewind past start of buffer");
                this.#r--;
                partial = partial.subarray(0, partial.byteLength - 1);
            }
            if (partial) {
                return {
                    line: partial,
                    more: !this.#eof
                };
            }
        }
        if (line === null) {
            return null;
        }
        if (line.byteLength === 0) {
            return {
                line,
                more: false
            };
        }
        if (line[line.byteLength - 1] == LF) {
            let drop = 1;
            if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                drop = 2;
            }
            line = line.subarray(0, line.byteLength - drop);
        }
        return {
            line,
            more: false
        };
    }
    async readSlice(delim) {
        let s4 = 0;
        let slice;
        while(true){
            let i10 = this.#buf.subarray(this.#r + s4, this.#w).indexOf(delim);
            if (i10 >= 0) {
                i10 += s4;
                slice = this.#buf.subarray(this.#r, this.#r + i10 + 1);
                this.#r += i10 + 1;
                break;
            }
            if (this.#eof) {
                if (this.#r === this.#w) {
                    return null;
                }
                slice = this.#buf.subarray(this.#r, this.#w);
                this.#r = this.#w;
                break;
            }
            if (this.buffered() >= this.#buf.byteLength) {
                this.#r = this.#w;
                const oldbuf = this.#buf;
                const newbuf = this.#buf.slice(0);
                this.#buf = newbuf;
                throw new BufferFullError(oldbuf);
            }
            s4 = this.#w - this.#r;
            try {
                await this.#fill();
            } catch (err3) {
                if (err3 instanceof PartialReadError) {
                    err3.partial = slice;
                } else if (err3 instanceof Error) {
                    const e2 = new PartialReadError();
                    e2.partial = slice;
                    e2.stack = err3.stack;
                    e2.message = err3.message;
                    e2.cause = err3.cause;
                    throw err3;
                }
                throw err3;
            }
        }
        return slice;
    }
    async peek(n6) {
        if (n6 < 0) {
            throw Error("negative count");
        }
        let avail = this.#w - this.#r;
        while(avail < n6 && avail < this.#buf.byteLength && !this.#eof){
            try {
                await this.#fill();
            } catch (err4) {
                if (err4 instanceof PartialReadError) {
                    err4.partial = this.#buf.subarray(this.#r, this.#w);
                } else if (err4 instanceof Error) {
                    const e3 = new PartialReadError();
                    e3.partial = this.#buf.subarray(this.#r, this.#w);
                    e3.stack = err4.stack;
                    e3.message = err4.message;
                    e3.cause = err4.cause;
                    throw err4;
                }
                throw err4;
            }
            avail = this.#w - this.#r;
        }
        if (avail === 0 && this.#eof) {
            return null;
        } else if (avail < n6 && this.#eof) {
            return this.#buf.subarray(this.#r, this.#r + avail);
        } else if (avail < n6) {
            throw new BufferFullError(this.#buf.subarray(this.#r, this.#w));
        }
        return this.#buf.subarray(this.#r, this.#r + n6);
    }
}
class AbstractBufBase {
    buf;
    usedBufferBytes = 0;
    err = null;
    constructor(buf){
        this.buf = buf;
    }
    size() {
        return this.buf.byteLength;
    }
    available() {
        return this.buf.byteLength - this.usedBufferBytes;
    }
    buffered() {
        return this.usedBufferBytes;
    }
}
class BufWriter extends AbstractBufBase {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriter ? writer : new BufWriter(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w1) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w1;
    }
    async flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p4 = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p4.length){
                nwritten += await this.#writer.write(p4.subarray(nwritten));
            }
        } catch (e4) {
            if (e4 instanceof Error) {
                this.err = e4;
            }
            throw e4;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    async write(data1) {
        if (this.err !== null) throw this.err;
        if (data1.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data1.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = await this.#writer.write(data1);
                } catch (e5) {
                    if (e5 instanceof Error) {
                        this.err = e5;
                    }
                    throw e5;
                }
            } else {
                numBytesWritten = copy(data1, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                await this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data1 = data1.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data1, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
class BufWriterSync extends AbstractBufBase {
    #writer;
    static create(writer, size = 4096) {
        return writer instanceof BufWriterSync ? writer : new BufWriterSync(writer, size);
    }
    constructor(writer, size = 4096){
        super(new Uint8Array(size <= 0 ? 4096 : size));
        this.#writer = writer;
    }
    reset(w2) {
        this.err = null;
        this.usedBufferBytes = 0;
        this.#writer = w2;
    }
    flush() {
        if (this.err !== null) throw this.err;
        if (this.usedBufferBytes === 0) return;
        try {
            const p5 = this.buf.subarray(0, this.usedBufferBytes);
            let nwritten = 0;
            while(nwritten < p5.length){
                nwritten += this.#writer.writeSync(p5.subarray(nwritten));
            }
        } catch (e6) {
            if (e6 instanceof Error) {
                this.err = e6;
            }
            throw e6;
        }
        this.buf = new Uint8Array(this.buf.length);
        this.usedBufferBytes = 0;
    }
    writeSync(data2) {
        if (this.err !== null) throw this.err;
        if (data2.length === 0) return 0;
        let totalBytesWritten = 0;
        let numBytesWritten = 0;
        while(data2.byteLength > this.available()){
            if (this.buffered() === 0) {
                try {
                    numBytesWritten = this.#writer.writeSync(data2);
                } catch (e7) {
                    if (e7 instanceof Error) {
                        this.err = e7;
                    }
                    throw e7;
                }
            } else {
                numBytesWritten = copy(data2, this.buf, this.usedBufferBytes);
                this.usedBufferBytes += numBytesWritten;
                this.flush();
            }
            totalBytesWritten += numBytesWritten;
            data2 = data2.subarray(numBytesWritten);
        }
        numBytesWritten = copy(data2, this.buf, this.usedBufferBytes);
        this.usedBufferBytes += numBytesWritten;
        totalBytesWritten += numBytesWritten;
        return totalBytesWritten;
    }
}
const DEFAULT_BUFFER_SIZE = 32 * 1024;
async function writeAll(w3, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += await w3.write(arr.subarray(nwritten));
    }
}
function writeAllSync(w4, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += w4.writeSync(arr.subarray(nwritten));
    }
}
async function* iterateReader(r3, options) {
    const bufSize = options?.bufSize ?? DEFAULT_BUFFER_SIZE;
    const b5 = new Uint8Array(bufSize);
    while(true){
        const result = await r3.read(b5);
        if (result === null) {
            break;
        }
        yield b5.subarray(0, result);
    }
}
function notImplemented(msg) {
    const message = msg ? `Not implemented: ${msg}` : "Not implemented";
    throw new Error(message);
}
function warnNotImplemented(msg) {
    const message = msg ? `Not implemented: ${msg}` : "Not implemented";
    console.warn(message);
}
const _TextDecoder = TextDecoder;
const _TextEncoder = TextEncoder;
function intoCallbackAPIWithIntercept(func, interceptor, cb, ...args) {
    func(...args).then((value)=>cb && cb(null, interceptor(value))
    , (err5)=>cb && cb(err5)
    );
}
function spliceOne(list, index1) {
    for(; index1 + 1 < list.length; index1++)list[index1] = list[index1 + 1];
    list.pop();
}
function normalizeEncoding(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases(enc);
}
function slowCases(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
function validateIntegerRange(value, name1, min1 = -2147483648, max = 2147483647) {
    if (!Number.isInteger(value)) {
        throw new Error(`${name1} must be 'an integer' but was ${value}`);
    }
    if (value < min1 || value > max) {
        throw new Error(`${name1} must be >= ${min1} && <= ${max}. Value was ${value}`);
    }
}
const _toString = Object.prototype.toString;
const _isObjectLike = (value)=>value !== null && typeof value === "object"
;
const _isFunctionLike = (value)=>value !== null && typeof value === "function"
;
function isAnyArrayBuffer(value) {
    return _isObjectLike(value) && (_toString.call(value) === "[object ArrayBuffer]" || _toString.call(value) === "[object SharedArrayBuffer]");
}
function isArgumentsObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Arguments]";
}
function isArrayBuffer(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object ArrayBuffer]";
}
function isAsyncFunction(value) {
    return _isFunctionLike(value) && _toString.call(value) === "[object AsyncFunction]";
}
function isBooleanObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Boolean]";
}
function isBoxedPrimitive(value) {
    return isBooleanObject(value) || isStringObject(value) || isNumberObject(value) || isSymbolObject(value) || isBigIntObject(value);
}
function isDataView(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object DataView]";
}
function isDate(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Date]";
}
function isGeneratorFunction(value) {
    return _isFunctionLike(value) && _toString.call(value) === "[object GeneratorFunction]";
}
function isGeneratorObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Generator]";
}
function isMap(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Map]";
}
function isMapIterator(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Map Iterator]";
}
function isModuleNamespaceObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Module]";
}
function isNativeError(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Error]";
}
function isNumberObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Number]";
}
function isBigIntObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object BigInt]";
}
function isPromise(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Promise]";
}
function isRegExp(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object RegExp]";
}
function isSet(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Set]";
}
function isSetIterator(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Set Iterator]";
}
function isSharedArrayBuffer(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object SharedArrayBuffer]";
}
function isStringObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object String]";
}
function isSymbolObject(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object Symbol]";
}
function isWeakMap(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object WeakMap]";
}
function isWeakSet(value) {
    return _isObjectLike(value) && _toString.call(value) === "[object WeakSet]";
}
const __default = {
    isAsyncFunction,
    isGeneratorFunction,
    isAnyArrayBuffer,
    isArrayBuffer,
    isArgumentsObject,
    isBoxedPrimitive,
    isDataView,
    isMap,
    isMapIterator,
    isModuleNamespaceObject,
    isNativeError,
    isPromise,
    isSet,
    isSetIterator,
    isWeakMap,
    isWeakSet,
    isRegExp,
    isDate,
    isStringObject,
    isNumberObject,
    isBooleanObject,
    isBigIntObject
};
const mod = {
    isAnyArrayBuffer: isAnyArrayBuffer,
    isArgumentsObject: isArgumentsObject,
    isArrayBuffer: isArrayBuffer,
    isAsyncFunction: isAsyncFunction,
    isBooleanObject: isBooleanObject,
    isBoxedPrimitive: isBoxedPrimitive,
    isDataView: isDataView,
    isDate: isDate,
    isGeneratorFunction: isGeneratorFunction,
    isGeneratorObject: isGeneratorObject,
    isMap: isMap,
    isMapIterator: isMapIterator,
    isModuleNamespaceObject: isModuleNamespaceObject,
    isNativeError: isNativeError,
    isNumberObject: isNumberObject,
    isBigIntObject: isBigIntObject,
    isPromise: isPromise,
    isRegExp: isRegExp,
    isSet: isSet,
    isSetIterator: isSetIterator,
    isSharedArrayBuffer: isSharedArrayBuffer,
    isStringObject: isStringObject,
    isSymbolObject: isSymbolObject,
    isWeakMap: isWeakMap,
    isWeakSet: isWeakSet,
    default: __default
};
const kKeyObject = Symbol("kKeyObject");
const kKeyType = Symbol("kKeyType");
function isKeyObject(obj) {
    return obj != null && obj[kKeyType] !== undefined;
}
function isCryptoKey(obj) {
    return obj != null && obj[kKeyObject] !== undefined;
}
const _toString1 = Object.prototype.toString;
const _isObjectLike1 = (value)=>value !== null && typeof value === "object"
;
function isArrayBufferView(value) {
    return ArrayBuffer.isView(value);
}
function isBigInt64Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object BigInt64Array]";
}
function isBigUint64Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object BigUint64Array]";
}
function isFloat32Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Float32Array]";
}
function isFloat64Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Float64Array]";
}
function isInt8Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Int8Array]";
}
function isInt16Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Int16Array]";
}
function isInt32Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Int32Array]";
}
function isTypedArray(value) {
    const reTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
    return _isObjectLike1(value) && reTypedTag.test(_toString1.call(value));
}
function isUint8Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Uint8Array]";
}
function isUint8ClampedArray(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Uint8ClampedArray]";
}
function isUint16Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Uint16Array]";
}
function isUint32Array(value) {
    return _isObjectLike1(value) && _toString1.call(value) === "[object Uint32Array]";
}
const { isDate: isDate1 , isArgumentsObject: isArgumentsObject1 , isBigIntObject: isBigIntObject1 , isBooleanObject: isBooleanObject1 , isNumberObject: isNumberObject1 , isStringObject: isStringObject1 , isSymbolObject: isSymbolObject1 , isNativeError: isNativeError1 , isRegExp: isRegExp1 , isAsyncFunction: isAsyncFunction1 , isGeneratorFunction: isGeneratorFunction1 , isGeneratorObject: isGeneratorObject1 , isPromise: isPromise1 , isMap: isMap1 , isSet: isSet1 , isMapIterator: isMapIterator1 , isSetIterator: isSetIterator1 , isWeakMap: isWeakMap1 , isWeakSet: isWeakSet1 , isArrayBuffer: isArrayBuffer1 , isDataView: isDataView1 , isSharedArrayBuffer: isSharedArrayBuffer1 , isModuleNamespaceObject: isModuleNamespaceObject1 , isAnyArrayBuffer: isAnyArrayBuffer1 , isBoxedPrimitive: isBoxedPrimitive1 ,  } = mod;
const mod1 = {
    isCryptoKey: isCryptoKey,
    isKeyObject: isKeyObject,
    isArrayBufferView: isArrayBufferView,
    isBigInt64Array: isBigInt64Array,
    isBigUint64Array: isBigUint64Array,
    isFloat32Array: isFloat32Array,
    isFloat64Array: isFloat64Array,
    isInt8Array: isInt8Array,
    isInt16Array: isInt16Array,
    isInt32Array: isInt32Array,
    isTypedArray: isTypedArray,
    isUint8Array: isUint8Array,
    isUint8ClampedArray: isUint8ClampedArray,
    isUint16Array: isUint16Array,
    isUint32Array: isUint32Array,
    isDate: isDate1,
    isArgumentsObject: isArgumentsObject1,
    isBigIntObject: isBigIntObject1,
    isBooleanObject: isBooleanObject1,
    isNumberObject: isNumberObject1,
    isStringObject: isStringObject1,
    isSymbolObject: isSymbolObject1,
    isNativeError: isNativeError1,
    isRegExp: isRegExp1,
    isAsyncFunction: isAsyncFunction1,
    isGeneratorFunction: isGeneratorFunction1,
    isGeneratorObject: isGeneratorObject1,
    isPromise: isPromise1,
    isMap: isMap1,
    isSet: isSet1,
    isMapIterator: isMapIterator1,
    isSetIterator: isSetIterator1,
    isWeakMap: isWeakMap1,
    isWeakSet: isWeakSet1,
    isArrayBuffer: isArrayBuffer1,
    isDataView: isDataView1,
    isSharedArrayBuffer: isSharedArrayBuffer1,
    isModuleNamespaceObject: isModuleNamespaceObject1,
    isAnyArrayBuffer: isAnyArrayBuffer1,
    isBoxedPrimitive: isBoxedPrimitive1
};
const codes = {};
function hideStackFrames(fn) {
    const hidden = "__node_internal_" + fn.name;
    Object.defineProperty(fn, "name", {
        value: hidden
    });
    return fn;
}
function normalizeEncoding1(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases1(enc);
}
function slowCases1(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        case 9:
            if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
                return "base64url";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
function isInt32(value) {
    return value === (value | 0);
}
function isUint32(value) {
    return value === value >>> 0;
}
const octalReg = /^[0-7]+$/;
const modeDesc = "must be a 32-bit unsigned integer or an octal string";
function parseFileMode(value, name2, def) {
    value ??= def;
    if (typeof value === "string") {
        if (!octalReg.test(value)) {
            throw new codes.ERR_INVALID_ARG_VALUE(name2, value, modeDesc);
        }
        value = Number.parseInt(value, 8);
    }
    validateInt32(value, name2, 0, 2 ** 32 - 1);
    return value;
}
const validateBuffer = hideStackFrames((buffer2, name3 = "buffer")=>{
    if (!isArrayBufferView(buffer2)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name3, [
            "Buffer",
            "TypedArray",
            "DataView"
        ], buffer2);
    }
});
const validateInteger = hideStackFrames((value, name4, min2 = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER)=>{
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name4, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name4, "an integer", value);
    }
    if (value < min2 || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name4, `>= ${min2} && <= ${max}`, value);
    }
});
const validateObject = hideStackFrames((value, name5, options)=>{
    const useDefaultOptions = options == null;
    const allowArray = useDefaultOptions ? false : options.allowArray;
    const allowFunction = useDefaultOptions ? false : options.allowFunction;
    const nullable = useDefaultOptions ? false : options.nullable;
    if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new codes.ERR_INVALID_ARG_TYPE(name5, "Object", value);
    }
});
const validateInt32 = hideStackFrames((value, name6, min3 = -2147483648, max = 2147483647)=>{
    if (!isInt32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name6, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name6, "an integer", value);
        }
        throw new codes.ERR_OUT_OF_RANGE(name6, `>= ${min3} && <= ${max}`, value);
    }
    if (value < min3 || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name6, `>= ${min3} && <= ${max}`, value);
    }
});
const validateUint32 = hideStackFrames((value, name7, positive)=>{
    if (!isUint32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name7, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name7, "an integer", value);
        }
        const min4 = positive ? 1 : 0;
        throw new codes.ERR_OUT_OF_RANGE(name7, `>= ${min4} && < 4294967296`, value);
    }
    if (positive && value === 0) {
        throw new codes.ERR_OUT_OF_RANGE(name7, ">= 1 && < 4294967296", value);
    }
});
function validateString(value, name8) {
    if (typeof value !== "string") {
        throw new codes.ERR_INVALID_ARG_TYPE(name8, "string", value);
    }
}
function validateNumber(value, name9) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name9, "number", value);
    }
}
function validateBoolean(value, name10) {
    if (typeof value !== "boolean") {
        throw new codes.ERR_INVALID_ARG_TYPE(name10, "boolean", value);
    }
}
const validateOneOf = hideStackFrames((value, name11, oneOf)=>{
    if (!Array.prototype.includes.call(oneOf, value)) {
        const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v2)=>typeof v2 === "string" ? `'${v2}'` : String(v2)
        ), ", ");
        const reason = "must be one of: " + allowed;
        throw new codes.ERR_INVALID_ARG_VALUE(name11, value, reason);
    }
});
function validateEncoding(data3, encoding) {
    const normalizedEncoding = normalizeEncoding1(encoding);
    const length = data3.length;
    if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new codes.ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
    }
}
function validatePort(port, name12 = "Port", allowZero = true) {
    if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && String.prototype.trim.call(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
        throw new codes.ERR_SOCKET_BAD_PORT(name12, port, allowZero);
    }
    return port;
}
const validateCallback = hideStackFrames((callback)=>{
    if (typeof callback !== "function") {
        throw new codes.ERR_INVALID_CALLBACK(callback);
    }
});
const validateAbortSignal = hideStackFrames((signal, name13)=>{
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new codes.ERR_INVALID_ARG_TYPE(name13, "AbortSignal", signal);
    }
});
const validateFunction = hideStackFrames((value, name14)=>{
    if (typeof value !== "function") {
        throw new codes.ERR_INVALID_ARG_TYPE(name14, "Function", value);
    }
});
const validateArray = hideStackFrames((value, name15, minLength = 0)=>{
    if (!Array.isArray(value)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name15, "Array", value);
    }
    if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new codes.ERR_INVALID_ARG_VALUE(name15, value, reason);
    }
});
function guessHandleType(_fd) {
    notImplemented();
}
const isNumericLookup = {};
function isArrayIndex(value) {
    switch(typeof value){
        case "number":
            return value >= 0 && (value | 0) === value;
        case "string":
            {
                const result = isNumericLookup[value];
                if (result !== void 0) {
                    return result;
                }
                const length = value.length;
                if (length === 0) {
                    return isNumericLookup[value] = false;
                }
                let ch = 0;
                let i11 = 0;
                for(; i11 < length; ++i11){
                    ch = value.charCodeAt(i11);
                    if (i11 === 0 && ch === 48 && length > 1 || ch < 48 || ch > 57) {
                        return isNumericLookup[value] = false;
                    }
                }
                return isNumericLookup[value] = true;
            }
        default:
            return false;
    }
}
function getOwnNonIndexProperties(obj, filter) {
    let allProperties = [
        ...Object.getOwnPropertyNames(obj),
        ...Object.getOwnPropertySymbols(obj), 
    ];
    if (Array.isArray(obj)) {
        allProperties = allProperties.filter((k5)=>!isArrayIndex(k5)
        );
    }
    if (filter === 0) {
        return allProperties;
    }
    const result = [];
    for (const key of allProperties){
        const desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc === undefined) {
            continue;
        }
        if (filter & 1 && !desc.writable) {
            continue;
        }
        if (filter & 2 && !desc.enumerable) {
            continue;
        }
        if (filter & 4 && !desc.configurable) {
            continue;
        }
        if (filter & 8 && typeof key === "string") {
            continue;
        }
        if (filter & 16 && typeof key === "symbol") {
            continue;
        }
        result.push(key);
    }
    return result;
}
const mod2 = function() {
    return {
        guessHandleType: guessHandleType,
        ALL_PROPERTIES: 0,
        ONLY_WRITABLE: 1,
        ONLY_ENUMERABLE: 2,
        ONLY_CONFIGURABLE: 4,
        ONLY_ENUM_WRITABLE: 6,
        SKIP_STRINGS: 8,
        SKIP_SYMBOLS: 16,
        isArrayIndex: isArrayIndex,
        getOwnNonIndexProperties: getOwnNonIndexProperties
    };
}();
const kObjectType = 0;
const kArrayExtrasType = 2;
const kRejected = 2;
const meta = [
    '\\x00',
    '\\x01',
    '\\x02',
    '\\x03',
    '\\x04',
    '\\x05',
    '\\x06',
    '\\x07',
    '\\b',
    '\\t',
    '\\n',
    '\\x0B',
    '\\f',
    '\\r',
    '\\x0E',
    '\\x0F',
    '\\x10',
    '\\x11',
    '\\x12',
    '\\x13',
    '\\x14',
    '\\x15',
    '\\x16',
    '\\x17',
    '\\x18',
    '\\x19',
    '\\x1A',
    '\\x1B',
    '\\x1C',
    '\\x1D',
    '\\x1E',
    '\\x1F',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    "\\'",
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\\\',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\x7F',
    '\\x80',
    '\\x81',
    '\\x82',
    '\\x83',
    '\\x84',
    '\\x85',
    '\\x86',
    '\\x87',
    '\\x88',
    '\\x89',
    '\\x8A',
    '\\x8B',
    '\\x8C',
    '\\x8D',
    '\\x8E',
    '\\x8F',
    '\\x90',
    '\\x91',
    '\\x92',
    '\\x93',
    '\\x94',
    '\\x95',
    '\\x96',
    '\\x97',
    '\\x98',
    '\\x99',
    '\\x9A',
    '\\x9B',
    '\\x9C',
    '\\x9D',
    '\\x9E',
    '\\x9F'
];
const isUndetectableObject = (v3)=>typeof v3 === "undefined" && v3 !== undefined
;
const strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
const strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c\x7f-\x9f]/g;
const keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
const numberRegExp = /^(0|[1-9][0-9]*)$/;
const nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
const classRegExp = /^(\s+[^(]*?)\s*{/;
const stripCommentsRegExp = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;
const inspectDefaultOptions = {
    showHidden: false,
    depth: 2,
    colors: false,
    customInspect: true,
    showProxy: false,
    maxArrayLength: 100,
    maxStringLength: 10000,
    breakLength: 80,
    compact: 3,
    sorted: false,
    getters: false
};
function getUserOptions(ctx, isCrossContext) {
    const ret = {
        stylize: ctx.stylize,
        showHidden: ctx.showHidden,
        depth: ctx.depth,
        colors: ctx.colors,
        customInspect: ctx.customInspect,
        showProxy: ctx.showProxy,
        maxArrayLength: ctx.maxArrayLength,
        maxStringLength: ctx.maxStringLength,
        breakLength: ctx.breakLength,
        compact: ctx.compact,
        sorted: ctx.sorted,
        getters: ctx.getters,
        ...ctx.userOptions
    };
    if (isCrossContext) {
        Object.setPrototypeOf(ret, null);
        for (const key of Object.keys(ret)){
            if ((typeof ret[key] === "object" || typeof ret[key] === "function") && ret[key] !== null) {
                delete ret[key];
            }
        }
        ret.stylize = Object.setPrototypeOf((value, flavour)=>{
            let stylized;
            try {
                stylized = `${ctx.stylize(value, flavour)}`;
            } catch  {}
            if (typeof stylized !== "string") return value;
            return stylized;
        }, null);
    }
    return ret;
}
function inspect(value, opts) {
    const ctx = {
        budget: {},
        indentationLvl: 0,
        seen: [],
        currentDepth: 0,
        stylize: stylizeNoColor,
        showHidden: inspectDefaultOptions.showHidden,
        depth: inspectDefaultOptions.depth,
        colors: inspectDefaultOptions.colors,
        customInspect: inspectDefaultOptions.customInspect,
        showProxy: inspectDefaultOptions.showProxy,
        maxArrayLength: inspectDefaultOptions.maxArrayLength,
        maxStringLength: inspectDefaultOptions.maxStringLength,
        breakLength: inspectDefaultOptions.breakLength,
        compact: inspectDefaultOptions.compact,
        sorted: inspectDefaultOptions.sorted,
        getters: inspectDefaultOptions.getters
    };
    if (arguments.length > 1) {
        if (arguments.length > 2) {
            if (arguments[2] !== undefined) {
                ctx.depth = arguments[2];
            }
            if (arguments.length > 3 && arguments[3] !== undefined) {
                ctx.colors = arguments[3];
            }
        }
        if (typeof opts === "boolean") {
            ctx.showHidden = opts;
        } else if (opts) {
            const optKeys = Object.keys(opts);
            for(let i12 = 0; i12 < optKeys.length; ++i12){
                const key = optKeys[i12];
                if (inspectDefaultOptions.hasOwnProperty(key) || key === "stylize") {
                    ctx[key] = opts[key];
                } else if (ctx.userOptions === undefined) {
                    ctx.userOptions = opts;
                }
            }
        }
    }
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;
    if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;
    return formatValue(ctx, value, 0);
}
const customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
inspect.custom = customInspectSymbol;
Object.defineProperty(inspect, "defaultOptions", {
    get () {
        return inspectDefaultOptions;
    },
    set (options) {
        validateObject(options, "options");
        return Object.assign(inspectDefaultOptions, options);
    }
});
const defaultFG = 39;
const defaultBG = 49;
inspect.colors = Object.assign(Object.create(null), {
    reset: [
        0,
        0
    ],
    bold: [
        1,
        22
    ],
    dim: [
        2,
        22
    ],
    italic: [
        3,
        23
    ],
    underline: [
        4,
        24
    ],
    blink: [
        5,
        25
    ],
    inverse: [
        7,
        27
    ],
    hidden: [
        8,
        28
    ],
    strikethrough: [
        9,
        29
    ],
    doubleunderline: [
        21,
        24
    ],
    black: [
        30,
        defaultFG
    ],
    red: [
        31,
        defaultFG
    ],
    green: [
        32,
        defaultFG
    ],
    yellow: [
        33,
        defaultFG
    ],
    blue: [
        34,
        defaultFG
    ],
    magenta: [
        35,
        defaultFG
    ],
    cyan: [
        36,
        defaultFG
    ],
    white: [
        37,
        defaultFG
    ],
    bgBlack: [
        40,
        defaultBG
    ],
    bgRed: [
        41,
        defaultBG
    ],
    bgGreen: [
        42,
        defaultBG
    ],
    bgYellow: [
        43,
        defaultBG
    ],
    bgBlue: [
        44,
        defaultBG
    ],
    bgMagenta: [
        45,
        defaultBG
    ],
    bgCyan: [
        46,
        defaultBG
    ],
    bgWhite: [
        47,
        defaultBG
    ],
    framed: [
        51,
        54
    ],
    overlined: [
        53,
        55
    ],
    gray: [
        90,
        defaultFG
    ],
    redBright: [
        91,
        defaultFG
    ],
    greenBright: [
        92,
        defaultFG
    ],
    yellowBright: [
        93,
        defaultFG
    ],
    blueBright: [
        94,
        defaultFG
    ],
    magentaBright: [
        95,
        defaultFG
    ],
    cyanBright: [
        96,
        defaultFG
    ],
    whiteBright: [
        97,
        defaultFG
    ],
    bgGray: [
        100,
        defaultBG
    ],
    bgRedBright: [
        101,
        defaultBG
    ],
    bgGreenBright: [
        102,
        defaultBG
    ],
    bgYellowBright: [
        103,
        defaultBG
    ],
    bgBlueBright: [
        104,
        defaultBG
    ],
    bgMagentaBright: [
        105,
        defaultBG
    ],
    bgCyanBright: [
        106,
        defaultBG
    ],
    bgWhiteBright: [
        107,
        defaultBG
    ]
});
function defineColorAlias(target, alias) {
    Object.defineProperty(inspect.colors, alias, {
        get () {
            return this[target];
        },
        set (value) {
            this[target] = value;
        },
        configurable: true,
        enumerable: false
    });
}
defineColorAlias("gray", "grey");
defineColorAlias("gray", "blackBright");
defineColorAlias("bgGray", "bgGrey");
defineColorAlias("bgGray", "bgBlackBright");
defineColorAlias("dim", "faint");
defineColorAlias("strikethrough", "crossedout");
defineColorAlias("strikethrough", "strikeThrough");
defineColorAlias("strikethrough", "crossedOut");
defineColorAlias("hidden", "conceal");
defineColorAlias("inverse", "swapColors");
defineColorAlias("inverse", "swapcolors");
defineColorAlias("doubleunderline", "doubleUnderline");
inspect.styles = Object.assign(Object.create(null), {
    special: "cyan",
    number: "yellow",
    bigint: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    symbol: "green",
    date: "magenta",
    regexp: "red",
    module: "underline"
});
function addQuotes(str, quotes) {
    if (quotes === -1) {
        return `"${str}"`;
    }
    if (quotes === -2) {
        return `\`${str}\``;
    }
    return `'${str}'`;
}
const escapeFn = (str)=>meta[str.charCodeAt(0)]
;
function strEscape(str) {
    let escapeTest = strEscapeSequencesRegExp;
    let escapeReplace = strEscapeSequencesReplacer;
    let singleQuote = 39;
    if (str.includes("'")) {
        if (!str.includes('"')) {
            singleQuote = -1;
        } else if (!str.includes("`") && !str.includes("${")) {
            singleQuote = -2;
        }
        if (singleQuote !== 39) {
            escapeTest = strEscapeSequencesRegExpSingle;
            escapeReplace = strEscapeSequencesReplacerSingle;
        }
    }
    if (str.length < 5000 && !escapeTest.test(str)) {
        return addQuotes(str, singleQuote);
    }
    if (str.length > 100) {
        str = str.replace(escapeReplace, escapeFn);
        return addQuotes(str, singleQuote);
    }
    let result = "";
    let last = 0;
    const lastIndex = str.length;
    for(let i13 = 0; i13 < lastIndex; i13++){
        const point = str.charCodeAt(i13);
        if (point === singleQuote || point === 92 || point < 32 || point > 126 && point < 160) {
            if (last === i13) {
                result += meta[point];
            } else {
                result += `${str.slice(last, i13)}${meta[point]}`;
            }
            last = i13 + 1;
        }
    }
    if (last !== lastIndex) {
        result += str.slice(last);
    }
    return addQuotes(result, singleQuote);
}
function stylizeWithColor(str, styleType) {
    const style = inspect.styles[styleType];
    if (style !== undefined) {
        const color = inspect.colors[style];
        if (color !== undefined) {
            return `\u001b[${color[0]}m${str}\u001b[${color[1]}m`;
        }
    }
    return str;
}
function stylizeNoColor(str) {
    return str;
}
function formatValue(ctx, value, recurseTimes, typedArray) {
    if (typeof value !== "object" && typeof value !== "function" && !isUndetectableObject(value)) {
        return formatPrimitive(ctx.stylize, value, ctx);
    }
    if (value === null) {
        return ctx.stylize("null", "null");
    }
    const context = value;
    const proxy = undefined;
    if (ctx.customInspect) {
        const maybeCustom = value[customInspectSymbol];
        if (typeof maybeCustom === "function" && maybeCustom !== inspect && !(value.constructor && value.constructor.prototype === value)) {
            const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
            const isCrossContext = proxy !== undefined || !(context instanceof Object);
            const ret = maybeCustom.call(context, depth, getUserOptions(ctx, isCrossContext));
            if (ret !== context) {
                if (typeof ret !== "string") {
                    return formatValue(ctx, ret, recurseTimes);
                }
                return ret.replace(/\n/g, `\n${" ".repeat(ctx.indentationLvl)}`);
            }
        }
    }
    if (ctx.seen.includes(value)) {
        let index2 = 1;
        if (ctx.circular === undefined) {
            ctx.circular = new Map();
            ctx.circular.set(value, index2);
        } else {
            index2 = ctx.circular.get(value);
            if (index2 === undefined) {
                index2 = ctx.circular.size + 1;
                ctx.circular.set(value, index2);
            }
        }
        return ctx.stylize(`[Circular *${index2}]`, "special");
    }
    return formatRaw(ctx, value, recurseTimes, typedArray);
}
function formatRaw(ctx, value, recurseTimes, typedArray) {
    let keys;
    let protoProps;
    if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
        protoProps = [];
    }
    const constructor = getConstructorName(value, ctx, recurseTimes, protoProps);
    if (protoProps !== undefined && protoProps.length === 0) {
        protoProps = undefined;
    }
    let tag1 = value[Symbol.toStringTag];
    if (typeof tag1 !== "string") {
        tag1 = "";
    }
    let base2 = "";
    let formatter = getEmptyFormatArray;
    let braces;
    let noIterator = true;
    let i14 = 0;
    const filter = ctx.showHidden ? 0 : 2;
    let extrasType = 0;
    if (value[Symbol.iterator] || constructor === null) {
        noIterator = false;
        if (Array.isArray(value)) {
            const prefix = constructor !== "Array" || tag1 !== "" ? getPrefix(constructor, tag1, "Array", `(${value.length})`) : "";
            keys = getOwnNonIndexProperties(value, filter);
            braces = [
                `${prefix}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}]`;
            }
            extrasType = kArrayExtrasType;
            formatter = formatArray;
        } else if (isSet1(value)) {
            const size = value.size;
            const prefix = getPrefix(constructor, tag1, "Set", `(${size})`);
            keys = getKeys(value, ctx.showHidden);
            formatter = constructor !== null ? formatSet.bind(null, value) : formatSet.bind(null, value.values());
            if (size === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix}{}`;
            }
            braces = [
                `${prefix}{`,
                "}"
            ];
        } else if (isMap1(value)) {
            const size = value.size;
            const prefix = getPrefix(constructor, tag1, "Map", `(${size})`);
            keys = getKeys(value, ctx.showHidden);
            formatter = constructor !== null ? formatMap.bind(null, value) : formatMap.bind(null, value.entries());
            if (size === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix}{}`;
            }
            braces = [
                `${prefix}{`,
                "}"
            ];
        } else if (isTypedArray(value)) {
            keys = getOwnNonIndexProperties(value, filter);
            const bound = value;
            const fallback = "";
            const size = value.length;
            const prefix = getPrefix(constructor, tag1, fallback, `(${size})`);
            braces = [
                `${prefix}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
                return `${braces[0]}]`;
            }
            formatter = formatTypedArray.bind(null, bound, size);
            extrasType = kArrayExtrasType;
        } else if (isMapIterator1(value)) {
            keys = getKeys(value, ctx.showHidden);
            braces = getIteratorBraces("Map", tag1);
            formatter = formatIterator.bind(null, braces);
        } else if (isSetIterator1(value)) {
            keys = getKeys(value, ctx.showHidden);
            braces = getIteratorBraces("Set", tag1);
            formatter = formatIterator.bind(null, braces);
        } else {
            noIterator = true;
        }
    }
    if (noIterator) {
        keys = getKeys(value, ctx.showHidden);
        braces = [
            "{",
            "}"
        ];
        if (constructor === "Object") {
            if (isArgumentsObject1(value)) {
                braces[0] = "[Arguments] {";
            } else if (tag1 !== "") {
                braces[0] = `${getPrefix(constructor, tag1, "Object")}{`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}}`;
            }
        } else if (typeof value === "function") {
            base2 = getFunctionBase(value, constructor, tag1);
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base2, "special");
            }
        } else if (isRegExp1(value)) {
            base2 = RegExp(constructor !== null ? value : new RegExp(value)).toString();
            const prefix = getPrefix(constructor, tag1, "RegExp");
            if (prefix !== "RegExp ") {
                base2 = `${prefix}${base2}`;
            }
            if (keys.length === 0 && protoProps === undefined || recurseTimes > ctx.depth && ctx.depth !== null) {
                return ctx.stylize(base2, "regexp");
            }
        } else if (isDate1(value)) {
            base2 = Number.isNaN(value.getTime()) ? value.toString() : value.toISOString();
            const prefix = getPrefix(constructor, tag1, "Date");
            if (prefix !== "Date ") {
                base2 = `${prefix}${base2}`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base2, "date");
            }
        } else if (value instanceof Error) {
            base2 = formatError(value, constructor, tag1, ctx, keys);
            if (keys.length === 0 && protoProps === undefined) {
                return base2;
            }
        } else if (isAnyArrayBuffer1(value)) {
            const arrayType = isArrayBuffer1(value) ? "ArrayBuffer" : "SharedArrayBuffer";
            const prefix = getPrefix(constructor, tag1, arrayType);
            if (typedArray === undefined) {
                formatter = formatArrayBuffer;
            } else if (keys.length === 0 && protoProps === undefined) {
                return prefix + `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;
            }
            braces[0] = `${prefix}{`;
            Array.prototype.unshift(keys, "byteLength");
        } else if (isDataView1(value)) {
            braces[0] = `${getPrefix(constructor, tag1, "DataView")}{`;
            Array.prototype.unshift(keys, "byteLength", "byteOffset", "buffer");
        } else if (isPromise1(value)) {
            braces[0] = `${getPrefix(constructor, tag1, "Promise")}{`;
            formatter = formatPromise;
        } else if (isWeakSet1(value)) {
            braces[0] = `${getPrefix(constructor, tag1, "WeakSet")}{`;
            formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
        } else if (isWeakMap1(value)) {
            braces[0] = `${getPrefix(constructor, tag1, "WeakMap")}{`;
            formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
        } else if (isModuleNamespaceObject1(value)) {
            braces[0] = `${getPrefix(constructor, tag1, "Module")}{`;
            formatter = formatNamespaceObject.bind(null, keys);
        } else if (isBoxedPrimitive1(value)) {
            base2 = getBoxedBase(value, ctx, keys, constructor, tag1);
            if (keys.length === 0 && protoProps === undefined) {
                return base2;
            }
        } else {
            if (keys.length === 0 && protoProps === undefined) {
                return `${getCtxStyle(value, constructor, tag1)}{}`;
            }
            braces[0] = `${getCtxStyle(value, constructor, tag1)}{`;
        }
    }
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        let constructorName = getCtxStyle(value, constructor, tag1).slice(0, -1);
        if (constructor !== null) {
            constructorName = `[${constructorName}]`;
        }
        return ctx.stylize(constructorName, "special");
    }
    recurseTimes += 1;
    ctx.seen.push(value);
    ctx.currentDepth = recurseTimes;
    let output;
    const indentationLvl = ctx.indentationLvl;
    try {
        output = formatter(ctx, value, recurseTimes);
        for(i14 = 0; i14 < keys.length; i14++){
            output.push(formatProperty(ctx, value, recurseTimes, keys[i14], extrasType));
        }
        if (protoProps !== undefined) {
            output.push(...protoProps);
        }
    } catch (err6) {
        const constructorName = getCtxStyle(value, constructor, tag1).slice(0, -1);
        return handleMaxCallStackSize(ctx, err6, constructorName, indentationLvl);
    }
    if (ctx.circular !== undefined) {
        const index3 = ctx.circular.get(value);
        if (index3 !== undefined) {
            const reference = ctx.stylize(`<ref *${index3}>`, "special");
            if (ctx.compact !== true) {
                base2 = base2 === "" ? reference : `${reference} ${base2}`;
            } else {
                braces[0] = `${reference} ${braces[0]}`;
            }
        }
    }
    ctx.seen.pop();
    if (ctx.sorted) {
        const comparator = ctx.sorted === true ? undefined : ctx.sorted;
        if (extrasType === 0) {
            output = output.sort(comparator);
        } else if (keys.length > 1) {
            const sorted = output.slice(output.length - keys.length).sort(comparator);
            output.splice(output.length - keys.length, keys.length, ...sorted);
        }
    }
    const res = reduceToSingleString(ctx, output, base2, braces, extrasType, recurseTimes, value);
    const budget = ctx.budget[ctx.indentationLvl] || 0;
    const newLength = budget + res.length;
    ctx.budget[ctx.indentationLvl] = newLength;
    if (newLength > 2 ** 27) {
        ctx.depth = -1;
    }
    return res;
}
const builtInObjects = new Set(Object.getOwnPropertyNames(globalThis).filter((e8)=>/^[A-Z][a-zA-Z0-9]+$/.test(e8)
));
function addPrototypeProperties(ctx, main, obj, recurseTimes, output) {
    let depth = 0;
    let keys;
    let keySet;
    do {
        if (depth !== 0 || main === obj) {
            obj = Object.getPrototypeOf(obj);
            if (obj === null) {
                return;
            }
            const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
            if (descriptor !== undefined && typeof descriptor.value === "function" && builtInObjects.has(descriptor.value.name)) {
                return;
            }
        }
        if (depth === 0) {
            keySet = new Set();
        } else {
            Array.prototype.forEach(keys, (key)=>keySet.add(key)
            );
        }
        keys = Reflect.ownKeys(obj);
        Array.prototype.push(ctx.seen, main);
        for (const key1 of keys){
            if (key1 === "constructor" || main.hasOwnProperty(key1) || depth !== 0 && keySet.has(key1)) {
                continue;
            }
            const desc = Object.getOwnPropertyDescriptor(obj, key1);
            if (typeof desc.value === "function") {
                continue;
            }
            const value = formatProperty(ctx, obj, recurseTimes, key1, 0, desc, main);
            if (ctx.colors) {
                Array.prototype.push(output, `\u001b[2m${value}\u001b[22m`);
            } else {
                Array.prototype.push(output, value);
            }
        }
        Array.prototype.pop(ctx.seen);
    }while (++depth !== 3)
}
function getConstructorName(obj, ctx, recurseTimes, protoProps) {
    let firstProto;
    const tmp = obj;
    while(obj || isUndetectableObject(obj)){
        const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
        if (descriptor !== undefined && typeof descriptor.value === "function" && descriptor.value.name !== "" && isInstanceof(tmp, descriptor.value)) {
            if (protoProps !== undefined && (firstProto !== obj || !builtInObjects.has(descriptor.value.name))) {
                addPrototypeProperties(ctx, tmp, firstProto || tmp, recurseTimes, protoProps);
            }
            return descriptor.value.name;
        }
        obj = Object.getPrototypeOf(obj);
        if (firstProto === undefined) {
            firstProto = obj;
        }
    }
    if (firstProto === null) {
        return null;
    }
    const res = undefined;
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        return `${res} <Complex prototype>`;
    }
    const protoConstr = getConstructorName(firstProto, ctx, recurseTimes + 1, protoProps);
    if (protoConstr === null) {
        return `${res} <${inspect(firstProto, {
            ...ctx,
            customInspect: false,
            depth: -1
        })}>`;
    }
    return `${res} <${protoConstr}>`;
}
function formatPrimitive(fn, value, ctx) {
    if (typeof value === "string") {
        let trailer = "";
        if (value.length > ctx.maxStringLength) {
            const remaining = value.length - ctx.maxStringLength;
            value = value.slice(0, ctx.maxStringLength);
            trailer = `... ${remaining} more character${remaining > 1 ? "s" : ""}`;
        }
        if (ctx.compact !== true && value.length > 16 && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
            return value.split(/(?<=\n)/).map((line)=>fn(strEscape(line), "string")
            ).join(` +\n${" ".repeat(ctx.indentationLvl + 2)}`) + trailer;
        }
        return fn(strEscape(value), "string") + trailer;
    }
    if (typeof value === "number") {
        return formatNumber(fn, value);
    }
    if (typeof value === "bigint") {
        return formatBigInt(fn, value);
    }
    if (typeof value === "boolean") {
        return fn(`${value}`, "boolean");
    }
    if (typeof value === "undefined") {
        return fn("undefined", "undefined");
    }
    return fn(value.toString(), "symbol");
}
function getEmptyFormatArray() {
    return [];
}
function isInstanceof(object, proto) {
    try {
        return object instanceof proto;
    } catch  {
        return false;
    }
}
function getPrefix(constructor, tag2, fallback, size = "") {
    if (constructor === null) {
        if (tag2 !== "" && fallback !== tag2) {
            return `[${fallback}${size}: null prototype] [${tag2}] `;
        }
        return `[${fallback}${size}: null prototype] `;
    }
    if (tag2 !== "" && constructor !== tag2) {
        return `${constructor}${size} [${tag2}] `;
    }
    return `${constructor}${size} `;
}
function formatArray(ctx, value, recurseTimes) {
    const valLen = value.length;
    const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
    const remaining = valLen - len;
    const output = [];
    for(let i15 = 0; i15 < len; i15++){
        if (!value.hasOwnProperty(i15)) {
            return formatSpecialArray(ctx, value, recurseTimes, len, output, i15);
        }
        output.push(formatProperty(ctx, value, recurseTimes, i15, 1));
    }
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getCtxStyle(_value, constructor, tag3) {
    let fallback = "";
    if (constructor === null) {
        if (fallback === tag3) {
            fallback = "Object";
        }
    }
    return getPrefix(constructor, tag3, fallback);
}
function getKeys(value, showHidden) {
    let keys;
    const symbols1 = Object.getOwnPropertySymbols(value);
    if (showHidden) {
        keys = Object.getOwnPropertyNames(value);
        if (symbols1.length !== 0) {
            Array.prototype.push.apply(keys, symbols1);
        }
    } else {
        try {
            keys = Object.keys(value);
        } catch (_err) {
            keys = Object.getOwnPropertyNames(value);
        }
        if (symbols1.length !== 0) {}
    }
    return keys;
}
function formatSet(value, ctx, _ignored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const v4 of value){
        Array.prototype.push(output, formatValue(ctx, v4, recurseTimes));
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatMap(value, ctx, _gnored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const { 0: k6 , 1: v5  } of value){
        output.push(`${formatValue(ctx, k6, recurseTimes)} => ${formatValue(ctx, v5, recurseTimes)}`);
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatTypedArray(value, length, ctx, _ignored, recurseTimes) {
    const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), length);
    const remaining = value.length - maxLength;
    const output = new Array(maxLength);
    const elementFormatter = value.length > 0 && typeof value[0] === "number" ? formatNumber : formatBigInt;
    for(let i16 = 0; i16 < maxLength; ++i16){
        output[i16] = elementFormatter(ctx.stylize, value[i16]);
    }
    if (remaining > 0) {
        output[maxLength] = `... ${remaining} more item${remaining > 1 ? "s" : ""}`;
    }
    if (ctx.showHidden) {
        ctx.indentationLvl += 2;
        for (const key of [
            "BYTES_PER_ELEMENT",
            "length",
            "byteLength",
            "byteOffset",
            "buffer", 
        ]){
            const str = formatValue(ctx, value[key], recurseTimes, true);
            Array.prototype.push(output, `[${key}]: ${str}`);
        }
        ctx.indentationLvl -= 2;
    }
    return output;
}
function getIteratorBraces(type4, tag4) {
    if (tag4 !== `${type4} Iterator`) {
        if (tag4 !== "") {
            tag4 += "] [";
        }
        tag4 += `${type4} Iterator`;
    }
    return [
        `[${tag4}] {`,
        "}"
    ];
}
function formatIterator(braces, ctx, value, recurseTimes) {
    const { 0: entries , 1: isKeyValue  } = value;
    if (isKeyValue) {
        braces[0] = braces[0].replace(/ Iterator] {$/, " Entries] {");
        return formatMapIterInner(ctx, recurseTimes, entries, 2);
    }
    return formatSetIterInner(ctx, recurseTimes, entries, 1);
}
function getFunctionBase(value, constructor, tag5) {
    const stringified = Function.prototype.toString(value);
    if (stringified.slice(0, 5) === "class" && stringified.endsWith("}")) {
        const slice = stringified.slice(5, -1);
        const bracketIndex = slice.indexOf("{");
        if (bracketIndex !== -1 && (!slice.slice(0, bracketIndex).includes("(") || classRegExp.test(slice.replace(stripCommentsRegExp)))) {
            return getClassBase(value, constructor, tag5);
        }
    }
    let type5 = "Function";
    if (isGeneratorFunction1(value)) {
        type5 = `Generator${type5}`;
    }
    if (isAsyncFunction1(value)) {
        type5 = `Async${type5}`;
    }
    let base3 = `[${type5}`;
    if (constructor === null) {
        base3 += " (null prototype)";
    }
    if (value.name === "") {
        base3 += " (anonymous)";
    } else {
        base3 += `: ${value.name}`;
    }
    base3 += "]";
    if (constructor !== type5 && constructor !== null) {
        base3 += ` ${constructor}`;
    }
    if (tag5 !== "" && constructor !== tag5) {
        base3 += ` [${tag5}]`;
    }
    return base3;
}
function formatError(err7, constructor, tag6, ctx, keys) {
    const name16 = err7.name != null ? String(err7.name) : "Error";
    let len = name16.length;
    let stack = err7.stack ? String(err7.stack) : err7.toString();
    if (!ctx.showHidden && keys.length !== 0) {
        for (const name17 of [
            "name",
            "message",
            "stack"
        ]){
            const index4 = keys.indexOf(name17);
            if (index4 !== -1 && stack.includes(err7[name17])) {
                keys.splice(index4, 1);
            }
        }
    }
    if (constructor === null || name16.endsWith("Error") && stack.startsWith(name16) && (stack.length === len || stack[len] === ":" || stack[len] === "\n")) {
        let fallback = "Error";
        if (constructor === null) {
            const start1 = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
            fallback = start1 && start1[1] || "";
            len = fallback.length;
            fallback = fallback || "Error";
        }
        const prefix = getPrefix(constructor, tag6, fallback).slice(0, -1);
        if (name16 !== prefix) {
            if (prefix.includes(name16)) {
                if (len === 0) {
                    stack = `${prefix}: ${stack}`;
                } else {
                    stack = `${prefix}${stack.slice(len)}`;
                }
            } else {
                stack = `${prefix} [${name16}]${stack.slice(len)}`;
            }
        }
    }
    let pos = err7.message && stack.indexOf(err7.message) || -1;
    if (pos !== -1) {
        pos += err7.message.length;
    }
    const stackStart = stack.indexOf("\n    at", pos);
    if (stackStart === -1) {
        stack = `[${stack}]`;
    } else if (ctx.colors) {
        let newStack = stack.slice(0, stackStart);
        const lines = stack.slice(stackStart + 1).split("\n");
        for (const line of lines){
            let nodeModule;
            newStack += "\n";
            let pos = 0;
            while(nodeModule = nodeModulesRegExp.exec(line)){
                newStack += line.slice(pos, nodeModule.index + 14);
                newStack += ctx.stylize(nodeModule[1], "module");
                pos = nodeModule.index + nodeModule[0].length;
            }
            newStack += pos === 0 ? line : line.slice(pos);
        }
        stack = newStack;
    }
    if (ctx.indentationLvl !== 0) {
        const indentation = " ".repeat(ctx.indentationLvl);
        stack = stack.replace(/\n/g, `\n${indentation}`);
    }
    return stack;
}
let hexSlice;
function formatArrayBuffer(ctx, value) {
    let buffer3;
    try {
        buffer3 = new Uint8Array(value);
    } catch  {
        return [
            ctx.stylize("(detached)", "special")
        ];
    }
    let str = hexSlice(buffer3, 0, Math.min(ctx.maxArrayLength, buffer3.length)).replace(/(.{2})/g, "$1 ").trim();
    const remaining = buffer3.length - ctx.maxArrayLength;
    if (remaining > 0) {
        str += ` ... ${remaining} more byte${remaining > 1 ? "s" : ""}`;
    }
    return [
        `${ctx.stylize("[Uint8Contents]", "special")}: <${str}>`
    ];
}
function formatNumber(fn, value) {
    return fn(Object.is(value, -0) ? "-0" : `${value}`, "number");
}
function formatPromise(ctx, value, recurseTimes) {
    let output;
    const { 0: state2 , 1: result  } = value;
    if (state2 === 0) {
        output = [
            ctx.stylize("<pending>", "special")
        ];
    } else {
        ctx.indentationLvl += 2;
        const str = formatValue(ctx, result, recurseTimes);
        ctx.indentationLvl -= 2;
        output = [
            state2 === kRejected ? `${ctx.stylize("<rejected>", "special")} ${str}` : str, 
        ];
    }
    return output;
}
function formatWeakCollection(ctx) {
    return [
        ctx.stylize("<items unknown>", "special")
    ];
}
function formatWeakSet(ctx, value, recurseTimes) {
    const entries = value;
    return formatSetIterInner(ctx, recurseTimes, entries, 0);
}
function formatWeakMap(ctx, value, recurseTimes) {
    const entries = value;
    return formatMapIterInner(ctx, recurseTimes, entries, 0);
}
function formatProperty(ctx, value, recurseTimes, key, type6, desc, original = value) {
    let name18, str;
    let extra = " ";
    desc = desc || Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key],
        enumerable: true
    };
    if (desc.value !== undefined) {
        const diff1 = ctx.compact !== true || type6 !== 0 ? 2 : 3;
        ctx.indentationLvl += diff1;
        str = formatValue(ctx, desc.value, recurseTimes);
        if (diff1 === 3 && ctx.breakLength < getStringWidth(str, ctx.colors)) {
            extra = `\n${" ".repeat(ctx.indentationLvl)}`;
        }
        ctx.indentationLvl -= diff1;
    } else if (desc.get !== undefined) {
        const label = desc.set !== undefined ? "Getter/Setter" : "Getter";
        const s5 = ctx.stylize;
        const sp = "special";
        if (ctx.getters && (ctx.getters === true || ctx.getters === "get" && desc.set === undefined || ctx.getters === "set" && desc.set !== undefined)) {
            try {
                const tmp = desc.get.call(original);
                ctx.indentationLvl += 2;
                if (tmp === null) {
                    str = `${s5(`[${label}:`, sp)} ${s5("null", "null")}${s5("]", sp)}`;
                } else if (typeof tmp === "object") {
                    str = `${s5(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;
                } else {
                    const primitive = formatPrimitive(s5, tmp, ctx);
                    str = `${s5(`[${label}:`, sp)} ${primitive}${s5("]", sp)}`;
                }
                ctx.indentationLvl -= 2;
            } catch (err8) {
                const message = `<Inspection threw (${err8.message})>`;
                str = `${s5(`[${label}:`, sp)} ${message}${s5("]", sp)}`;
            }
        } else {
            str = ctx.stylize(`[${label}]`, sp);
        }
    } else if (desc.set !== undefined) {
        str = ctx.stylize("[Setter]", "special");
    } else {
        str = ctx.stylize("undefined", "undefined");
    }
    if (type6 === 1) {
        return str;
    }
    if (typeof key === "symbol") {
        const tmp = key.toString().replace(strEscapeSequencesReplacer, escapeFn);
        name18 = `[${ctx.stylize(tmp, "symbol")}]`;
    } else if (key === "__proto__") {
        name18 = "['__proto__']";
    } else if (desc.enumerable === false) {
        const tmp = key.replace(strEscapeSequencesReplacer, escapeFn);
        name18 = `[${tmp}]`;
    } else if (keyStrRegExp.test(key)) {
        name18 = ctx.stylize(key, "name");
    } else {
        name18 = ctx.stylize(strEscape(key), "string");
    }
    return `${name18}:${extra}${str}`;
}
function handleMaxCallStackSize(_ctx, _err, _constructorName, _indentationLvl) {}
const colorRegExp = /\u001b\[\d\d?m/g;
function removeColors(str) {
    return str.replace(colorRegExp, "");
}
function isBelowBreakLength(ctx, output, start2, base4) {
    let totalLength = output.length + start2;
    if (totalLength + output.length > ctx.breakLength) {
        return false;
    }
    for(let i17 = 0; i17 < output.length; i17++){
        if (ctx.colors) {
            totalLength += removeColors(output[i17]).length;
        } else {
            totalLength += output[i17].length;
        }
        if (totalLength > ctx.breakLength) {
            return false;
        }
    }
    return base4 === "" || !base4.includes("\n");
}
function formatBigInt(fn, value) {
    return fn(`${value}n`, "bigint");
}
function formatNamespaceObject(keys, ctx, value, recurseTimes) {
    const output = new Array(keys.length);
    for(let i18 = 0; i18 < keys.length; i18++){
        try {
            output[i18] = formatProperty(ctx, value, recurseTimes, keys[i18], kObjectType);
        } catch (_err) {
            const tmp = {
                [keys[i18]]: ""
            };
            output[i18] = formatProperty(ctx, tmp, recurseTimes, keys[i18], kObjectType);
            const pos = output[i18].lastIndexOf(" ");
            output[i18] = output[i18].slice(0, pos + 1) + ctx.stylize("<uninitialized>", "special");
        }
    }
    keys.length = 0;
    return output;
}
function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i19) {
    const keys = Object.keys(value);
    let index5 = i19;
    for(; i19 < keys.length && output.length < maxLength; i19++){
        const key = keys[i19];
        const tmp = +key;
        if (tmp > 2 ** 32 - 2) {
            break;
        }
        if (`${index5}` !== key) {
            if (!numberRegExp.test(key)) {
                break;
            }
            const emptyItems = tmp - index5;
            const ending = emptyItems > 1 ? "s" : "";
            const message = `<${emptyItems} empty item${ending}>`;
            output.push(ctx.stylize(message, "undefined"));
            index5 = tmp;
            if (output.length === maxLength) {
                break;
            }
        }
        output.push(formatProperty(ctx, value, recurseTimes, key, 1));
        index5++;
    }
    const remaining = value.length - index5;
    if (output.length !== maxLength) {
        if (remaining > 0) {
            const ending = remaining > 1 ? "s" : "";
            const message = `<${remaining} empty item${ending}>`;
            output.push(ctx.stylize(message, "undefined"));
        }
    } else if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getBoxedBase(value, ctx, keys, constructor, tag7) {
    let type7;
    if (isNumberObject1(value)) {
        type7 = "Number";
    } else if (isStringObject1(value)) {
        type7 = "String";
        keys.splice(0, value.length);
    } else if (isBooleanObject1(value)) {
        type7 = "Boolean";
    } else if (isBigIntObject1(value)) {
        type7 = "BigInt";
    } else {
        type7 = "Symbol";
    }
    let base5 = `[${type7}`;
    if (type7 !== constructor) {
        if (constructor === null) {
            base5 += " (null prototype)";
        } else {
            base5 += ` (${constructor})`;
        }
    }
    base5 += `: ${formatPrimitive(stylizeNoColor, value.valueOf(), ctx)}]`;
    if (tag7 !== "" && tag7 !== constructor) {
        base5 += ` [${tag7}]`;
    }
    if (keys.length !== 0 || ctx.stylize === stylizeNoColor) {
        return base5;
    }
    return ctx.stylize(base5, type7.toLowerCase());
}
function getClassBase(value, constructor, tag8) {
    const hasName = value.hasOwnProperty("name");
    const name19 = hasName && value.name || "(anonymous)";
    let base6 = `class ${name19}`;
    if (constructor !== "Function" && constructor !== null) {
        base6 += ` [${constructor}]`;
    }
    if (tag8 !== "" && constructor !== tag8) {
        base6 += ` [${tag8}]`;
    }
    if (constructor !== null) {
        const superName = Object.getPrototypeOf(value).name;
        if (superName) {
            base6 += ` extends ${superName}`;
        }
    } else {
        base6 += " extends [null prototype]";
    }
    return `[${base6}]`;
}
function reduceToSingleString(ctx, output, base7, braces, extrasType, recurseTimes, value) {
    if (ctx.compact !== true) {
        if (typeof ctx.compact === "number" && ctx.compact >= 1) {
            const entries = output.length;
            if (extrasType === 2 && entries > 6) {
                output = groupArrayElements(ctx, output, value);
            }
            if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
                const start3 = output.length + ctx.indentationLvl + braces[0].length + base7.length + 10;
                if (isBelowBreakLength(ctx, output, start3, base7)) {
                    return `${base7 ? `${base7} ` : ""}${braces[0]} ${join(output, ", ")}` + ` ${braces[1]}`;
                }
            }
        }
        const indentation = `\n${" ".repeat(ctx.indentationLvl)}`;
        return `${base7 ? `${base7} ` : ""}${braces[0]}${indentation}  ` + `${join(output, `,${indentation}  `)}${indentation}${braces[1]}`;
    }
    if (isBelowBreakLength(ctx, output, 0, base7)) {
        return `${braces[0]}${base7 ? ` ${base7}` : ""} ${join(output, ", ")} ` + braces[1];
    }
    const indentation = " ".repeat(ctx.indentationLvl);
    const ln = base7 === "" && braces[0].length === 1 ? " " : `${base7 ? ` ${base7}` : ""}\n${indentation}  `;
    return `${braces[0]}${ln}${join(output, `,\n${indentation}  `)} ${braces[1]}`;
}
function join(output, separator) {
    let str = "";
    if (output.length !== 0) {
        const lastIndex = output.length - 1;
        for(let i20 = 0; i20 < lastIndex; i20++){
            str += output[i20];
            str += separator;
        }
        str += output[lastIndex];
    }
    return str;
}
function groupArrayElements(ctx, output, value) {
    let totalLength = 0;
    let maxLength = 0;
    let i21 = 0;
    let outputLength = output.length;
    if (ctx.maxArrayLength < output.length) {
        outputLength--;
    }
    const separatorSpace = 2;
    const dataLen = new Array(outputLength);
    for(; i21 < outputLength; i21++){
        const len = getStringWidth(output[i21], ctx.colors);
        dataLen[i21] = len;
        totalLength += len + separatorSpace;
        if (maxLength < len) {
            maxLength = len;
        }
    }
    const actualMax = maxLength + 2;
    if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
        const averageBias = Math.sqrt(actualMax - totalLength / output.length);
        const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
        const columns = Math.min(Math.round(Math.sqrt(2.5 * biasedMax * outputLength) / biasedMax), Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), ctx.compact * 4, 15);
        if (columns <= 1) {
            return output;
        }
        const tmp = [];
        const maxLineLength = [];
        for(let i22 = 0; i22 < columns; i22++){
            let lineMaxLength = 0;
            for(let j = i22; j < output.length; j += columns){
                if (dataLen[j] > lineMaxLength) {
                    lineMaxLength = dataLen[j];
                }
            }
            lineMaxLength += separatorSpace;
            maxLineLength[i22] = lineMaxLength;
        }
        let order = String.prototype.padStart;
        if (value !== undefined) {
            for(let i23 = 0; i23 < output.length; i23++){
                if (typeof value[i23] !== "number" && typeof value[i23] !== "bigint") {
                    order = String.prototype.padEnd;
                    break;
                }
            }
        }
        for(let i1 = 0; i1 < outputLength; i1 += columns){
            const max = Math.min(i1 + columns, outputLength);
            let str = "";
            let j = i1;
            for(; j < max - 1; j++){
                const padding = maxLineLength[j - i1] + output[j].length - dataLen[j];
                str += `${output[j]}, `.padStart(padding, " ");
            }
            if (order === String.prototype.padStart) {
                const padding = maxLineLength[j - i1] + output[j].length - dataLen[j] - 2;
                str += output[j].padStart(padding, " ");
            } else {
                str += output[j];
            }
            Array.prototype.push(tmp, str);
        }
        if (ctx.maxArrayLength < output.length) {
            Array.prototype.push(tmp, output[outputLength]);
        }
        output = tmp;
    }
    return output;
}
function formatMapIterInner(ctx, recurseTimes, entries, state3) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const len = entries.length / 2;
    const remaining = len - maxArrayLength;
    const maxLength = Math.min(maxArrayLength, len);
    let output = new Array(maxLength);
    let i24 = 0;
    ctx.indentationLvl += 2;
    if (state3 === 0) {
        for(; i24 < maxLength; i24++){
            const pos = i24 * 2;
            output[i24] = `${formatValue(ctx, entries[pos], recurseTimes)} => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;
        }
        if (!ctx.sorted) {
            output = output.sort();
        }
    } else {
        for(; i24 < maxLength; i24++){
            const pos = i24 * 2;
            const res = [
                formatValue(ctx, entries[pos], recurseTimes),
                formatValue(ctx, entries[pos + 1], recurseTimes), 
            ];
            output[i24] = reduceToSingleString(ctx, res, "", [
                "[",
                "]"
            ], kArrayExtrasType, recurseTimes);
        }
    }
    ctx.indentationLvl -= 2;
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function formatSetIterInner(ctx, recurseTimes, entries, state4) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const maxLength = Math.min(maxArrayLength, entries.length);
    const output = new Array(maxLength);
    ctx.indentationLvl += 2;
    for(let i25 = 0; i25 < maxLength; i25++){
        output[i25] = formatValue(ctx, entries[i25], recurseTimes);
    }
    ctx.indentationLvl -= 2;
    if (state4 === 0 && !ctx.sorted) {
        output.sort();
    }
    const remaining = entries.length - maxLength;
    if (remaining > 0) {
        Array.prototype.push(output, `... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
const ansiPattern = "[\\u001B\\u009B][[\\]()#;?]*" + "(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*" + "|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)" + "|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
const ansi = new RegExp(ansiPattern, "g");
function getStringWidth(str, removeControlChars = true) {
    let width = 0;
    if (removeControlChars) {
        str = stripVTControlCharacters(str);
    }
    str = str.normalize("NFC");
    for (const __char of str[Symbol.iterator]()){
        const code1 = __char.codePointAt(0);
        if (isFullWidthCodePoint(code1)) {
            width += 2;
        } else if (!isZeroWidthCodePoint(code1)) {
            width++;
        }
    }
    return width;
}
const isFullWidthCodePoint = (code2)=>{
    return code2 >= 4352 && (code2 <= 4447 || code2 === 9001 || code2 === 9002 || code2 >= 11904 && code2 <= 12871 && code2 !== 12351 || code2 >= 12880 && code2 <= 19903 || code2 >= 19968 && code2 <= 42182 || code2 >= 43360 && code2 <= 43388 || code2 >= 44032 && code2 <= 55203 || code2 >= 63744 && code2 <= 64255 || code2 >= 65040 && code2 <= 65049 || code2 >= 65072 && code2 <= 65131 || code2 >= 65281 && code2 <= 65376 || code2 >= 65504 && code2 <= 65510 || code2 >= 110592 && code2 <= 110593 || code2 >= 127488 && code2 <= 127569 || code2 >= 127744 && code2 <= 128591 || code2 >= 131072 && code2 <= 262141);
};
const isZeroWidthCodePoint = (code3)=>{
    return code3 <= 31 || code3 >= 127 && code3 <= 159 || code3 >= 768 && code3 <= 879 || code3 >= 8203 && code3 <= 8207 || code3 >= 8400 && code3 <= 8447 || code3 >= 65024 && code3 <= 65039 || code3 >= 65056 && code3 <= 65071 || code3 >= 917760 && code3 <= 917999;
};
function hasBuiltInToString(value) {
    const proxyTarget = undefined;
    if (proxyTarget !== undefined) {
        value = proxyTarget;
    }
    if (typeof value.toString !== "function") {
        return true;
    }
    if (Object.prototype.hasOwnProperty.call(value, "toString")) {
        return false;
    }
    let pointer = value;
    do {
        pointer = Object.getPrototypeOf(pointer);
    }while (!Object.prototype.hasOwnProperty.call(pointer, "toString"))
    const descriptor = Object.getOwnPropertyDescriptor(pointer, "constructor");
    return descriptor !== undefined && typeof descriptor.value === "function" && builtInObjects.has(descriptor.value.name);
}
const firstErrorLine = (error2)=>error2.message.split("\n", 1)[0]
;
let CIRCULAR_ERROR_MESSAGE;
function tryStringify(arg) {
    try {
        return JSON.stringify(arg);
    } catch (err9) {
        if (!CIRCULAR_ERROR_MESSAGE) {
            try {
                const a6 = {};
                a6.a = a6;
                JSON.stringify(a6);
            } catch (circularError) {
                CIRCULAR_ERROR_MESSAGE = firstErrorLine(circularError);
            }
        }
        if (err9.name === "TypeError" && firstErrorLine(err9) === CIRCULAR_ERROR_MESSAGE) {
            return "[Circular]";
        }
        throw err9;
    }
}
function format(...args) {
    return formatWithOptionsInternal(undefined, args);
}
function formatWithOptions(inspectOptions, ...args) {
    if (typeof inspectOptions !== "object" || inspectOptions === null) {
        throw new codes.ERR_INVALID_ARG_TYPE("inspectOptions", "object", inspectOptions);
    }
    return formatWithOptionsInternal(inspectOptions, args);
}
function formatNumberNoColor(number, options) {
    return formatNumber(stylizeNoColor, number, options?.numericSeparator ?? inspectDefaultOptions.numericSeparator);
}
function formatBigIntNoColor(bigint, options) {
    return formatBigInt(stylizeNoColor, bigint, options?.numericSeparator ?? inspectDefaultOptions.numericSeparator);
}
function formatWithOptionsInternal(inspectOptions, args) {
    const first = args[0];
    let a7 = 0;
    let str = "";
    let join1 = "";
    if (typeof first === "string") {
        if (args.length === 1) {
            return first;
        }
        let tempStr;
        let lastPos = 0;
        for(let i26 = 0; i26 < first.length - 1; i26++){
            if (first.charCodeAt(i26) === 37) {
                const nextChar = first.charCodeAt(++i26);
                if (a7 + 1 !== args.length) {
                    switch(nextChar){
                        case 115:
                            const tempArg = args[++a7];
                            if (typeof tempArg === "number") {
                                tempStr = formatNumberNoColor(tempArg, inspectOptions);
                            } else if (typeof tempArg === "bigint") {
                                tempStr = formatBigIntNoColor(tempArg, inspectOptions);
                            } else if (typeof tempArg !== "object" || tempArg === null || !hasBuiltInToString(tempArg)) {
                                tempStr = String(tempArg);
                            } else {
                                tempStr = inspect(tempArg, {
                                    ...inspectOptions,
                                    compact: 3,
                                    colors: false,
                                    depth: 0
                                });
                            }
                            break;
                        case 106:
                            tempStr = tryStringify(args[++a7]);
                            break;
                        case 100:
                            const tempNum = args[++a7];
                            if (typeof tempNum === "bigint") {
                                tempStr = formatBigIntNoColor(tempNum, inspectOptions);
                            } else if (typeof tempNum === "symbol") {
                                tempStr = "NaN";
                            } else {
                                tempStr = formatNumberNoColor(Number(tempNum), inspectOptions);
                            }
                            break;
                        case 79:
                            tempStr = inspect(args[++a7], inspectOptions);
                            break;
                        case 111:
                            tempStr = inspect(args[++a7], {
                                ...inspectOptions,
                                showHidden: true,
                                showProxy: true,
                                depth: 4
                            });
                            break;
                        case 105:
                            const tempInteger = args[++a7];
                            if (typeof tempInteger === "bigint") {
                                tempStr = formatBigIntNoColor(tempInteger, inspectOptions);
                            } else if (typeof tempInteger === "symbol") {
                                tempStr = "NaN";
                            } else {
                                tempStr = formatNumberNoColor(Number.parseInt(tempInteger), inspectOptions);
                            }
                            break;
                        case 102:
                            const tempFloat = args[++a7];
                            if (typeof tempFloat === "symbol") {
                                tempStr = "NaN";
                            } else {
                                tempStr = formatNumberNoColor(Number.parseFloat(tempFloat), inspectOptions);
                            }
                            break;
                        case 99:
                            a7 += 1;
                            tempStr = "";
                            break;
                        case 37:
                            str += first.slice(lastPos, i26);
                            lastPos = i26 + 1;
                            continue;
                        default:
                            continue;
                    }
                    if (lastPos !== i26 - 1) {
                        str += first.slice(lastPos, i26 - 1);
                    }
                    str += tempStr;
                    lastPos = i26 + 1;
                } else if (nextChar === 37) {
                    str += first.slice(lastPos, i26);
                    lastPos = i26 + 1;
                }
            }
        }
        if (lastPos !== 0) {
            a7++;
            join1 = " ";
            if (lastPos < first.length) {
                str += first.slice(lastPos);
            }
        }
    }
    while(a7 < args.length){
        const value = args[a7];
        str += join1;
        str += typeof value !== "string" ? inspect(value, inspectOptions) : value;
        join1 = " ";
        a7++;
    }
    return str;
}
function stripVTControlCharacters(str) {
    validateString(str, "str");
    return str.replace(ansi, "");
}
const __default1 = {
    getStringWidth,
    stripVTControlCharacters,
    formatWithOptions
};
function once(callback) {
    let called = false;
    return function(...args) {
        if (called) return;
        called = true;
        Reflect.apply(callback, this, args);
    };
}
function createDeferredPromise() {
    let resolve9;
    let reject;
    const promise = new Promise((res, rej)=>{
        resolve9 = res;
        reject = rej;
    });
    return {
        promise,
        resolve: resolve9,
        reject
    };
}
const codesWarned = new Set();
function deprecate(fn, msg, code4) {
    if (code4 !== undefined) {
        validateString(code4, "code");
    }
    let warned = false;
    function deprecated(...args) {
        if (!warned) {
            warned = true;
            if (code4 !== undefined) {
                if (!codesWarned.has(code4)) {
                    process.emitWarning(msg, "DeprecationWarning", code4, deprecated);
                    codesWarned.add(code4);
                }
            } else {
                process.emitWarning(msg, "DeprecationWarning", deprecated);
            }
        }
        if (new.target) {
            return Reflect.construct(fn, args, new.target);
        }
        return Reflect.apply(fn, this, args);
    }
    Object.setPrototypeOf(deprecated, fn);
    if (fn.prototype) {
        deprecated.prototype = fn.prototype;
    }
    return deprecated;
}
const kCustomPromisifiedSymbol = Symbol.for("nodejs.util.promisify.custom");
const kCustomPromisifyArgsSymbol = Symbol.for("nodejs.util.promisify.customArgs");
const customPromisifyArgs = kCustomPromisifyArgsSymbol;
function promisify(original) {
    validateFunction(original, "original");
    if (original[kCustomPromisifiedSymbol]) {
        const fn = original[kCustomPromisifiedSymbol];
        validateFunction(fn, "util.promisify.custom");
        return Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    const argumentNames = original[kCustomPromisifyArgsSymbol];
    function fn(...args) {
        return new Promise((resolve10, reject)=>{
            args.push((err10, ...values)=>{
                if (err10) {
                    return reject(err10);
                }
                if (argumentNames !== undefined && values.length > 1) {
                    const obj = {};
                    for(let i27 = 0; i27 < argumentNames.length; i27++){
                        obj[argumentNames[i27]] = values[i27];
                    }
                    resolve10(obj);
                } else {
                    resolve10(values[0]);
                }
            });
            Reflect.apply(original, this, args);
        });
    }
    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn, Object.getOwnPropertyDescriptors(original));
}
promisify.custom = kCustomPromisifiedSymbol;
const __default2 = {
    createDeferredPromise,
    normalizeEncoding: normalizeEncoding1,
    once,
    deprecate,
    promisify
};
let core;
if (Deno?.core) {
    core = Deno.core;
} else {
    core = {
        setNextTickCallback: undefined,
        evalContext (_code, _filename) {
            throw new Error("Deno.core.evalContext is not supported in this environment");
        },
        encode (chunk) {
            return new TextEncoder().encode(chunk);
        }
    };
}
let _exiting = false;
const kSize = 2048;
const kMask = 2048 - 1;
class FixedCircularBuffer {
    bottom;
    top;
    list;
    next;
    constructor(){
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
    }
    isEmpty() {
        return this.top === this.bottom;
    }
    isFull() {
        return (this.top + 1 & kMask) === this.bottom;
    }
    push(data4) {
        this.list[this.top] = data4;
        this.top = this.top + 1 & kMask;
    }
    shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === undefined) {
            return null;
        }
        this.list[this.bottom] = undefined;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
    }
}
class FixedQueue {
    head;
    tail;
    constructor(){
        this.head = this.tail = new FixedCircularBuffer();
    }
    isEmpty() {
        return this.head.isEmpty();
    }
    push(data5) {
        if (this.head.isFull()) {
            this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data5);
    }
    shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
            this.tail = tail.next;
        }
        return next;
    }
}
const queue = new FixedQueue();
let _nextTick;
if (typeof core.setNextTickCallback !== "undefined") {
    function runNextTicks() {
        if (!core.hasTickScheduled()) {
            core.runMicrotasks();
        }
        if (!core.hasTickScheduled()) {
            return true;
        }
        processTicksAndRejections();
        return true;
    }
    function processTicksAndRejections() {
        let tock;
        do {
            while(tock = queue.shift()){
                try {
                    const callback = tock.callback;
                    if (tock.args === undefined) {
                        callback();
                    } else {
                        const args = tock.args;
                        switch(args.length){
                            case 1:
                                callback(args[0]);
                                break;
                            case 2:
                                callback(args[0], args[1]);
                                break;
                            case 3:
                                callback(args[0], args[1], args[2]);
                                break;
                            case 4:
                                callback(args[0], args[1], args[2], args[3]);
                                break;
                            default:
                                callback(...args);
                        }
                    }
                } finally{}
            }
            core.runMicrotasks();
        }while (!queue.isEmpty())
        core.setHasTickScheduled(false);
    }
    core.setNextTickCallback(processTicksAndRejections);
    core.setMacrotaskCallback(runNextTicks);
    function __nextTickNative(callback, ...args) {
        validateCallback(callback);
        if (_exiting) {
            return;
        }
        let args_;
        switch(args.length){
            case 0:
                break;
            case 1:
                args_ = [
                    args[0]
                ];
                break;
            case 2:
                args_ = [
                    args[0],
                    args[1]
                ];
                break;
            case 3:
                args_ = [
                    args[0],
                    args[1],
                    args[2]
                ];
                break;
            default:
                args_ = new Array(args.length);
                for(let i28 = 0; i28 < args.length; i28++){
                    args_[i28] = args[i28];
                }
        }
        if (queue.isEmpty()) {
            core.setHasTickScheduled(true);
        }
        const tickObject = {
            callback,
            args: args_
        };
        queue.push(tickObject);
    }
    _nextTick = __nextTickNative;
} else {
    function __nextTickQueueMicrotask(callback, ...args) {
        if (args) {
            queueMicrotask(()=>callback.call(this, ...args)
            );
        } else {
            queueMicrotask(callback);
        }
    }
    _nextTick = __nextTickQueueMicrotask;
}
function nextTick2(callback, ...args) {
    _nextTick(callback, ...args);
}
class NodeFalsyValueRejectionError extends Error {
    reason;
    code = "ERR_FALSY_VALUE_REJECTION";
    constructor(reason){
        super("Promise was rejected with falsy value");
        this.reason = reason;
    }
}
class NodeInvalidArgTypeError extends TypeError {
    code = "ERR_INVALID_ARG_TYPE";
    constructor(argumentName){
        super(`The ${argumentName} argument must be of type function.`);
    }
}
function callbackify(original) {
    if (typeof original !== "function") {
        throw new NodeInvalidArgTypeError('"original"');
    }
    const callbackified = function(...args1) {
        const maybeCb = args1.pop();
        if (typeof maybeCb !== "function") {
            throw new NodeInvalidArgTypeError("last");
        }
        const cb = (...args)=>{
            maybeCb.apply(this, args);
        };
        original.apply(this, args1).then((ret)=>{
            nextTick2(cb.bind(this, null, ret));
        }, (rej)=>{
            rej = rej || new NodeFalsyValueRejectionError(rej);
            nextTick2(cb.bind(this, rej));
        });
    };
    const descriptors = Object.getOwnPropertyDescriptors(original);
    if (typeof descriptors.length.value === "number") {
        descriptors.length.value++;
    }
    if (typeof descriptors.name.value === "string") {
        descriptors.name.value += "Callbackified";
    }
    Object.defineProperties(callbackified, descriptors);
    return callbackified;
}
var State;
(function(State1) {
    State1[State1["PASSTHROUGH"] = 0] = "PASSTHROUGH";
    State1[State1["PERCENT"] = 1] = "PERCENT";
    State1[State1["POSITIONAL"] = 2] = "POSITIONAL";
    State1[State1["PRECISION"] = 3] = "PRECISION";
    State1[State1["WIDTH"] = 4] = "WIDTH";
})(State || (State = {}));
var WorP;
(function(WorP1) {
    WorP1[WorP1["WIDTH"] = 0] = "WIDTH";
    WorP1[WorP1["PRECISION"] = 1] = "PRECISION";
})(WorP || (WorP = {}));
class Flags {
    plus;
    dash;
    sharp;
    space;
    zero;
    lessthan;
    width = -1;
    precision = -1;
}
const min = Math.min;
const UNICODE_REPLACEMENT_CHARACTER = "\ufffd";
const FLOAT_REGEXP = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
var F;
(function(F1) {
    F1[F1["sign"] = 1] = "sign";
    F1[F1["mantissa"] = 2] = "mantissa";
    F1[F1["fractional"] = 3] = "fractional";
    F1[F1["esign"] = 4] = "esign";
    F1[F1["exponent"] = 5] = "exponent";
})(F || (F = {}));
class Printf {
    format;
    args;
    i;
    state = State.PASSTHROUGH;
    verb = "";
    buf = "";
    argNum = 0;
    flags = new Flags();
    haveSeen;
    tmpError;
    constructor(format8, ...args){
        this.format = format8;
        this.args = args;
        this.haveSeen = Array.from({
            length: args.length
        });
        this.i = 0;
    }
    doPrintf() {
        for(; this.i < this.format.length; ++this.i){
            const c8 = this.format[this.i];
            switch(this.state){
                case State.PASSTHROUGH:
                    if (c8 === "%") {
                        this.state = State.PERCENT;
                    } else {
                        this.buf += c8;
                    }
                    break;
                case State.PERCENT:
                    if (c8 === "%") {
                        this.buf += c8;
                        this.state = State.PASSTHROUGH;
                    } else {
                        this.handleFormat();
                    }
                    break;
                default:
                    throw Error("Should be unreachable, certainly a bug in the lib.");
            }
        }
        let extras = false;
        let err11 = "%!(EXTRA";
        for(let i29 = 0; i29 !== this.haveSeen.length; ++i29){
            if (!this.haveSeen[i29]) {
                extras = true;
                err11 += ` '${Deno.inspect(this.args[i29])}'`;
            }
        }
        err11 += ")";
        if (extras) {
            this.buf += err11;
        }
        return this.buf;
    }
    handleFormat() {
        this.flags = new Flags();
        const flags = this.flags;
        for(; this.i < this.format.length; ++this.i){
            const c9 = this.format[this.i];
            switch(this.state){
                case State.PERCENT:
                    switch(c9){
                        case "[":
                            this.handlePositional();
                            this.state = State.POSITIONAL;
                            break;
                        case "+":
                            flags.plus = true;
                            break;
                        case "<":
                            flags.lessthan = true;
                            break;
                        case "-":
                            flags.dash = true;
                            flags.zero = false;
                            break;
                        case "#":
                            flags.sharp = true;
                            break;
                        case " ":
                            flags.space = true;
                            break;
                        case "0":
                            flags.zero = !flags.dash;
                            break;
                        default:
                            if ("1" <= c9 && c9 <= "9" || c9 === "." || c9 === "*") {
                                if (c9 === ".") {
                                    this.flags.precision = 0;
                                    this.state = State.PRECISION;
                                    this.i++;
                                } else {
                                    this.state = State.WIDTH;
                                }
                                this.handleWidthAndPrecision(flags);
                            } else {
                                this.handleVerb();
                                return;
                            }
                    }
                    break;
                case State.POSITIONAL:
                    if (c9 === "*") {
                        const worp = this.flags.precision === -1 ? WorP.WIDTH : WorP.PRECISION;
                        this.handleWidthOrPrecisionRef(worp);
                        this.state = State.PERCENT;
                        break;
                    } else {
                        this.handleVerb();
                        return;
                    }
                default:
                    throw new Error(`Should not be here ${this.state}, library bug!`);
            }
        }
    }
    handleWidthOrPrecisionRef(wOrP) {
        if (this.argNum >= this.args.length) {
            return;
        }
        const arg = this.args[this.argNum];
        this.haveSeen[this.argNum] = true;
        if (typeof arg === "number") {
            switch(wOrP){
                case WorP.WIDTH:
                    this.flags.width = arg;
                    break;
                default:
                    this.flags.precision = arg;
            }
        } else {
            const tmp = wOrP === WorP.WIDTH ? "WIDTH" : "PREC";
            this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
        }
        this.argNum++;
    }
    handleWidthAndPrecision(flags) {
        const fmt = this.format;
        for(; this.i !== this.format.length; ++this.i){
            const c10 = fmt[this.i];
            switch(this.state){
                case State.WIDTH:
                    switch(c10){
                        case ".":
                            this.flags.precision = 0;
                            this.state = State.PRECISION;
                            break;
                        case "*":
                            this.handleWidthOrPrecisionRef(WorP.WIDTH);
                            break;
                        default:
                            {
                                const val = parseInt(c10);
                                if (isNaN(val)) {
                                    this.i--;
                                    this.state = State.PERCENT;
                                    return;
                                }
                                flags.width = flags.width == -1 ? 0 : flags.width;
                                flags.width *= 10;
                                flags.width += val;
                            }
                    }
                    break;
                case State.PRECISION:
                    {
                        if (c10 === "*") {
                            this.handleWidthOrPrecisionRef(WorP.PRECISION);
                            break;
                        }
                        const val = parseInt(c10);
                        if (isNaN(val)) {
                            this.i--;
                            this.state = State.PERCENT;
                            return;
                        }
                        flags.precision *= 10;
                        flags.precision += val;
                        break;
                    }
                default:
                    throw new Error("can't be here. bug.");
            }
        }
    }
    handlePositional() {
        if (this.format[this.i] !== "[") {
            throw new Error("Can't happen? Bug.");
        }
        let positional = 0;
        const format9 = this.format;
        this.i++;
        let err12 = false;
        for(; this.i !== this.format.length; ++this.i){
            if (format9[this.i] === "]") {
                break;
            }
            positional *= 10;
            const val = parseInt(format9[this.i]);
            if (isNaN(val)) {
                this.tmpError = "%!(BAD INDEX)";
                err12 = true;
            }
            positional += val;
        }
        if (positional - 1 >= this.args.length) {
            this.tmpError = "%!(BAD INDEX)";
            err12 = true;
        }
        this.argNum = err12 ? this.argNum : positional - 1;
        return;
    }
    handleLessThan() {
        const arg = this.args[this.argNum];
        if ((arg || {}).constructor.name !== "Array") {
            throw new Error(`arg ${arg} is not an array. Todo better error handling`);
        }
        let str = "[ ";
        for(let i30 = 0; i30 !== arg.length; ++i30){
            if (i30 !== 0) str += ", ";
            str += this._handleVerb(arg[i30]);
        }
        return str + " ]";
    }
    handleVerb() {
        const verb = this.format[this.i];
        this.verb = verb;
        if (this.tmpError) {
            this.buf += this.tmpError;
            this.tmpError = undefined;
            if (this.argNum < this.haveSeen.length) {
                this.haveSeen[this.argNum] = true;
            }
        } else if (this.args.length <= this.argNum) {
            this.buf += `%!(MISSING '${verb}')`;
        } else {
            const arg = this.args[this.argNum];
            this.haveSeen[this.argNum] = true;
            if (this.flags.lessthan) {
                this.buf += this.handleLessThan();
            } else {
                this.buf += this._handleVerb(arg);
            }
        }
        this.argNum++;
        this.state = State.PASSTHROUGH;
    }
    _handleVerb(arg) {
        switch(this.verb){
            case "t":
                return this.pad(arg.toString());
            case "b":
                return this.fmtNumber(arg, 2);
            case "c":
                return this.fmtNumberCodePoint(arg);
            case "d":
                return this.fmtNumber(arg, 10);
            case "o":
                return this.fmtNumber(arg, 8);
            case "x":
                return this.fmtHex(arg);
            case "X":
                return this.fmtHex(arg, true);
            case "e":
                return this.fmtFloatE(arg);
            case "E":
                return this.fmtFloatE(arg, true);
            case "f":
            case "F":
                return this.fmtFloatF(arg);
            case "g":
                return this.fmtFloatG(arg);
            case "G":
                return this.fmtFloatG(arg, true);
            case "s":
                return this.fmtString(arg);
            case "T":
                return this.fmtString(typeof arg);
            case "v":
                return this.fmtV(arg);
            case "j":
                return this.fmtJ(arg);
            default:
                return `%!(BAD VERB '${this.verb}')`;
        }
    }
    pad(s6) {
        const padding = this.flags.zero ? "0" : " ";
        if (this.flags.dash) {
            return s6.padEnd(this.flags.width, padding);
        }
        return s6.padStart(this.flags.width, padding);
    }
    padNum(nStr, neg) {
        let sign;
        if (neg) {
            sign = "-";
        } else if (this.flags.plus || this.flags.space) {
            sign = this.flags.plus ? "+" : " ";
        } else {
            sign = "";
        }
        const zero1 = this.flags.zero;
        if (!zero1) {
            nStr = sign + nStr;
        }
        const pad1 = zero1 ? "0" : " ";
        const len = zero1 ? this.flags.width - sign.length : this.flags.width;
        if (this.flags.dash) {
            nStr = nStr.padEnd(len, pad1);
        } else {
            nStr = nStr.padStart(len, pad1);
        }
        if (zero1) {
            nStr = sign + nStr;
        }
        return nStr;
    }
    fmtNumber(n1, radix, upcase = false) {
        let num = Math.abs(n1).toString(radix);
        const prec = this.flags.precision;
        if (prec !== -1) {
            this.flags.zero = false;
            num = n1 === 0 && prec === 0 ? "" : num;
            while(num.length < prec){
                num = "0" + num;
            }
        }
        let prefix = "";
        if (this.flags.sharp) {
            switch(radix){
                case 2:
                    prefix += "0b";
                    break;
                case 8:
                    prefix += num.startsWith("0") ? "" : "0";
                    break;
                case 16:
                    prefix += "0x";
                    break;
                default:
                    throw new Error("cannot handle base: " + radix);
            }
        }
        num = num.length === 0 ? num : prefix + num;
        if (upcase) {
            num = num.toUpperCase();
        }
        return this.padNum(num, n1 < 0);
    }
    fmtNumberCodePoint(n2) {
        let s7 = "";
        try {
            s7 = String.fromCodePoint(n2);
        } catch  {
            s7 = UNICODE_REPLACEMENT_CHARACTER;
        }
        return this.pad(s7);
    }
    fmtFloatSpecial(n3) {
        if (isNaN(n3)) {
            this.flags.zero = false;
            return this.padNum("NaN", false);
        }
        if (n3 === Number.POSITIVE_INFINITY) {
            this.flags.zero = false;
            this.flags.plus = true;
            return this.padNum("Inf", false);
        }
        if (n3 === Number.NEGATIVE_INFINITY) {
            this.flags.zero = false;
            return this.padNum("Inf", true);
        }
        return "";
    }
    roundFractionToPrecision(fractional, precision) {
        let round = false;
        if (fractional.length > precision) {
            fractional = "1" + fractional;
            let tmp = parseInt(fractional.substr(0, precision + 2)) / 10;
            tmp = Math.round(tmp);
            fractional = Math.floor(tmp).toString();
            round = fractional[0] === "2";
            fractional = fractional.substr(1);
        } else {
            while(fractional.length < precision){
                fractional += "0";
            }
        }
        return [
            fractional,
            round
        ];
    }
    fmtFloatE(n4, upcase = false) {
        const special = this.fmtFloatSpecial(n4);
        if (special !== "") {
            return special;
        }
        const m2 = n4.toExponential().match(FLOAT_REGEXP);
        if (!m2) {
            throw Error("can't happen, bug");
        }
        let fractional = m2[F.fractional];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        let rounding = false;
        [fractional, rounding] = this.roundFractionToPrecision(fractional, precision);
        let e9 = m2[F.exponent];
        let esign = m2[F.esign];
        let mantissa = parseInt(m2[F.mantissa]);
        if (rounding) {
            mantissa += 1;
            if (10 <= mantissa) {
                mantissa = 1;
                const r4 = parseInt(esign + e9) + 1;
                e9 = r4.toString();
                esign = r4 < 0 ? "-" : "+";
            }
        }
        e9 = e9.length == 1 ? "0" + e9 : e9;
        const val = `${mantissa}.${fractional}${upcase ? "E" : "e"}${esign}${e9}`;
        return this.padNum(val, n4 < 0);
    }
    fmtFloatF(n1) {
        const special = this.fmtFloatSpecial(n1);
        if (special !== "") {
            return special;
        }
        function expandNumber(n5) {
            if (Number.isSafeInteger(n5)) {
                return n5.toString() + ".";
            }
            const t2 = n5.toExponential().split("e");
            let m3 = t2[0].replace(".", "");
            const e10 = parseInt(t2[1]);
            if (e10 < 0) {
                let nStr = "0.";
                for(let i31 = 0; i31 !== Math.abs(e10) - 1; ++i31){
                    nStr += "0";
                }
                return nStr += m3;
            } else {
                const splIdx = e10 + 1;
                while(m3.length < splIdx){
                    m3 += "0";
                }
                return m3.substr(0, splIdx) + "." + m3.substr(splIdx);
            }
        }
        const val = expandNumber(Math.abs(n1));
        const arr = val.split(".");
        let dig = arr[0];
        let fractional = arr[1];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        let round = false;
        [fractional, round] = this.roundFractionToPrecision(fractional, precision);
        if (round) {
            dig = (parseInt(dig) + 1).toString();
        }
        return this.padNum(`${dig}.${fractional}`, n1 < 0);
    }
    fmtFloatG(n6, upcase = false) {
        const special = this.fmtFloatSpecial(n6);
        if (special !== "") {
            return special;
        }
        let P = this.flags.precision !== -1 ? this.flags.precision : 6;
        P = P === 0 ? 1 : P;
        const m4 = n6.toExponential().match(FLOAT_REGEXP);
        if (!m4) {
            throw Error("can't happen");
        }
        const X = parseInt(m4[F.exponent]) * (m4[F.esign] === "-" ? -1 : 1);
        let nStr = "";
        if (P > X && X >= -4) {
            this.flags.precision = P - (X + 1);
            nStr = this.fmtFloatF(n6);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*$/, "");
            }
        } else {
            this.flags.precision = P - 1;
            nStr = this.fmtFloatE(n6);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
            }
        }
        return nStr;
    }
    fmtString(s8) {
        if (this.flags.precision !== -1) {
            s8 = s8.substr(0, this.flags.precision);
        }
        return this.pad(s8);
    }
    fmtHex(val, upper = false) {
        switch(typeof val){
            case "number":
                return this.fmtNumber(val, 16, upper);
            case "string":
                {
                    const sharp = this.flags.sharp && val.length !== 0;
                    let hex = sharp ? "0x" : "";
                    const prec = this.flags.precision;
                    const end = prec !== -1 ? min(prec, val.length) : val.length;
                    for(let i32 = 0; i32 !== end; ++i32){
                        if (i32 !== 0 && this.flags.space) {
                            hex += sharp ? " 0x" : " ";
                        }
                        const c11 = (val.charCodeAt(i32) & 255).toString(16);
                        hex += c11.length === 1 ? `0${c11}` : c11;
                    }
                    if (upper) {
                        hex = hex.toUpperCase();
                    }
                    return this.pad(hex);
                }
            default:
                throw new Error("currently only number and string are implemented for hex");
        }
    }
    fmtV(val) {
        if (this.flags.sharp) {
            const options = this.flags.precision !== -1 ? {
                depth: this.flags.precision
            } : {};
            return this.pad(Deno.inspect(val, options));
        } else {
            const p6 = this.flags.precision;
            return p6 === -1 ? val.toString() : val.toString().substr(0, p6);
        }
    }
    fmtJ(val) {
        return JSON.stringify(val);
    }
}
function sprintf(format10, ...args) {
    const printf1 = new Printf(format10, ...args);
    return printf1.doPrintf();
}
let debugImpls;
let testEnabled;
function initializeDebugEnv(debugEnv) {
    debugImpls = Object.create(null);
    if (debugEnv) {
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replaceAll("*", ".*").replaceAll(",", "$|^");
        const debugEnvRegex = new RegExp(`^${debugEnv}$`, "i");
        testEnabled = (str)=>debugEnvRegex.exec(str) !== null
        ;
    } else {
        testEnabled = ()=>false
        ;
    }
}
function emitWarningIfNeeded(set) {
    if ("HTTP" === set || "HTTP2" === set) {
        console.warn("Setting the NODE_DEBUG environment variable " + "to '" + set.toLowerCase() + "' can expose sensitive " + "data (such as passwords, tokens and authentication headers) " + "in the resulting log.");
    }
}
const noop = ()=>{};
function debuglogImpl(enabled1, set) {
    if (debugImpls[set] === undefined) {
        if (enabled1) {
            emitWarningIfNeeded(set);
            debugImpls[set] = function debug(...args) {
                const msg = args.map((arg)=>inspect(arg)
                ).join(" ");
                console.error(sprintf("%s %s: %s", set, String(Deno.pid), msg));
            };
        } else {
            debugImpls[set] = noop;
        }
    }
    return debugImpls[set];
}
function debuglog(set, cb) {
    function init() {
        set = set.toUpperCase();
        enabled2 = testEnabled(set);
    }
    let debug5 = (...args)=>{
        init();
        debug5 = debuglogImpl(enabled2, set);
        if (typeof cb === "function") {
            cb(debug5);
        }
        return debug5(...args);
    };
    let enabled2;
    let test = ()=>{
        init();
        test = ()=>enabled2
        ;
        return enabled2;
    };
    const logger = (...args)=>debug5(...args)
    ;
    Object.defineProperty(logger, "enabled", {
        get () {
            return test();
        },
        configurable: true,
        enumerable: true
    });
    return logger;
}
let state = "";
if (Deno.permissions) {
    state = (await Deno.permissions.query({
        name: "env",
        variable: "NODE_DEBUG"
    })).state;
}
if (state === "granted") {
    initializeDebugEnv(Deno.env.get("NODE_DEBUG") ?? "");
} else {
    initializeDebugEnv("");
}
const osType = (()=>{
    const { Deno  } = globalThis;
    if (typeof Deno?.build?.os === "string") {
        return Deno.build.os;
    }
    const { navigator  } = globalThis;
    if (navigator?.appVersion?.includes?.("Win") ?? false) {
        return "windows";
    }
    return "linux";
})();
const isWindows = osType === "windows";
function uvTranslateSysError(sysErrno) {
    switch(sysErrno){
        case 5:
            return "EACCES";
        case 998:
            return "EACCES";
        case 10013:
            return "EACCES";
        case 1920:
            return "EACCES";
        case 1227:
            return "EADDRINUSE";
        case 10048:
            return "EADDRINUSE";
        case 10049:
            return "EADDRNOTAVAIL";
        case 10047:
            return "EAFNOSUPPORT";
        case 10035:
            return "EAGAIN";
        case 10037:
            return "EALREADY";
        case 1004:
            return "EBADF";
        case 6:
            return "EBADF";
        case 33:
            return "EBUSY";
        case 231:
            return "EBUSY";
        case 32:
            return "EBUSY";
        case 995:
            return "ECANCELED";
        case 10004:
            return "ECANCELED";
        case 1113:
            return "ECHARSET";
        case 1236:
            return "ECONNABORTED";
        case 10053:
            return "ECONNABORTED";
        case 1225:
            return "ECONNREFUSED";
        case 10061:
            return "ECONNREFUSED";
        case 64:
            return "ECONNRESET";
        case 10054:
            return "ECONNRESET";
        case 183:
            return "EEXIST";
        case 80:
            return "EEXIST";
        case 111:
            return "EFAULT";
        case 10014:
            return "EFAULT";
        case 1232:
            return "EHOSTUNREACH";
        case 10065:
            return "EHOSTUNREACH";
        case 122:
            return "EINVAL";
        case 13:
            return "EINVAL";
        case 123:
            return "EINVAL";
        case 87:
            return "EINVAL";
        case 10022:
            return "EINVAL";
        case 10046:
            return "EINVAL";
        case 1102:
            return "EIO";
        case 1111:
            return "EIO";
        case 23:
            return "EIO";
        case 1166:
            return "EIO";
        case 1165:
            return "EIO";
        case 1393:
            return "EIO";
        case 1129:
            return "EIO";
        case 1101:
            return "EIO";
        case 31:
            return "EIO";
        case 1106:
            return "EIO";
        case 1117:
            return "EIO";
        case 1104:
            return "EIO";
        case 205:
            return "EIO";
        case 110:
            return "EIO";
        case 1103:
            return "EIO";
        case 156:
            return "EIO";
        case 10056:
            return "EISCONN";
        case 1921:
            return "ELOOP";
        case 4:
            return "EMFILE";
        case 10024:
            return "EMFILE";
        case 10040:
            return "EMSGSIZE";
        case 206:
            return "ENAMETOOLONG";
        case 1231:
            return "ENETUNREACH";
        case 10051:
            return "ENETUNREACH";
        case 10055:
            return "ENOBUFS";
        case 161:
            return "ENOENT";
        case 267:
            return "ENOTDIR";
        case 203:
            return "ENOENT";
        case 2:
            return "ENOENT";
        case 15:
            return "ENOENT";
        case 4392:
            return "ENOENT";
        case 126:
            return "ENOENT";
        case 3:
            return "ENOENT";
        case 11001:
            return "ENOENT";
        case 11004:
            return "ENOENT";
        case 8:
            return "ENOMEM";
        case 14:
            return "ENOMEM";
        case 82:
            return "ENOSPC";
        case 112:
            return "ENOSPC";
        case 277:
            return "ENOSPC";
        case 1100:
            return "ENOSPC";
        case 39:
            return "ENOSPC";
        case 2250:
            return "ENOTCONN";
        case 10057:
            return "ENOTCONN";
        case 145:
            return "ENOTEMPTY";
        case 10038:
            return "ENOTSOCK";
        case 50:
            return "ENOTSUP";
        case 109:
            return "EOF";
        case 1314:
            return "EPERM";
        case 230:
            return "EPIPE";
        case 232:
            return "EPIPE";
        case 233:
            return "EPIPE";
        case 10058:
            return "EPIPE";
        case 10043:
            return "EPROTONOSUPPORT";
        case 19:
            return "EROFS";
        case 121:
            return "ETIMEDOUT";
        case 10060:
            return "ETIMEDOUT";
        case 17:
            return "EXDEV";
        case 1:
            return "EISDIR";
        case 208:
            return "E2BIG";
        case 10044:
            return "ESOCKTNOSUPPORT";
        default:
            return "UNKNOWN";
    }
}
const os = {
    UV_UDP_REUSEADDR: 4,
    dlopen: {
        RTLD_LAZY: 1,
        RTLD_NOW: 2,
        RTLD_GLOBAL: 8,
        RTLD_LOCAL: 4
    },
    errno: {
        E2BIG: 7,
        EACCES: 13,
        EADDRINUSE: 48,
        EADDRNOTAVAIL: 49,
        EAFNOSUPPORT: 47,
        EAGAIN: 35,
        EALREADY: 37,
        EBADF: 9,
        EBADMSG: 94,
        EBUSY: 16,
        ECANCELED: 89,
        ECHILD: 10,
        ECONNABORTED: 53,
        ECONNREFUSED: 61,
        ECONNRESET: 54,
        EDEADLK: 11,
        EDESTADDRREQ: 39,
        EDOM: 33,
        EDQUOT: 69,
        EEXIST: 17,
        EFAULT: 14,
        EFBIG: 27,
        EHOSTUNREACH: 65,
        EIDRM: 90,
        EILSEQ: 92,
        EINPROGRESS: 36,
        EINTR: 4,
        EINVAL: 22,
        EIO: 5,
        EISCONN: 56,
        EISDIR: 21,
        ELOOP: 62,
        EMFILE: 24,
        EMLINK: 31,
        EMSGSIZE: 40,
        EMULTIHOP: 95,
        ENAMETOOLONG: 63,
        ENETDOWN: 50,
        ENETRESET: 52,
        ENETUNREACH: 51,
        ENFILE: 23,
        ENOBUFS: 55,
        ENODATA: 96,
        ENODEV: 19,
        ENOENT: 2,
        ENOEXEC: 8,
        ENOLCK: 77,
        ENOLINK: 97,
        ENOMEM: 12,
        ENOMSG: 91,
        ENOPROTOOPT: 42,
        ENOSPC: 28,
        ENOSR: 98,
        ENOSTR: 99,
        ENOSYS: 78,
        ENOTCONN: 57,
        ENOTDIR: 20,
        ENOTEMPTY: 66,
        ENOTSOCK: 38,
        ENOTSUP: 45,
        ENOTTY: 25,
        ENXIO: 6,
        EOPNOTSUPP: 102,
        EOVERFLOW: 84,
        EPERM: 1,
        EPIPE: 32,
        EPROTO: 100,
        EPROTONOSUPPORT: 43,
        EPROTOTYPE: 41,
        ERANGE: 34,
        EROFS: 30,
        ESPIPE: 29,
        ESRCH: 3,
        ESTALE: 70,
        ETIME: 101,
        ETIMEDOUT: 60,
        ETXTBSY: 26,
        EWOULDBLOCK: 35,
        EXDEV: 18
    },
    signals: {
        SIGHUP: 1,
        SIGINT: 2,
        SIGQUIT: 3,
        SIGILL: 4,
        SIGTRAP: 5,
        SIGABRT: 6,
        SIGIOT: 6,
        SIGBUS: 10,
        SIGFPE: 8,
        SIGKILL: 9,
        SIGUSR1: 30,
        SIGSEGV: 11,
        SIGUSR2: 31,
        SIGPIPE: 13,
        SIGALRM: 14,
        SIGTERM: 15,
        SIGCHLD: 20,
        SIGCONT: 19,
        SIGSTOP: 17,
        SIGTSTP: 18,
        SIGTTIN: 21,
        SIGTTOU: 22,
        SIGURG: 16,
        SIGXCPU: 24,
        SIGXFSZ: 25,
        SIGVTALRM: 26,
        SIGPROF: 27,
        SIGWINCH: 28,
        SIGIO: 23,
        SIGINFO: 29,
        SIGSYS: 12
    },
    priority: {
        PRIORITY_LOW: 19,
        PRIORITY_BELOW_NORMAL: 10,
        PRIORITY_NORMAL: 0,
        PRIORITY_ABOVE_NORMAL: -7,
        PRIORITY_HIGH: -14,
        PRIORITY_HIGHEST: -20
    }
};
const fs = {
    UV_FS_SYMLINK_DIR: 1,
    UV_FS_SYMLINK_JUNCTION: 2,
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    UV_DIRENT_UNKNOWN: 0,
    UV_DIRENT_FILE: 1,
    UV_DIRENT_DIR: 2,
    UV_DIRENT_LINK: 3,
    UV_DIRENT_FIFO: 4,
    UV_DIRENT_SOCKET: 5,
    UV_DIRENT_CHAR: 6,
    UV_DIRENT_BLOCK: 7,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 512,
    O_EXCL: 2048,
    UV_FS_O_FILEMAP: 0,
    O_NOCTTY: 131072,
    O_TRUNC: 1024,
    O_APPEND: 8,
    O_DIRECTORY: 1048576,
    O_NOFOLLOW: 256,
    O_SYNC: 128,
    O_DSYNC: 4194304,
    O_SYMLINK: 2097152,
    O_NONBLOCK: 4,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_COPYFILE_EXCL: 1,
    COPYFILE_EXCL: 1,
    UV_FS_COPYFILE_FICLONE: 2,
    COPYFILE_FICLONE: 2,
    UV_FS_COPYFILE_FICLONE_FORCE: 4,
    COPYFILE_FICLONE_FORCE: 4
};
const crypto1 = {
    OPENSSL_VERSION_NUMBER: 269488319,
    SSL_OP_ALL: 2147485780,
    SSL_OP_ALLOW_NO_DHE_KEX: 1024,
    SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: 262144,
    SSL_OP_CIPHER_SERVER_PREFERENCE: 4194304,
    SSL_OP_CISCO_ANYCONNECT: 32768,
    SSL_OP_COOKIE_EXCHANGE: 8192,
    SSL_OP_CRYPTOPRO_TLSEXT_BUG: 2147483648,
    SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: 2048,
    SSL_OP_EPHEMERAL_RSA: 0,
    SSL_OP_LEGACY_SERVER_CONNECT: 4,
    SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: 0,
    SSL_OP_MICROSOFT_SESS_ID_BUG: 0,
    SSL_OP_MSIE_SSLV2_RSA_PADDING: 0,
    SSL_OP_NETSCAPE_CA_DN_BUG: 0,
    SSL_OP_NETSCAPE_CHALLENGE_BUG: 0,
    SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: 0,
    SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: 0,
    SSL_OP_NO_COMPRESSION: 131072,
    SSL_OP_NO_ENCRYPT_THEN_MAC: 524288,
    SSL_OP_NO_QUERY_MTU: 4096,
    SSL_OP_NO_RENEGOTIATION: 1073741824,
    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: 65536,
    SSL_OP_NO_SSLv2: 0,
    SSL_OP_NO_SSLv3: 33554432,
    SSL_OP_NO_TICKET: 16384,
    SSL_OP_NO_TLSv1: 67108864,
    SSL_OP_NO_TLSv1_1: 268435456,
    SSL_OP_NO_TLSv1_2: 134217728,
    SSL_OP_NO_TLSv1_3: 536870912,
    SSL_OP_PKCS1_CHECK_1: 0,
    SSL_OP_PKCS1_CHECK_2: 0,
    SSL_OP_PRIORITIZE_CHACHA: 2097152,
    SSL_OP_SINGLE_DH_USE: 0,
    SSL_OP_SINGLE_ECDH_USE: 0,
    SSL_OP_SSLEAY_080_CLIENT_DH_BUG: 0,
    SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: 0,
    SSL_OP_TLS_BLOCK_PADDING_BUG: 0,
    SSL_OP_TLS_D5_BUG: 0,
    SSL_OP_TLS_ROLLBACK_BUG: 8388608,
    ENGINE_METHOD_RSA: 1,
    ENGINE_METHOD_DSA: 2,
    ENGINE_METHOD_DH: 4,
    ENGINE_METHOD_RAND: 8,
    ENGINE_METHOD_EC: 2048,
    ENGINE_METHOD_CIPHERS: 64,
    ENGINE_METHOD_DIGESTS: 128,
    ENGINE_METHOD_PKEY_METHS: 512,
    ENGINE_METHOD_PKEY_ASN1_METHS: 1024,
    ENGINE_METHOD_ALL: 65535,
    ENGINE_METHOD_NONE: 0,
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    RSA_PSS_SALTLEN_DIGEST: -1,
    RSA_PSS_SALTLEN_MAX_SIGN: -2,
    RSA_PSS_SALTLEN_AUTO: -2,
    defaultCoreCipherList: "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
    TLS1_VERSION: 769,
    TLS1_1_VERSION: 770,
    TLS1_2_VERSION: 771,
    TLS1_3_VERSION: 772,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
};
const zlib = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    ZLIB_VERNUM: 4784,
    DEFLATE: 1,
    INFLATE: 2,
    GZIP: 3,
    GUNZIP: 4,
    DEFLATERAW: 5,
    INFLATERAW: 6,
    UNZIP: 7,
    BROTLI_DECODE: 8,
    BROTLI_ENCODE: 9,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: Infinity,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1,
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_PARAM_MODE: 0,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_DEFAULT_MODE: 0,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_LARGE_MAX_WINDOW_BITS: 30,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24,
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
    BROTLI_PARAM_SIZE_HINT: 5,
    BROTLI_PARAM_LARGE_WINDOW: 6,
    BROTLI_PARAM_NPOSTFIX: 7,
    BROTLI_PARAM_NDIRECT: 8,
    BROTLI_DECODER_RESULT_ERROR: 0,
    BROTLI_DECODER_RESULT_SUCCESS: 1,
    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
    BROTLI_DECODER_NO_ERROR: 0,
    BROTLI_DECODER_SUCCESS: 1,
    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
    BROTLI_DECODER_ERROR_UNREACHABLE: -31
};
const trace = {
    TRACE_EVENT_PHASE_BEGIN: 66,
    TRACE_EVENT_PHASE_END: 69,
    TRACE_EVENT_PHASE_COMPLETE: 88,
    TRACE_EVENT_PHASE_INSTANT: 73,
    TRACE_EVENT_PHASE_ASYNC_BEGIN: 83,
    TRACE_EVENT_PHASE_ASYNC_STEP_INTO: 84,
    TRACE_EVENT_PHASE_ASYNC_STEP_PAST: 112,
    TRACE_EVENT_PHASE_ASYNC_END: 70,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN: 98,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_END: 101,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT: 110,
    TRACE_EVENT_PHASE_FLOW_BEGIN: 115,
    TRACE_EVENT_PHASE_FLOW_STEP: 116,
    TRACE_EVENT_PHASE_FLOW_END: 102,
    TRACE_EVENT_PHASE_METADATA: 77,
    TRACE_EVENT_PHASE_COUNTER: 67,
    TRACE_EVENT_PHASE_SAMPLE: 80,
    TRACE_EVENT_PHASE_CREATE_OBJECT: 78,
    TRACE_EVENT_PHASE_SNAPSHOT_OBJECT: 79,
    TRACE_EVENT_PHASE_DELETE_OBJECT: 68,
    TRACE_EVENT_PHASE_MEMORY_DUMP: 118,
    TRACE_EVENT_PHASE_MARK: 82,
    TRACE_EVENT_PHASE_CLOCK_SYNC: 99,
    TRACE_EVENT_PHASE_ENTER_CONTEXT: 40,
    TRACE_EVENT_PHASE_LEAVE_CONTEXT: 41,
    TRACE_EVENT_PHASE_LINK_IDS: 61
};
const mod3 = {
    os: os,
    fs: fs,
    crypto: crypto1,
    zlib: zlib,
    trace: trace
};
const UV_EEXIST = os.errno.EEXIST;
const UV_ENOENT = os.errno.ENOENT;
const codeToErrorWindows = [
    [
        -4093,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -4092,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -4091,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -4090,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -4089,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -4088,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -4084,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -4083,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -4082,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -4081,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -4079,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -4078,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -4077,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -4076,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -4075,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -4074,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -4036,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -4073,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4072,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -4071,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -4070,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -4069,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -4068,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -4067,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -4066,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -4065,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -4064,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -4063,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -4062,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -4061,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -4060,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -4059,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -4058,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -4057,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -4035,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -4055,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -4054,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -4053,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -4052,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -4051,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -4050,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -4049,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -4048,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -4047,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -4046,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -4045,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -4044,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -4034,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -4043,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -4042,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -4041,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -4040,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -4039,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -4038,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -4037,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -4033,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -4032,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -4031,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -4029,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -4027,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeWindows = codeToErrorWindows.map(([status, [error3]])=>[
        error3,
        status
    ]
);
const codeToErrorDarwin = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -48,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -49,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -47,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -35,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -37,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -89,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -53,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -61,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -54,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -39,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -65,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -56,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -62,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -40,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -63,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -50,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -51,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -55,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -42,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -78,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -57,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -66,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -38,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -45,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -100,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -43,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -41,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -58,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -60,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -64,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -79,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -92,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeDarwin = codeToErrorDarwin.map(([status, [code5]])=>[
        code5,
        status
    ]
);
const codeToErrorLinux = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -98,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -99,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -97,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -11,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -114,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -125,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -103,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -111,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -104,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -89,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -113,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -106,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -40,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -90,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -36,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -100,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -101,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -105,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -64,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -92,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -38,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -107,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -39,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -88,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -95,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -71,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -93,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -91,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -108,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -110,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -112,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -121,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -84,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ], 
];
const errorToCodeLinux = codeToErrorLinux.map(([status, [code6]])=>[
        code6,
        status
    ]
);
const errorMap = new Map(osType === "windows" ? codeToErrorWindows : osType === "darwin" ? codeToErrorDarwin : osType === "linux" ? codeToErrorLinux : unreachable());
const codeMap = new Map(osType === "windows" ? errorToCodeWindows : osType === "darwin" ? errorToCodeDarwin : osType === "linux" ? errorToCodeLinux : unreachable());
function mapSysErrnoToUvErrno(sysErrno) {
    if (osType === "windows") {
        const code7 = uvTranslateSysError(sysErrno);
        return codeMap.get(code7) ?? -sysErrno;
    } else {
        return -sysErrno;
    }
}
const mod4 = {
    UV_EEXIST: UV_EEXIST,
    UV_ENOENT: UV_ENOENT,
    errorMap: errorMap,
    codeMap: codeMap,
    mapSysErrnoToUvErrno: mapSysErrnoToUvErrno
};
const __default3 = {
    ...mod1
};
var Encodings;
(function(Encodings1) {
    Encodings1[Encodings1["ASCII"] = 0] = "ASCII";
    Encodings1[Encodings1["UTF8"] = 1] = "UTF8";
    Encodings1[Encodings1["BASE64"] = 2] = "BASE64";
    Encodings1[Encodings1["UCS2"] = 3] = "UCS2";
    Encodings1[Encodings1["BINARY"] = 4] = "BINARY";
    Encodings1[Encodings1["HEX"] = 5] = "HEX";
    Encodings1[Encodings1["BUFFER"] = 6] = "BUFFER";
    Encodings1[Encodings1["BASE64URL"] = 7] = "BASE64URL";
    Encodings1[Encodings1["LATIN1"] = 4] = "LATIN1";
})(Encodings || (Encodings = {}));
const encodings = [];
encodings[Encodings.ASCII] = "ascii";
encodings[Encodings.BASE64] = "base64";
encodings[Encodings.BASE64URL] = "base64url";
encodings[Encodings.BUFFER] = "buffer";
encodings[Encodings.HEX] = "hex";
encodings[Encodings.LATIN1] = "latin1";
encodings[Encodings.UCS2] = "utf16le";
encodings[Encodings.UTF8] = "utf8";
const __default4 = {
    encodings
};
const mod5 = {
    encodings: encodings,
    default: __default4
};
function numberToBytes(n7) {
    if (n7 === 0) return new Uint8Array([
        0
    ]);
    const bytes = [];
    bytes.unshift(n7 & 255);
    while(n7 >= 256){
        n7 = n7 >>> 8;
        bytes.unshift(n7 & 255);
    }
    return new Uint8Array(bytes);
}
function findLastIndex(targetBuffer, buffer4, offset) {
    offset = offset > targetBuffer.length ? targetBuffer.length : offset;
    const searchableBuffer = targetBuffer.slice(0, offset + buffer4.length);
    const searchableBufferLastIndex = searchableBuffer.length - 1;
    const bufferLastIndex = buffer4.length - 1;
    let lastMatchIndex = -1;
    let matches = 0;
    let index6 = -1;
    for(let x2 = 0; x2 <= searchableBufferLastIndex; x2++){
        if (searchableBuffer[searchableBufferLastIndex - x2] === buffer4[bufferLastIndex - matches]) {
            if (lastMatchIndex === -1) {
                lastMatchIndex = x2;
            }
            matches++;
        } else {
            matches = 0;
            if (lastMatchIndex !== -1) {
                x2 = lastMatchIndex + 1;
                lastMatchIndex = -1;
            }
            continue;
        }
        if (matches === buffer4.length) {
            index6 = x2;
            break;
        }
    }
    if (index6 === -1) return index6;
    return searchableBufferLastIndex - index6;
}
function indexOfBuffer(targetBuffer, buffer5, byteOffset, encoding, forwardDirection) {
    if (!Encodings[encoding] === undefined) {
        throw new Error(`Unknown encoding code ${encoding}`);
    }
    if (!forwardDirection) {
        if (byteOffset < 0) {
            byteOffset = targetBuffer.length + byteOffset;
        }
        if (buffer5.length === 0) {
            return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
        }
        return findLastIndex(targetBuffer, buffer5, byteOffset);
    }
    if (buffer5.length === 0) {
        return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return indexOf(targetBuffer, buffer5, byteOffset);
}
function indexOfNumber(targetBuffer, number, byteOffset, forwardDirection) {
    const bytes = numberToBytes(number);
    if (bytes.length > 1) {
        throw new Error("Multi byte number search is not supported");
    }
    return indexOfBuffer(targetBuffer, numberToBytes(number), byteOffset, Encodings.UTF8, forwardDirection);
}
const __default5 = {
    indexOfBuffer,
    indexOfNumber
};
const mod6 = {
    indexOfBuffer: indexOfBuffer,
    indexOfNumber: indexOfNumber,
    numberToBytes: numberToBytes,
    default: __default5
};
const base64abc = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/", 
];
function encode(data6) {
    const uint8 = typeof data6 === "string" ? new TextEncoder().encode(data6) : data6 instanceof Uint8Array ? data6 : new Uint8Array(data6);
    let result = "", i33;
    const l2 = uint8.length;
    for(i33 = 2; i33 < l2; i33 += 3){
        result += base64abc[uint8[i33 - 2] >> 2];
        result += base64abc[(uint8[i33 - 2] & 3) << 4 | uint8[i33 - 1] >> 4];
        result += base64abc[(uint8[i33 - 1] & 15) << 2 | uint8[i33] >> 6];
        result += base64abc[uint8[i33] & 63];
    }
    if (i33 === l2 + 1) {
        result += base64abc[uint8[i33 - 2] >> 2];
        result += base64abc[(uint8[i33 - 2] & 3) << 4];
        result += "==";
    }
    if (i33 === l2) {
        result += base64abc[uint8[i33 - 2] >> 2];
        result += base64abc[(uint8[i33 - 2] & 3) << 4 | uint8[i33 - 1] >> 4];
        result += base64abc[(uint8[i33 - 1] & 15) << 2];
        result += "=";
    }
    return result;
}
function decode(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i34 = 0; i34 < size; i34++){
        bytes[i34] = binString.charCodeAt(i34);
    }
    return bytes;
}
function addPaddingToBase64url(base64url) {
    if (base64url.length % 4 === 2) return base64url + "==";
    if (base64url.length % 4 === 3) return base64url + "=";
    if (base64url.length % 4 === 1) {
        throw new TypeError("Illegal base64url string!");
    }
    return base64url;
}
function convertBase64urlToBase64(b64url) {
    if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
        throw new TypeError("Failed to decode base64url: invalid character");
    }
    return addPaddingToBase64url(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url(b64) {
    return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode1(data7) {
    return convertBase64ToBase64url(encode(data7));
}
function decode1(b64url) {
    return decode(convertBase64urlToBase64(b64url));
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i35 = 0; i35 < str.length; ++i35){
        byteArray.push(str.charCodeAt(i35) & 255);
    }
    return new Uint8Array(byteArray);
}
function base64ToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("-", "+").replaceAll("_", "/");
    return decode(str);
}
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while(str.length % 4 !== 0){
        str = str + "=";
    }
    return str;
}
function base64UrlToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("+", "-").replaceAll("/", "_");
    return decode1(str);
}
function hexToBytes(str) {
    const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
    let i36;
    for(i36 = 0; i36 < byteArray.length; i36++){
        const a8 = Number.parseInt(str[i36 * 2], 16);
        const b6 = Number.parseInt(str[i36 * 2 + 1], 16);
        if (Number.isNaN(a8) && Number.isNaN(b6)) {
            break;
        }
        byteArray[i36] = a8 << 4 | b6;
    }
    return new Uint8Array(i36 === byteArray.length ? byteArray : byteArray.slice(0, i36));
}
function utf16leToBytes(str, units) {
    let c12, hi, lo;
    const byteArray = [];
    for(let i37 = 0; i37 < str.length; ++i37){
        if ((units -= 2) < 0) {
            break;
        }
        c12 = str.charCodeAt(i37);
        hi = c12 >> 8;
        lo = c12 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return new Uint8Array(byteArray);
}
function bytesToAscii(bytes) {
    let ret = "";
    for(let i38 = 0; i38 < bytes.length; ++i38){
        ret += String.fromCharCode(bytes[i38] & 127);
    }
    return ret;
}
function bytesToUtf16le(bytes) {
    let res = "";
    for(let i39 = 0; i39 < bytes.length - 1; i39 += 2){
        res += String.fromCharCode(bytes[i39] + bytes[i39 + 1] * 256);
    }
    return res;
}
const utf8Encoder = new TextEncoder();
const float32Array = new Float32Array(1);
const uInt8Float32Array = new Uint8Array(float32Array.buffer);
const float64Array = new Float64Array(1);
const uInt8Float64Array = new Uint8Array(float64Array.buffer);
float32Array[0] = -1;
const bigEndian = uInt8Float32Array[3] === 0;
function readUInt48LE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first * 2 ** 8 + last;
}
function readUInt32BE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards(buffer6, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buffer6[offset];
    const last = buffer6[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer6.length - 8);
    }
    uInt8Float64Array[7] = first;
    uInt8Float64Array[6] = buffer6[++offset];
    uInt8Float64Array[5] = buffer6[++offset];
    uInt8Float64Array[4] = buffer6[++offset];
    uInt8Float64Array[3] = buffer6[++offset];
    uInt8Float64Array[2] = buffer6[++offset];
    uInt8Float64Array[1] = buffer6[++offset];
    uInt8Float64Array[0] = last;
    return float64Array[0];
}
function readDoubleForwards(buffer7, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buffer7[offset];
    const last = buffer7[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer7.length - 8);
    }
    uInt8Float64Array[0] = first;
    uInt8Float64Array[1] = buffer7[++offset];
    uInt8Float64Array[2] = buffer7[++offset];
    uInt8Float64Array[3] = buffer7[++offset];
    uInt8Float64Array[4] = buffer7[++offset];
    uInt8Float64Array[5] = buffer7[++offset];
    uInt8Float64Array[6] = buffer7[++offset];
    uInt8Float64Array[7] = last;
    return float64Array[0];
}
function writeDoubleForwards(buffer8, val, offset = 0) {
    val = +val;
    checkBounds(buffer8, offset, 7);
    float64Array[0] = val;
    buffer8[offset++] = uInt8Float64Array[0];
    buffer8[offset++] = uInt8Float64Array[1];
    buffer8[offset++] = uInt8Float64Array[2];
    buffer8[offset++] = uInt8Float64Array[3];
    buffer8[offset++] = uInt8Float64Array[4];
    buffer8[offset++] = uInt8Float64Array[5];
    buffer8[offset++] = uInt8Float64Array[6];
    buffer8[offset++] = uInt8Float64Array[7];
    return offset;
}
function writeDoubleBackwards(buffer9, val, offset = 0) {
    val = +val;
    checkBounds(buffer9, offset, 7);
    float64Array[0] = val;
    buffer9[offset++] = uInt8Float64Array[7];
    buffer9[offset++] = uInt8Float64Array[6];
    buffer9[offset++] = uInt8Float64Array[5];
    buffer9[offset++] = uInt8Float64Array[4];
    buffer9[offset++] = uInt8Float64Array[3];
    buffer9[offset++] = uInt8Float64Array[2];
    buffer9[offset++] = uInt8Float64Array[1];
    buffer9[offset++] = uInt8Float64Array[0];
    return offset;
}
function readFloatBackwards(buffer10, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buffer10[offset];
    const last = buffer10[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer10.length - 4);
    }
    uInt8Float32Array[3] = first;
    uInt8Float32Array[2] = buffer10[++offset];
    uInt8Float32Array[1] = buffer10[++offset];
    uInt8Float32Array[0] = last;
    return float32Array[0];
}
function readFloatForwards(buffer11, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buffer11[offset];
    const last = buffer11[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer11.length - 4);
    }
    uInt8Float32Array[0] = first;
    uInt8Float32Array[1] = buffer11[++offset];
    uInt8Float32Array[2] = buffer11[++offset];
    uInt8Float32Array[3] = last;
    return float32Array[0];
}
function writeFloatForwards(buffer12, val, offset = 0) {
    val = +val;
    checkBounds(buffer12, offset, 3);
    float32Array[0] = val;
    buffer12[offset++] = uInt8Float32Array[0];
    buffer12[offset++] = uInt8Float32Array[1];
    buffer12[offset++] = uInt8Float32Array[2];
    buffer12[offset++] = uInt8Float32Array[3];
    return offset;
}
function writeFloatBackwards(buffer13, val, offset = 0) {
    val = +val;
    checkBounds(buffer13, offset, 3);
    float32Array[0] = val;
    buffer13[offset++] = uInt8Float32Array[3];
    buffer13[offset++] = uInt8Float32Array[2];
    buffer13[offset++] = uInt8Float32Array[1];
    buffer13[offset++] = uInt8Float32Array[0];
    return offset;
}
function readInt24LE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
    return val | (val & 2 ** 23) * 510;
}
function readInt40LE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (last | (last & 2 ** 7) * 33554430) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[offset + 4] + last * 2 ** 8;
    return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
    return val | (val & 2 ** 23) * 510;
}
function readInt48BE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[++offset] + first * 2 ** 8;
    return (val | (val & 2 ** 15) * 131070) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE(buf, offset = 0) {
    validateNumber1(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (first | (first & 2 ** 7) * 33554430) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf8(str) {
    return utf8Encoder.encode(str).length;
}
function base64ByteLength(str, bytes) {
    if (str.charCodeAt(bytes - 1) === 61) {
        bytes--;
    }
    if (bytes > 1 && str.charCodeAt(bytes - 1) === 61) {
        bytes--;
    }
    return bytes * 3 >>> 2;
}
const encodingsMap = Object.create(null);
for(let i = 0; i < encodings.length; ++i){
    encodingsMap[encodings[i]] = i;
}
const encodingOps = {
    ascii: {
        byteLength: (string)=>string.length
        ,
        encoding: "ascii",
        encodingVal: encodingsMap.ascii,
        indexOf: (buf, val, byteOffset, dir1)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.ascii, dir1)
        ,
        slice: (buf, start4, end)=>buf.asciiSlice(start4, end)
        ,
        write: (buf, string, offset, len)=>buf.asciiWrite(string, offset, len)
    },
    base64: {
        byteLength: (string)=>base64ByteLength(string, string.length)
        ,
        encoding: "base64",
        encodingVal: encodingsMap.base64,
        indexOf: (buf, val, byteOffset, dir2)=>indexOfBuffer(buf, base64ToBytes(val), byteOffset, encodingsMap.base64, dir2)
        ,
        slice: (buf, start5, end)=>buf.base64Slice(start5, end)
        ,
        write: (buf, string, offset, len)=>buf.base64Write(string, offset, len)
    },
    base64url: {
        byteLength: (string)=>base64ByteLength(string, string.length)
        ,
        encoding: "base64url",
        encodingVal: encodingsMap.base64url,
        indexOf: (buf, val, byteOffset, dir3)=>indexOfBuffer(buf, base64UrlToBytes(val), byteOffset, encodingsMap.base64url, dir3)
        ,
        slice: (buf, start6, end)=>buf.base64urlSlice(start6, end)
        ,
        write: (buf, string, offset, len)=>buf.base64urlWrite(string, offset, len)
    },
    hex: {
        byteLength: (string)=>string.length >>> 1
        ,
        encoding: "hex",
        encodingVal: encodingsMap.hex,
        indexOf: (buf, val, byteOffset, dir4)=>indexOfBuffer(buf, hexToBytes(val), byteOffset, encodingsMap.hex, dir4)
        ,
        slice: (buf, start7, end)=>buf.hexSlice(start7, end)
        ,
        write: (buf, string, offset, len)=>buf.hexWrite(string, offset, len)
    },
    latin1: {
        byteLength: (string)=>string.length
        ,
        encoding: "latin1",
        encodingVal: encodingsMap.latin1,
        indexOf: (buf, val, byteOffset, dir5)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.latin1, dir5)
        ,
        slice: (buf, start8, end)=>buf.latin1Slice(start8, end)
        ,
        write: (buf, string, offset, len)=>buf.latin1Write(string, offset, len)
    },
    ucs2: {
        byteLength: (string)=>string.length * 2
        ,
        encoding: "ucs2",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir6)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir6)
        ,
        slice: (buf, start9, end)=>buf.ucs2Slice(start9, end)
        ,
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    },
    utf8: {
        byteLength: byteLengthUtf8,
        encoding: "utf8",
        encodingVal: encodingsMap.utf8,
        indexOf: (buf, val, byteOffset, dir7)=>indexOfBuffer(buf, utf8Encoder.encode(val), byteOffset, encodingsMap.utf8, dir7)
        ,
        slice: (buf, start10, end)=>buf.utf8Slice(start10, end)
        ,
        write: (buf, string, offset, len)=>buf.utf8Write(string, offset, len)
    },
    utf16le: {
        byteLength: (string)=>string.length * 2
        ,
        encoding: "utf16le",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir8)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir8)
        ,
        slice: (buf, start11, end)=>buf.ucs2Slice(start11, end)
        ,
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    }
};
function getEncodingOps(encoding) {
    encoding = String(encoding).toLowerCase();
    switch(encoding.length){
        case 4:
            if (encoding === "utf8") return encodingOps.utf8;
            if (encoding === "ucs2") return encodingOps.ucs2;
            break;
        case 5:
            if (encoding === "utf-8") return encodingOps.utf8;
            if (encoding === "ascii") return encodingOps.ascii;
            if (encoding === "ucs-2") return encodingOps.ucs2;
            break;
        case 7:
            if (encoding === "utf16le") {
                return encodingOps.utf16le;
            }
            break;
        case 8:
            if (encoding === "utf-16le") {
                return encodingOps.utf16le;
            }
            break;
        case 6:
            if (encoding === "latin1" || encoding === "binary") {
                return encodingOps.latin1;
            }
            if (encoding === "base64") return encodingOps.base64;
        case 3:
            if (encoding === "hex") {
                return encodingOps.hex;
            }
            break;
        case 9:
            if (encoding === "base64url") {
                return encodingOps.base64url;
            }
            break;
    }
}
function _copyActual(source, target, targetStart, sourceStart, sourceEnd) {
    if (sourceEnd - sourceStart > target.length - targetStart) {
        sourceEnd = sourceStart + target.length - targetStart;
    }
    let nb = sourceEnd - sourceStart;
    const sourceLen = source.length - sourceStart;
    if (nb > sourceLen) {
        nb = sourceLen;
    }
    if (sourceStart !== 0 || sourceEnd < source.length) {
        source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
    }
    target.set(source, targetStart);
    return nb;
}
function boundsError(value, length, type8) {
    if (Math.floor(value) !== value) {
        validateNumber1(value, type8);
        throw new codes.ERR_OUT_OF_RANGE(type8 || "offset", "an integer", value);
    }
    if (length < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new codes.ERR_OUT_OF_RANGE(type8 || "offset", `>= ${type8 ? 1 : 0} and <= ${length}`, value);
}
function validateNumber1(value, name20) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name20, "number", value);
    }
}
function checkBounds(buf, offset, byteLength1) {
    validateNumber1(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength1] === undefined) {
        boundsError(offset, buf.length - (byteLength1 + 1));
    }
}
function checkInt(value, min5, max, buf, offset, byteLength2) {
    if (value > max || value < min5) {
        const n8 = typeof min5 === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
            if (min5 === 0 || min5 === 0n) {
                range = `>= 0${n8} and < 2${n8} ** ${(byteLength2 + 1) * 8}${n8}`;
            } else {
                range = `>= -(2${n8} ** ${(byteLength2 + 1) * 8 - 1}${n8}) and ` + `< 2${n8} ** ${(byteLength2 + 1) * 8 - 1}${n8}`;
            }
        } else {
            range = `>= ${min5}${n8} and <= ${max}${n8}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
}
function toInteger(n9, defaultVal) {
    n9 = +n9;
    if (!Number.isNaN(n9) && n9 >= Number.MIN_SAFE_INTEGER && n9 <= Number.MAX_SAFE_INTEGER) {
        return n9 % 1 === 0 ? n9 : Math.floor(n9);
    }
    return defaultVal;
}
function writeU_Int8(buf, value, offset, min6, max) {
    value = +value;
    validateNumber1(offset, "offset");
    if (value > max || value < min6) {
        throw new codes.ERR_OUT_OF_RANGE("value", `>= ${min6} and <= ${max}`, value);
    }
    if (buf[offset] === undefined) {
        boundsError(offset, buf.length - 1);
    }
    buf[offset] = value;
    return offset + 1;
}
function writeU_Int16BE(buf, value, offset, min7, max) {
    value = +value;
    checkInt(value, min7, max, buf, offset, 1);
    buf[offset++] = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function _writeUInt32LE(buf, value, offset, min8, max) {
    value = +value;
    checkInt(value, min8, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int16LE(buf, value, offset, min9, max) {
    value = +value;
    checkInt(value, min9, max, buf, offset, 1);
    buf[offset++] = value;
    buf[offset++] = value >>> 8;
    return offset;
}
function _writeUInt32BE(buf, value, offset, min10, max) {
    value = +value;
    checkInt(value, min10, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int48BE(buf, value, offset, min11, max) {
    value = +value;
    checkInt(value, min11, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = newVal >>> 8;
    buf[offset++] = newVal;
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int40BE(buf, value, offset, min12, max) {
    value = +value;
    checkInt(value, min12, max, buf, offset, 4);
    buf[offset++] = Math.floor(value * 2 ** -32);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int32BE(buf, value, offset, min13, max) {
    value = +value;
    checkInt(value, min13, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int24BE(buf, value, offset, min14, max) {
    value = +value;
    checkInt(value, min14, max, buf, offset, 2);
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 3;
}
function validateOffset(value, name21, min15 = 0, max = Number.MAX_SAFE_INTEGER) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name21, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name21, "an integer", value);
    }
    if (value < min15 || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name21, `>= ${min15} && <= ${max}`, value);
    }
}
function writeU_Int48LE(buf, value, offset, min16, max) {
    value = +value;
    checkInt(value, min16, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = newVal;
    buf[offset++] = newVal >>> 8;
    return offset;
}
function writeU_Int40LE(buf, value, offset, min17, max) {
    value = +value;
    checkInt(value, min17, max, buf, offset, 4);
    const newVal = value;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = Math.floor(newVal * 2 ** -32);
    return offset;
}
function writeU_Int32LE(buf, value, offset, min18, max) {
    value = +value;
    checkInt(value, min18, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int24LE(buf, value, offset, min19, max) {
    value = +value;
    checkInt(value, min19, max, buf, offset, 2);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
const kMaxLength = 2147483647;
const MAX_UINT32 = 2 ** 32;
const customInspectSymbol1 = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
const INSPECT_MAX_BYTES = 50;
const constants = {
    MAX_LENGTH: 2147483647,
    MAX_STRING_LENGTH: 536870888
};
Object.defineProperty(Buffer1.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer1.isBuffer(this)) {
            return void 0;
        }
        return this.buffer;
    }
});
Object.defineProperty(Buffer1.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer1.isBuffer(this)) {
            return void 0;
        }
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > 2147483647) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer1.prototype);
    return buf;
}
function Buffer1(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("string", "string", arg);
        }
        return _allocUnsafe(arg);
    }
    return _from(arg, encodingOrOffset, length);
}
Buffer1.poolSize = 8192;
function _from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
    }
    if (typeof value === "object" && value !== null) {
        if (isAnyArrayBuffer1(value)) {
            return fromArrayBuffer(value, encodingOrOffset, length);
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
            return _from(valueOf, encodingOrOffset, length);
        }
        const b7 = fromObject(value);
        if (b7) {
            return b7;
        }
        if (typeof value[Symbol.toPrimitive] === "function") {
            const primitive = value[Symbol.toPrimitive]("string");
            if (typeof primitive === "string") {
                return fromString(primitive, encodingOrOffset);
            }
        }
    }
    throw new codes.ERR_INVALID_ARG_TYPE("first argument", [
        "string",
        "Buffer",
        "ArrayBuffer",
        "Array",
        "Array-like Object"
    ], value);
}
Buffer1.from = function from(value, encodingOrOffset, length) {
    return _from(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer1.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer1, Uint8Array);
function assertSize(size) {
    validateNumber1(size, "size");
    if (!(size >= 0 && size <= 2147483647)) {
        throw new codes.ERR_INVALID_ARG_VALUE.RangeError("size", size);
    }
}
function _alloc(size, fill, encoding) {
    assertSize(size);
    const buffer14 = createBuffer(size);
    if (fill !== undefined) {
        if (encoding !== undefined && typeof encoding !== "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
        }
        return buffer14.fill(fill, encoding);
    }
    return buffer14;
}
Buffer1.alloc = function alloc(size, fill, encoding) {
    return _alloc(size, fill, encoding);
};
function _allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
Buffer1.allocUnsafe = function allocUnsafe(size) {
    return _allocUnsafe(size);
};
Buffer1.allocUnsafeSlow = function allocUnsafeSlow(size) {
    return _allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
    }
    if (!Buffer1.isEncoding(encoding)) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
        buf = buf.slice(0, actual);
    }
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i40 = 0; i40 < length; i40 += 1){
        buf[i40] = array[i40] & 255;
    }
    return buf;
}
function fromObject(obj) {
    if (obj.length !== undefined || isAnyArrayBuffer1(obj.buffer)) {
        if (typeof obj.length !== "number") {
            return createBuffer(0);
        }
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
    }
}
function checked(length) {
    if (length >= 2147483647) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647..toString(16) + " bytes");
    }
    return length | 0;
}
function SlowBuffer(length) {
    assertSize(length);
    return Buffer1.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer, Uint8Array);
Buffer1.isBuffer = function isBuffer(b8) {
    return b8 != null && b8._isBuffer === true && b8 !== Buffer1.prototype;
};
Buffer1.compare = function compare(a9, b9) {
    if (isInstance(a9, Uint8Array)) {
        a9 = Buffer1.from(a9, a9.offset, a9.byteLength);
    }
    if (isInstance(b9, Uint8Array)) {
        b9 = Buffer1.from(b9, b9.offset, b9.byteLength);
    }
    if (!Buffer1.isBuffer(a9) || !Buffer1.isBuffer(b9)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a9 === b9) {
        return 0;
    }
    let x3 = a9.length;
    let y1 = b9.length;
    for(let i41 = 0, len = Math.min(x3, y1); i41 < len; ++i41){
        if (a9[i41] !== b9[i41]) {
            x3 = a9[i41];
            y1 = b9[i41];
            break;
        }
    }
    if (x3 < y1) {
        return -1;
    }
    if (y1 < x3) {
        return 1;
    }
    return 0;
};
Buffer1.isEncoding = function isEncoding(encoding) {
    return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding1(encoding) !== undefined;
};
Buffer1.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
        throw new codes.ERR_INVALID_ARG_TYPE("list", "Array", list);
    }
    if (list.length === 0) {
        return Buffer1.alloc(0);
    }
    if (length === undefined) {
        length = 0;
        for(let i42 = 0; i42 < list.length; i42++){
            if (list[i42].length) {
                length += list[i42].length;
            }
        }
    } else {
        validateOffset(length, "length");
    }
    const buffer15 = Buffer1.allocUnsafe(length);
    let pos = 0;
    for(let i43 = 0; i43 < list.length; i43++){
        const buf = list[i43];
        if (!isUint8Array(buf)) {
            throw new codes.ERR_INVALID_ARG_TYPE(`list[${i43}]`, [
                "Buffer",
                "Uint8Array"
            ], list[i43]);
        }
        pos += _copyActual(buf, buffer15, pos, 0, buf.length);
    }
    if (pos < length) {
        buffer15.fill(0, pos, length);
    }
    return buffer15;
};
function byteLength(string, encoding) {
    if (typeof string !== "string") {
        if (isArrayBufferView(string) || isAnyArrayBuffer1(string)) {
            return string.byteLength;
        }
        throw new codes.ERR_INVALID_ARG_TYPE("string", [
            "string",
            "Buffer",
            "ArrayBuffer"
        ], string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) {
        return 0;
    }
    if (!encoding) {
        return mustMatch ? -1 : byteLengthUtf8(string);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        return mustMatch ? -1 : byteLengthUtf8(string);
    }
    return ops.byteLength(string);
}
Buffer1.byteLength = byteLength;
Buffer1.prototype._isBuffer = true;
function swap(b10, n10, m5) {
    const i44 = b10[n10];
    b10[n10] = b10[m5];
    b10[m5] = i44;
}
Buffer1.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for(let i45 = 0; i45 < len; i45 += 2){
        swap(this, i45, i45 + 1);
    }
    return this;
};
Buffer1.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for(let i46 = 0; i46 < len; i46 += 4){
        swap(this, i46, i46 + 3);
        swap(this, i46 + 1, i46 + 2);
    }
    return this;
};
Buffer1.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for(let i47 = 0; i47 < len; i47 += 8){
        swap(this, i47, i47 + 7);
        swap(this, i47 + 1, i47 + 6);
        swap(this, i47 + 2, i47 + 5);
        swap(this, i47 + 3, i47 + 4);
    }
    return this;
};
Buffer1.prototype.toString = function toString(encoding, start12, end) {
    if (arguments.length === 0) {
        return this.utf8Slice(0, this.length);
    }
    const len = this.length;
    if (start12 <= 0) {
        start12 = 0;
    } else if (start12 >= len) {
        return "";
    } else {
        start12 |= 0;
    }
    if (end === undefined || end > len) {
        end = len;
    } else {
        end |= 0;
    }
    if (end <= start12) {
        return "";
    }
    if (encoding === undefined) {
        return this.utf8Slice(start12, end);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.slice(this, start12, end);
};
Buffer1.prototype.toLocaleString = Buffer1.prototype.toString;
Buffer1.prototype.equals = function equals(b11) {
    if (!isUint8Array(b11)) {
        throw new codes.ERR_INVALID_ARG_TYPE("otherBuffer", [
            "Buffer",
            "Uint8Array"
        ], b11);
    }
    if (this === b11) {
        return true;
    }
    return Buffer1.compare(this, b11) === 0;
};
Buffer1.prototype.inspect = function inspect() {
    let str = "";
    const max = INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) {
        str += " ... ";
    }
    return "<Buffer " + str + ">";
};
if (customInspectSymbol1) {
    Buffer1.prototype[customInspectSymbol1] = Buffer1.prototype.inspect;
}
Buffer1.prototype.compare = function compare(target, start13, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
        target = Buffer1.from(target, target.offset, target.byteLength);
    }
    if (!Buffer1.isBuffer(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (start13 === undefined) {
        start13 = 0;
    } else {
        validateOffset(start13, "targetStart", 0, kMaxLength);
    }
    if (end === undefined) {
        end = target.length;
    } else {
        validateOffset(end, "targetEnd", 0, target.length);
    }
    if (thisStart === undefined) {
        thisStart = 0;
    } else {
        validateOffset(start13, "sourceStart", 0, kMaxLength);
    }
    if (thisEnd === undefined) {
        thisEnd = this.length;
    } else {
        validateOffset(end, "sourceEnd", 0, this.length);
    }
    if (start13 < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new codes.ERR_OUT_OF_RANGE("out of range index", "range");
    }
    if (thisStart >= thisEnd && start13 >= end) {
        return 0;
    }
    if (thisStart >= thisEnd) {
        return -1;
    }
    if (start13 >= end) {
        return 1;
    }
    start13 >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) {
        return 0;
    }
    let x4 = thisEnd - thisStart;
    let y2 = end - start13;
    const len = Math.min(x4, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start13, end);
    for(let i48 = 0; i48 < len; ++i48){
        if (thisCopy[i48] !== targetCopy[i48]) {
            x4 = thisCopy[i48];
            y2 = targetCopy[i48];
            break;
        }
    }
    if (x4 < y2) {
        return -1;
    }
    if (y2 < x4) {
        return 1;
    }
    return 0;
};
function bidirectionalIndexOf(buffer16, val, byteOffset, encoding, dir9) {
    validateBuffer(buffer16);
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = undefined;
    } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
        byteOffset = dir9 ? 0 : buffer16.length || buffer16.byteLength;
    }
    dir9 = !!dir9;
    if (typeof val === "number") {
        return indexOfNumber(buffer16, val >>> 0, byteOffset, dir9);
    }
    let ops;
    if (encoding === undefined) {
        ops = encodingOps.utf8;
    } else {
        ops = getEncodingOps(encoding);
    }
    if (typeof val === "string") {
        if (ops === undefined) {
            throw new codes.ERR_UNKNOWN_ENCODING(encoding);
        }
        return ops.indexOf(buffer16, val, byteOffset, dir9);
    }
    if (isUint8Array(val)) {
        const encodingVal = ops === undefined ? encodingsMap.utf8 : ops.encodingVal;
        return indexOfBuffer(buffer16, val, byteOffset, encodingVal, dir9);
    }
    throw new codes.ERR_INVALID_ARG_TYPE("value", [
        "number",
        "string",
        "Buffer",
        "Uint8Array"
    ], val);
}
Buffer1.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer1.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer1.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
Buffer1.prototype.asciiSlice = function asciiSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToAscii(this);
    } else {
        return bytesToAscii(this.slice(offset, length));
    }
};
Buffer1.prototype.asciiWrite = function asciiWrite(string, offset, length) {
    return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer1.prototype.base64Slice = function base64Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode(this);
    } else {
        return encode(this.slice(offset, length));
    }
};
Buffer1.prototype.base64Write = function base64Write(string, offset, length) {
    return blitBuffer(base64ToBytes(string), this, offset, length);
};
Buffer1.prototype.base64urlSlice = function base64urlSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode1(this);
    } else {
        return encode1(this.slice(offset, length));
    }
};
Buffer1.prototype.base64urlWrite = function base64urlWrite(string, offset, length) {
    return blitBuffer(base64UrlToBytes(string), this, offset, length);
};
Buffer1.prototype.hexWrite = function hexWrite(string, offset, length) {
    return blitBuffer(hexToBytes(string, this.length - offset), this, offset, length);
};
Buffer1.prototype.hexSlice = function hexSlice(string, offset, length) {
    return _hexSlice(this, string, offset, length);
};
Buffer1.prototype.latin1Slice = function latin1Slice(string, offset, length) {
    return _latin1Slice(this, string, offset, length);
};
Buffer1.prototype.latin1Write = function latin1Write(string, offset, length) {
    return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer1.prototype.ucs2Slice = function ucs2Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToUtf16le(this);
    } else {
        return bytesToUtf16le(this.slice(offset, length));
    }
};
Buffer1.prototype.ucs2Write = function ucs2Write(string, offset, length) {
    return blitBuffer(utf16leToBytes(string, this.length - offset), this, offset, length);
};
Buffer1.prototype.utf8Slice = function utf8Slice(string, offset, length) {
    return _utf8Slice(this, string, offset, length);
};
Buffer1.prototype.utf8Write = function utf8Write(string, offset, length) {
    return blitBuffer(utf8ToBytes(string, this.length - offset), this, offset, length);
};
Buffer1.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
        return this.utf8Write(string, 0, this.length);
    }
    if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    } else {
        validateOffset(offset, "offset", 0, this.length);
        const remaining = this.length - offset;
        if (length === undefined) {
            length = remaining;
        } else if (typeof length === "string") {
            encoding = length;
            length = remaining;
        } else {
            validateOffset(length, "length", 0, this.length);
            if (length > remaining) {
                length = remaining;
            }
        }
    }
    if (!encoding) {
        return this.utf8Write(string, offset, length);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.write(this, string, offset, length);
};
Buffer1.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function fromArrayBuffer(obj, byteOffset, length) {
    if (byteOffset === undefined) {
        byteOffset = 0;
    } else {
        byteOffset = +byteOffset;
        if (Number.isNaN(byteOffset)) {
            byteOffset = 0;
        }
    }
    const maxLength = obj.byteLength - byteOffset;
    if (maxLength < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("offset");
    }
    if (length === undefined) {
        length = maxLength;
    } else {
        length = +length;
        if (length > 0) {
            if (length > maxLength) {
                throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("length");
            }
        } else {
            length = 0;
        }
    }
    const buffer17 = new Uint8Array(obj, byteOffset, length);
    Object.setPrototypeOf(buffer17, Buffer1.prototype);
    return buffer17;
}
function _utf8Slice(buf, start14, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i49 = start14;
    while(i49 < end){
        const firstByte = buf[i49];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i49 + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) {
                        codePoint = firstByte;
                    }
                    break;
                case 2:
                    secondByte = buf[i49 + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 3:
                    secondByte = buf[i49 + 1];
                    thirdByte = buf[i49 + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 4:
                    secondByte = buf[i49 + 1];
                    thirdByte = buf[i49 + 2];
                    fourthByte = buf[i49 + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                            codePoint = tempCodePoint;
                        }
                    }
            }
        }
        if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i49 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
const MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= 4096) {
        return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i50 = 0;
    while(i50 < len){
        res += String.fromCharCode.apply(String, codePoints.slice(i50, i50 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
}
function _latin1Slice(buf, start15, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i51 = start15; i51 < end; ++i51){
        ret += String.fromCharCode(buf[i51]);
    }
    return ret;
}
function _hexSlice(buf, start16, end) {
    const len = buf.length;
    if (!start16 || start16 < 0) {
        start16 = 0;
    }
    if (!end || end < 0 || end > len) {
        end = len;
    }
    let out = "";
    for(let i52 = start16; i52 < end; ++i52){
        out += hexSliceLookupTable[buf[i52]];
    }
    return out;
}
Buffer1.prototype.slice = function slice(start17, end) {
    const len = this.length;
    start17 = ~~start17;
    end = end === void 0 ? len : ~~end;
    if (start17 < 0) {
        start17 += len;
        if (start17 < 0) {
            start17 = 0;
        }
    } else if (start17 > len) {
        start17 = len;
    }
    if (end < 0) {
        end += len;
        if (end < 0) {
            end = 0;
        }
    } else if (end > len) {
        end = len;
    }
    if (end < start17) {
        end = start17;
    }
    const newBuf = this.subarray(start17, end);
    Object.setPrototypeOf(newBuf, Buffer1.prototype);
    return newBuf;
};
Buffer1.prototype.readUintLE = Buffer1.prototype.readUIntLE = function readUIntLE(offset, byteLength1) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength1 === 6) {
        return readUInt48LE(this, offset);
    }
    if (byteLength1 === 5) {
        return readUInt40LE(this, offset);
    }
    if (byteLength1 === 3) {
        return readUInt24LE(this, offset);
    }
    if (byteLength1 === 4) {
        return this.readUInt32LE(offset);
    }
    if (byteLength1 === 2) {
        return this.readUInt16LE(offset);
    }
    if (byteLength1 === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength1, 6, "byteLength");
};
Buffer1.prototype.readUintBE = Buffer1.prototype.readUIntBE = function readUIntBE(offset, byteLength2) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength2 === 6) {
        return readUInt48BE(this, offset);
    }
    if (byteLength2 === 5) {
        return readUInt40BE(this, offset);
    }
    if (byteLength2 === 3) {
        return readUInt24BE(this, offset);
    }
    if (byteLength2 === 4) {
        return this.readUInt32BE(offset);
    }
    if (byteLength2 === 2) {
        return this.readUInt16BE(offset);
    }
    if (byteLength2 === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength2, 6, "byteLength");
};
Buffer1.prototype.readUint8 = Buffer1.prototype.readUInt8 = function readUInt8(offset = 0) {
    validateNumber1(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val;
};
Buffer1.prototype.readUint16BE = Buffer1.prototype.readUInt16BE = readUInt16BE;
Buffer1.prototype.readUint16LE = Buffer1.prototype.readUInt16LE = function readUInt16LE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first + last * 2 ** 8;
};
Buffer1.prototype.readUint32LE = Buffer1.prototype.readUInt32LE = function readUInt32LE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer1.prototype.readUint32BE = Buffer1.prototype.readUInt32BE = readUInt32BE;
Buffer1.prototype.readBigUint64LE = Buffer1.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer1.prototype.readBigUint64BE = Buffer1.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer1.prototype.readIntLE = function readIntLE(offset, byteLength3) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength3 === 6) {
        return readInt48LE(this, offset);
    }
    if (byteLength3 === 5) {
        return readInt40LE(this, offset);
    }
    if (byteLength3 === 3) {
        return readInt24LE(this, offset);
    }
    if (byteLength3 === 4) {
        return this.readInt32LE(offset);
    }
    if (byteLength3 === 2) {
        return this.readInt16LE(offset);
    }
    if (byteLength3 === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength3, 6, "byteLength");
};
Buffer1.prototype.readIntBE = function readIntBE(offset, byteLength4) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength4 === 6) {
        return readInt48BE(this, offset);
    }
    if (byteLength4 === 5) {
        return readInt40BE(this, offset);
    }
    if (byteLength4 === 3) {
        return readInt24BE(this, offset);
    }
    if (byteLength4 === 4) {
        return this.readInt32BE(offset);
    }
    if (byteLength4 === 2) {
        return this.readInt16BE(offset);
    }
    if (byteLength4 === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength4, 6, "byteLength");
};
Buffer1.prototype.readInt8 = function readInt8(offset = 0) {
    validateNumber1(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val | (val & 2 ** 7) * 33554430;
};
Buffer1.prototype.readInt16LE = function readInt16LE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first + last * 2 ** 8;
    return val | (val & 2 ** 15) * 131070;
};
Buffer1.prototype.readInt16BE = function readInt16BE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first * 2 ** 8 + last;
    return val | (val & 2 ** 15) * 131070;
};
Buffer1.prototype.readInt32LE = function readInt32LE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer1.prototype.readInt32BE = function readInt32BE(offset = 0) {
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer1.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer1.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber1(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer1.prototype.readFloatLE = function readFloatLE(offset) {
    return bigEndian ? readFloatBackwards(this, offset) : readFloatForwards(this, offset);
};
Buffer1.prototype.readFloatBE = function readFloatBE(offset) {
    return bigEndian ? readFloatForwards(this, offset) : readFloatBackwards(this, offset);
};
Buffer1.prototype.readDoubleLE = function readDoubleLE(offset) {
    return bigEndian ? readDoubleBackwards(this, offset) : readDoubleForwards(this, offset);
};
Buffer1.prototype.readDoubleBE = function readDoubleBE(offset) {
    return bigEndian ? readDoubleForwards(this, offset) : readDoubleBackwards(this, offset);
};
Buffer1.prototype.writeUintLE = Buffer1.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength5) {
    if (byteLength5 === 6) {
        return writeU_Int48LE(this, value, offset, 0, 281474976710655);
    }
    if (byteLength5 === 5) {
        return writeU_Int40LE(this, value, offset, 0, 1099511627775);
    }
    if (byteLength5 === 3) {
        return writeU_Int24LE(this, value, offset, 0, 16777215);
    }
    if (byteLength5 === 4) {
        return writeU_Int32LE(this, value, offset, 0, 4294967295);
    }
    if (byteLength5 === 2) {
        return writeU_Int16LE(this, value, offset, 0, 65535);
    }
    if (byteLength5 === 1) {
        return writeU_Int8(this, value, offset, 0, 255);
    }
    boundsError(byteLength5, 6, "byteLength");
};
Buffer1.prototype.writeUintBE = Buffer1.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength6) {
    if (byteLength6 === 6) {
        return writeU_Int48BE(this, value, offset, 0, 281474976710655);
    }
    if (byteLength6 === 5) {
        return writeU_Int40BE(this, value, offset, 0, 1099511627775);
    }
    if (byteLength6 === 3) {
        return writeU_Int24BE(this, value, offset, 0, 16777215);
    }
    if (byteLength6 === 4) {
        return writeU_Int32BE(this, value, offset, 0, 4294967295);
    }
    if (byteLength6 === 2) {
        return writeU_Int16BE(this, value, offset, 0, 65535);
    }
    if (byteLength6 === 1) {
        return writeU_Int8(this, value, offset, 0, 255);
    }
    boundsError(byteLength6, 6, "byteLength");
};
Buffer1.prototype.writeUint8 = Buffer1.prototype.writeUInt8 = function writeUInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, 0, 255);
};
Buffer1.prototype.writeUint16LE = Buffer1.prototype.writeUInt16LE = function writeUInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, 0, 65535);
};
Buffer1.prototype.writeUint16BE = Buffer1.prototype.writeUInt16BE = function writeUInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, 0, 65535);
};
Buffer1.prototype.writeUint32LE = Buffer1.prototype.writeUInt32LE = function writeUInt32LE(value, offset = 0) {
    return _writeUInt32LE(this, value, offset, 0, 4294967295);
};
Buffer1.prototype.writeUint32BE = Buffer1.prototype.writeUInt32BE = function writeUInt32BE(value, offset = 0) {
    return _writeUInt32BE(this, value, offset, 0, 4294967295);
};
function wrtBigUInt64LE(buf, value, offset, min20, max) {
    checkIntBI(value, min20, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min21, max) {
    checkIntBI(value, min21, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer1.prototype.writeBigUint64LE = Buffer1.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer1.prototype.writeBigUint64BE = Buffer1.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer1.prototype.writeIntLE = function writeIntLE(value, offset, byteLength7) {
    if (byteLength7 === 6) {
        return writeU_Int48LE(this, value, offset, -140737488355328, 140737488355327);
    }
    if (byteLength7 === 5) {
        return writeU_Int40LE(this, value, offset, -549755813888, 549755813887);
    }
    if (byteLength7 === 3) {
        return writeU_Int24LE(this, value, offset, -8388608, 8388607);
    }
    if (byteLength7 === 4) {
        return writeU_Int32LE(this, value, offset, -2147483648, 2147483647);
    }
    if (byteLength7 === 2) {
        return writeU_Int16LE(this, value, offset, -32768, 32767);
    }
    if (byteLength7 === 1) {
        return writeU_Int8(this, value, offset, -128, 127);
    }
    boundsError(byteLength7, 6, "byteLength");
};
Buffer1.prototype.writeIntBE = function writeIntBE(value, offset, byteLength8) {
    if (byteLength8 === 6) {
        return writeU_Int48BE(this, value, offset, -140737488355328, 140737488355327);
    }
    if (byteLength8 === 5) {
        return writeU_Int40BE(this, value, offset, -549755813888, 549755813887);
    }
    if (byteLength8 === 3) {
        return writeU_Int24BE(this, value, offset, -8388608, 8388607);
    }
    if (byteLength8 === 4) {
        return writeU_Int32BE(this, value, offset, -2147483648, 2147483647);
    }
    if (byteLength8 === 2) {
        return writeU_Int16BE(this, value, offset, -32768, 32767);
    }
    if (byteLength8 === 1) {
        return writeU_Int8(this, value, offset, -128, 127);
    }
    boundsError(byteLength8, 6, "byteLength");
};
Buffer1.prototype.writeInt8 = function writeInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, -128, 127);
};
Buffer1.prototype.writeInt16LE = function writeInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, -32768, 32767);
};
Buffer1.prototype.writeInt16BE = function writeInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, -32768, 32767);
};
Buffer1.prototype.writeInt32LE = function writeInt32LE(value, offset = 0) {
    return writeU_Int32LE(this, value, offset, -2147483648, 2147483647);
};
Buffer1.prototype.writeInt32BE = function writeInt32BE(value, offset = 0) {
    return writeU_Int32BE(this, value, offset, -2147483648, 2147483647);
};
Buffer1.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer1.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer1.prototype.writeFloatLE = function writeFloatLE(value, offset) {
    return bigEndian ? writeFloatBackwards(this, value, offset) : writeFloatForwards(this, value, offset);
};
Buffer1.prototype.writeFloatBE = function writeFloatBE(value, offset) {
    return bigEndian ? writeFloatForwards(this, value, offset) : writeFloatBackwards(this, value, offset);
};
Buffer1.prototype.writeDoubleLE = function writeDoubleLE(value, offset) {
    return bigEndian ? writeDoubleBackwards(this, value, offset) : writeDoubleForwards(this, value, offset);
};
Buffer1.prototype.writeDoubleBE = function writeDoubleBE(value, offset) {
    return bigEndian ? writeDoubleForwards(this, value, offset) : writeDoubleBackwards(this, value, offset);
};
Buffer1.prototype.copy = function copy(target, targetStart, sourceStart, sourceEnd) {
    if (!isUint8Array(this)) {
        throw new codes.ERR_INVALID_ARG_TYPE("source", [
            "Buffer",
            "Uint8Array"
        ], this);
    }
    if (!isUint8Array(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (targetStart === undefined) {
        targetStart = 0;
    } else {
        targetStart = toInteger(targetStart, 0);
        if (targetStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
        }
    }
    if (sourceStart === undefined) {
        sourceStart = 0;
    } else {
        sourceStart = toInteger(sourceStart, 0);
        if (sourceStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
        }
        if (sourceStart >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT32}`, sourceStart);
        }
    }
    if (sourceEnd === undefined) {
        sourceEnd = this.length;
    } else {
        sourceEnd = toInteger(sourceEnd, 0);
        if (sourceEnd < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
        }
        if (sourceEnd >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT32}`, sourceEnd);
        }
    }
    if (targetStart >= target.length) {
        return 0;
    }
    if (sourceEnd > 0 && sourceEnd < sourceStart) {
        sourceEnd = sourceStart;
    }
    if (sourceEnd === sourceStart) {
        return 0;
    }
    if (target.length === 0 || this.length === 0) {
        return 0;
    }
    if (sourceEnd > this.length) {
        sourceEnd = this.length;
    }
    if (target.length - targetStart < sourceEnd - sourceStart) {
        sourceEnd = target.length - targetStart + sourceStart;
    }
    const len = sourceEnd - sourceStart;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, sourceStart, sourceEnd);
    } else {
        Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
    }
    return len;
};
Buffer1.prototype.fill = function fill(val, start18, end, encoding) {
    if (typeof val === "string") {
        if (typeof start18 === "string") {
            encoding = start18;
            start18 = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer1.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
            const code8 = val.charCodeAt(0);
            if (encoding === "utf8" && code8 < 128 || encoding === "latin1") {
                val = code8;
            }
        }
    } else if (typeof val === "number") {
        val = val & 255;
    } else if (typeof val === "boolean") {
        val = Number(val);
    }
    if (start18 < 0 || this.length < start18 || this.length < end) {
        throw new RangeError("Out of range index");
    }
    if (end <= start18) {
        return this;
    }
    start18 = start18 >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) {
        val = 0;
    }
    let i53;
    if (typeof val === "number") {
        for(i53 = start18; i53 < end; ++i53){
            this[i53] = val;
        }
    } else {
        const bytes = Buffer1.isBuffer(val) ? val : Buffer1.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
            throw new codes.ERR_INVALID_ARG_VALUE("value", val);
        }
        for(i53 = 0; i53 < end - start18; ++i53){
            this[i53 + start18] = bytes[i53 % len];
        }
    }
    return this;
};
function checkBounds1(buf, offset, byteLength2) {
    validateNumber1(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
    }
}
function checkIntBI(value, min22, max, buf, offset, byteLength2) {
    if (value > max || value < min22) {
        const n11 = typeof min22 === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
            if (min22 === 0 || min22 === BigInt(0)) {
                range = `>= 0${n11} and < 2${n11} ** ${(byteLength2 + 1) * 8}${n11}`;
            } else {
                range = `>= -(2${n11} ** ${(byteLength2 + 1) * 8 - 1}${n11}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n11}`;
            }
        } else {
            range = `>= ${min22}${n11} and <= ${max}${n11}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds1(buf, offset, byteLength2);
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i54 = 0; i54 < length; ++i54){
        codePoint = string.charCodeAt(i54);
        if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
                if (codePoint > 56319) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                } else if (i54 + 1 === length) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                }
                leadSurrogate = codePoint;
                continue;
            }
            if (codePoint < 56320) {
                if ((units -= 3) > -1) {
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = codePoint;
                continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
            if ((units -= 3) > -1) {
                bytes.push(239, 191, 189);
            }
        }
        leadSurrogate = null;
        if (codePoint < 128) {
            if ((units -= 1) < 0) {
                break;
            }
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) {
                break;
            }
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) {
                break;
            }
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) {
                break;
            }
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
            throw new Error("Invalid code point");
        }
    }
    return bytes;
}
function blitBuffer(src, dst, offset, length) {
    let i55;
    for(i55 = 0; i55 < length; ++i55){
        if (i55 + offset >= dst.length || i55 >= src.length) {
            break;
        }
        dst[i55 + offset] = src[i55];
    }
    return i55;
}
function isInstance(obj, type9) {
    return obj instanceof type9 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type9.name;
}
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table1 = new Array(256);
    for(let i56 = 0; i56 < 16; ++i56){
        const i16 = i56 * 16;
        for(let j = 0; j < 16; ++j){
            table1[i16 + j] = alphabet[i56] + alphabet[j];
        }
    }
    return table1;
}();
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}
const atob1 = globalThis.atob;
const Blob1 = globalThis.Blob;
const btoa = globalThis.btoa;
const __default6 = {
    atob: atob1,
    btoa,
    Blob: Blob1,
    Buffer: Buffer1,
    constants,
    kMaxLength: 2147483647,
    kStringMaxLength: 536870888,
    SlowBuffer
};
var valueType;
(function(valueType1) {
    valueType1[valueType1["noIterator"] = 0] = "noIterator";
    valueType1[valueType1["isArray"] = 1] = "isArray";
    valueType1[valueType1["isSet"] = 2] = "isSet";
    valueType1[valueType1["isMap"] = 3] = "isMap";
})(valueType || (valueType = {}));
let memo;
function isDeepStrictEqual(val1, val2) {
    return innerDeepEqual(val1, val2, true);
}
function innerDeepEqual(val1, val2, strict1, memos = memo) {
    if (val1 === val2) {
        if (val1 !== 0) return true;
        return strict1 ? Object.is(val1, val2) : true;
    }
    if (strict1) {
        if (typeof val1 !== "object") {
            return typeof val1 === "number" && Number.isNaN(val1) && Number.isNaN(val2);
        }
        if (typeof val2 !== "object" || val1 === null || val2 === null) {
            return false;
        }
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
            return false;
        }
    } else {
        if (val1 === null || typeof val1 !== "object") {
            if (val2 === null || typeof val2 !== "object") {
                return val1 == val2 || Number.isNaN(val1) && Number.isNaN(val2);
            }
            return false;
        }
        if (val2 === null || typeof val2 !== "object") {
            return false;
        }
    }
    const val1Tag = Object.prototype.toString.call(val1);
    const val2Tag = Object.prototype.toString.call(val2);
    if (val1Tag !== val2Tag) {
        return false;
    }
    if (Array.isArray(val1)) {
        if (!Array.isArray(val2) || val1.length !== val2.length) {
            return false;
        }
        const filter = strict1 ? 2 : 2 | 16;
        const keys1 = getOwnNonIndexProperties(val1, filter);
        const keys2 = getOwnNonIndexProperties(val2, filter);
        if (keys1.length !== keys2.length) {
            return false;
        }
        return keyCheck(val1, val2, strict1, memos, valueType.isArray, keys1);
    } else if (val1Tag === "[object Object]") {
        return keyCheck(val1, val2, strict1, memos, valueType.noIterator);
    } else if (val1 instanceof Date) {
        if (!(val2 instanceof Date) || val1.getTime() !== val2.getTime()) {
            return false;
        }
    } else if (val1 instanceof RegExp) {
        if (!(val2 instanceof RegExp) || !areSimilarRegExps(val1, val2)) {
            return false;
        }
    } else if (isNativeError1(val1) || val1 instanceof Error) {
        if (!isNativeError1(val2) && !(val2 instanceof Error) || val1.message !== val2.message || val1.name !== val2.name) {
            return false;
        }
    } else if (isArrayBufferView(val1)) {
        const TypedArrayPrototypeGetSymbolToStringTag = (val)=>Object.getOwnPropertySymbols(val).map((item)=>item.toString()
            ).toString()
        ;
        if (isTypedArray(val1) && isTypedArray(val2) && TypedArrayPrototypeGetSymbolToStringTag(val1) !== TypedArrayPrototypeGetSymbolToStringTag(val2)) {
            return false;
        }
        if (!strict1 && (isFloat32Array(val1) || isFloat64Array(val1))) {
            if (!areSimilarFloatArrays(val1, val2)) {
                return false;
            }
        } else if (!areSimilarTypedArrays(val1, val2)) {
            return false;
        }
        const filter = strict1 ? 2 : 2 | 16;
        const keysVal1 = getOwnNonIndexProperties(val1, filter);
        const keysVal2 = getOwnNonIndexProperties(val2, filter);
        if (keysVal1.length !== keysVal2.length) {
            return false;
        }
        return keyCheck(val1, val2, strict1, memos, valueType.noIterator, keysVal1);
    } else if (isSet1(val1)) {
        if (!isSet1(val2) || val1.size !== val2.size) {
            return false;
        }
        return keyCheck(val1, val2, strict1, memos, valueType.isSet);
    } else if (isMap1(val1)) {
        if (!isMap1(val2) || val1.size !== val2.size) {
            return false;
        }
        return keyCheck(val1, val2, strict1, memos, valueType.isMap);
    } else if (isAnyArrayBuffer1(val1)) {
        if (!isAnyArrayBuffer1(val2) || !areEqualArrayBuffers(val1, val2)) {
            return false;
        }
    } else if (isBoxedPrimitive1(val1)) {
        if (!isEqualBoxedPrimitive(val1, val2)) {
            return false;
        }
    } else if (Array.isArray(val2) || isArrayBufferView(val2) || isSet1(val2) || isMap1(val2) || isDate1(val2) || isRegExp1(val2) || isAnyArrayBuffer1(val2) || isBoxedPrimitive1(val2) || isNativeError1(val2) || val2 instanceof Error) {
        return false;
    }
    return keyCheck(val1, val2, strict1, memos, valueType.noIterator);
}
function keyCheck(val1, val2, strict2, memos, iterationType, aKeys = []) {
    if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        const bKeys = Object.keys(val2);
        if (aKeys.length !== bKeys.length) {
            return false;
        }
    }
    let i57 = 0;
    for(; i57 < aKeys.length; i57++){
        if (!val2.propertyIsEnumerable(aKeys[i57])) {
            return false;
        }
    }
    if (strict2 && arguments.length === 5) {
        const symbolKeysA = Object.getOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
            let count1 = 0;
            for(i57 = 0; i57 < symbolKeysA.length; i57++){
                const key = symbolKeysA[i57];
                if (val1.propertyIsEnumerable(key)) {
                    if (!val2.propertyIsEnumerable(key)) {
                        return false;
                    }
                    aKeys.push(key.toString());
                    count1++;
                } else if (val2.propertyIsEnumerable(key)) {
                    return false;
                }
            }
            const symbolKeysB = Object.getOwnPropertySymbols(val2);
            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count1) {
                return false;
            }
        } else {
            const symbolKeysB = Object.getOwnPropertySymbols(val2);
            if (symbolKeysB.length !== 0 && getEnumerables(val2, symbolKeysB).length !== 0) {
                return false;
            }
        }
    }
    if (aKeys.length === 0 && (iterationType === valueType.noIterator || iterationType === valueType.isArray && val1.length === 0 || val1.size === 0)) {
        return true;
    }
    if (memos === undefined) {
        memos = {
            val1: new Map(),
            val2: new Map(),
            position: 0
        };
    } else {
        const val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== undefined) {
            const val2MemoB = memos.val2.get(val2);
            if (val2MemoB !== undefined) {
                return val2MemoA === val2MemoB;
            }
        }
        memos.position++;
    }
    memos.val1.set(val1, memos.position);
    memos.val2.set(val2, memos.position);
    const areEq = objEquiv(val1, val2, strict2, aKeys, memos, iterationType);
    memos.val1.delete(val1);
    memos.val2.delete(val2);
    return areEq;
}
function areSimilarRegExps(a10, b12) {
    return a10.source === b12.source && a10.flags === b12.flags && a10.lastIndex === b12.lastIndex;
}
function areSimilarFloatArrays(arr1, arr2) {
    if (arr1.byteLength !== arr2.byteLength) {
        return false;
    }
    for(let i58 = 0; i58 < arr1.byteLength; i58++){
        if (arr1[i58] !== arr2[i58]) {
            return false;
        }
    }
    return true;
}
function areSimilarTypedArrays(arr1, arr2) {
    if (arr1.byteLength !== arr2.byteLength) {
        return false;
    }
    return Buffer1.compare(new Uint8Array(arr1.buffer, arr1.byteOffset, arr1.byteLength), new Uint8Array(arr2.buffer, arr2.byteOffset, arr2.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
    return buf1.byteLength === buf2.byteLength && Buffer1.compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(a11, b13) {
    if (Object.getOwnPropertyNames(a11).length !== Object.getOwnPropertyNames(b13).length) {
        return false;
    }
    if (Object.getOwnPropertySymbols(a11).length !== Object.getOwnPropertySymbols(b13).length) {
        return false;
    }
    if (isNumberObject1(a11)) {
        return isNumberObject1(b13) && Object.is(Number.prototype.valueOf.call(a11), Number.prototype.valueOf.call(b13));
    }
    if (isStringObject1(a11)) {
        return isStringObject1(b13) && String.prototype.valueOf.call(a11) === String.prototype.valueOf.call(b13);
    }
    if (isBooleanObject1(a11)) {
        return isBooleanObject1(b13) && Boolean.prototype.valueOf.call(a11) === Boolean.prototype.valueOf.call(b13);
    }
    if (isBigIntObject1(a11)) {
        return isBigIntObject1(b13) && BigInt.prototype.valueOf.call(a11) === BigInt.prototype.valueOf.call(b13);
    }
    if (isSymbolObject1(a11)) {
        return isSymbolObject1(b13) && Symbol.prototype.valueOf.call(a11) === Symbol.prototype.valueOf.call(b13);
    }
    throw Error(`Unknown boxed type`);
}
function getEnumerables(val, keys) {
    return keys.filter((key)=>val.propertyIsEnumerable(key)
    );
}
function objEquiv(obj1, obj2, strict3, keys, memos, iterationType) {
    let i59 = 0;
    if (iterationType === valueType.isSet) {
        if (!setEquiv(obj1, obj2, strict3, memos)) {
            return false;
        }
    } else if (iterationType === valueType.isMap) {
        if (!mapEquiv(obj1, obj2, strict3, memos)) {
            return false;
        }
    } else if (iterationType === valueType.isArray) {
        for(; i59 < obj1.length; i59++){
            if (obj1.hasOwnProperty(i59)) {
                if (!obj2.hasOwnProperty(i59) || !innerDeepEqual(obj1[i59], obj2[i59], strict3, memos)) {
                    return false;
                }
            } else if (obj2.hasOwnProperty(i59)) {
                return false;
            } else {
                const keys1 = Object.keys(obj1);
                for(; i59 < keys1.length; i59++){
                    const key = keys1[i59];
                    if (!obj2.hasOwnProperty(key) || !innerDeepEqual(obj1[key], obj2[key], strict3, memos)) {
                        return false;
                    }
                }
                if (keys1.length !== Object.keys(obj2).length) {
                    return false;
                }
                if (keys1.length !== Object.keys(obj2).length) {
                    return false;
                }
                return true;
            }
        }
    }
    for(i59 = 0; i59 < keys.length; i59++){
        const key = keys[i59];
        if (!innerDeepEqual(obj1[key], obj2[key], strict3, memos)) {
            return false;
        }
    }
    return true;
}
function findLooseMatchingPrimitives(primitive) {
    switch(typeof primitive){
        case "undefined":
            return null;
        case "object":
            return undefined;
        case "symbol":
            return false;
        case "string":
            primitive = +primitive;
        case "number":
            if (Number.isNaN(primitive)) {
                return false;
            }
    }
    return true;
}
function setMightHaveLoosePrim(set1, set2, primitive) {
    const altValue = findLooseMatchingPrimitives(primitive);
    if (altValue != null) return altValue;
    return set2.has(altValue) && !set1.has(altValue);
}
function setHasEqualElement(set, val1, strict4, memos) {
    for (const val2 of set){
        if (innerDeepEqual(val1, val2, strict4, memos)) {
            set.delete(val2);
            return true;
        }
    }
    return false;
}
function setEquiv(set1, set2, strict5, memos) {
    let set = null;
    for (const item of set1){
        if (typeof item === "object" && item !== null) {
            if (set === null) {
                set = new Set();
            }
            set.add(item);
        } else if (!set2.has(item)) {
            if (strict5) return false;
            if (!setMightHaveLoosePrim(set1, set2, item)) {
                return false;
            }
            if (set === null) {
                set = new Set();
            }
            set.add(item);
        }
    }
    if (set !== null) {
        for (const item of set2){
            if (typeof item === "object" && item !== null) {
                if (!setHasEqualElement(set, item, strict5, memos)) return false;
            } else if (!strict5 && !set1.has(item) && !setHasEqualElement(set, item, strict5, memos)) {
                return false;
            }
        }
        return set.size === 0;
    }
    return true;
}
function mapMightHaveLoosePrimitive(map1, map2, primitive, item, memos) {
    const altValue = findLooseMatchingPrimitives(primitive);
    if (altValue != null) {
        return altValue;
    }
    const curB = map2.get(altValue);
    if (curB === undefined && !map2.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
        return false;
    }
    return !map1.has(altValue) && innerDeepEqual(item, curB, false, memos);
}
function mapEquiv(map1, map2, strict6, memos) {
    let set = null;
    for (const { 0: key , 1: item1  } of map1){
        if (typeof key === "object" && key !== null) {
            if (set === null) {
                set = new Set();
            }
            set.add(key);
        } else {
            const item2 = map2.get(key);
            if (item2 === undefined && !map2.has(key) || !innerDeepEqual(item1, item2, strict6, memos)) {
                if (strict6) return false;
                if (!mapMightHaveLoosePrimitive(map1, map2, key, item1, memos)) {
                    return false;
                }
                if (set === null) {
                    set = new Set();
                }
                set.add(key);
            }
        }
    }
    if (set !== null) {
        for (const { 0: key , 1: item  } of map2){
            if (typeof key === "object" && key !== null) {
                if (!mapHasEqualEntry(set, map1, key, item, strict6, memos)) {
                    return false;
                }
            } else if (!strict6 && (!map1.has(key) || !innerDeepEqual(map1.get(key), item, false, memos)) && !mapHasEqualEntry(set, map1, key, item, false, memos)) {
                return false;
            }
        }
        return set.size === 0;
    }
    return true;
}
function mapHasEqualEntry(set, map, key1, item1, strict7, memos) {
    for (const key2 of set){
        if (innerDeepEqual(key1, key2, strict7, memos) && innerDeepEqual(item1, map.get(key2), strict7, memos)) {
            set.delete(key2);
            return true;
        }
    }
    return false;
}
const NumberIsSafeInteger = Number.isSafeInteger;
function isArray(value) {
    return Array.isArray(value);
}
function isBoolean(value) {
    return typeof value === "boolean" || value instanceof Boolean;
}
function isNull(value) {
    return value === null;
}
function isNullOrUndefined(value) {
    return value === null || value === undefined;
}
function isNumber(value) {
    return typeof value === "number" || value instanceof Number;
}
function isString(value) {
    return typeof value === "string" || value instanceof String;
}
function isSymbol(value) {
    return typeof value === "symbol";
}
function isUndefined(value) {
    return value === undefined;
}
function isObject(value) {
    return value !== null && typeof value === "object";
}
function isError(e11) {
    return e11 instanceof Error;
}
function isFunction(value) {
    return typeof value === "function";
}
function isRegExp2(value) {
    return __default3.isRegExp(value);
}
function isDate2(value) {
    return __default3.isDate(value);
}
function isPrimitive(value) {
    return value === null || typeof value !== "object" && typeof value !== "function";
}
function isBuffer(value) {
    return Buffer1.isBuffer(value);
}
function _extend(target, source) {
    if (source === null || typeof source !== "object") return target;
    const keys = Object.keys(source);
    let i60 = keys.length;
    while(i60--){
        target[keys[i60]] = source[keys[i60]];
    }
    return target;
}
function getSystemErrorName(code9) {
    if (typeof code9 !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE("err", "number", code9);
    }
    if (code9 >= 0 || !NumberIsSafeInteger(code9)) {
        throw new codes.ERR_OUT_OF_RANGE("err", "a negative integer", code9);
    }
    return errorMap.get(code9)?.[0];
}
function inherits(ctor, superCtor) {
    if (ctor === undefined || ctor === null) {
        throw new codes.ERR_INVALID_ARG_TYPE("ctor", "Function", ctor);
    }
    if (superCtor === undefined || superCtor === null) {
        throw new codes.ERR_INVALID_ARG_TYPE("superCtor", "Function", superCtor);
    }
    if (superCtor.prototype === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("superCtor.prototype", "Object", superCtor.prototype);
    }
    Object.defineProperty(ctor, "super_", {
        value: superCtor,
        writable: true,
        configurable: true
    });
    Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
}
function pad(n12) {
    return n12.toString().padStart(2, "0");
}
const months = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec", 
];
function timestamp() {
    const d2 = new Date();
    const t3 = [
        pad(d2.getHours()),
        pad(d2.getMinutes()),
        pad(d2.getSeconds()), 
    ].join(":");
    return `${d2.getDate()} ${months[d2.getMonth()]} ${t3}`;
}
function log(...args) {
    console.log("%s - %s", timestamp(), format(...args));
}
const __default7 = {
    format,
    formatWithOptions,
    inspect,
    isArray,
    isBoolean,
    isNull,
    isNullOrUndefined,
    isNumber,
    isString,
    isSymbol,
    isUndefined,
    isObject,
    isError,
    isFunction,
    isRegExp: isRegExp2,
    isDate: isDate2,
    isPrimitive,
    isBuffer,
    _extend,
    getSystemErrorName,
    deprecate,
    callbackify,
    promisify,
    inherits,
    types: __default3,
    stripVTControlCharacters,
    TextDecoder: _TextDecoder,
    TextEncoder: _TextEncoder,
    log,
    debuglog,
    isDeepStrictEqual
};
const { errno: { ENOTDIR , ENOENT  } ,  } = os;
const kIsNodeError = Symbol("kIsNodeError");
const classRegExp1 = /^([A-Z][a-z0-9]*)+$/;
const kTypes = [
    "string",
    "function",
    "number",
    "object",
    "Function",
    "Object",
    "boolean",
    "bigint",
    "symbol", 
];
class AbortError extends Error {
    code;
    constructor(){
        super("The operation was aborted");
        this.code = "ABORT_ERR";
        this.name = "AbortError";
    }
}
function addNumericalSeparator(val) {
    let res = "";
    let i61 = val.length;
    const start19 = val[0] === "-" ? 1 : 0;
    for(; i61 >= start19 + 4; i61 -= 3){
        res = `_${val.slice(i61 - 3, i61)}${res}`;
    }
    return `${val.slice(0, i61)}${res}`;
}
const captureLargerStackTrace = hideStackFrames(function captureLargerStackTrace(err13) {
    Error.captureStackTrace(err13);
    return err13;
});
const uvExceptionWithHostPort = hideStackFrames(function uvExceptionWithHostPort(err14, syscall1, address, port) {
    const { 0: code10 , 1: uvmsg  } = uvErrmapGet(err14) || uvUnmappedError;
    const message = `${syscall1} ${code10}: ${uvmsg}`;
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    const ex = new Error(`${message}${details}`);
    ex.code = code10;
    ex.errno = err14;
    ex.syscall = syscall1;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace(ex);
});
const errnoException = hideStackFrames(function errnoException(err15, syscall2, original) {
    const code11 = getSystemErrorName(err15);
    const message = original ? `${syscall2} ${code11} ${original}` : `${syscall2} ${code11}`;
    const ex = new Error(message);
    ex.errno = err15;
    ex.code = code11;
    ex.syscall = syscall2;
    return captureLargerStackTrace(ex);
});
function uvErrmapGet(name22) {
    return errorMap.get(name22);
}
const uvUnmappedError = [
    "UNKNOWN",
    "unknown error"
];
const uvException = hideStackFrames(function uvException(ctx) {
    const { 0: code12 , 1: uvmsg  } = uvErrmapGet(ctx.errno) || uvUnmappedError;
    let message = `${code12}: ${ctx.message || uvmsg}, ${ctx.syscall}`;
    let path4;
    let dest;
    if (ctx.path) {
        path4 = ctx.path.toString();
        message += ` '${path4}'`;
    }
    if (ctx.dest) {
        dest = ctx.dest.toString();
        message += ` -> '${dest}'`;
    }
    const err16 = new Error(message);
    for (const prop of Object.keys(ctx)){
        if (prop === "message" || prop === "path" || prop === "dest") {
            continue;
        }
        err16[prop] = ctx[prop];
    }
    err16.code = code12;
    if (path4) {
        err16.path = path4;
    }
    if (dest) {
        err16.dest = dest;
    }
    return captureLargerStackTrace(err16);
});
const exceptionWithHostPort = hideStackFrames(function exceptionWithHostPort(err17, syscall3, address, port, additional) {
    const code13 = getSystemErrorName(err17);
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    if (additional) {
        details += ` - Local (${additional})`;
    }
    const ex = new Error(`${syscall3} ${code13}${details}`);
    ex.errno = err17;
    ex.code = code13;
    ex.syscall = syscall3;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace(ex);
});
const dnsException = hideStackFrames(function(code14, syscall4, hostname2) {
    let errno;
    if (typeof code14 === "number") {
        errno = code14;
        if (code14 === codeMap.get("EAI_NODATA") || code14 === codeMap.get("EAI_NONAME")) {
            code14 = "ENOTFOUND";
        } else {
            code14 = getSystemErrorName(code14);
        }
    }
    const message = `${syscall4} ${code14}${hostname2 ? ` ${hostname2}` : ""}`;
    const ex = new Error(message);
    ex.errno = errno;
    ex.code = code14;
    ex.syscall = syscall4;
    if (hostname2) {
        ex.hostname = hostname2;
    }
    return captureLargerStackTrace(ex);
});
class NodeErrorAbstraction extends Error {
    code;
    constructor(name23, code15, message){
        super(message);
        this.code = code15;
        this.name = name23;
        this.stack = this.stack && `${name23} [${this.code}]${this.stack.slice(20)}`;
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
class NodeError extends NodeErrorAbstraction {
    constructor(code16, message){
        super(Error.prototype.name, code16, message);
    }
}
class NodeRangeError extends NodeErrorAbstraction {
    constructor(code17, message){
        super(RangeError.prototype.name, code17, message);
        Object.setPrototypeOf(this, RangeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeTypeError extends NodeErrorAbstraction {
    constructor(code18, message){
        super(TypeError.prototype.name, code18, message);
        Object.setPrototypeOf(this, TypeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeURIError extends NodeErrorAbstraction {
    constructor(code19, message){
        super(URIError.prototype.name, code19, message);
        Object.setPrototypeOf(this, URIError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeSystemError extends NodeErrorAbstraction {
    constructor(key, context, msgPrefix){
        let message = `${msgPrefix}: ${context.syscall} returned ` + `${context.code} (${context.message})`;
        if (context.path !== undefined) {
            message += ` ${context.path}`;
        }
        if (context.dest !== undefined) {
            message += ` => ${context.dest}`;
        }
        super("SystemError", key, message);
        captureLargerStackTrace(this);
        Object.defineProperties(this, {
            [kIsNodeError]: {
                value: true,
                enumerable: false,
                writable: false,
                configurable: true
            },
            info: {
                value: context,
                enumerable: true,
                configurable: true,
                writable: false
            },
            errno: {
                get () {
                    return context.errno;
                },
                set: (value)=>{
                    context.errno = value;
                },
                enumerable: true,
                configurable: true
            },
            syscall: {
                get () {
                    return context.syscall;
                },
                set: (value)=>{
                    context.syscall = value;
                },
                enumerable: true,
                configurable: true
            }
        });
        if (context.path !== undefined) {
            Object.defineProperty(this, "path", {
                get () {
                    return context.path;
                },
                set: (value)=>{
                    context.path = value;
                },
                enumerable: true,
                configurable: true
            });
        }
        if (context.dest !== undefined) {
            Object.defineProperty(this, "dest", {
                get () {
                    return context.dest;
                },
                set: (value)=>{
                    context.dest = value;
                },
                enumerable: true,
                configurable: true
            });
        }
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
function makeSystemErrorWithCode(key, msgPrfix) {
    return class NodeError extends NodeSystemError {
        constructor(ctx){
            super(key, ctx, msgPrfix);
        }
    };
}
const ERR_FS_EISDIR = makeSystemErrorWithCode("ERR_FS_EISDIR", "Path is a directory");
function createInvalidArgType(name24, expected) {
    expected = Array.isArray(expected) ? expected : [
        expected
    ];
    let msg = "The ";
    if (name24.endsWith(" argument")) {
        msg += `${name24} `;
    } else {
        const type10 = name24.includes(".") ? "property" : "argument";
        msg += `"${name24}" ${type10} `;
    }
    msg += "must be ";
    const types = [];
    const instances = [];
    const other = [];
    for (const value of expected){
        if (kTypes.includes(value)) {
            types.push(value.toLocaleLowerCase());
        } else if (classRegExp1.test(value)) {
            instances.push(value);
        } else {
            other.push(value);
        }
    }
    if (instances.length > 0) {
        const pos = types.indexOf("object");
        if (pos !== -1) {
            types.splice(pos, 1);
            instances.push("Object");
        }
    }
    if (types.length > 0) {
        if (types.length > 2) {
            const last = types.pop();
            msg += `one of type ${types.join(", ")}, or ${last}`;
        } else if (types.length === 2) {
            msg += `one of type ${types[0]} or ${types[1]}`;
        } else {
            msg += `of type ${types[0]}`;
        }
        if (instances.length > 0 || other.length > 0) {
            msg += " or ";
        }
    }
    if (instances.length > 0) {
        if (instances.length > 2) {
            const last = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last}`;
        } else {
            msg += `an instance of ${instances[0]}`;
            if (instances.length === 2) {
                msg += ` or ${instances[1]}`;
            }
        }
        if (other.length > 0) {
            msg += " or ";
        }
    }
    if (other.length > 0) {
        if (other.length > 2) {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
        } else if (other.length === 2) {
            msg += `one of ${other[0]} or ${other[1]}`;
        } else {
            if (other[0].toLowerCase() !== other[0]) {
                msg += "an ";
            }
            msg += `${other[0]}`;
        }
    }
    return msg;
}
class ERR_INVALID_ARG_TYPE_RANGE extends NodeRangeError {
    constructor(name25, expected, actual){
        const msg = createInvalidArgType(name25, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
    }
}
class ERR_INVALID_ARG_TYPE extends NodeTypeError {
    constructor(name26, expected, actual){
        const msg = createInvalidArgType(name26, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
    }
    static RangeError = ERR_INVALID_ARG_TYPE_RANGE;
}
class ERR_INVALID_ARG_VALUE_RANGE extends NodeRangeError {
    constructor(name27, value, reason = "is invalid"){
        const type11 = name27.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type11} '${name27}' ${reason}. Received ${inspected}`);
    }
}
class ERR_INVALID_ARG_VALUE extends NodeTypeError {
    constructor(name28, value, reason = "is invalid"){
        const type12 = name28.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type12} '${name28}' ${reason}. Received ${inspected}`);
    }
    static RangeError = ERR_INVALID_ARG_VALUE_RANGE;
}
function invalidArgTypeHelper(input) {
    if (input == null) {
        return ` Received ${input}`;
    }
    if (typeof input === "function" && input.name) {
        return ` Received function ${input.name}`;
    }
    if (typeof input === "object") {
        if (input.constructor && input.constructor.name) {
            return ` Received an instance of ${input.constructor.name}`;
        }
        return ` Received ${inspect(input, {
            depth: -1
        })}`;
    }
    let inspected = inspect(input, {
        colors: false
    });
    if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`;
    }
    return ` Received type ${typeof input} (${inspected})`;
}
class ERR_OUT_OF_RANGE extends RangeError {
    code = "ERR_OUT_OF_RANGE";
    constructor(str, range, input, replaceDefaultBoolean = false){
        assert1(range, 'Missing "range" argument');
        let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
            received = String(input);
            if (input > 2n ** 32n || input < -(2n ** 32n)) {
                received = addNumericalSeparator(received);
            }
            received += "n";
        } else {
            received = inspect(input);
        }
        msg += ` It must be ${range}. Received ${received}`;
        super(msg);
        const { name: name29  } = this;
        this.name = `${name29} [${this.code}]`;
        this.stack;
        this.name = name29;
    }
}
class ERR_AMBIGUOUS_ARGUMENT extends NodeTypeError {
    constructor(x5, y3){
        super("ERR_AMBIGUOUS_ARGUMENT", `The "${x5}" argument is ambiguous. ${y3}`);
    }
}
class ERR_ASYNC_TYPE extends NodeTypeError {
    constructor(x6){
        super("ERR_ASYNC_TYPE", `Invalid name for async "type": ${x6}`);
    }
}
class ERR_BUFFER_OUT_OF_BOUNDS extends NodeRangeError {
    constructor(name30){
        super("ERR_BUFFER_OUT_OF_BOUNDS", name30 ? `"${name30}" is outside of buffer bounds` : "Attempt to access memory outside buffer bounds");
    }
}
class ERR_CHILD_PROCESS_IPC_REQUIRED extends NodeError {
    constructor(x7){
        super("ERR_CHILD_PROCESS_IPC_REQUIRED", `Forked processes must have an IPC channel, missing value 'ipc' in ${x7}`);
    }
}
class ERR_CHILD_PROCESS_STDIO_MAXBUFFER extends NodeRangeError {
    constructor(x8){
        super("ERR_CHILD_PROCESS_STDIO_MAXBUFFER", `${x8} maxBuffer length exceeded`);
    }
}
class ERR_FS_INVALID_SYMLINK_TYPE extends NodeError {
    constructor(x9){
        super("ERR_FS_INVALID_SYMLINK_TYPE", `Symlink type must be one of "dir", "file", or "junction". Received "${x9}"`);
    }
}
class ERR_HTTP_HEADERS_SENT extends NodeError {
    constructor(x10){
        super("ERR_HTTP_HEADERS_SENT", `Cannot ${x10} headers after they are sent to the client`);
    }
}
class ERR_HTTP_INVALID_HEADER_VALUE extends NodeTypeError {
    constructor(x11, y4){
        super("ERR_HTTP_INVALID_HEADER_VALUE", `Invalid value "${x11}" for header "${y4}"`);
    }
}
class ERR_HTTP_TRAILER_INVALID extends NodeError {
    constructor(){
        super("ERR_HTTP_TRAILER_INVALID", `Trailers are invalid with this transfer encoding`);
    }
}
class ERR_INVALID_ASYNC_ID extends NodeRangeError {
    constructor(x12, y5){
        super("ERR_INVALID_ASYNC_ID", `Invalid ${x12} value: ${y5}`);
    }
}
class ERR_INVALID_CALLBACK extends NodeTypeError {
    constructor(object){
        super("ERR_INVALID_CALLBACK", `Callback must be a function. Received ${inspect(object)}`);
    }
}
class ERR_INVALID_CURSOR_POS extends NodeTypeError {
    constructor(){
        super("ERR_INVALID_CURSOR_POS", `Cannot set cursor row without setting its column`);
    }
}
class ERR_INVALID_FD_TYPE extends NodeTypeError {
    constructor(x13){
        super("ERR_INVALID_FD_TYPE", `Unsupported fd type: ${x13}`);
    }
}
class ERR_INVALID_FILE_URL_HOST extends NodeTypeError {
    constructor(x14){
        super("ERR_INVALID_FILE_URL_HOST", `File URL host must be "localhost" or empty on ${x14}`);
    }
}
class ERR_INVALID_FILE_URL_PATH extends NodeTypeError {
    constructor(x15){
        super("ERR_INVALID_FILE_URL_PATH", `File URL path ${x15}`);
    }
}
class ERR_INVALID_HTTP_TOKEN extends NodeTypeError {
    constructor(x16, y6){
        super("ERR_INVALID_HTTP_TOKEN", `${x16} must be a valid HTTP token ["${y6}"]`);
    }
}
class ERR_INVALID_IP_ADDRESS extends NodeTypeError {
    constructor(x17){
        super("ERR_INVALID_IP_ADDRESS", `Invalid IP address: ${x17}`);
    }
}
class ERR_INVALID_OPT_VALUE_ENCODING extends NodeTypeError {
    constructor(x18){
        super("ERR_INVALID_OPT_VALUE_ENCODING", `The value "${x18}" is invalid for option "encoding"`);
    }
}
class ERR_INVALID_URI extends NodeURIError {
    constructor(){
        super("ERR_INVALID_URI", `URI malformed`);
    }
}
class ERR_IPC_CHANNEL_CLOSED extends NodeError {
    constructor(){
        super("ERR_IPC_CHANNEL_CLOSED", `Channel closed`);
    }
}
class ERR_METHOD_NOT_IMPLEMENTED extends NodeError {
    constructor(x19){
        super("ERR_METHOD_NOT_IMPLEMENTED", `The ${x19} method is not implemented`);
    }
}
class ERR_MISSING_ARGS extends NodeTypeError {
    constructor(...args){
        let msg = "The ";
        const len = args.length;
        const wrap1 = (a12)=>`"${a12}"`
        ;
        args = args.map((a13)=>Array.isArray(a13) ? a13.map(wrap1).join(" or ") : wrap1(a13)
        );
        switch(len){
            case 1:
                msg += `${args[0]} argument`;
                break;
            case 2:
                msg += `${args[0]} and ${args[1]} arguments`;
                break;
            default:
                msg += args.slice(0, len - 1).join(", ");
                msg += `, and ${args[len - 1]} arguments`;
                break;
        }
        super("ERR_MISSING_ARGS", `${msg} must be specified`);
    }
}
class ERR_MULTIPLE_CALLBACK extends NodeError {
    constructor(){
        super("ERR_MULTIPLE_CALLBACK", `Callback called multiple times`);
    }
}
class ERR_SERVER_ALREADY_LISTEN extends NodeError {
    constructor(){
        super("ERR_SERVER_ALREADY_LISTEN", `Listen method has been called more than once without closing.`);
    }
}
class ERR_SERVER_NOT_RUNNING extends NodeError {
    constructor(){
        super("ERR_SERVER_NOT_RUNNING", `Server is not running.`);
    }
}
class ERR_SOCKET_BAD_PORT extends NodeRangeError {
    constructor(name31, port, allowZero = true){
        assert1(typeof allowZero === "boolean", "The 'allowZero' argument must be of type boolean.");
        const operator = allowZero ? ">=" : ">";
        super("ERR_SOCKET_BAD_PORT", `${name31} should be ${operator} 0 and < 65536. Received ${port}.`);
    }
}
class ERR_SOCKET_CLOSED extends NodeError {
    constructor(){
        super("ERR_SOCKET_CLOSED", `Socket is closed`);
    }
}
class ERR_STREAM_ALREADY_FINISHED extends NodeError {
    constructor(x20){
        super("ERR_STREAM_ALREADY_FINISHED", `Cannot call ${x20} after a stream was finished`);
    }
}
class ERR_STREAM_CANNOT_PIPE extends NodeError {
    constructor(){
        super("ERR_STREAM_CANNOT_PIPE", `Cannot pipe, not readable`);
    }
}
class ERR_STREAM_DESTROYED extends NodeError {
    constructor(x21){
        super("ERR_STREAM_DESTROYED", `Cannot call ${x21} after a stream was destroyed`);
    }
}
class ERR_STREAM_NULL_VALUES extends NodeTypeError {
    constructor(){
        super("ERR_STREAM_NULL_VALUES", `May not write null values to stream`);
    }
}
class ERR_STREAM_PREMATURE_CLOSE extends NodeError {
    constructor(){
        super("ERR_STREAM_PREMATURE_CLOSE", `Premature close`);
    }
}
class ERR_STREAM_PUSH_AFTER_EOF extends NodeError {
    constructor(){
        super("ERR_STREAM_PUSH_AFTER_EOF", `stream.push() after EOF`);
    }
}
class ERR_STREAM_UNSHIFT_AFTER_END_EVENT extends NodeError {
    constructor(){
        super("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", `stream.unshift() after end event`);
    }
}
class ERR_STREAM_WRITE_AFTER_END extends NodeError {
    constructor(){
        super("ERR_STREAM_WRITE_AFTER_END", `write after end`);
    }
}
class ERR_UNHANDLED_ERROR extends NodeError {
    constructor(x22){
        super("ERR_UNHANDLED_ERROR", `Unhandled error. (${x22})`);
    }
}
class ERR_UNKNOWN_ENCODING extends NodeTypeError {
    constructor(x23){
        super("ERR_UNKNOWN_ENCODING", `Unknown encoding: ${x23}`);
    }
}
class ERR_INVALID_ADDRESS_FAMILY extends NodeRangeError {
    host;
    port;
    constructor(addressType, host, port){
        super("ERR_INVALID_ADDRESS_FAMILY", `Invalid address family: ${addressType} ${host}:${port}`);
        this.host = host;
        this.port = port;
    }
}
class ERR_INVALID_CHAR extends NodeTypeError {
    constructor(name32, field){
        super("ERR_INVALID_CHAR", field ? `Invalid character in ${name32}` : `Invalid character in ${name32} ["${field}"]`);
    }
}
function buildReturnPropertyType(value) {
    if (value && value.constructor && value.constructor.name) {
        return `instance of ${value.constructor.name}`;
    } else {
        return `type ${typeof value}`;
    }
}
class ERR_INVALID_RETURN_VALUE extends NodeTypeError {
    constructor(input, name33, value){
        super("ERR_INVALID_RETURN_VALUE", `Expected ${input} to be returned from the "${name33}" function but got ${buildReturnPropertyType(value)}.`);
    }
}
class ERR_INVALID_URL_SCHEME extends NodeTypeError {
    constructor(expected){
        expected = Array.isArray(expected) ? expected : [
            expected
        ];
        const res = expected.length === 2 ? `one of scheme ${expected[0]} or ${expected[1]}` : `of scheme ${expected[0]}`;
        super("ERR_INVALID_URL_SCHEME", `The URL must be ${res}`);
    }
}
class ERR_MODULE_NOT_FOUND extends NodeError {
    constructor(path5, base8, type13 = "package"){
        super("ERR_MODULE_NOT_FOUND", `Cannot find ${type13} '${path5}' imported from ${base8}`);
    }
}
class ERR_INVALID_PACKAGE_CONFIG extends NodeError {
    constructor(path6, base9, message){
        const msg = `Invalid package config ${path6}${base9 ? ` while importing ${base9}` : ""}${message ? `. ${message}` : ""}`;
        super("ERR_INVALID_PACKAGE_CONFIG", msg);
    }
}
class ERR_INVALID_MODULE_SPECIFIER extends NodeTypeError {
    constructor(request2, reason, base10){
        super("ERR_INVALID_MODULE_SPECIFIER", `Invalid module "${request2}" ${reason}${base10 ? ` imported from ${base10}` : ""}`);
    }
}
class ERR_INVALID_PACKAGE_TARGET extends NodeError {
    constructor(pkgPath, key, target, isImport, base11){
        let msg;
        const relError = typeof target === "string" && !isImport && target.length && !target.startsWith("./");
        if (key === ".") {
            assert1(isImport === false);
            msg = `Invalid "exports" main target ${JSON.stringify(target)} defined ` + `in the package config ${pkgPath}package.json${base11 ? ` imported from ${base11}` : ""}${relError ? '; targets must start with "./"' : ""}`;
        } else {
            msg = `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(target)} defined for '${key}' in the package config ${pkgPath}package.json${base11 ? ` imported from ${base11}` : ""}${relError ? '; targets must start with "./"' : ""}`;
        }
        super("ERR_INVALID_PACKAGE_TARGET", msg);
    }
}
class ERR_PACKAGE_IMPORT_NOT_DEFINED extends NodeTypeError {
    constructor(specifier, packagePath, base12){
        const msg = `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base12}`;
        super("ERR_PACKAGE_IMPORT_NOT_DEFINED", msg);
    }
}
class ERR_PACKAGE_PATH_NOT_EXPORTED extends NodeError {
    constructor(subpath, pkgPath, basePath){
        let msg;
        if (subpath === ".") {
            msg = `No "exports" main defined in ${pkgPath}package.json${basePath ? ` imported from ${basePath}` : ""}`;
        } else {
            msg = `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${basePath ? ` imported from ${basePath}` : ""}`;
        }
        super("ERR_PACKAGE_PATH_NOT_EXPORTED", msg);
    }
}
class ERR_INTERNAL_ASSERTION extends NodeError {
    constructor(message){
        const suffix = "This is caused by either a bug in Node.js " + "or incorrect usage of Node.js internals.\n" + "Please open an issue with this stack trace at " + "https://github.com/nodejs/node/issues\n";
        super("ERR_INTERNAL_ASSERTION", message === undefined ? suffix : `${message}\n${suffix}`);
    }
}
class ERR_FS_RMDIR_ENOTDIR extends NodeSystemError {
    constructor(path7){
        const code20 = isWindows ? "ENOENT" : "ENOTDIR";
        const ctx = {
            message: "not a directory",
            path: path7,
            syscall: "rmdir",
            code: code20,
            errno: isWindows ? ENOENT : ENOTDIR
        };
        super(code20, ctx, "Path is not a directory");
    }
}
function denoErrorToNodeError(e12, ctx) {
    const errno = extractOsErrorNumberFromErrorMessage(e12);
    if (typeof errno === "undefined") {
        return e12;
    }
    const ex = uvException({
        errno: mapSysErrnoToUvErrno(errno),
        ...ctx
    });
    return ex;
}
function extractOsErrorNumberFromErrorMessage(e13) {
    const match1 = e13 instanceof Error ? e13.message.match(/\(os error (\d+)\)/) : false;
    if (match1) {
        return +match1[1];
    }
    return undefined;
}
function connResetException(msg) {
    const ex = new Error(msg);
    ex.code = "ECONNRESET";
    return ex;
}
function aggregateTwoErrors(innerError, outerError) {
    if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
            outerError.errors.push(innerError);
            return outerError;
        }
        const err18 = new AggregateError([
            outerError,
            innerError, 
        ], outerError.message);
        err18.code = outerError.code;
        return err18;
    }
    return innerError || outerError;
}
codes.ERR_IPC_CHANNEL_CLOSED = ERR_IPC_CHANNEL_CLOSED;
codes.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE;
codes.ERR_INVALID_ARG_VALUE = ERR_INVALID_ARG_VALUE;
codes.ERR_INVALID_CALLBACK = ERR_INVALID_CALLBACK;
codes.ERR_OUT_OF_RANGE = ERR_OUT_OF_RANGE;
codes.ERR_SOCKET_BAD_PORT = ERR_SOCKET_BAD_PORT;
codes.ERR_BUFFER_OUT_OF_BOUNDS = ERR_BUFFER_OUT_OF_BOUNDS;
codes.ERR_UNKNOWN_ENCODING = ERR_UNKNOWN_ENCODING;
const __default8 = {
    AbortError,
    aggregateTwoErrors,
    codes
};
"use strict";
const kRejection = Symbol.for("nodejs.rejection");
const kCapture = Symbol("kCapture");
const kErrorMonitor = Symbol("events.errorMonitor");
const kMaxEventTargetListeners = Symbol("events.maxEventTargetListeners");
const kMaxEventTargetListenersWarned = Symbol("events.maxEventTargetListenersWarned");
function EventEmitter(opts) {
    EventEmitter.init.call(this, opts);
}
EventEmitter.on = on;
EventEmitter.once = once1;
EventEmitter.getEventListeners = getEventListeners;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.captureRejectionSymbol = kRejection;
EventEmitter.captureRejectionSymbol;
EventEmitter.errorMonitor;
Object.defineProperty(EventEmitter, "captureRejections", {
    get () {
        return EventEmitter.prototype[kCapture];
    },
    set (value) {
        validateBoolean(value, "EventEmitter.captureRejections");
        EventEmitter.prototype[kCapture] = value;
    },
    enumerable: true
});
EventEmitter.errorMonitor = kErrorMonitor;
Object.defineProperty(EventEmitter.prototype, kCapture, {
    value: false,
    writable: true,
    enumerable: false
});
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
let defaultMaxListeners = 10;
let isEventTarget;
function checkListener(listener) {
    validateFunction(listener, "listener");
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
        return defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || Number.isNaN(arg)) {
            throw new ERR_OUT_OF_RANGE("defaultMaxListeners", "a non-negative number", arg);
        }
        defaultMaxListeners = arg;
    }
});
Object.defineProperties(EventEmitter, {
    kMaxEventTargetListeners: {
        value: kMaxEventTargetListeners,
        enumerable: false,
        configurable: false,
        writable: false
    },
    kMaxEventTargetListenersWarned: {
        value: kMaxEventTargetListenersWarned,
        enumerable: false,
        configurable: false,
        writable: false
    }
});
EventEmitter.setMaxListeners = function(n13 = defaultMaxListeners, ...eventTargets) {
    if (typeof n13 !== "number" || n13 < 0 || Number.isNaN(n13)) {
        throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n13);
    }
    if (eventTargets.length === 0) {
        defaultMaxListeners = n13;
    } else {
        if (isEventTarget === undefined) {
            isEventTarget = require("internal/event_target").isEventTarget;
        }
        for(let i62 = 0; i62 < eventTargets.length; i62++){
            const target = eventTargets[i62];
            if (isEventTarget(target)) {
                target[kMaxEventTargetListeners] = n13;
                target[kMaxEventTargetListenersWarned] = false;
            } else if (typeof target.setMaxListeners === "function") {
                target.setMaxListeners(n13);
            } else {
                throw new ERR_INVALID_ARG_TYPE("eventTargets", [
                    "EventEmitter",
                    "EventTarget"
                ], target);
            }
        }
    }
};
EventEmitter.init = function(opts) {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
    if (opts?.captureRejections) {
        validateBoolean(opts.captureRejections, "options.captureRejections");
        this[kCapture] = Boolean(opts.captureRejections);
    } else {
        this[kCapture] = EventEmitter.prototype[kCapture];
    }
};
function addCatch(that, promise, type14, args) {
    if (!that[kCapture]) {
        return;
    }
    try {
        const then = promise.then;
        if (typeof then === "function") {
            then.call(promise, undefined, function(err19) {
                process.nextTick(emitUnhandledRejectionOrErr, that, err19, type14, args);
            });
        }
    } catch (err20) {
        that.emit("error", err20);
    }
}
function emitUnhandledRejectionOrErr(ee, err21, type15, args) {
    if (typeof ee[kRejection] === "function") {
        ee[kRejection](err21, type15, ...args);
    } else {
        const prev = ee[kCapture];
        try {
            ee[kCapture] = false;
            ee.emit("error", err21);
        } finally{
            ee[kCapture] = prev;
        }
    }
}
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n14) {
    if (typeof n14 !== "number" || n14 < 0 || Number.isNaN(n14)) {
        throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n14);
    }
    this._maxListeners = n14;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined) {
        return EventEmitter.defaultMaxListeners;
    }
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type16, ...args) {
    let doError = type16 === "error";
    const events = this._events;
    if (events !== undefined) {
        if (doError && events[kErrorMonitor] !== undefined) {
            this.emit(kErrorMonitor, ...args);
        }
        doError = doError && events.error === undefined;
    } else if (!doError) {
        return false;
    }
    if (doError) {
        let er;
        if (args.length > 0) {
            er = args[0];
        }
        if (er instanceof Error) {
            try {
                const capture = {};
                Error.captureStackTrace(capture, EventEmitter.prototype.emit);
            } catch  {}
            throw er;
        }
        let stringifiedEr;
        try {
            stringifiedEr = inspect(er);
        } catch  {
            stringifiedEr = er;
        }
        const err22 = new ERR_UNHANDLED_ERROR(stringifiedEr);
        err22.context = er;
        throw err22;
    }
    const handler = events[type16];
    if (handler === undefined) {
        return false;
    }
    if (typeof handler === "function") {
        const result = handler.apply(this, args);
        if (result !== undefined && result !== null) {
            addCatch(this, result, type16, args);
        }
    } else {
        const len = handler.length;
        const listeners = arrayClone(handler);
        for(let i63 = 0; i63 < len; ++i63){
            const result = listeners[i63].apply(this, args);
            if (result !== undefined && result !== null) {
                addCatch(this, result, type16, args);
            }
        }
    }
    return true;
};
function _addListener(target, type17, listener, prepend) {
    let m6;
    let events;
    let existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        if (events.newListener !== undefined) {
            target.emit("newListener", type17, listener.listener ?? listener);
            events = target._events;
        }
        existing = events[type17];
    }
    if (existing === undefined) {
        events[type17] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === "function") {
            existing = events[type17] = prepend ? [
                listener,
                existing
            ] : [
                existing,
                listener
            ];
        } else if (prepend) {
            existing.unshift(listener);
        } else {
            existing.push(listener);
        }
        m6 = _getMaxListeners(target);
        if (m6 > 0 && existing.length > m6 && !existing.warned) {
            existing.warned = true;
            const w5 = new Error("Possible EventEmitter memory leak detected. " + `${existing.length} ${String(type17)} listeners ` + `added to ${inspect(target, {
                depth: -1
            })}. Use ` + "emitter.setMaxListeners() to increase limit");
            w5.name = "MaxListenersExceededWarning";
            w5.emitter = target;
            w5.type = type17;
            w5.count = existing.length;
            process.emitWarning(w5);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type18, listener) {
    return _addListener(this, type18, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type19, listener) {
    return _addListener(this, type19, listener, true);
};
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) {
            return this.listener.call(this.target);
        }
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type20, listener) {
    const state5 = {
        fired: false,
        wrapFn: undefined,
        target,
        type: type20,
        listener
    };
    const wrapped = onceWrapper.bind(state5);
    wrapped.listener = listener;
    state5.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type21, listener) {
    checkListener(listener);
    this.on(type21, _onceWrap(this, type21, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type22, listener) {
    checkListener(listener);
    this.prependListener(type22, _onceWrap(this, type22, listener));
    return this;
};
EventEmitter.prototype.removeListener = function removeListener(type23, listener) {
    checkListener(listener);
    const events = this._events;
    if (events === undefined) {
        return this;
    }
    const list = events[type23];
    if (list === undefined) {
        return this;
    }
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) {
            this._events = Object.create(null);
        } else {
            delete events[type23];
            if (events.removeListener) {
                this.emit("removeListener", type23, list.listener || listener);
            }
        }
    } else if (typeof list !== "function") {
        let position = -1;
        for(let i64 = list.length - 1; i64 >= 0; i64--){
            if (list[i64] === listener || list[i64].listener === listener) {
                position = i64;
                break;
            }
        }
        if (position < 0) {
            return this;
        }
        if (position === 0) {
            list.shift();
        } else {
            spliceOne(list, position);
        }
        if (list.length === 1) {
            events[type23] = list[0];
        }
        if (events.removeListener !== undefined) {
            this.emit("removeListener", type23, listener);
        }
    }
    return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type24) {
    const events = this._events;
    if (events === undefined) {
        return this;
    }
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type24] !== undefined) {
            if (--this._eventsCount === 0) {
                this._events = Object.create(null);
            } else {
                delete events[type24];
            }
        }
        return this;
    }
    if (arguments.length === 0) {
        for (const key of Reflect.ownKeys(events)){
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    const listeners = events[type24];
    if (typeof listeners === "function") {
        this.removeListener(type24, listeners);
    } else if (listeners !== undefined) {
        for(let i65 = listeners.length - 1; i65 >= 0; i65--){
            this.removeListener(type24, listeners[i65]);
        }
    }
    return this;
};
function _listeners(target, type25, unwrap) {
    const events = target._events;
    if (events === undefined) {
        return [];
    }
    const evlistener = events[type25];
    if (evlistener === undefined) {
        return [];
    }
    if (typeof evlistener === "function") {
        return unwrap ? [
            evlistener.listener || evlistener
        ] : [
            evlistener
        ];
    }
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener);
}
EventEmitter.prototype.listeners = function listeners(type26) {
    return _listeners(this, type26, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type27) {
    return _listeners(this, type27, false);
};
EventEmitter.listenerCount = function(emitter, type28) {
    if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type28);
    }
    return listenerCount.call(emitter, type28);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type29) {
    const events = this._events;
    if (events !== undefined) {
        const evlistener = events[type29];
        if (typeof evlistener === "function") {
            return 1;
        } else if (evlistener !== undefined) {
            return evlistener.length;
        }
    }
    return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function arrayClone(arr) {
    switch(arr.length){
        case 2:
            return [
                arr[0],
                arr[1]
            ];
        case 3:
            return [
                arr[0],
                arr[1],
                arr[2]
            ];
        case 4:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3]
            ];
        case 5:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3],
                arr[4]
            ];
        case 6:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3],
                arr[4],
                arr[5]
            ];
    }
    return arr.slice();
}
function unwrapListeners(arr) {
    const ret = arrayClone(arr);
    for(let i66 = 0; i66 < ret.length; ++i66){
        const orig = ret[i66].listener;
        if (typeof orig === "function") {
            ret[i66] = orig;
        }
    }
    return ret;
}
function getEventListeners(emitterOrTarget, type30) {
    if (typeof emitterOrTarget.listeners === "function") {
        return emitterOrTarget.listeners(type30);
    }
    const { isEventTarget: isEventTarget1 , kEvents  } = require("internal/event_target");
    if (isEventTarget1(emitterOrTarget)) {
        const root = emitterOrTarget[kEvents].get(type30);
        const listeners = [];
        let handler = root?.next;
        while(handler?.listener !== undefined){
            const listener = handler.listener?.deref ? handler.listener.deref() : handler.listener;
            listeners.push(listener);
            handler = handler.next;
        }
        return listeners;
    }
    throw new ERR_INVALID_ARG_TYPE("emitter", [
        "EventEmitter",
        "EventTarget"
    ], emitterOrTarget);
}
async function once1(emitter, name34, options = {}) {
    const signal = options?.signal;
    validateAbortSignal(signal, "options.signal");
    if (signal?.aborted) {
        throw new AbortError();
    }
    return new Promise((resolve11, reject)=>{
        const errorListener = (err23)=>{
            emitter.removeListener(name34, resolver);
            if (signal != null) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
            }
            reject(err23);
        };
        const resolver = (...args)=>{
            if (typeof emitter.removeListener === "function") {
                emitter.removeListener("error", errorListener);
            }
            if (signal != null) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
            }
            resolve11(args);
        };
        eventTargetAgnosticAddListener(emitter, name34, resolver, {
            once: true
        });
        if (name34 !== "error" && typeof emitter.once === "function") {
            emitter.once("error", errorListener);
        }
        function abortListener() {
            eventTargetAgnosticRemoveListener(emitter, name34, resolver);
            eventTargetAgnosticRemoveListener(emitter, "error", errorListener);
            reject(new AbortError());
        }
        if (signal != null) {
            eventTargetAgnosticAddListener(signal, "abort", abortListener, {
                once: true
            });
        }
    });
}
const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype);
function createIterResult(value, done) {
    return {
        value,
        done
    };
}
function eventTargetAgnosticRemoveListener(emitter, name35, listener, flags) {
    if (typeof emitter.removeListener === "function") {
        emitter.removeListener(name35, listener);
    } else if (typeof emitter.removeEventListener === "function") {
        emitter.removeEventListener(name35, listener, flags);
    } else {
        throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
    }
}
function eventTargetAgnosticAddListener(emitter, name36, listener, flags) {
    if (typeof emitter.on === "function") {
        if (flags?.once) {
            emitter.once(name36, listener);
        } else {
            emitter.on(name36, listener);
        }
    } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name36, (arg)=>{
            listener(arg);
        }, flags);
    } else {
        throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
    }
}
function on(emitter, event, options) {
    const signal = options?.signal;
    validateAbortSignal(signal, "options.signal");
    if (signal?.aborted) {
        throw new AbortError();
    }
    const unconsumedEvents = [];
    const unconsumedPromises = [];
    let error4 = null;
    let finished1 = false;
    const iterator = Object.setPrototypeOf({
        next () {
            const value = unconsumedEvents.shift();
            if (value) {
                return Promise.resolve(createIterResult(value, false));
            }
            if (error4) {
                const p7 = Promise.reject(error4);
                error4 = null;
                return p7;
            }
            if (finished1) {
                return Promise.resolve(createIterResult(undefined, true));
            }
            return new Promise(function(resolve12, reject) {
                unconsumedPromises.push({
                    resolve: resolve12,
                    reject
                });
            });
        },
        return () {
            eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
            eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
            if (signal) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener, {
                    once: true
                });
            }
            finished1 = true;
            for (const promise of unconsumedPromises){
                promise.resolve(createIterResult(undefined, true));
            }
            return Promise.resolve(createIterResult(undefined, true));
        },
        throw (err24) {
            if (!err24 || !(err24 instanceof Error)) {
                throw new ERR_INVALID_ARG_TYPE("EventEmitter.AsyncIterator", "Error", err24);
            }
            error4 = err24;
            eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
            eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
        },
        [Symbol.asyncIterator] () {
            return this;
        }
    }, AsyncIteratorPrototype);
    eventTargetAgnosticAddListener(emitter, event, eventHandler);
    if (event !== "error" && typeof emitter.on === "function") {
        emitter.on("error", errorHandler);
    }
    if (signal) {
        eventTargetAgnosticAddListener(signal, "abort", abortListener, {
            once: true
        });
    }
    return iterator;
    function abortListener() {
        errorHandler(new AbortError());
    }
    function eventHandler(...args) {
        const promise = unconsumedPromises.shift();
        if (promise) {
            promise.resolve(createIterResult(args, false));
        } else {
            unconsumedEvents.push(args);
        }
    }
    function errorHandler(err25) {
        finished1 = true;
        const toError = unconsumedPromises.shift();
        if (toError) {
            toError.reject(err25);
        } else {
            error4 = err25;
        }
        iterator.return();
    }
}
const { hasOwn  } = Object;
function get(obj, key) {
    if (hasOwn(obj, key)) {
        return obj[key];
    }
}
function getForce(obj, key) {
    const v6 = get(obj, key);
    assert1(v6 != null);
    return v6;
}
function isNumber1(x24) {
    if (typeof x24 === "number") return true;
    if (/^0x[0-9a-f]+$/i.test(String(x24))) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(String(x24));
}
function hasKey(obj, keys) {
    let o1 = obj;
    keys.slice(0, -1).forEach((key)=>{
        o1 = get(o1, key) ?? {};
    });
    const key1 = keys[keys.length - 1];
    return key1 in o1;
}
function parse(args, { "--": doubleDash = false , alias: alias3 = {} , boolean: __boolean = false , default: defaults = {} , stopEarly =false , string =[] , unknown =(i67)=>i67
  } = {}) {
    const flags = {
        bools: {},
        strings: {},
        unknownFn: unknown,
        allBools: false
    };
    if (__boolean !== undefined) {
        if (typeof __boolean === "boolean") {
            flags.allBools = !!__boolean;
        } else {
            const booleanArgs = typeof __boolean === "string" ? [
                __boolean
            ] : __boolean;
            for (const key of booleanArgs.filter(Boolean)){
                flags.bools[key] = true;
            }
        }
    }
    const aliases = {};
    if (alias3 !== undefined) {
        for(const key in alias3){
            const val = getForce(alias3, key);
            if (typeof val === "string") {
                aliases[key] = [
                    val
                ];
            } else {
                aliases[key] = val;
            }
            for (const alias1 of getForce(aliases, key)){
                aliases[alias1] = [
                    key
                ].concat(aliases[key].filter((y7)=>alias1 !== y7
                ));
            }
        }
    }
    if (string !== undefined) {
        const stringArgs = typeof string === "string" ? [
            string
        ] : string;
        for (const key of stringArgs.filter(Boolean)){
            flags.strings[key] = true;
            const alias = get(aliases, key);
            if (alias) {
                for (const al of alias){
                    flags.strings[al] = true;
                }
            }
        }
    }
    const argv1 = {
        _: []
    };
    function argDefined(key, arg) {
        return flags.allBools && /^--[^=]+$/.test(arg) || get(flags.bools, key) || !!get(flags.strings, key) || !!get(aliases, key);
    }
    function setKey(obj, keys, value) {
        let o2 = obj;
        keys.slice(0, -1).forEach(function(key) {
            if (get(o2, key) === undefined) {
                o2[key] = {};
            }
            o2 = get(o2, key);
        });
        const key4 = keys[keys.length - 1];
        if (get(o2, key4) === undefined || get(flags.bools, key4) || typeof get(o2, key4) === "boolean") {
            o2[key4] = value;
        } else if (Array.isArray(get(o2, key4))) {
            o2[key4].push(value);
        } else {
            o2[key4] = [
                get(o2, key4),
                value
            ];
        }
    }
    function setArg(key, val, arg = undefined) {
        if (arg && flags.unknownFn && !argDefined(key, arg)) {
            if (flags.unknownFn(arg, key, val) === false) return;
        }
        const value = !get(flags.strings, key) && isNumber1(val) ? Number(val) : val;
        setKey(argv1, key.split("."), value);
        const alias = get(aliases, key);
        if (alias) {
            for (const x25 of alias){
                setKey(argv1, x25.split("."), value);
            }
        }
    }
    function aliasIsBoolean(key) {
        return getForce(aliases, key).some((x26)=>typeof get(flags.bools, x26) === "boolean"
        );
    }
    for (const key3 of Object.keys(flags.bools)){
        setArg(key3, defaults[key3] === undefined ? false : defaults[key3]);
    }
    let notFlags = [];
    if (args.includes("--")) {
        notFlags = args.slice(args.indexOf("--") + 1);
        args = args.slice(0, args.indexOf("--"));
    }
    for(let i68 = 0; i68 < args.length; i68++){
        const arg = args[i68];
        if (/^--.+=/.test(arg)) {
            const m7 = arg.match(/^--([^=]+)=(.*)$/s);
            assert1(m7 != null);
            const [, key, value] = m7;
            if (flags.bools[key]) {
                const booleanValue = value !== "false";
                setArg(key, booleanValue, arg);
            } else {
                setArg(key, value, arg);
            }
        } else if (/^--no-.+/.test(arg)) {
            const m8 = arg.match(/^--no-(.+)/);
            assert1(m8 != null);
            setArg(m8[1], false, arg);
        } else if (/^--.+/.test(arg)) {
            const m9 = arg.match(/^--(.+)/);
            assert1(m9 != null);
            const [, key] = m9;
            const next = args[i68 + 1];
            if (next !== undefined && !/^-/.test(next) && !get(flags.bools, key) && !flags.allBools && (get(aliases, key) ? !aliasIsBoolean(key) : true)) {
                setArg(key, next, arg);
                i68++;
            } else if (/^(true|false)$/.test(next)) {
                setArg(key, next === "true", arg);
                i68++;
            } else {
                setArg(key, get(flags.strings, key) ? "" : true, arg);
            }
        } else if (/^-[^-]+/.test(arg)) {
            const letters = arg.slice(1, -1).split("");
            let broken = false;
            for(let j = 0; j < letters.length; j++){
                const next = arg.slice(j + 2);
                if (next === "-") {
                    setArg(letters[j], next, arg);
                    continue;
                }
                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
                    setArg(letters[j], next.split(/=(.+)/)[1], arg);
                    broken = true;
                    break;
                }
                if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                    setArg(letters[j], next, arg);
                    broken = true;
                    break;
                }
                if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                    setArg(letters[j], arg.slice(j + 2), arg);
                    broken = true;
                    break;
                } else {
                    setArg(letters[j], get(flags.strings, letters[j]) ? "" : true, arg);
                }
            }
            const [key] = arg.slice(-1);
            if (!broken && key !== "-") {
                if (args[i68 + 1] && !/^(-|--)[^-]/.test(args[i68 + 1]) && !get(flags.bools, key) && (get(aliases, key) ? !aliasIsBoolean(key) : true)) {
                    setArg(key, args[i68 + 1], arg);
                    i68++;
                } else if (args[i68 + 1] && /^(true|false)$/.test(args[i68 + 1])) {
                    setArg(key, args[i68 + 1] === "true", arg);
                    i68++;
                } else {
                    setArg(key, get(flags.strings, key) ? "" : true, arg);
                }
            }
        } else {
            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                argv1._.push(flags.strings["_"] ?? !isNumber1(arg) ? arg : Number(arg));
            }
            if (stopEarly) {
                argv1._.push(...args.slice(i68 + 1));
                break;
            }
        }
    }
    for (const key2 of Object.keys(defaults)){
        if (!hasKey(argv1, key2.split("."))) {
            setKey(argv1, key2.split("."), defaults[key2]);
            if (aliases[key2]) {
                for (const x27 of aliases[key2]){
                    setKey(argv1, x27.split("."), defaults[key2]);
                }
            }
        }
    }
    if (doubleDash) {
        argv1["--"] = [];
        for (const key of notFlags){
            argv1["--"].push(key);
        }
    } else {
        for (const key of notFlags){
            argv1._.push(key);
        }
    }
    return argv1;
}
function getOptions() {
    const args = parse(Deno.args);
    const options = new Map(Object.entries(args).map(([key, value])=>[
            key,
            {
                value
            }
        ]
    ));
    return {
        options
    };
}
let optionsMap;
function getOptionsFromBinding() {
    if (!optionsMap) {
        ({ options: optionsMap  } = getOptions());
    }
    return optionsMap;
}
function getOptionValue(optionName) {
    const options = getOptionsFromBinding();
    if (optionName.startsWith("--no-")) {
        const option = options.get("--" + optionName.slice(5));
        return option && !option.value;
    }
    return options.get(optionName)?.value;
}
const CHAR_FORWARD_SLASH = 47;
function assertPath(path8) {
    if (typeof path8 !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path8)}`);
    }
}
function isPosixPathSeparator(code21) {
    return code21 === 47;
}
function isPathSeparator(code22) {
    return isPosixPathSeparator(code22) || code22 === 92;
}
function isWindowsDeviceRoot(code23) {
    return code23 >= 97 && code23 <= 122 || code23 >= 65 && code23 <= 90;
}
function normalizeString(path9, allowAboveRoot, separator, isPathSeparator1) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code24;
    for(let i69 = 0, len = path9.length; i69 <= len; ++i69){
        if (i69 < len) code24 = path9.charCodeAt(i69);
        else if (isPathSeparator1(code24)) break;
        else code24 = CHAR_FORWARD_SLASH;
        if (isPathSeparator1(code24)) {
            if (lastSlash === i69 - 1 || dots === 1) {} else if (lastSlash !== i69 - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i69;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i69;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path9.slice(lastSlash + 1, i69);
                else res = path9.slice(lastSlash + 1, i69);
                lastSegmentLength = i69 - lastSlash - 1;
            }
            lastSlash = i69;
            dots = 0;
        } else if (code24 === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format1(sep6, pathObject) {
    const dir10 = pathObject.dir || pathObject.root;
    const base13 = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir10) return base13;
    if (dir10 === pathObject.root) return dir10 + base13;
    return dir10 + sep6 + base13;
}
const WHITESPACE_ENCODINGS = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace(string) {
    return string.replaceAll(/[\s]/g, (c13)=>{
        return WHITESPACE_ENCODINGS[c13] ?? c13;
    });
}
const sep = "\\";
const delimiter = ";";
function resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i70 = pathSegments.length - 1; i70 >= -1; i70--){
        let path10;
        const { Deno  } = globalThis;
        if (i70 >= 0) {
            path10 = pathSegments[i70];
        } else if (!resolvedDevice) {
            if (typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path10 = Deno.cwd();
        } else {
            if (typeof Deno?.env?.get !== "function" || typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path10 = Deno.cwd();
            if (path10 === undefined || path10.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path10 = `${resolvedDevice}\\`;
            }
        }
        assertPath(path10);
        const len = path10.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute1 = false;
        const code25 = path10.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator(code25)) {
                isAbsolute1 = true;
                if (isPathSeparator(path10.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator(path10.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path10.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator(path10.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator(path10.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path10.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path10.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot(code25)) {
                if (path10.charCodeAt(1) === 58) {
                    device = path10.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator(path10.charCodeAt(2))) {
                            isAbsolute1 = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator(code25)) {
            rootEnd = 1;
            isAbsolute1 = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path10.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute1;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize(path11) {
    assertPath(path11);
    const len = path11.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute2 = false;
    const code26 = path11.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code26)) {
            isAbsolute2 = true;
            if (isPathSeparator(path11.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path11.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path11.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path11.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path11.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path11.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path11.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot(code26)) {
            if (path11.charCodeAt(1) === 58) {
                device = path11.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path11.charCodeAt(2))) {
                        isAbsolute2 = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator(code26)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString(path11.slice(rootEnd), !isAbsolute2, "\\", isPathSeparator);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute2) tail = ".";
    if (tail.length > 0 && isPathSeparator(path11.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute2) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute2) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute(path12) {
    assertPath(path12);
    const len = path12.length;
    if (len === 0) return false;
    const code27 = path12.charCodeAt(0);
    if (isPathSeparator(code27)) {
        return true;
    } else if (isWindowsDeviceRoot(code27)) {
        if (len > 2 && path12.charCodeAt(1) === 58) {
            if (isPathSeparator(path12.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join1(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i71 = 0; i71 < pathsCount; ++i71){
        const path13 = paths[i71];
        assertPath(path13);
        if (path13.length > 0) {
            if (joined === undefined) joined = firstPart = path13;
            else joined += `\\${path13}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert1(firstPart != null);
    if (isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize(joined);
}
function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    const fromOrig = resolve(from);
    const toOrig = resolve(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i72 = 0;
    for(; i72 <= length; ++i72){
        if (i72 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i72) === 92) {
                    return toOrig.slice(toStart + i72 + 1);
                } else if (i72 === 2) {
                    return toOrig.slice(toStart + i72);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i72) === 92) {
                    lastCommonSep = i72;
                } else if (i72 === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i72);
        const toCode = to.charCodeAt(toStart + i72);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i72;
    }
    if (i72 !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i72 = fromStart + lastCommonSep + 1; i72 <= fromEnd; ++i72){
        if (i72 === fromEnd || from.charCodeAt(i72) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath(path14) {
    if (typeof path14 !== "string") return path14;
    if (path14.length === 0) return "";
    const resolvedPath = resolve(path14);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code28 = resolvedPath.charCodeAt(2);
                if (code28 !== 63 && code28 !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path14;
}
function dirname(path15) {
    assertPath(path15);
    const len = path15.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code29 = path15.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code29)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path15.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path15.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path15.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path15.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path15;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code29)) {
            if (path15.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator(path15.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator(code29)) {
        return path15;
    }
    for(let i73 = len - 1; i73 >= offset; --i73){
        if (isPathSeparator(path15.charCodeAt(i73))) {
            if (!matchedSlash) {
                end = i73;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path15.slice(0, end);
}
function basename(path16, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path16);
    let start20 = 0;
    let end = -1;
    let matchedSlash = true;
    let i74;
    if (path16.length >= 2) {
        const drive = path16.charCodeAt(0);
        if (isWindowsDeviceRoot(drive)) {
            if (path16.charCodeAt(1) === 58) start20 = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path16.length) {
        if (ext.length === path16.length && ext === path16) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i74 = path16.length - 1; i74 >= start20; --i74){
            const code30 = path16.charCodeAt(i74);
            if (isPathSeparator(code30)) {
                if (!matchedSlash) {
                    start20 = i74 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i74 + 1;
                }
                if (extIdx >= 0) {
                    if (code30 === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i74;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start20 === end) end = firstNonSlashEnd;
        else if (end === -1) end = path16.length;
        return path16.slice(start20, end);
    } else {
        for(i74 = path16.length - 1; i74 >= start20; --i74){
            if (isPathSeparator(path16.charCodeAt(i74))) {
                if (!matchedSlash) {
                    start20 = i74 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i74 + 1;
            }
        }
        if (end === -1) return "";
        return path16.slice(start20, end);
    }
}
function extname(path17) {
    assertPath(path17);
    let start21 = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path17.length >= 2 && path17.charCodeAt(1) === 58 && isWindowsDeviceRoot(path17.charCodeAt(0))) {
        start21 = startPart = 2;
    }
    for(let i75 = path17.length - 1; i75 >= start21; --i75){
        const code31 = path17.charCodeAt(i75);
        if (isPathSeparator(code31)) {
            if (!matchedSlash) {
                startPart = i75 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i75 + 1;
        }
        if (code31 === 46) {
            if (startDot === -1) startDot = i75;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path17.slice(startDot, end);
}
function format1(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format1("\\", pathObject);
}
function parse1(path18) {
    assertPath(path18);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path18.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code32 = path18.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code32)) {
            rootEnd = 1;
            if (isPathSeparator(path18.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path18.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path18.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path18.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code32)) {
            if (path18.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path18.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path18;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path18;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator(code32)) {
        ret.root = ret.dir = path18;
        return ret;
    }
    if (rootEnd > 0) ret.root = path18.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i76 = path18.length - 1;
    let preDotState = 0;
    for(; i76 >= rootEnd; --i76){
        code32 = path18.charCodeAt(i76);
        if (isPathSeparator(code32)) {
            if (!matchedSlash) {
                startPart = i76 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i76 + 1;
        }
        if (code32 === 46) {
            if (startDot === -1) startDot = i76;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path18.slice(startPart, end);
        }
    } else {
        ret.name = path18.slice(startPart, startDot);
        ret.base = path18.slice(startPart, end);
        ret.ext = path18.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path18.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl(url2) {
    url2 = url2 instanceof URL ? url2 : new URL(url2);
    if (url2.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path19 = decodeURIComponent(url2.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url2.hostname != "") {
        path19 = `\\\\${url2.hostname}${path19}`;
    }
    return path19;
}
function toFileUrl(path20) {
    if (!isAbsolute(path20)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname3, pathname] = path20.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url3 = new URL("file:///");
    url3.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
    if (hostname3 != null && hostname3 != "localhost") {
        url3.hostname = hostname3;
        if (!url3.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url3;
}
const mod7 = {
    sep: sep,
    delimiter: delimiter,
    resolve: resolve,
    normalize: normalize,
    isAbsolute: isAbsolute,
    join: join1,
    relative: relative,
    toNamespacedPath: toNamespacedPath,
    dirname: dirname,
    basename: basename,
    extname: extname,
    format: format1,
    parse: parse1,
    fromFileUrl: fromFileUrl,
    toFileUrl: toFileUrl
};
const sep1 = "/";
const delimiter1 = ":";
function resolve1(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i77 = pathSegments.length - 1; i77 >= -1 && !resolvedAbsolute; i77--){
        let path21;
        if (i77 >= 0) path21 = pathSegments[i77];
        else {
            const { Deno  } = globalThis;
            if (typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path21 = Deno.cwd();
        }
        assertPath(path21);
        if (path21.length === 0) {
            continue;
        }
        resolvedPath = `${path21}/${resolvedPath}`;
        resolvedAbsolute = path21.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize1(path22) {
    assertPath(path22);
    if (path22.length === 0) return ".";
    const isAbsolute1 = path22.charCodeAt(0) === 47;
    const trailingSeparator = path22.charCodeAt(path22.length - 1) === 47;
    path22 = normalizeString(path22, !isAbsolute1, "/", isPosixPathSeparator);
    if (path22.length === 0 && !isAbsolute1) path22 = ".";
    if (path22.length > 0 && trailingSeparator) path22 += "/";
    if (isAbsolute1) return `/${path22}`;
    return path22;
}
function isAbsolute1(path23) {
    assertPath(path23);
    return path23.length > 0 && path23.charCodeAt(0) === 47;
}
function join2(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i78 = 0, len = paths.length; i78 < len; ++i78){
        const path24 = paths[i78];
        assertPath(path24);
        if (path24.length > 0) {
            if (!joined) joined = path24;
            else joined += `/${path24}`;
        }
    }
    if (!joined) return ".";
    return normalize1(joined);
}
function relative1(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    from = resolve1(from);
    to = resolve1(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i79 = 0;
    for(; i79 <= length; ++i79){
        if (i79 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i79) === 47) {
                    return to.slice(toStart + i79 + 1);
                } else if (i79 === 0) {
                    return to.slice(toStart + i79);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i79) === 47) {
                    lastCommonSep = i79;
                } else if (i79 === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i79);
        const toCode = to.charCodeAt(toStart + i79);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i79;
    }
    let out = "";
    for(i79 = fromStart + lastCommonSep + 1; i79 <= fromEnd; ++i79){
        if (i79 === fromEnd || from.charCodeAt(i79) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath1(path25) {
    return path25;
}
function dirname1(path26) {
    assertPath(path26);
    if (path26.length === 0) return ".";
    const hasRoot = path26.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i80 = path26.length - 1; i80 >= 1; --i80){
        if (path26.charCodeAt(i80) === 47) {
            if (!matchedSlash) {
                end = i80;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path26.slice(0, end);
}
function basename1(path27, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path27);
    let start22 = 0;
    let end = -1;
    let matchedSlash = true;
    let i81;
    if (ext !== undefined && ext.length > 0 && ext.length <= path27.length) {
        if (ext.length === path27.length && ext === path27) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i81 = path27.length - 1; i81 >= 0; --i81){
            const code33 = path27.charCodeAt(i81);
            if (code33 === 47) {
                if (!matchedSlash) {
                    start22 = i81 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i81 + 1;
                }
                if (extIdx >= 0) {
                    if (code33 === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i81;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start22 === end) end = firstNonSlashEnd;
        else if (end === -1) end = path27.length;
        return path27.slice(start22, end);
    } else {
        for(i81 = path27.length - 1; i81 >= 0; --i81){
            if (path27.charCodeAt(i81) === 47) {
                if (!matchedSlash) {
                    start22 = i81 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i81 + 1;
            }
        }
        if (end === -1) return "";
        return path27.slice(start22, end);
    }
}
function extname1(path28) {
    assertPath(path28);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i82 = path28.length - 1; i82 >= 0; --i82){
        const code34 = path28.charCodeAt(i82);
        if (code34 === 47) {
            if (!matchedSlash) {
                startPart = i82 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i82 + 1;
        }
        if (code34 === 46) {
            if (startDot === -1) startDot = i82;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path28.slice(startDot, end);
}
function format2(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format1("/", pathObject);
}
function parse2(path29) {
    assertPath(path29);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path29.length === 0) return ret;
    const isAbsolute2 = path29.charCodeAt(0) === 47;
    let start23;
    if (isAbsolute2) {
        ret.root = "/";
        start23 = 1;
    } else {
        start23 = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i83 = path29.length - 1;
    let preDotState = 0;
    for(; i83 >= start23; --i83){
        const code35 = path29.charCodeAt(i83);
        if (code35 === 47) {
            if (!matchedSlash) {
                startPart = i83 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i83 + 1;
        }
        if (code35 === 46) {
            if (startDot === -1) startDot = i83;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute2) {
                ret.base = ret.name = path29.slice(1, end);
            } else {
                ret.base = ret.name = path29.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute2) {
            ret.name = path29.slice(1, startDot);
            ret.base = path29.slice(1, end);
        } else {
            ret.name = path29.slice(startPart, startDot);
            ret.base = path29.slice(startPart, end);
        }
        ret.ext = path29.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path29.slice(0, startPart - 1);
    else if (isAbsolute2) ret.dir = "/";
    return ret;
}
function fromFileUrl1(url4) {
    url4 = url4 instanceof URL ? url4 : new URL(url4);
    if (url4.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url4.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl1(path30) {
    if (!isAbsolute1(path30)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url5 = new URL("file:///");
    url5.pathname = encodeWhitespace(path30.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url5;
}
const mod8 = {
    sep: sep1,
    delimiter: delimiter1,
    resolve: resolve1,
    normalize: normalize1,
    isAbsolute: isAbsolute1,
    join: join2,
    relative: relative1,
    toNamespacedPath: toNamespacedPath1,
    dirname: dirname1,
    basename: basename1,
    extname: extname1,
    format: format2,
    parse: parse2,
    fromFileUrl: fromFileUrl1,
    toFileUrl: toFileUrl1
};
const path = isWindows ? mod7 : mod8;
const { join: join3 , normalize: normalize2  } = path;
const path1 = isWindows ? mod7 : mod8;
const { basename: basename2 , delimiter: delimiter2 , dirname: dirname2 , extname: extname2 , format: format3 , fromFileUrl: fromFileUrl2 , isAbsolute: isAbsolute2 , join: join4 , normalize: normalize3 , parse: parse3 , relative: relative2 , resolve: resolve2 , sep: sep2 , toFileUrl: toFileUrl2 , toNamespacedPath: toNamespacedPath2 ,  } = path1;
function _arch() {
    if (Deno.build.arch == "x86_64") {
        return "x64";
    } else if (Deno.build.arch == "aarch64") {
        return "arm64";
    } else {
        throw Error("unreachable");
    }
}
const arch = _arch();
const chdir = Deno.chdir;
const cwd = Deno.cwd;
const nextTick1 = nextTick2;
const env = new Proxy({}, {
    get (_target, prop) {
        return Deno.env.get(String(prop));
    },
    ownKeys: ()=>Reflect.ownKeys(Deno.env.toObject())
    ,
    getOwnPropertyDescriptor: (_target, name37)=>{
        const e14 = Deno.env.toObject();
        if (name37 in Deno.env.toObject()) {
            const o3 = {
                enumerable: true,
                configurable: true
            };
            if (typeof name37 === "string") {
                o3.value = e14[name37];
            }
            return o3;
        }
    },
    set (_target, prop, value) {
        Deno.env.set(String(prop), String(value));
        return value;
    }
});
const pid = Deno.pid;
const platform = isWindows ? "win32" : Deno.build.os;
const version = "v16.11.1";
const versions = {
    node: "16.11.1",
    uv: "1.42.0",
    zlib: "1.2.11",
    brotli: "1.0.9",
    ares: "1.17.2",
    modules: "93",
    nghttp2: "1.45.1",
    napi: "8",
    llhttp: "6.0.4",
    openssl: "1.1.1l",
    cldr: "39.0",
    icu: "69.1",
    tz: "2021a",
    unicode: "13.0",
    ...Deno.version
};
function hrtime(time1) {
    const milli = performance.now();
    const sec = Math.floor(milli / 1000);
    const nano = Math.floor(milli * 1000000 - sec * 1000000000);
    if (!time1) {
        return [
            sec,
            nano
        ];
    }
    const [prevSec, prevNano] = time1;
    return [
        sec - prevSec,
        nano - prevNano
    ];
}
hrtime.bigint = function() {
    const [sec, nano] = hrtime();
    return BigInt(sec) * 1000000000n + BigInt(nano);
};
function memoryUsage() {
    return {
        ...Deno.memoryUsage(),
        arrayBuffers: 0
    };
}
memoryUsage.rss = function() {
    return memoryUsage().rss;
};
function _uint8ArrayToBuffer(chunk) {
    return Buffer1.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function isServerResponse(stream) {
    return typeof stream._sent100 === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean" && typeof stream._removedTE === "boolean" && typeof stream._closed === "boolean";
}
function isReadable(stream) {
    return typeof stream.readable === "boolean" || typeof stream.readableEnded === "boolean" || !!stream._readableState;
}
function isWritable(stream) {
    return typeof stream.writable === "boolean" || typeof stream.writableEnded === "boolean" || !!stream._writableState;
}
function isWritableFinished(stream) {
    if (stream.writableFinished) return true;
    const wState = stream._writableState;
    if (!wState || wState.errored) return false;
    return wState.finished || wState.ended && wState.length === 0;
}
const nop = ()=>{};
function isReadableEnded(stream) {
    if (stream.readableEnded) return true;
    const rState = stream._readableState;
    if (!rState || rState.errored) return false;
    return rState.endEmitted || rState.ended && rState.length === 0;
}
function eos(stream, options, callback) {
    if (arguments.length === 2) {
        callback = options;
        options = {};
    } else if (options == null) {
        options = {};
    } else {
        validateObject(options, "options");
    }
    validateFunction(callback, "callback");
    validateAbortSignal(options.signal, "options.signal");
    callback = once(callback);
    const readable = options.readable || options.readable !== false && isReadable(stream);
    const writable = options.writable || options.writable !== false && isWritable(stream);
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state6 = wState || rState;
    const onlegacyfinish = ()=>{
        if (!stream.writable) onfinish();
    };
    let willEmitClose = isServerResponse(stream) || state6 && state6.autoDestroy && state6.emitClose && state6.closed === false && isReadable(stream) === readable && isWritable(stream) === writable;
    let writableFinished = stream.writableFinished || wState && wState.finished;
    const onfinish = ()=>{
        writableFinished = true;
        if (stream.destroyed) willEmitClose = false;
        if (willEmitClose && (!stream.readable || readable)) return;
        if (!readable || readableEnded) callback.call(stream);
    };
    let readableEnded = stream.readableEnded || rState && rState.endEmitted;
    const onend = ()=>{
        readableEnded = true;
        if (stream.destroyed) willEmitClose = false;
        if (willEmitClose && (!stream.writable || writable)) return;
        if (!writable || writableFinished) callback.call(stream);
    };
    const onerror = (err26)=>{
        callback.call(stream, err26);
    };
    const onclose = ()=>{
        if (readable && !readableEnded) {
            if (!isReadableEnded(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
            }
        }
        if (writable && !writableFinished) {
            if (!isWritableFinished(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
            }
        }
        callback.call(stream);
    };
    const onrequest = ()=>{
        stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
            stream.on("abort", onclose);
        }
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
    } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
    }
    if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (options.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    const closed = !wState && !rState && stream._closed === true || wState && wState.closed || rState && rState.closed || wState && wState.errorEmitted || rState && rState.errorEmitted || rState && stream.req && stream.aborted || (!wState || !willEmitClose || typeof wState.closed !== "boolean") && (!rState || !willEmitClose || typeof rState.closed !== "boolean") && (!writable || wState && wState.finished) && (!readable || rState && rState.endEmitted);
    if (closed) {
        nextTick2(()=>{
            callback();
        });
    }
    const cleanup = ()=>{
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
    };
    if (options.signal && !closed) {
        const abort = ()=>{
            const endCallback = callback;
            cleanup();
            endCallback.call(stream, new AbortError());
        };
        if (options.signal.aborted) {
            nextTick2(abort);
        } else {
            const originalCallback = callback;
            callback = once((...args)=>{
                options.signal.removeEventListener("abort", abort);
                originalCallback.apply(stream, args);
            });
            options.signal.addEventListener("abort", abort);
        }
    }
    return cleanup;
}
const validateAbortSignal1 = (signal, name38)=>{
    if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE(name38, "AbortSignal", signal);
    }
};
function isStream(obj) {
    return !!(obj && typeof obj.pipe === "function");
}
function addAbortSignal(signal, stream) {
    validateAbortSignal1(signal, "signal");
    if (!isStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", "stream.Stream", stream);
    }
    return addAbortSignalNoValidate(signal, stream);
}
function addAbortSignalNoValidate(signal, stream) {
    if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
    }
    const onAbort = ()=>{
        stream.destroy(new AbortError());
    };
    if (signal.aborted) {
        onAbort();
    } else {
        signal.addEventListener("abort", onAbort);
        eos(stream, ()=>signal.removeEventListener("abort", onAbort)
        );
    }
    return stream;
}
const __default9 = {
    addAbortSignal,
    addAbortSignalNoValidate
};
const kDestroy = Symbol("kDestroy");
const kConstruct = Symbol("kConstruct");
function checkError(err27, w6, r5) {
    if (err27) {
        err27.stack;
        if (w6 && !w6.errored) {
            w6.errored = err27;
        }
        if (r5 && !r5.errored) {
            r5.errored = err27;
        }
    }
}
function destroy(err28, cb) {
    const r6 = this._readableState;
    const w7 = this._writableState;
    const s9 = w7 || r6;
    if (w7 && w7.destroyed || r6 && r6.destroyed) {
        if (typeof cb === "function") {
            cb();
        }
        return this;
    }
    checkError(err28, w7, r6);
    if (w7) {
        w7.destroyed = true;
    }
    if (r6) {
        r6.destroyed = true;
    }
    if (!s9.constructed) {
        this.once(kDestroy, function(er) {
            _destroy(this, aggregateTwoErrors(er, err28), cb);
        });
    } else {
        _destroy(this, err28, cb);
    }
    return this;
}
function _destroy(self, err1, cb) {
    let called = false;
    function onDestroy(err29) {
        if (called) {
            return;
        }
        called = true;
        const r7 = self._readableState;
        const w8 = self._writableState;
        checkError(err29, w8, r7);
        if (w8) {
            w8.closed = true;
        }
        if (r7) {
            r7.closed = true;
        }
        if (typeof cb === "function") {
            cb(err29);
        }
        if (err29) {
            nextTick2(emitErrorCloseNT, self, err29);
        } else {
            nextTick2(emitCloseNT, self);
        }
    }
    try {
        const result = self._destroy(err1 || null, onDestroy);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick2(onDestroy, null);
                }, function(err30) {
                    nextTick2(onDestroy, err30);
                });
            }
        }
    } catch (err31) {
        onDestroy(err31);
    }
}
function emitErrorCloseNT(self, err32) {
    emitErrorNT(self, err32);
    emitCloseNT(self);
}
function emitCloseNT(self) {
    const r8 = self._readableState;
    const w9 = self._writableState;
    if (w9) {
        w9.closeEmitted = true;
    }
    if (r8) {
        r8.closeEmitted = true;
    }
    if (w9 && w9.emitClose || r8 && r8.emitClose) {
        self.emit("close");
    }
}
function emitErrorNT(self, err33) {
    const r9 = self._readableState;
    const w10 = self._writableState;
    if (w10 && w10.errorEmitted || r9 && r9.errorEmitted) {
        return;
    }
    if (w10) {
        w10.errorEmitted = true;
    }
    if (r9) {
        r9.errorEmitted = true;
    }
    self.emit("error", err33);
}
function undestroy() {
    const r10 = this._readableState;
    const w11 = this._writableState;
    if (r10) {
        r10.constructed = true;
        r10.closed = false;
        r10.closeEmitted = false;
        r10.destroyed = false;
        r10.errored = null;
        r10.errorEmitted = false;
        r10.reading = false;
        r10.ended = false;
        r10.endEmitted = false;
    }
    if (w11) {
        w11.constructed = true;
        w11.destroyed = false;
        w11.closed = false;
        w11.closeEmitted = false;
        w11.errored = null;
        w11.errorEmitted = false;
        w11.ended = false;
        w11.ending = false;
        w11.finalCalled = false;
        w11.prefinished = false;
        w11.finished = false;
    }
}
function errorOrDestroy(stream, err34, sync) {
    const r11 = stream._readableState;
    const w12 = stream._writableState;
    if (w12 && w12.destroyed || r11 && r11.destroyed) {
        return this;
    }
    if (r11 && r11.autoDestroy || w12 && w12.autoDestroy) {
        stream.destroy(err34);
    } else if (err34) {
        err34.stack;
        if (w12 && !w12.errored) {
            w12.errored = err34;
        }
        if (r11 && !r11.errored) {
            r11.errored = err34;
        }
        if (sync) {
            nextTick2(emitErrorNT, stream, err34);
        } else {
            emitErrorNT(stream, err34);
        }
    }
}
function construct(stream, cb) {
    if (typeof stream._construct !== "function") {
        return;
    }
    const r12 = stream._readableState;
    const w13 = stream._writableState;
    if (r12) {
        r12.constructed = false;
    }
    if (w13) {
        w13.constructed = false;
    }
    stream.once(kConstruct, cb);
    if (stream.listenerCount(kConstruct) > 1) {
        return;
    }
    nextTick2(constructNT, stream);
}
function constructNT(stream) {
    let called = false;
    function onConstruct(err35) {
        if (called) {
            errorOrDestroy(stream, err35 ?? new ERR_MULTIPLE_CALLBACK());
            return;
        }
        called = true;
        const r13 = stream._readableState;
        const w14 = stream._writableState;
        const s10 = w14 || r13;
        if (r13) {
            r13.constructed = true;
        }
        if (w14) {
            w14.constructed = true;
        }
        if (s10.destroyed) {
            stream.emit(kDestroy, err35);
        } else if (err35) {
            errorOrDestroy(stream, err35, true);
        } else {
            nextTick2(emitConstructNT, stream);
        }
    }
    try {
        const result = stream._construct(onConstruct);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick2(onConstruct, null);
                }, function(err36) {
                    nextTick2(onConstruct, err36);
                });
            }
        }
    } catch (err37) {
        onConstruct(err37);
    }
}
function emitConstructNT(stream) {
    stream.emit(kConstruct);
}
function isRequest1(stream) {
    return stream && stream.setHeader && typeof stream.abort === "function";
}
function destroyer(stream, err38) {
    if (!stream) return;
    if (isRequest1(stream)) return stream.abort();
    if (isRequest1(stream.req)) return stream.req.abort();
    if (typeof stream.destroy === "function") return stream.destroy(err38);
    if (typeof stream.close === "function") return stream.close();
}
const __default10 = {
    construct,
    destroyer,
    destroy,
    undestroy,
    errorOrDestroy
};
const kIsDisturbed = Symbol("kIsDisturbed");
function isReadableNodeStream(obj) {
    return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!obj._writableState || obj._readableState?.readable !== false) && (!obj._writableState || obj._readableState));
}
function isWritableNodeStream(obj) {
    return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || obj._writableState?.writable !== false));
}
function isDuplexNodeStream(obj) {
    return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
}
function isNodeStream(obj) {
    return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
}
function isIterable(obj, isAsync) {
    if (obj == null) return false;
    if (isAsync === true) return typeof obj[Symbol.asyncIterator] === "function";
    if (isAsync === false) return typeof obj[Symbol.iterator] === "function";
    return typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function";
}
function isDestroyed(stream) {
    if (!isNodeStream(stream)) return null;
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state7 = wState || rState;
    return !!(stream.destroyed || state7?.destroyed);
}
function isWritableEnded(stream) {
    if (!isWritableNodeStream(stream)) return null;
    if (stream.writableEnded === true) return true;
    const wState = stream._writableState;
    if (wState?.errored) return false;
    if (typeof wState?.ended !== "boolean") return null;
    return wState.ended;
}
function isReadableFinished(stream, strict8) {
    if (!isReadableNodeStream(stream)) return null;
    const rState = stream._readableState;
    if (rState?.errored) return false;
    if (typeof rState?.endEmitted !== "boolean") return null;
    return !!(rState.endEmitted || strict8 === false && rState.ended === true && rState.length === 0);
}
function isDisturbed(stream) {
    return !!(stream && (stream.readableDidRead || stream.readableAborted || stream[kIsDisturbed]));
}
function isReadable1(stream) {
    const r14 = isReadableNodeStream(stream);
    if (r14 === null || typeof stream?.readable !== "boolean") return null;
    if (isDestroyed(stream)) return false;
    return r14 && stream.readable && !isReadableFinished(stream);
}
function isWritable1(stream) {
    const r15 = isWritableNodeStream(stream);
    if (r15 === null || typeof stream?.writable !== "boolean") return null;
    if (isDestroyed(stream)) return false;
    return r15 && stream.writable && !isWritableEnded(stream);
}
const stdio = {};
function isBlob(object) {
    return object instanceof Blob;
}
function _from1(Readable2, iterable, opts) {
    let iterator;
    if (typeof iterable === "string" || iterable instanceof Buffer1) {
        return new Readable2({
            objectMode: true,
            ...opts,
            read () {
                this.push(iterable);
                this.push(null);
            }
        });
    }
    let isAsync;
    if (iterable && iterable[Symbol.asyncIterator]) {
        isAsync = true;
        iterator = iterable[Symbol.asyncIterator]();
    } else if (iterable && iterable[Symbol.iterator]) {
        isAsync = false;
        iterator = iterable[Symbol.iterator]();
    } else {
        throw new ERR_INVALID_ARG_TYPE("iterable", [
            "Iterable"
        ], iterable);
    }
    const readable = new Readable2({
        objectMode: true,
        highWaterMark: 1,
        ...opts
    });
    let reading = false;
    readable._read = function() {
        if (!reading) {
            reading = true;
            next();
        }
    };
    readable._destroy = function(error5, cb) {
        close3(error5).then(()=>nextTick1(cb, error5)
        , (e15)=>nextTick1(cb, e15 || error5)
        );
    };
    async function close3(error6) {
        const hadError = error6 !== undefined && error6 !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
            const { value , done  } = await iterator.throw(error6);
            await value;
            if (done) {
                return;
            }
        }
        if (typeof iterator.return === "function") {
            const { value  } = await iterator.return();
            await value;
        }
    }
    async function next() {
        for(;;){
            try {
                const { value , done  } = isAsync ? await iterator.next() : iterator.next();
                if (done) {
                    readable.push(null);
                } else {
                    const res = value && typeof value.then === "function" ? await value : value;
                    if (res === null) {
                        reading = false;
                        throw new ERR_STREAM_NULL_VALUES();
                    } else if (readable.push(res)) {
                        continue;
                    } else {
                        reading = false;
                    }
                }
            } catch (err39) {
                readable.destroy(err39);
            }
            break;
        }
    }
    return readable;
}
function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getDefaultHighWaterMark(objectMode) {
    return objectMode ? 16 : 16 * 1024;
}
function getHighWaterMark(state8, options, duplexKey, isDuplex) {
    const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
        if (!Number.isInteger(hwm) || hwm < 0) {
            const name39 = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
            throw new ERR_INVALID_ARG_VALUE(name39, hwm);
        }
        return Math.floor(hwm);
    }
    return getDefaultHighWaterMark(state8.objectMode);
}
const __default11 = {
    getHighWaterMark,
    getDefaultHighWaterMark
};
function Stream(opts) {
    EventEmitter.call(this, opts);
}
Object.setPrototypeOf(Stream.prototype, EventEmitter.prototype);
Object.setPrototypeOf(Stream, EventEmitter);
Stream.prototype.pipe = function(dest, options) {
    const source = this;
    function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
            source.pause();
        }
    }
    source.on("data", ondata);
    function ondrain() {
        if (source.readable && source.resume) {
            source.resume();
        }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
    }
    let didOnEnd = false;
    function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
    }
    function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
    }
    function onerror(er) {
        cleanup();
        if (EventEmitter.listenerCount(this, "error") === 0) {
            this.emit("error", er);
        }
    }
    prependListener(source, "error", onerror);
    prependListener(dest, "error", onerror);
    function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
};
function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") {
        return emitter.prependListener(event, fn);
    }
    if (!emitter._events || !emitter._events[event]) {
        emitter.on(event, fn);
    } else if (Array.isArray(emitter._events[event])) {
        emitter._events[event].unshift(fn);
    } else {
        emitter._events[event] = [
            fn,
            emitter._events[event]
        ];
    }
}
var NotImplemented;
(function(NotImplemented1) {
    NotImplemented1[NotImplemented1["ascii"] = 0] = "ascii";
    NotImplemented1[NotImplemented1["latin1"] = 1] = "latin1";
    NotImplemented1[NotImplemented1["utf16le"] = 2] = "utf16le";
})(NotImplemented || (NotImplemented = {}));
function normalizeEncoding2(enc) {
    const encoding = normalizeEncoding(enc ?? null);
    if (encoding && encoding in NotImplemented) notImplemented(encoding);
    if (!encoding && typeof enc === "string" && enc.toLowerCase() !== "raw") {
        throw new Error(`Unknown encoding: ${enc}`);
    }
    return String(encoding);
}
function utf8CheckByte(__byte) {
    if (__byte <= 127) return 0;
    else if (__byte >> 5 === 6) return 2;
    else if (__byte >> 4 === 14) return 3;
    else if (__byte >> 3 === 30) return 4;
    return __byte >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(self, buf, i84) {
    let j = buf.length - 1;
    if (j < i84) return 0;
    let nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i84 || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i84 || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
function utf8CheckExtraBytes(self, buf) {
    if ((buf[0] & 192) !== 128) {
        self.lastNeed = 0;
        return "\ufffd";
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
            self.lastNeed = 1;
            return "\ufffd";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 192) !== 128) {
                self.lastNeed = 2;
                return "\ufffd";
            }
        }
    }
}
function utf8FillLastComplete(buf) {
    const p8 = this.lastTotal - this.lastNeed;
    const r16 = utf8CheckExtraBytes(this, buf);
    if (r16 !== undefined) return r16;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p8, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p8, 0, buf.length);
    this.lastNeed -= buf.length;
}
function utf8FillLastIncomplete(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
}
function utf8Text(buf, i85) {
    const total = utf8CheckIncomplete(this, buf, i85);
    if (!this.lastNeed) return buf.toString("utf8", i85);
    this.lastTotal = total;
    const end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i85, end);
}
function utf8End(buf) {
    const r17 = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r17 + "\ufffd";
    return r17;
}
function utf8Write(buf) {
    if (typeof buf === "string") {
        return buf;
    }
    if (buf.length === 0) return "";
    let r18;
    let i86;
    if (this.lastNeed) {
        r18 = this.fillLast(buf);
        if (r18 === undefined) return "";
        i86 = this.lastNeed;
        this.lastNeed = 0;
    } else {
        i86 = 0;
    }
    if (i86 < buf.length) return r18 ? r18 + this.text(buf, i86) : this.text(buf, i86);
    return r18 || "";
}
function base64Text(buf, i87) {
    const n15 = (buf.length - i87) % 3;
    if (n15 === 0) return buf.toString("base64", i87);
    this.lastNeed = 3 - n15;
    this.lastTotal = 3;
    if (n15 === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i87, buf.length - n15);
}
function base64End(buf) {
    const r19 = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        return r19 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    }
    return r19;
}
function simpleWrite(buf) {
    if (typeof buf === "string") {
        return buf;
    }
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}
class StringDecoderBase {
    encoding;
    lastChar;
    lastNeed = 0;
    lastTotal = 0;
    constructor(encoding, nb){
        this.encoding = encoding;
        this.lastChar = Buffer1.allocUnsafe(nb);
    }
}
class Base64Decoder extends StringDecoderBase {
    end = base64End;
    fillLast = utf8FillLastIncomplete;
    text = base64Text;
    write = utf8Write;
    constructor(encoding){
        super(normalizeEncoding2(encoding), 3);
    }
}
class GenericDecoder extends StringDecoderBase {
    end = simpleEnd;
    fillLast = undefined;
    text = utf8Text;
    write = simpleWrite;
    constructor(encoding){
        super(normalizeEncoding2(encoding), 4);
    }
}
class Utf8Decoder extends StringDecoderBase {
    end = utf8End;
    fillLast = utf8FillLastComplete;
    text = utf8Text;
    write = utf8Write;
    constructor(encoding){
        super(normalizeEncoding2(encoding), 4);
    }
}
class StringDecoder {
    encoding;
    end;
    fillLast;
    lastChar;
    lastNeed;
    lastTotal;
    text;
    write;
    constructor(encoding){
        let decoder;
        switch(encoding){
            case "utf8":
                decoder = new Utf8Decoder(encoding);
                break;
            case "base64":
                decoder = new Base64Decoder(encoding);
                break;
            default:
                decoder = new GenericDecoder(encoding);
        }
        this.encoding = decoder.encoding;
        this.end = decoder.end;
        this.fillLast = decoder.fillLast;
        this.lastChar = decoder.lastChar;
        this.lastNeed = decoder.lastNeed;
        this.lastTotal = decoder.lastTotal;
        this.text = decoder.text;
        this.write = decoder.write;
    }
}
const PStringDecoder = new Proxy(StringDecoder, {
    apply (_target, thisArg, args) {
        return Object.assign(thisArg, new StringDecoder(...args));
    }
});
const __default12 = {
    StringDecoder: PStringDecoder
};
class BufferList {
    constructor(){
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    push(v7) {
        const entry = {
            data: v7,
            next: null
        };
        if (this.length > 0) {
            this.tail.next = entry;
        } else {
            this.head = entry;
        }
        this.tail = entry;
        ++this.length;
    }
    unshift(v8) {
        const entry = {
            data: v8,
            next: this.head
        };
        if (this.length === 0) {
            this.tail = entry;
        }
        this.head = entry;
        ++this.length;
    }
    shift() {
        if (this.length === 0) {
            return;
        }
        const ret = this.head.data;
        if (this.length === 1) {
            this.head = this.tail = null;
        } else {
            this.head = this.head.next;
        }
        --this.length;
        return ret;
    }
    clear() {
        this.head = this.tail = null;
        this.length = 0;
    }
    join(s11) {
        if (this.length === 0) {
            return "";
        }
        let p9 = this.head;
        let ret = "" + p9.data;
        while(p9 = p9.next){
            ret += s11 + p9.data;
        }
        return ret;
    }
    concat(n16) {
        if (this.length === 0) {
            return Buffer1.alloc(0);
        }
        const ret = Buffer1.allocUnsafe(n16 >>> 0);
        let p10 = this.head;
        let i88 = 0;
        while(p10){
            ret.set(p10.data, i88);
            i88 += p10.data.length;
            p10 = p10.next;
        }
        return ret;
    }
    consume(n17, hasStrings) {
        const data8 = this.head.data;
        if (n17 < data8.length) {
            const slice = data8.slice(0, n17);
            this.head.data = data8.slice(n17);
            return slice;
        }
        if (n17 === data8.length) {
            return this.shift();
        }
        return hasStrings ? this._getString(n17) : this._getBuffer(n17);
    }
    first() {
        return this.head.data;
    }
    *[Symbol.iterator]() {
        for(let p11 = this.head; p11; p11 = p11.next){
            yield p11.data;
        }
    }
    _getString(n18) {
        let ret = "";
        let p12 = this.head;
        let c14 = 0;
        do {
            const str = p12.data;
            if (n18 > str.length) {
                ret += str;
                n18 -= str.length;
            } else {
                if (n18 === str.length) {
                    ret += str;
                    ++c14;
                    if (p12.next) {
                        this.head = p12.next;
                    } else {
                        this.head = this.tail = null;
                    }
                } else {
                    ret += str.slice(0, n18);
                    this.head = p12;
                    p12.data = str.slice(n18);
                }
                break;
            }
            ++c14;
        }while (p12 = p12.next)
        this.length -= c14;
        return ret;
    }
    _getBuffer(n19) {
        const ret = Buffer1.allocUnsafe(n19);
        const retLen = n19;
        let p13 = this.head;
        let c15 = 0;
        do {
            const buf = p13.data;
            if (n19 > buf.length) {
                ret.set(buf, retLen - n19);
                n19 -= buf.length;
            } else {
                if (n19 === buf.length) {
                    ret.set(buf, retLen - n19);
                    ++c15;
                    if (p13.next) {
                        this.head = p13.next;
                    } else {
                        this.head = this.tail = null;
                    }
                } else {
                    ret.set(new Uint8Array(buf.buffer, buf.byteOffset, n19), retLen - n19);
                    this.head = p13;
                    p13.data = buf.slice(n19);
                }
                break;
            }
            ++c15;
        }while (p13 = p13.next)
        this.length -= c15;
        return ret;
    }
    [inspect.custom](_, options) {
        return inspect(this, {
            ...options,
            depth: 0,
            customInspect: false
        });
    }
}
let debug = debuglog("stream", (fn)=>{
    debug = fn;
});
const kPaused = Symbol("kPaused");
Object.setPrototypeOf(Readable.prototype, Stream.prototype);
Object.setPrototypeOf(Readable, Stream);
const nop1 = ()=>{};
const { errorOrDestroy: errorOrDestroy1  } = __default10;
function ReadableState(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean") {
        isDuplex = stream instanceof Stream.Duplex;
    }
    this.objectMode = !!(options && options.objectMode);
    if (isDuplex) {
        this.objectMode = this.objectMode || !!(options && options.readableObjectMode);
    }
    this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = [];
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.constructed = true;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this[kPaused] = null;
    this.errorEmitted = false;
    this.emitClose = !options || options.emitClose !== false;
    this.autoDestroy = !options || options.autoDestroy !== false;
    this.destroyed = false;
    this.errored = null;
    this.closed = false;
    this.closeEmitted = false;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.awaitDrainWriters = null;
    this.multiAwaitDrain = false;
    this.readingMore = false;
    this.dataEmitted = false;
    this.decoder = null;
    this.encoding = null;
    if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable(options) {
    if (!(this instanceof Readable)) {
        return new Readable(options);
    }
    const isDuplex = this instanceof Stream.Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    if (options) {
        if (typeof options.read === "function") {
            this._read = options.read;
        }
        if (typeof options.destroy === "function") {
            this._destroy = options.destroy;
        }
        if (typeof options.construct === "function") {
            this._construct = options.construct;
        }
        if (options.signal && !isDuplex) {
            addAbortSignalNoValidate(options.signal, this);
        }
    }
    Stream.call(this, options);
    __default10.construct(this, ()=>{
        if (this._readableState.needReadable) {
            maybeReadMore(this, this._readableState);
        }
    });
}
Readable.prototype.destroy = __default10.destroy;
Readable.prototype._undestroy = __default10.undestroy;
Readable.prototype._destroy = function(err40, cb) {
    cb(err40);
};
Readable.prototype[EventEmitter.captureRejectionSymbol] = function(err41) {
    this.destroy(err41);
};
Readable.prototype.push = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, false);
};
Readable.prototype.unshift = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, true);
};
function readableAddChunk(stream, chunk, encoding, addToFront) {
    debug("readableAddChunk", chunk);
    const state9 = stream._readableState;
    let err42;
    if (!state9.objectMode) {
        if (typeof chunk === "string") {
            encoding = encoding || state9.defaultEncoding;
            if (state9.encoding !== encoding) {
                if (addToFront && state9.encoding) {
                    chunk = Buffer1.from(chunk, encoding).toString(state9.encoding);
                } else {
                    chunk = Buffer1.from(chunk, encoding);
                    encoding = "";
                }
            }
        } else if (chunk instanceof Buffer1) {
            encoding = "";
        } else if (Stream._isUint8Array(chunk)) {
            chunk = Stream._uint8ArrayToBuffer(chunk);
            encoding = "";
        } else if (chunk != null) {
            err42 = new ERR_INVALID_ARG_TYPE("chunk", [
                "string",
                "Buffer",
                "Uint8Array"
            ], chunk);
        }
    }
    if (err42) {
        errorOrDestroy1(stream, err42);
    } else if (chunk === null) {
        state9.reading = false;
        onEofChunk(stream, state9);
    } else if (state9.objectMode || chunk && chunk.length > 0) {
        if (addToFront) {
            if (state9.endEmitted) {
                errorOrDestroy1(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            } else {
                addChunk(stream, state9, chunk, true);
            }
        } else if (state9.ended) {
            errorOrDestroy1(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state9.destroyed || state9.errored) {
            return false;
        } else {
            state9.reading = false;
            if (state9.decoder && !encoding) {
                chunk = state9.decoder.write(chunk);
                if (state9.objectMode || chunk.length !== 0) {
                    addChunk(stream, state9, chunk, false);
                } else {
                    maybeReadMore(stream, state9);
                }
            } else {
                addChunk(stream, state9, chunk, false);
            }
        }
    } else if (!addToFront) {
        state9.reading = false;
        maybeReadMore(stream, state9);
    }
    return !state9.ended && (state9.length < state9.highWaterMark || state9.length === 0);
}
function addChunk(stream, state10, chunk, addToFront) {
    if (state10.flowing && state10.length === 0 && !state10.sync && stream.listenerCount("data") > 0) {
        if (state10.multiAwaitDrain) {
            state10.awaitDrainWriters.clear();
        } else {
            state10.awaitDrainWriters = null;
        }
        state10.dataEmitted = true;
        stream.emit("data", chunk);
    } else {
        state10.length += state10.objectMode ? 1 : chunk.length;
        if (addToFront) {
            state10.buffer.unshift(chunk);
        } else {
            state10.buffer.push(chunk);
        }
        if (state10.needReadable) {
            emitReadable(stream);
        }
    }
    maybeReadMore(stream, state10);
}
Readable.prototype.isPaused = function() {
    const state11 = this._readableState;
    return state11[kPaused] === true || state11.flowing === false;
};
Readable.prototype.setEncoding = function(enc) {
    const decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    const buffer18 = this._readableState.buffer;
    let content = "";
    for (const data9 of buffer18){
        content += decoder.write(data9);
    }
    buffer18.clear();
    if (content !== "") {
        buffer18.push(content);
    }
    this._readableState.length = content.length;
    return this;
};
const MAX_HWM = 1073741824;
function computeNewHighWaterMark(n20) {
    if (n20 >= 1073741824) {
        n20 = MAX_HWM;
    } else {
        n20--;
        n20 |= n20 >>> 1;
        n20 |= n20 >>> 2;
        n20 |= n20 >>> 4;
        n20 |= n20 >>> 8;
        n20 |= n20 >>> 16;
        n20++;
    }
    return n20;
}
function howMuchToRead(n21, state12) {
    if (n21 <= 0 || state12.length === 0 && state12.ended) {
        return 0;
    }
    if (state12.objectMode) {
        return 1;
    }
    if (Number.isNaN(n21)) {
        if (state12.flowing && state12.length) {
            return state12.buffer.first().length;
        }
        return state12.length;
    }
    if (n21 <= state12.length) {
        return n21;
    }
    return state12.ended ? state12.length : 0;
}
Readable.prototype.read = function(n22) {
    debug("read", n22);
    if (n22 === undefined) {
        n22 = NaN;
    } else if (!Number.isInteger(n22)) {
        n22 = Number.parseInt(n22, 10);
    }
    const state13 = this._readableState;
    const nOrig = n22;
    if (n22 > state13.highWaterMark) {
        state13.highWaterMark = computeNewHighWaterMark(n22);
    }
    if (n22 !== 0) {
        state13.emittedReadable = false;
    }
    if (n22 === 0 && state13.needReadable && ((state13.highWaterMark !== 0 ? state13.length >= state13.highWaterMark : state13.length > 0) || state13.ended)) {
        debug("read: emitReadable", state13.length, state13.ended);
        if (state13.length === 0 && state13.ended) {
            endReadable(this);
        } else {
            emitReadable(this);
        }
        return null;
    }
    n22 = howMuchToRead(n22, state13);
    if (n22 === 0 && state13.ended) {
        if (state13.length === 0) {
            endReadable(this);
        }
        return null;
    }
    let doRead = state13.needReadable;
    debug("need readable", doRead);
    if (state13.length === 0 || state13.length - n22 < state13.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
    }
    if (state13.ended || state13.reading || state13.destroyed || state13.errored || !state13.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
    } else if (doRead) {
        debug("do read");
        state13.reading = true;
        state13.sync = true;
        if (state13.length === 0) {
            state13.needReadable = true;
        }
        this._read(state13.highWaterMark);
        state13.sync = false;
        if (!state13.reading) {
            n22 = howMuchToRead(nOrig, state13);
        }
    }
    let ret;
    if (n22 > 0) {
        ret = fromList(n22, state13);
    } else {
        ret = null;
    }
    if (ret === null) {
        state13.needReadable = state13.length <= state13.highWaterMark;
        n22 = 0;
    } else {
        state13.length -= n22;
        if (state13.multiAwaitDrain) {
            state13.awaitDrainWriters.clear();
        } else {
            state13.awaitDrainWriters = null;
        }
    }
    if (state13.length === 0) {
        if (!state13.ended) {
            state13.needReadable = true;
        }
        if (nOrig !== n22 && state13.ended) {
            endReadable(this);
        }
    }
    if (ret !== null) {
        state13.dataEmitted = true;
        this.emit("data", ret);
    }
    return ret;
};
function onEofChunk(stream, state14) {
    debug("onEofChunk");
    if (state14.ended) return;
    if (state14.decoder) {
        const chunk = state14.decoder.end();
        if (chunk && chunk.length) {
            state14.buffer.push(chunk);
            state14.length += state14.objectMode ? 1 : chunk.length;
        }
    }
    state14.ended = true;
    if (state14.sync) {
        emitReadable(stream);
    } else {
        state14.needReadable = false;
        state14.emittedReadable = true;
        emitReadable_(stream);
    }
}
function emitReadable(stream) {
    const state15 = stream._readableState;
    debug("emitReadable", state15.needReadable, state15.emittedReadable);
    state15.needReadable = false;
    if (!state15.emittedReadable) {
        debug("emitReadable", state15.flowing);
        state15.emittedReadable = true;
        nextTick2(emitReadable_, stream);
    }
}
function emitReadable_(stream) {
    const state16 = stream._readableState;
    debug("emitReadable_", state16.destroyed, state16.length, state16.ended);
    if (!state16.destroyed && !state16.errored && (state16.length || state16.ended)) {
        stream.emit("readable");
        state16.emittedReadable = false;
    }
    state16.needReadable = !state16.flowing && !state16.ended && state16.length <= state16.highWaterMark;
    flow(stream);
}
function maybeReadMore(stream, state17) {
    if (!state17.readingMore && state17.constructed) {
        state17.readingMore = true;
        nextTick2(maybeReadMore_, stream, state17);
    }
}
function maybeReadMore_(stream, state18) {
    while(!state18.reading && !state18.ended && (state18.length < state18.highWaterMark || state18.flowing && state18.length === 0)){
        const len = state18.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state18.length) {
            break;
        }
    }
    state18.readingMore = false;
}
Readable.prototype._read = function(n) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
};
Readable.prototype.pipe = function(dest, pipeOpts) {
    const src = this;
    const state19 = this._readableState;
    if (state19.pipes.length === 1) {
        if (!state19.multiAwaitDrain) {
            state19.multiAwaitDrain = true;
            state19.awaitDrainWriters = new Set(state19.awaitDrainWriters ? [
                state19.awaitDrainWriters
            ] : []);
        }
    }
    state19.pipes.push(dest);
    debug("pipe count=%d opts=%j", state19.pipes.length, pipeOpts);
    const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== stdio.stdout && dest !== stdio.stderr;
    const endFn = doEnd ? onend : unpipe;
    if (state19.endEmitted) {
        nextTick2(endFn);
    } else {
        src.once("end", endFn);
    }
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        debug("onend");
        dest.end();
    }
    let ondrain;
    let cleanedUp = false;
    function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
            dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state19.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) {
            ondrain();
        }
    }
    function pause() {
        if (!cleanedUp) {
            if (state19.pipes.length === 1 && state19.pipes[0] === dest) {
                debug("false write response, pause", 0);
                state19.awaitDrainWriters = dest;
                state19.multiAwaitDrain = false;
            } else if (state19.pipes.length > 1 && state19.pipes.includes(dest)) {
                debug("false write response, pause", state19.awaitDrainWriters.size);
                state19.awaitDrainWriters.add(dest);
            }
            src.pause();
        }
        if (!ondrain) {
            ondrain = pipeOnDrain(src, dest);
            dest.on("drain", ondrain);
        }
    }
    src.on("data", ondata);
    function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
            pause();
        }
    }
    function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EventEmitter.listenerCount(dest, "error") === 0) {
            const s12 = dest._writableState || dest._readableState;
            if (s12 && !s12.errorEmitted) {
                errorOrDestroy1(dest, er);
            } else {
                dest.emit("error", er);
            }
        }
    }
    prependListener(dest, "error", onerror);
    function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (dest.writableNeedDrain === true) {
        if (state19.flowing) {
            pause();
        }
    } else if (!state19.flowing) {
        debug("pipe resume");
        src.resume();
    }
    return dest;
};
function pipeOnDrain(src, dest) {
    return function pipeOnDrainFunctionResult() {
        const state20 = src._readableState;
        if (state20.awaitDrainWriters === dest) {
            debug("pipeOnDrain", 1);
            state20.awaitDrainWriters = null;
        } else if (state20.multiAwaitDrain) {
            debug("pipeOnDrain", state20.awaitDrainWriters.size);
            state20.awaitDrainWriters.delete(dest);
        }
        if ((!state20.awaitDrainWriters || state20.awaitDrainWriters.size === 0) && EventEmitter.listenerCount(src, "data")) {
            state20.flowing = true;
            flow(src);
        }
    };
}
Readable.prototype.unpipe = function(dest) {
    const state21 = this._readableState;
    const unpipeInfo = {
        hasUnpiped: false
    };
    if (state21.pipes.length === 0) {
        return this;
    }
    if (!dest) {
        const dests = state21.pipes;
        state21.pipes = [];
        this.pause();
        for(let i89 = 0; i89 < dests.length; i89++){
            dests[i89].emit("unpipe", this, {
                hasUnpiped: false
            });
        }
        return this;
    }
    const index7 = state21.pipes.indexOf(dest);
    if (index7 === -1) {
        return this;
    }
    state21.pipes.splice(index7, 1);
    if (state21.pipes.length === 0) {
        this.pause();
    }
    dest.emit("unpipe", this, unpipeInfo);
    return this;
};
Readable.prototype.on = function(ev, fn) {
    const res = Stream.prototype.on.call(this, ev, fn);
    const state22 = this._readableState;
    if (ev === "data") {
        state22.readableListening = this.listenerCount("readable") > 0;
        if (state22.flowing !== false) {
            this.resume();
        }
    } else if (ev === "readable") {
        if (!state22.endEmitted && !state22.readableListening) {
            state22.readableListening = state22.needReadable = true;
            state22.flowing = false;
            state22.emittedReadable = false;
            debug("on readable", state22.length, state22.reading);
            if (state22.length) {
                emitReadable(this);
            } else if (!state22.reading) {
                nextTick2(nReadingNextTick, this);
            }
        }
    }
    return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function(ev, fn) {
    const res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
        nextTick2(updateReadableListening, this);
    }
    return res;
};
Readable.prototype.off = Readable.prototype.removeListener;
Readable.prototype.removeAllListeners = function(ev) {
    const res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === undefined) {
        nextTick2(updateReadableListening, this);
    }
    return res;
};
function updateReadableListening(self) {
    const state23 = self._readableState;
    state23.readableListening = self.listenerCount("readable") > 0;
    if (state23.resumeScheduled && state23[kPaused] === false) {
        state23.flowing = true;
    } else if (self.listenerCount("data") > 0) {
        self.resume();
    } else if (!state23.readableListening) {
        state23.flowing = null;
    }
}
function nReadingNextTick(self) {
    debug("readable nexttick read 0");
    self.read(0);
}
Readable.prototype.resume = function() {
    const state24 = this._readableState;
    if (!state24.flowing) {
        debug("resume");
        state24.flowing = !state24.readableListening;
        resume(this, state24);
    }
    state24[kPaused] = false;
    return this;
};
function resume(stream, state25) {
    if (!state25.resumeScheduled) {
        state25.resumeScheduled = true;
        nextTick2(resume_, stream, state25);
    }
}
function resume_(stream, state26) {
    debug("resume", state26.reading);
    if (!state26.reading) {
        stream.read(0);
    }
    state26.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state26.flowing && !state26.reading) {
        stream.read(0);
    }
}
Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
    }
    this._readableState[kPaused] = true;
    return this;
};
function flow(stream) {
    const state27 = stream._readableState;
    debug("flow", state27.flowing);
    while(state27.flowing && stream.read() !== null);
}
Readable.prototype.wrap = function(stream) {
    let paused = false;
    stream.on("data", (chunk)=>{
        if (!this.push(chunk) && stream.pause) {
            paused = true;
            stream.pause();
        }
    });
    stream.on("end", ()=>{
        this.push(null);
    });
    stream.on("error", (err43)=>{
        errorOrDestroy1(this, err43);
    });
    stream.on("close", ()=>{
        this.destroy();
    });
    stream.on("destroy", ()=>{
        this.destroy();
    });
    this._read = ()=>{
        if (paused && stream.resume) {
            paused = false;
            stream.resume();
        }
    };
    const streamKeys = Object.keys(stream);
    for(let j = 1; j < streamKeys.length; j++){
        const i90 = streamKeys[j];
        if (this[i90] === undefined && typeof stream[i90] === "function") {
            this[i90] = stream[i90].bind(stream);
        }
    }
    return this;
};
Readable.prototype[Symbol.asyncIterator] = function() {
    return streamToAsyncIterator(this);
};
Readable.prototype.iterator = function(options) {
    if (options !== undefined) {
        validateObject(options, "options");
    }
    return streamToAsyncIterator(this, options);
};
function streamToAsyncIterator(stream, options) {
    if (typeof stream.read !== "function") {
        stream = Readable.wrap(stream, {
            objectMode: true
        });
    }
    const iter = createAsyncIterator(stream, options);
    iter.stream = stream;
    return iter;
}
async function* createAsyncIterator(stream, options) {
    let callback = nop1;
    const opts = {
        destroyOnReturn: true,
        destroyOnError: true,
        ...options
    };
    function next(resolve13) {
        if (this === stream) {
            callback();
            callback = nop1;
        } else {
            callback = resolve13;
        }
    }
    const state28 = stream._readableState;
    let error7 = state28.errored;
    let errorEmitted = state28.errorEmitted;
    let endEmitted = state28.endEmitted;
    let closeEmitted = state28.closeEmitted;
    stream.on("readable", next).on("error", function(err44) {
        error7 = err44;
        errorEmitted = true;
        next.call(this);
    }).on("end", function() {
        endEmitted = true;
        next.call(this);
    }).on("close", function() {
        closeEmitted = true;
        next.call(this);
    });
    let errorThrown = false;
    try {
        while(true){
            const chunk = stream.destroyed ? null : stream.read();
            if (chunk !== null) {
                yield chunk;
            } else if (errorEmitted) {
                throw error7;
            } else if (endEmitted) {
                break;
            } else if (closeEmitted) {
                break;
            } else {
                await new Promise(next);
            }
        }
    } catch (err45) {
        if (opts.destroyOnError) {
            __default10.destroyer(stream, err45);
        }
        errorThrown = true;
        throw err45;
    } finally{
        if (!errorThrown && opts.destroyOnReturn) {
            if (state28.autoDestroy || !endEmitted) {
                __default10.destroyer(stream, null);
            }
        }
    }
}
Object.defineProperties(Readable.prototype, {
    readable: {
        get () {
            const r20 = this._readableState;
            return !!r20 && r20.readable !== false && !r20.destroyed && !r20.errorEmitted && !r20.endEmitted;
        },
        set (val) {
            if (this._readableState) {
                this._readableState.readable = !!val;
            }
        }
    },
    readableDidRead: {
        enumerable: false,
        get: function() {
            return this._readableState.dataEmitted;
        }
    },
    readableAborted: {
        enumerable: false,
        get: function() {
            return !!(this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted;
        }
    },
    readableHighWaterMark: {
        enumerable: false,
        get: function() {
            return this._readableState.highWaterMark;
        }
    },
    readableBuffer: {
        enumerable: false,
        get: function() {
            return this._readableState && this._readableState.buffer;
        }
    },
    readableFlowing: {
        enumerable: false,
        get: function() {
            return this._readableState.flowing;
        },
        set: function(state29) {
            if (this._readableState) {
                this._readableState.flowing = state29;
            }
        }
    },
    readableLength: {
        enumerable: false,
        get () {
            return this._readableState.length;
        }
    },
    readableObjectMode: {
        enumerable: false,
        get () {
            return this._readableState ? this._readableState.objectMode : false;
        }
    },
    readableEncoding: {
        enumerable: false,
        get () {
            return this._readableState ? this._readableState.encoding : null;
        }
    },
    destroyed: {
        enumerable: false,
        get () {
            if (this._readableState === undefined) {
                return false;
            }
            return this._readableState.destroyed;
        },
        set (value) {
            if (!this._readableState) {
                return;
            }
            this._readableState.destroyed = value;
        }
    },
    readableEnded: {
        enumerable: false,
        get () {
            return this._readableState ? this._readableState.endEmitted : false;
        }
    }
});
Object.defineProperties(ReadableState.prototype, {
    pipesCount: {
        get () {
            return this.pipes.length;
        }
    },
    paused: {
        get () {
            return this[kPaused] !== false;
        },
        set (value) {
            this[kPaused] = !!value;
        }
    }
});
function fromList(n23, state30) {
    if (state30.length === 0) {
        return null;
    }
    let ret;
    if (state30.objectMode) {
        ret = state30.buffer.shift();
    } else if (!n23 || n23 >= state30.length) {
        if (state30.decoder) {
            ret = state30.buffer.join("");
        } else if (state30.buffer.length === 1) {
            ret = state30.buffer.first();
        } else {
            ret = state30.buffer.concat(state30.length);
        }
        state30.buffer.clear();
    } else {
        ret = state30.buffer.consume(n23, state30.decoder);
    }
    return ret;
}
function endReadable(stream) {
    const state31 = stream._readableState;
    debug("endReadable", state31.endEmitted);
    if (!state31.endEmitted) {
        state31.ended = true;
        nextTick2(endReadableNT, state31, stream);
    }
}
function endReadableNT(state32, stream) {
    debug("endReadableNT", state32.endEmitted, state32.length);
    if (!state32.errorEmitted && !state32.closeEmitted && !state32.endEmitted && state32.length === 0) {
        state32.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
            nextTick2(endWritableNT, stream);
        } else if (state32.autoDestroy) {
            const wState = stream._writableState;
            const autoDestroy = !wState || wState.autoDestroy && (wState.finished || wState.writable === false);
            if (autoDestroy) {
                stream.destroy();
            }
        }
    }
}
function endWritableNT(stream) {
    const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
    if (writable) {
        stream.end();
    }
}
function readableFrom(iterable, opts) {
    return _from1(Readable, iterable, opts);
}
function wrap(src, options) {
    return new Readable({
        objectMode: (src.readableObjectMode ?? src.objectMode) ?? true,
        ...options,
        destroy (err46, callback) {
            __default10.destroyer(src, err46);
            callback(err46);
        }
    }).wrap(src);
}
Readable._fromList = fromList;
Readable.ReadableState = ReadableState;
Readable.from = readableFrom;
Readable.wrap = wrap;
const { errorOrDestroy: errorOrDestroy2  } = __default10;
function isDuplexStream(maybe_duplex) {
    const isReadable2 = Readable.prototype.isPrototypeOf(maybe_duplex);
    let prototype = maybe_duplex;
    let isDuplex = false;
    while(prototype?.constructor && prototype.constructor.name !== "Object"){
        if (prototype.constructor.name === "Duplex") {
            isDuplex = true;
            break;
        }
        prototype = Object.getPrototypeOf(prototype);
    }
    return isReadable2 && isDuplex;
}
Object.setPrototypeOf(Writable.prototype, Stream.prototype);
Object.setPrototypeOf(Writable, Stream);
function nop2() {}
const kOnFinished = Symbol("kOnFinished");
function WritableState(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean") {
        isDuplex = isDuplexStream(stream);
    }
    this.objectMode = !!(options && options.objectMode);
    if (isDuplex) {
        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
    }
    this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    const noDecode = !!(options && options.decodeStrings === false);
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options && options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = onwrite.bind(undefined, stream);
    this.writecb = null;
    this.writelen = 0;
    this.afterWriteTickInfo = null;
    resetBuffer(this);
    this.pendingcb = 0;
    this.constructed = true;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = !options || options.emitClose !== false;
    this.autoDestroy = !options || options.autoDestroy !== false;
    this.errored = null;
    this.closed = false;
    this.closeEmitted = false;
    this[kOnFinished] = [];
}
function resetBuffer(state33) {
    state33.buffered = [];
    state33.bufferedIndex = 0;
    state33.allBuffers = true;
    state33.allNoop = true;
}
WritableState.prototype.getBuffer = function getBuffer() {
    return this.buffered.slice(this.bufferedIndex);
};
Object.defineProperty(WritableState.prototype, "bufferedRequestCount", {
    get () {
        return this.buffered.length - this.bufferedIndex;
    }
});
function Writable(options) {
    const isDuplex = isDuplexStream(this);
    if (!isDuplex && !Function.prototype[Symbol.hasInstance].call(Writable, this)) {
        return new Writable(options);
    }
    this._writableState = new WritableState(options, this, isDuplex);
    if (options) {
        if (typeof options.write === "function") {
            this._write = options.write;
        }
        if (typeof options.writev === "function") {
            this._writev = options.writev;
        }
        if (typeof options.destroy === "function") {
            this._destroy = options.destroy;
        }
        if (typeof options.final === "function") {
            this._final = options.final;
        }
        if (typeof options.construct === "function") {
            this._construct = options.construct;
        }
        if (options.signal) {
            addAbortSignalNoValidate(options.signal, this);
        }
    }
    Stream.call(this, options);
    __default10.construct(this, ()=>{
        const state34 = this._writableState;
        if (!state34.writing) {
            clearBuffer(this, state34);
        }
        finishMaybe(this, state34);
    });
}
Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function(object) {
        if (Function.prototype[Symbol.hasInstance].call(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
    }
});
Writable.prototype.pipe = function() {
    errorOrDestroy2(this, new ERR_STREAM_CANNOT_PIPE());
};
function _write(stream, chunk, encoding, cb) {
    const state35 = stream._writableState;
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = state35.defaultEncoding;
    } else {
        if (!encoding) {
            encoding = state35.defaultEncoding;
        } else if (encoding !== "buffer" && !Buffer1.isEncoding(encoding)) {
            throw new ERR_UNKNOWN_ENCODING(encoding);
        }
        if (typeof cb !== "function") {
            cb = nop2;
        }
    }
    if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
    } else if (!state35.objectMode) {
        if (typeof chunk === "string") {
            if (state35.decodeStrings !== false) {
                chunk = Buffer1.from(chunk, encoding);
                encoding = "buffer";
            }
        } else if (chunk instanceof Buffer1) {
            encoding = "buffer";
        } else if (isUint8Array(chunk)) {
            chunk = _uint8ArrayToBuffer(chunk);
            encoding = "buffer";
        } else {
            throw new ERR_INVALID_ARG_TYPE("chunk", [
                "string",
                "Buffer",
                "Uint8Array"
            ], chunk);
        }
    }
    let err47;
    if (state35.ending) {
        err47 = new ERR_STREAM_WRITE_AFTER_END();
    } else if (state35.destroyed) {
        err47 = new ERR_STREAM_DESTROYED("write");
    }
    if (err47) {
        nextTick2(cb, err47);
        errorOrDestroy2(stream, err47, true);
        return err47;
    }
    state35.pendingcb++;
    return writeOrBuffer(stream, state35, chunk, encoding, cb);
}
Writable.prototype.write = function(chunk, encoding, cb) {
    return _write(this, chunk, encoding, cb) === true;
};
Writable.prototype.cork = function() {
    this._writableState.corked++;
};
Writable.prototype.uncork = function() {
    const state36 = this._writableState;
    if (state36.corked) {
        state36.corked--;
        if (!state36.writing) {
            clearBuffer(this, state36);
        }
    }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") {
        encoding = encoding.toLowerCase();
    }
    if (!Buffer1.isEncoding(encoding)) {
        throw new ERR_UNKNOWN_ENCODING(encoding);
    }
    this._writableState.defaultEncoding = encoding;
    return this;
};
function writeOrBuffer(stream, state37, chunk, encoding, callback) {
    const len = state37.objectMode ? 1 : chunk.length;
    state37.length += len;
    const ret = state37.length < state37.highWaterMark;
    if (!ret) {
        state37.needDrain = true;
    }
    if (state37.writing || state37.corked || state37.errored || !state37.constructed) {
        state37.buffered.push({
            chunk,
            encoding,
            callback
        });
        if (state37.allBuffers && encoding !== "buffer") {
            state37.allBuffers = false;
        }
        if (state37.allNoop && callback !== nop2) {
            state37.allNoop = false;
        }
    } else {
        state37.writelen = len;
        state37.writecb = callback;
        state37.writing = true;
        state37.sync = true;
        stream._write(chunk, encoding, state37.onwrite);
        state37.sync = false;
    }
    return ret && !state37.errored && !state37.destroyed;
}
function doWrite(stream, state38, writev1, len, chunk, encoding, cb) {
    state38.writelen = len;
    state38.writecb = cb;
    state38.writing = true;
    state38.sync = true;
    if (state38.destroyed) {
        state38.onwrite(new ERR_STREAM_DESTROYED("write"));
    } else if (writev1) {
        stream._writev(chunk, state38.onwrite);
    } else {
        stream._write(chunk, encoding, state38.onwrite);
    }
    state38.sync = false;
}
function onwriteError(stream, state39, er, cb) {
    --state39.pendingcb;
    cb(er);
    errorBuffer(state39);
    errorOrDestroy2(stream, er);
}
function onwrite(stream, er) {
    const state40 = stream._writableState;
    const sync = state40.sync;
    const cb = state40.writecb;
    if (typeof cb !== "function") {
        errorOrDestroy2(stream, new ERR_MULTIPLE_CALLBACK());
        return;
    }
    state40.writing = false;
    state40.writecb = null;
    state40.length -= state40.writelen;
    state40.writelen = 0;
    if (er) {
        er.stack;
        if (!state40.errored) {
            state40.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
            stream._readableState.errored = er;
        }
        if (sync) {
            nextTick2(onwriteError, stream, state40, er, cb);
        } else {
            onwriteError(stream, state40, er, cb);
        }
    } else {
        if (state40.buffered.length > state40.bufferedIndex) {
            clearBuffer(stream, state40);
        }
        if (sync) {
            if (state40.afterWriteTickInfo !== null && state40.afterWriteTickInfo.cb === cb) {
                state40.afterWriteTickInfo.count++;
            } else {
                state40.afterWriteTickInfo = {
                    count: 1,
                    cb,
                    stream,
                    state: state40
                };
                nextTick2(afterWriteTick, state40.afterWriteTickInfo);
            }
        } else {
            afterWrite(stream, state40, 1, cb);
        }
    }
}
function afterWriteTick({ stream , state: state41 , count: count2 , cb  }) {
    state41.afterWriteTickInfo = null;
    return afterWrite(stream, state41, count2, cb);
}
function afterWrite(stream, state42, count3, cb) {
    const needDrain = !state42.ending && !stream.destroyed && state42.length === 0 && state42.needDrain;
    if (needDrain) {
        state42.needDrain = false;
        stream.emit("drain");
    }
    while(count3-- > 0){
        state42.pendingcb--;
        cb();
    }
    if (state42.destroyed) {
        errorBuffer(state42);
    }
    finishMaybe(stream, state42);
}
function errorBuffer(state43) {
    if (state43.writing) {
        return;
    }
    for(let n24 = state43.bufferedIndex; n24 < state43.buffered.length; ++n24){
        const { chunk , callback  } = state43.buffered[n24];
        const len = state43.objectMode ? 1 : chunk.length;
        state43.length -= len;
        callback(new ERR_STREAM_DESTROYED("write"));
    }
    const onfinishCallbacks = state43[kOnFinished].splice(0);
    for(let i91 = 0; i91 < onfinishCallbacks.length; i91++){
        onfinishCallbacks[i91](new ERR_STREAM_DESTROYED("end"));
    }
    resetBuffer(state43);
}
function clearBuffer(stream, state44) {
    if (state44.corked || state44.bufferProcessing || state44.destroyed || !state44.constructed) {
        return;
    }
    const { buffered , bufferedIndex , objectMode  } = state44;
    const bufferedLength = buffered.length - bufferedIndex;
    if (!bufferedLength) {
        return;
    }
    let i92 = bufferedIndex;
    state44.bufferProcessing = true;
    if (bufferedLength > 1 && stream._writev) {
        state44.pendingcb -= bufferedLength - 1;
        const callback = state44.allNoop ? nop2 : (err48)=>{
            for(let n25 = i92; n25 < buffered.length; ++n25){
                buffered[n25].callback(err48);
            }
        };
        const chunks = state44.allNoop && i92 === 0 ? buffered : buffered.slice(i92);
        chunks.allBuffers = state44.allBuffers;
        doWrite(stream, state44, true, state44.length, chunks, "", callback);
        resetBuffer(state44);
    } else {
        do {
            const { chunk , encoding , callback  } = buffered[i92];
            buffered[i92++] = null;
            const len = objectMode ? 1 : chunk.length;
            doWrite(stream, state44, false, len, chunk, encoding, callback);
        }while (i92 < buffered.length && !state44.writing)
        if (i92 === buffered.length) {
            resetBuffer(state44);
        } else if (i92 > 256) {
            buffered.splice(0, i92);
            state44.bufferedIndex = 0;
        } else {
            state44.bufferedIndex = i92;
        }
    }
    state44.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
    if (this._writev) {
        this._writev([
            {
                chunk,
                encoding
            }
        ], cb);
    } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
    }
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
    const state45 = this._writableState;
    if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    let err49;
    if (chunk !== null && chunk !== undefined) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error) {
            err49 = ret;
        }
    }
    if (state45.corked) {
        state45.corked = 1;
        this.uncork();
    }
    if (err49) {} else if (!state45.errored && !state45.ending) {
        state45.ending = true;
        finishMaybe(this, state45, true);
        state45.ended = true;
    } else if (state45.finished) {
        err49 = new ERR_STREAM_ALREADY_FINISHED("end");
    } else if (state45.destroyed) {
        err49 = new ERR_STREAM_DESTROYED("end");
    }
    if (typeof cb === "function") {
        if (err49 || state45.finished) {
            nextTick1(cb, err49);
        } else {
            state45[kOnFinished].push(cb);
        }
    }
    return this;
};
function needFinish(state46) {
    return state46.ending && state46.constructed && state46.length === 0 && !state46.errored && state46.buffered.length === 0 && !state46.finished && !state46.writing && !state46.errorEmitted && !state46.closeEmitted;
}
function callFinal(stream, state47) {
    let called = false;
    function onFinish1(err50) {
        if (called) {
            errorOrDestroy2(stream, err50 ?? ERR_MULTIPLE_CALLBACK());
            return;
        }
        called = true;
        state47.pendingcb--;
        if (err50) {
            const onfinishCallbacks = state47[kOnFinished].splice(0);
            for(let i93 = 0; i93 < onfinishCallbacks.length; i93++){
                onfinishCallbacks[i93](err50);
            }
            errorOrDestroy2(stream, err50, state47.sync);
        } else if (needFinish(state47)) {
            state47.prefinished = true;
            stream.emit("prefinish");
            state47.pendingcb++;
            nextTick2(finish, stream, state47);
        }
    }
    state47.sync = true;
    state47.pendingcb++;
    try {
        const result = stream._final(onFinish1);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick2(onFinish1, null);
                }, function(err51) {
                    nextTick2(onFinish1, err51);
                });
            }
        }
    } catch (err52) {
        onFinish1(stream, state47, err52);
    }
    state47.sync = false;
}
function prefinish(stream, state48) {
    if (!state48.prefinished && !state48.finalCalled) {
        if (typeof stream._final === "function" && !state48.destroyed) {
            state48.finalCalled = true;
            callFinal(stream, state48);
        } else {
            state48.prefinished = true;
            stream.emit("prefinish");
        }
    }
}
function finishMaybe(stream, state49, sync) {
    if (needFinish(state49)) {
        prefinish(stream, state49);
        if (state49.pendingcb === 0 && needFinish(state49)) {
            state49.pendingcb++;
            if (sync) {
                nextTick2(finish, stream, state49);
            } else {
                finish(stream, state49);
            }
        }
    }
}
function finish(stream, state50) {
    state50.pendingcb--;
    state50.finished = true;
    const onfinishCallbacks = state50[kOnFinished].splice(0);
    for(let i94 = 0; i94 < onfinishCallbacks.length; i94++){
        onfinishCallbacks[i94]();
    }
    stream.emit("finish");
    if (state50.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
            stream.destroy();
        }
    }
}
Object.defineProperties(Writable.prototype, {
    destroyed: {
        get () {
            return this._writableState ? this._writableState.destroyed : false;
        },
        set (value) {
            if (this._writableState) {
                this._writableState.destroyed = value;
            }
        }
    },
    writable: {
        get () {
            const w15 = this._writableState;
            return !!w15 && w15.writable !== false && !w15.destroyed && !w15.errored && !w15.ending && !w15.ended;
        },
        set (val) {
            if (this._writableState) {
                this._writableState.writable = !!val;
            }
        }
    },
    writableFinished: {
        get () {
            return this._writableState ? this._writableState.finished : false;
        }
    },
    writableObjectMode: {
        get () {
            return this._writableState ? this._writableState.objectMode : false;
        }
    },
    writableBuffer: {
        get () {
            return this._writableState && this._writableState.getBuffer();
        }
    },
    writableEnded: {
        get () {
            return this._writableState ? this._writableState.ending : false;
        }
    },
    writableNeedDrain: {
        get () {
            const wState = this._writableState;
            if (!wState) return false;
            return !wState.destroyed && !wState.ending && wState.needDrain;
        }
    },
    writableHighWaterMark: {
        get () {
            return this._writableState && this._writableState.highWaterMark;
        }
    },
    writableCorked: {
        get () {
            return this._writableState ? this._writableState.corked : 0;
        }
    },
    writableLength: {
        get () {
            return this._writableState && this._writableState.length;
        }
    }
});
const destroy1 = __default10.destroy;
Writable.prototype.destroy = function(err53, cb) {
    const state51 = this._writableState;
    if (!state51.destroyed && (state51.bufferedIndex < state51.buffered.length || state51[kOnFinished].length)) {
        nextTick1(errorBuffer, state51);
    }
    destroy1.call(this, err53, cb);
    return this;
};
Writable.prototype._undestroy = __default10.undestroy;
Writable.prototype._destroy = function(err54, cb) {
    cb(err54);
};
Writable.prototype[EventEmitter.captureRejectionSymbol] = function(err55) {
    this.destroy(err55);
};
Writable.WritableState = WritableState;
Object.setPrototypeOf(Duplex.prototype, Readable.prototype);
Object.setPrototypeOf(Duplex, Readable);
{
    for (const method of Object.keys(Writable.prototype)){
        if (!Duplex.prototype[method]) {
            Duplex.prototype[method] = Writable.prototype[method];
        }
    }
}function Duplex(options) {
    if (!(this instanceof Duplex)) {
        return new Duplex(options);
    }
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
        if (options.readable === false) {
            this.readable = false;
        }
        if (options.writable === false) {
            this.writable = false;
        }
        if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
        }
    }
}
Object.defineProperties(Duplex.prototype, {
    writable: Object.getOwnPropertyDescriptor(Writable.prototype, "writable"),
    writableHighWaterMark: Object.getOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark"),
    writableObjectMode: Object.getOwnPropertyDescriptor(Writable.prototype, "writableObjectMode"),
    writableBuffer: Object.getOwnPropertyDescriptor(Writable.prototype, "writableBuffer"),
    writableLength: Object.getOwnPropertyDescriptor(Writable.prototype, "writableLength"),
    writableFinished: Object.getOwnPropertyDescriptor(Writable.prototype, "writableFinished"),
    writableCorked: Object.getOwnPropertyDescriptor(Writable.prototype, "writableCorked"),
    writableEnded: Object.getOwnPropertyDescriptor(Writable.prototype, "writableEnded"),
    writableNeedDrain: Object.getOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain"),
    destroyed: {
        get () {
            if (this._readableState === undefined || this._writableState === undefined) {
                return false;
            }
            return this._readableState.destroyed && this._writableState.destroyed;
        },
        set (value) {
            if (this._readableState && this._writableState) {
                this._readableState.destroyed = value;
                this._writableState.destroyed = value;
            }
        }
    }
});
class Duplexify extends Duplex {
    constructor(options){
        super(options);
        if (options?.readable === false) {
            this._readableState.readable = false;
            this._readableState.ended = true;
            this._readableState.endEmitted = true;
        }
        if (options?.writable === false) {
            this._writableState.writable = false;
            this._writableState.ending = true;
            this._writableState.ended = true;
            this._writableState.finished = true;
        }
    }
}
function duplexify(body, name40) {
    if (isDuplexNodeStream(body)) {
        return body;
    }
    if (isReadableNodeStream(body)) {
        return _duplexify({
            readable: body
        });
    }
    if (isWritableNodeStream(body)) {
        return _duplexify({
            writable: body
        });
    }
    if (isNodeStream(body)) {
        return _duplexify({
            writable: false,
            readable: false
        });
    }
    if (typeof body === "function") {
        const { value , write: write1 , final: __final1 , destroy: destroy2  } = fromAsyncGen(body);
        if (isIterable(value)) {
            return _from1(Duplexify, value, {
                objectMode: true,
                write: write1,
                final: __final1,
                destroy: destroy2
            });
        }
        const then = value?.then;
        if (typeof then === "function") {
            let d3;
            const promise = then.call(value, (val)=>{
                if (val != null) {
                    throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
                }
            }, (err56)=>{
                destroyer(d3, err56);
            });
            return d3 = new Duplexify({
                objectMode: true,
                readable: false,
                write: write1,
                final (cb) {
                    __final1(async ()=>{
                        try {
                            await promise;
                            nextTick1(cb, null);
                        } catch (err57) {
                            nextTick1(cb, err57);
                        }
                    });
                },
                destroy: destroy2
            });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name40, value);
    }
    if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
    }
    if (isIterable(body)) {
        return _from1(Duplexify, body, {
            objectMode: true,
            writable: false
        });
    }
    if (typeof body?.writable === "object" || typeof body?.readable === "object") {
        const readable = body?.readable ? isReadableNodeStream(body?.readable) ? body?.readable : duplexify(body.readable) : undefined;
        const writable = body?.writable ? isWritableNodeStream(body?.writable) ? body?.writable : duplexify(body.writable) : undefined;
        return _duplexify({
            readable,
            writable
        });
    }
    const then = body?.then;
    if (typeof then === "function") {
        let d4;
        then.call(body, (val)=>{
            if (val != null) {
                d4.push(val);
            }
            d4.push(null);
        }, (err58)=>{
            destroyer(d4, err58);
        });
        return d4 = new Duplexify({
            objectMode: true,
            writable: false,
            read () {}
        });
    }
    throw new ERR_INVALID_ARG_TYPE(name40, [
        "Blob",
        "ReadableStream",
        "WritableStream",
        "Stream",
        "Iterable",
        "AsyncIterable",
        "Function",
        "{ readable, writable } pair",
        "Promise", 
    ], body);
}
function fromAsyncGen(fn) {
    let { promise , resolve: resolve14  } = createDeferredPromise();
    const ac = new AbortController();
    const signal = ac.signal;
    const value = fn(async function*() {
        while(true){
            const _promise = promise;
            promise = null;
            const { chunk , done , cb  } = await _promise;
            nextTick2(cb);
            if (done) return;
            if (signal.aborted) throw new AbortError();
            ({ promise , resolve: resolve14  } = createDeferredPromise());
            yield chunk;
        }
    }(), {
        signal
    });
    return {
        value,
        write (chunk, encoding, cb) {
            const _resolve = resolve14;
            resolve14 = null;
            _resolve({
                chunk,
                done: false,
                cb
            });
        },
        final (cb) {
            const _resolve = resolve14;
            resolve14 = null;
            _resolve({
                done: true,
                cb
            });
        },
        destroy (err59, cb) {
            ac.abort();
            cb(err59);
        }
    };
}
function _duplexify(pair) {
    const r21 = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable;
    const w16 = pair.writable;
    let readable = !!isReadable1(r21);
    let writable = !!isWritable1(w16);
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d5;
    function onfinished(err60) {
        const cb = onclose;
        onclose = null;
        if (cb) {
            cb(err60);
        } else if (err60) {
            d5.destroy(err60);
        } else if (!readable && !writable) {
            d5.destroy();
        }
    }
    d5 = new Duplexify({
        readableObjectMode: !!r21?.readableObjectMode,
        writableObjectMode: !!w16?.writableObjectMode,
        readable,
        writable
    });
    if (writable) {
        eos(w16, (err61)=>{
            writable = false;
            if (err61) {
                destroyer(r21, err61);
            }
            onfinished(err61);
        });
        d5._write = function(chunk, encoding, callback) {
            if (w16.write(chunk, encoding)) {
                callback();
            } else {
                ondrain = callback;
            }
        };
        d5._final = function(callback) {
            w16.end();
            onfinish = callback;
        };
        w16.on("drain", function() {
            if (ondrain) {
                const cb = ondrain;
                ondrain = null;
                cb();
            }
        });
        w16.on("finish", function() {
            if (onfinish) {
                const cb = onfinish;
                onfinish = null;
                cb();
            }
        });
    }
    if (readable) {
        eos(r21, (err62)=>{
            readable = false;
            if (err62) {
                destroyer(r21, err62);
            }
            onfinished(err62);
        });
        r21.on("readable", function() {
            if (onreadable) {
                const cb = onreadable;
                onreadable = null;
                cb();
            }
        });
        r21.on("end", function() {
            d5.push(null);
        });
        d5._read = function() {
            while(true){
                const buf = r21.read();
                if (buf === null) {
                    onreadable = d5._read;
                    return;
                }
                if (!d5.push(buf)) {
                    return;
                }
            }
        };
    }
    d5._destroy = function(err63, callback) {
        if (!err63 && onclose !== null) {
            err63 = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
            callback(err63);
        } else {
            onclose = callback;
            destroyer(w16, err63);
            destroyer(r21, err63);
        }
    };
    return d5;
}
function duplexFrom(body) {
    return duplexify(body, "body");
}
Duplex.from = duplexFrom;
Object.setPrototypeOf(Transform.prototype, Duplex.prototype);
Object.setPrototypeOf(Transform, Duplex);
const kCallback = Symbol("kCallback");
function Transform(options) {
    if (!(this instanceof Transform)) {
        return new Transform(options);
    }
    Duplex.call(this, options);
    this._readableState.sync = false;
    this[kCallback] = null;
    if (options) {
        if (typeof options.transform === "function") {
            this._transform = options.transform;
        }
        if (typeof options.flush === "function") {
            this._flush = options.flush;
        }
    }
    this.on("prefinish", prefinish1);
}
function __final(cb) {
    let called = false;
    if (typeof this._flush === "function" && !this.destroyed) {
        const result = this._flush((er, data10)=>{
            called = true;
            if (er) {
                if (cb) {
                    cb(er);
                } else {
                    this.destroy(er);
                }
                return;
            }
            if (data10 != null) {
                this.push(data10);
            }
            this.push(null);
            if (cb) {
                cb();
            }
        });
        if (result !== undefined && result !== null) {
            try {
                const then = result.then;
                if (typeof then === "function") {
                    then.call(result, (data11)=>{
                        if (called) {
                            return;
                        }
                        if (data11 != null) {
                            this.push(data11);
                        }
                        this.push(null);
                        if (cb) {
                            nextTick2(cb);
                        }
                    }, (err64)=>{
                        if (cb) {
                            nextTick2(cb, err64);
                        } else {
                            nextTick2(()=>this.destroy(err64)
                            );
                        }
                    });
                }
            } catch (err65) {
                nextTick2(()=>this.destroy(err65)
                );
            }
        }
    } else {
        this.push(null);
        if (cb) {
            cb();
        }
    }
}
function prefinish1() {
    if (this._final !== __final) {
        __final.call(this);
    }
}
Transform.prototype._final = __final;
Transform.prototype._transform = function(chunk, encoding, callback) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
};
Transform.prototype._write = function(chunk, encoding, callback) {
    const rState = this._readableState;
    const wState = this._writableState;
    const length = rState.length;
    let called = false;
    const result = this._transform(chunk, encoding, (err66, val)=>{
        called = true;
        if (err66) {
            callback(err66);
            return;
        }
        if (val != null) {
            this.push(val);
        }
        if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
            callback();
        } else {
            this[kCallback] = callback;
        }
    });
    if (result !== undefined && result != null) {
        try {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, (val)=>{
                    if (called) {
                        return;
                    }
                    if (val != null) {
                        this.push(val);
                    }
                    if (wState.ended || length === rState.length || rState.length < rState.highWaterMark || rState.length === 0) {
                        nextTick1(callback);
                    } else {
                        this[kCallback] = callback;
                    }
                }, (err67)=>{
                    nextTick1(callback, err67);
                });
            }
        } catch (err68) {
            nextTick1(callback, err68);
        }
    }
};
Transform.prototype._read = function() {
    if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
    }
};
Object.setPrototypeOf(PassThrough.prototype, Transform.prototype);
Object.setPrototypeOf(PassThrough, Transform);
function PassThrough(options) {
    if (!(this instanceof PassThrough)) {
        return new PassThrough(options);
    }
    Transform.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
};
function destroyer1(stream, reading, writing, callback) {
    callback = once(callback);
    let finished2 = false;
    stream.on("close", ()=>{
        finished2 = true;
    });
    eos(stream, {
        readable: reading,
        writable: writing
    }, (err69)=>{
        finished2 = !err69;
        const rState = stream._readableState;
        if (err69 && err69.code === "ERR_STREAM_PREMATURE_CLOSE" && reading && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            stream.once("end", callback).once("error", callback);
        } else {
            callback(err69);
        }
    });
    return (err70)=>{
        if (finished2) return;
        finished2 = true;
        __default10.destroyer(stream, err70);
        callback(err70 || new ERR_STREAM_DESTROYED("pipe"));
    };
}
function popCallback(streams) {
    validateCallback(streams[streams.length - 1]);
    return streams.pop();
}
function makeAsyncIterable(val) {
    if (isIterable(val)) {
        return val;
    } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
    }
    throw new ERR_INVALID_ARG_TYPE("val", [
        "Readable",
        "Iterable",
        "AsyncIterable"
    ], val);
}
async function* fromReadable(val) {
    yield* Readable.prototype[Symbol.asyncIterator].call(val);
}
async function pump(iterable, writable, finish1) {
    let error8;
    let onresolve = null;
    const resume1 = (err71)=>{
        if (err71) {
            error8 = err71;
        }
        if (onresolve) {
            const callback = onresolve;
            onresolve = null;
            callback();
        }
    };
    const wait = ()=>new Promise((resolve15, reject)=>{
            if (error8) {
                reject(error8);
            } else {
                onresolve = ()=>{
                    if (error8) {
                        reject(error8);
                    } else {
                        resolve15();
                    }
                };
            }
        })
    ;
    writable.on("drain", resume1);
    const cleanup = eos(writable, {
        readable: false
    }, resume1);
    try {
        if (writable.writableNeedDrain) {
            await wait();
        }
        for await (const chunk of iterable){
            if (!writable.write(chunk)) {
                await wait();
            }
        }
        writable.end();
        await wait();
        finish1();
    } catch (err72) {
        finish1(error8 !== err72 ? aggregateTwoErrors(error8, err72) : err72);
    } finally{
        cleanup();
        writable.off("drain", resume1);
    }
}
function pipeline(...streams) {
    const callback = once(popCallback(streams));
    if (Array.isArray(streams[0]) && streams.length === 1) {
        streams = streams[0];
    }
    return pipelineImpl(streams, callback);
}
function pipelineImpl(streams, callback, opts) {
    if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
    }
    const ac = new AbortController();
    const signal = ac.signal;
    const outerSignal = opts?.signal;
    validateAbortSignal(outerSignal, "options.signal");
    function abort() {
        finishImpl(new AbortError());
    }
    outerSignal?.addEventListener("abort", abort);
    let error9;
    let value;
    const destroys = [];
    let finishCount = 0;
    function finish2(err73) {
        finishImpl(err73, --finishCount === 0);
    }
    function finishImpl(err74, __final2) {
        if (err74 && (!error9 || error9.code === "ERR_STREAM_PREMATURE_CLOSE")) {
            error9 = err74;
        }
        if (!error9 && !__final2) {
            return;
        }
        while(destroys.length){
            destroys.shift()(error9);
        }
        outerSignal?.removeEventListener("abort", abort);
        ac.abort();
        if (__final2) {
            callback(error9, value);
        }
    }
    let ret;
    for(let i95 = 0; i95 < streams.length; i95++){
        const stream = streams[i95];
        const reading = i95 < streams.length - 1;
        const writing = i95 > 0;
        if (isNodeStream(stream)) {
            finishCount++;
            destroys.push(destroyer1(stream, reading, writing, finish2));
        }
        if (i95 === 0) {
            if (typeof stream === "function") {
                ret = stream({
                    signal
                });
                if (!isIterable(ret)) {
                    throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
                }
            } else if (isIterable(stream) || isReadableNodeStream(stream)) {
                ret = stream;
            } else {
                ret = Duplex.from(stream);
            }
        } else if (typeof stream === "function") {
            ret = makeAsyncIterable(ret);
            ret = stream(ret, {
                signal
            });
            if (reading) {
                if (!isIterable(ret, true)) {
                    throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i95 - 1}]`, ret);
                }
            } else {
                const pt = new PassThrough({
                    objectMode: true
                });
                const then = ret?.then;
                if (typeof then === "function") {
                    then.call(ret, (val)=>{
                        value = val;
                        pt.end(val);
                    }, (err75)=>{
                        pt.destroy(err75);
                    });
                } else if (isIterable(ret, true)) {
                    finishCount++;
                    pump(ret, pt, finish2);
                } else {
                    throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
                }
                ret = pt;
                finishCount++;
                destroys.push(destroyer1(ret, false, true, finish2));
            }
        } else if (isNodeStream(stream)) {
            if (isReadableNodeStream(ret)) {
                ret.pipe(stream);
                if (stream === stdio.stdout || stream === stdio.stderr) {
                    ret.on("end", ()=>stream.end()
                    );
                }
            } else {
                ret = makeAsyncIterable(ret);
                finishCount++;
                pump(ret, stream, finish2);
            }
            ret = stream;
        } else {
            ret = Duplex.from(stream);
        }
    }
    if (signal?.aborted || outerSignal?.aborted) {
        nextTick2(abort);
    }
    return ret;
}
class ComposeDuplex extends Duplex {
    constructor(options){
        super(options);
        if (options?.readable === false) {
            this._readableState.readable = false;
            this._readableState.ended = true;
            this._readableState.endEmitted = true;
        }
        if (options?.writable === false) {
            this._writableState.writable = false;
            this._writableState.ending = true;
            this._writableState.ended = true;
            this._writableState.finished = true;
        }
    }
}
function compose(...streams) {
    if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
    }
    if (streams.length === 1) {
        return Duplex.from(streams[0]);
    }
    const orgStreams = [
        ...streams
    ];
    if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
    }
    if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
    }
    for(let n26 = 0; n26 < streams.length; ++n26){
        if (!isNodeStream(streams[n26])) {
            continue;
        }
        if (n26 < streams.length - 1 && !isReadable1(streams[n26])) {
            throw new ERR_INVALID_ARG_VALUE(`streams[${n26}]`, orgStreams[n26], "must be readable");
        }
        if (n26 > 0 && !isWritable1(streams[n26])) {
            throw new ERR_INVALID_ARG_VALUE(`streams[${n26}]`, orgStreams[n26], "must be writable");
        }
    }
    let ondrain;
    let onfinish;
    let onreadable;
    let onclose;
    let d6;
    function onfinished(err76) {
        const cb = onclose;
        onclose = null;
        if (cb) {
            cb(err76);
        } else if (err76) {
            d6.destroy(err76);
        } else if (!readable && !writable) {
            d6.destroy();
        }
    }
    const head = streams[0];
    const tail = pipeline(streams, onfinished);
    const writable = !!isWritable1(head);
    const readable = !!isReadable1(tail);
    d6 = new ComposeDuplex({
        writableObjectMode: !!head?.writableObjectMode,
        readableObjectMode: !!tail?.writableObjectMode,
        writable,
        readable
    });
    if (writable) {
        d6._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
                callback();
            } else {
                ondrain = callback;
            }
        };
        d6._final = function(callback) {
            head.end();
            onfinish = callback;
        };
        head.on("drain", function() {
            if (ondrain) {
                const cb = ondrain;
                ondrain = null;
                cb();
            }
        });
        tail.on("finish", function() {
            if (onfinish) {
                const cb = onfinish;
                onfinish = null;
                cb();
            }
        });
    }
    if (readable) {
        tail.on("readable", function() {
            if (onreadable) {
                const cb = onreadable;
                onreadable = null;
                cb();
            }
        });
        tail.on("end", function() {
            d6.push(null);
        });
        d6._read = function() {
            while(true){
                const buf = tail.read();
                if (buf === null) {
                    onreadable = d6._read;
                    return;
                }
                if (!d6.push(buf)) {
                    return;
                }
            }
        };
    }
    d6._destroy = function(err77, callback) {
        if (!err77 && onclose !== null) {
            err77 = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
            callback(err77);
        } else {
            onclose = callback;
            destroyer(tail, err77);
        }
    };
    return d6;
}
function pipeline1(...streams) {
    return new Promise((resolve16, reject)=>{
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg)) {
            const options = streams.pop();
            signal = options.signal;
            end = options.end;
        }
        pipelineImpl(streams, (err78, value)=>{
            if (err78) {
                reject(err78);
            } else {
                resolve16(value);
            }
        }, {
            signal,
            end
        });
    });
}
function finished(stream, opts) {
    return new Promise((resolve17, reject)=>{
        eos(stream, opts, (err79)=>{
            if (err79) {
                reject(err79);
            } else {
                resolve17();
            }
        });
    });
}
const __default13 = {
    finished,
    pipeline: pipeline1
};
const { custom: customPromisify  } = promisify;
Stream.isDisturbed = isDisturbed;
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex;
Stream.Transform = Transform;
Stream.PassThrough = PassThrough;
Stream.pipeline = pipeline;
Stream.addAbortSignal = addAbortSignal;
Stream.finished = eos;
Stream.destroy = destroyer;
Stream.compose = compose;
Object.defineProperty(Stream, "promises", {
    configurable: true,
    enumerable: true,
    get () {
        return __default13;
    }
});
Object.defineProperty(pipeline, customPromisify, {
    enumerable: true,
    get () {
        return __default13.pipeline;
    }
});
Object.defineProperty(eos, customPromisify, {
    enumerable: true,
    get () {
        return __default13.finished;
    }
});
Stream.Stream = Stream;
Stream._isUint8Array = isUint8Array;
Stream._uint8ArrayToBuffer = _uint8ArrayToBuffer;
function createWritableStdioStream(writer, name41) {
    const stream = new Writable({
        write (buf, enc, cb) {
            if (!writer) {
                this.destroy(new Error(`Deno.${name41} is not available in this environment`));
                return;
            }
            writer.writeSync(buf instanceof Uint8Array ? buf : Buffer1.from(buf, enc));
            cb();
        },
        destroy (err80, cb) {
            cb(err80);
            this._undestroy();
            if (!this._writableState.emitClose) {
                nextTick(()=>this.emit("close")
                );
            }
        }
    });
    stream.fd = writer?.rid ?? -1;
    stream.destroySoon = stream.destroy;
    stream._isStdio = true;
    stream.once("close", ()=>writer?.close()
    );
    Object.defineProperties(stream, {
        columns: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.(writer?.rid).columns : undefined
        },
        rows: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.(writer?.rid).rows : undefined
        },
        isTTY: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid)
        },
        getWindowSize: {
            enumerable: true,
            configurable: true,
            value: ()=>Deno.isatty?.(writer?.rid) ? Object.values(Deno.consoleSize?.(writer?.rid)) : undefined
        }
    });
    return stream;
}
const stderr = stdio.stderr = createWritableStdioStream(Deno.stderr, "stderr");
const stdout = stdio.stdout = createWritableStdioStream(Deno.stdout, "stdout");
const stdin = stdio.stdin = new Readable({
    highWaterMark: 0,
    emitClose: false,
    read (size) {
        const p14 = Buffer1.alloc(size || 16 * 1024);
        if (!Deno.stdin) {
            this.destroy(new Error("Deno.stdin is not available in this environment"));
            return;
        }
        Deno.stdin.read(p14).then((length)=>{
            this.push(length === null ? null : p14.slice(0, length));
        }, (error10)=>{
            this.destroy(error10);
        });
    }
});
stdin.on("close", ()=>Deno.stdin?.close()
);
stdin.fd = Deno.stdin?.rid ?? -1;
Object.defineProperty(stdin, "isTTY", {
    enumerable: true,
    configurable: true,
    get () {
        return Deno.isatty?.(Deno.stdin.rid);
    }
});
stdin._isRawMode = false;
stdin.setRawMode = (enable)=>{
    setRaw?.(Deno.stdin?.rid, enable);
    stdin._isRawMode = enable;
    return stdin;
};
Object.defineProperty(stdin, "isRaw", {
    enumerable: true,
    configurable: true,
    get () {
        return stdin._isRawMode;
    }
});
function registerDestroyHook(_target, _asyncId, _prop) {}
var constants1;
(function(constants10) {
    constants10[constants10["kInit"] = 0] = "kInit";
    constants10[constants10["kBefore"] = 1] = "kBefore";
    constants10[constants10["kAfter"] = 2] = "kAfter";
    constants10[constants10["kDestroy"] = 3] = "kDestroy";
    constants10[constants10["kPromiseResolve"] = 4] = "kPromiseResolve";
    constants10[constants10["kTotals"] = 5] = "kTotals";
    constants10[constants10["kCheck"] = 6] = "kCheck";
    constants10[constants10["kExecutionAsyncId"] = 7] = "kExecutionAsyncId";
    constants10[constants10["kTriggerAsyncId"] = 8] = "kTriggerAsyncId";
    constants10[constants10["kAsyncIdCounter"] = 9] = "kAsyncIdCounter";
    constants10[constants10["kDefaultTriggerAsyncId"] = 10] = "kDefaultTriggerAsyncId";
    constants10[constants10["kUsesExecutionAsyncResource"] = 11] = "kUsesExecutionAsyncResource";
    constants10[constants10["kStackLength"] = 12] = "kStackLength";
})(constants1 || (constants1 = {}));
const asyncHookFields = new Uint32Array(Object.keys(constants1).length);
function newAsyncId() {
    return ++asyncIdFields[constants1.kAsyncIdCounter];
}
var UidFields;
(function(UidFields1) {
    UidFields1[UidFields1["kExecutionAsyncId"] = 0] = "kExecutionAsyncId";
    UidFields1[UidFields1["kTriggerAsyncId"] = 1] = "kTriggerAsyncId";
    UidFields1[UidFields1["kAsyncIdCounter"] = 2] = "kAsyncIdCounter";
    UidFields1[UidFields1["kDefaultTriggerAsyncId"] = 3] = "kDefaultTriggerAsyncId";
    UidFields1[UidFields1["kUidFieldsCount"] = 4] = "kUidFieldsCount";
})(UidFields || (UidFields = {}));
const asyncIdFields = new Float64Array(Object.keys(UidFields).length);
asyncIdFields[UidFields.kAsyncIdCounter] = 1;
asyncIdFields[UidFields.kDefaultTriggerAsyncId] = -1;
var providerType;
(function(providerType1) {
    providerType1[providerType1["NONE"] = 0] = "NONE";
    providerType1[providerType1["GETADDRINFOREQWRAP"] = 1] = "GETADDRINFOREQWRAP";
    providerType1[providerType1["PIPECONNECTWRAP"] = 2] = "PIPECONNECTWRAP";
    providerType1[providerType1["PIPESERVERWRAP"] = 3] = "PIPESERVERWRAP";
    providerType1[providerType1["PIPEWRAP"] = 4] = "PIPEWRAP";
    providerType1[providerType1["SHUTDOWNWRAP"] = 5] = "SHUTDOWNWRAP";
    providerType1[providerType1["TCPCONNECTWRAP"] = 6] = "TCPCONNECTWRAP";
    providerType1[providerType1["TCPSERVERWRAP"] = 7] = "TCPSERVERWRAP";
    providerType1[providerType1["TCPWRAP"] = 8] = "TCPWRAP";
    providerType1[providerType1["WRITEWRAP"] = 9] = "WRITEWRAP";
})(providerType || (providerType = {}));
const kInvalidAsyncId = -1;
class AsyncWrap {
    provider = providerType.NONE;
    asyncId = kInvalidAsyncId;
    constructor(provider){
        this.provider = provider;
        this.getAsyncId();
    }
    getAsyncId() {
        this.asyncId = this.asyncId === kInvalidAsyncId ? newAsyncId() : this.asyncId;
        return this.asyncId;
    }
    getProviderType() {
        return this.provider;
    }
}
const mod9 = {
    async_hook_fields: asyncHookFields,
    asyncIdFields: asyncIdFields,
    registerDestroyHook: registerDestroyHook,
    constants: constants1,
    newAsyncId: newAsyncId,
    UidFields: UidFields,
    providerType: providerType,
    AsyncWrap: AsyncWrap
};
const mod10 = {};
const v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
const v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
const IPv4Reg = new RegExp(`^${v4Str}$`);
const v6Seg = "(?:[0-9a-fA-F]{1,4})";
const IPv6Reg = new RegExp("^(" + `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` + `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` + `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|` + `(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|` + `(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|` + `(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|` + `(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|` + `(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:))` + ")(%[0-9a-zA-Z-.:]{1,})?$");
function isIPv4(ip) {
    return RegExp.prototype.test.call(IPv4Reg, ip);
}
function isIPv6(ip) {
    return RegExp.prototype.test.call(IPv6Reg, ip);
}
function isIP(ip) {
    if (isIPv4(ip)) {
        return 4;
    }
    if (isIPv6(ip)) {
        return 6;
    }
    return 0;
}
const normalizedArgsSymbol = Symbol("normalizedArgs");
const ARES_AI_CANONNAME = 1 << 0;
const ARES_AI_NUMERICHOST = 1 << 1;
const ARES_AI_PASSIVE = 1 << 2;
const ARES_AI_NUMERICSERV = 1 << 3;
const AI_V4MAPPED = 1 << 4;
const AI_ALL = 1 << 5;
const AI_ADDRCONFIG = 1 << 6;
const ARES_AI_NOSORT = 1 << 7;
const ARES_AI_ENVHOSTS = 1 << 8;
class GetAddrInfoReqWrap extends AsyncWrap {
    callback;
    family;
    hostname;
    oncomplete;
    constructor(){
        super(providerType.GETADDRINFOREQWRAP);
    }
}
function getaddrinfo(req, hostname4, family, _hints, verbatim) {
    (async ()=>{
        const addresses = [];
        const recordTypes = [];
        if (family === 0 || family === 4) {
            recordTypes.push("A");
        }
        if (family === 0 || family === 6) {
            recordTypes.push("AAAA");
        }
        await Promise.allSettled(recordTypes.map((recordType)=>Deno.resolveDns(hostname4, recordType).then((records)=>{
                records.forEach((record)=>addresses.push(record)
                );
            })
        ));
        const error11 = addresses.length ? null : codeMap.get("EAI_NODATA");
        if (!verbatim) {
            addresses.sort((a14, b14)=>{
                if (isIPv4(a14)) {
                    return -1;
                } else if (isIPv4(b14)) {
                    return 1;
                }
                return 0;
            });
        }
        req.oncomplete(error11, addresses);
    })();
}
const mod11 = {
    ARES_AI_CANONNAME: ARES_AI_CANONNAME,
    ARES_AI_NUMERICHOST: ARES_AI_NUMERICHOST,
    ARES_AI_PASSIVE: ARES_AI_PASSIVE,
    ARES_AI_NUMERICSERV: ARES_AI_NUMERICSERV,
    AI_V4MAPPED: AI_V4MAPPED,
    AI_ALL: AI_ALL,
    AI_ADDRCONFIG: AI_ADDRCONFIG,
    ARES_AI_NOSORT: ARES_AI_NOSORT,
    ARES_AI_ENVHOSTS: ARES_AI_ENVHOSTS,
    GetAddrInfoReqWrap: GetAddrInfoReqWrap,
    getaddrinfo: getaddrinfo
};
const mod12 = {};
const mod13 = {};
const mod14 = {};
const mod15 = {};
const mod16 = {};
const mod17 = {};
const mod18 = {};
const mod19 = {};
const mod20 = {};
const mod21 = {};
const mod22 = {};
const mod23 = {};
const mod24 = {};
const mod25 = {};
const mod26 = {};
const mod27 = {};
const mod28 = {};
const mod29 = {};
class HandleWrap extends AsyncWrap {
    constructor(provider){
        super(provider);
    }
    async close(cb = ()=>{}) {
        await this._onClose();
        nextTick2(cb);
    }
    ref() {
        notImplemented();
    }
    unref() {
        notImplemented();
    }
    async _onClose() {}
}
var StreamBaseStateFields;
(function(StreamBaseStateFields1) {
    StreamBaseStateFields1[StreamBaseStateFields1["kReadBytesOrError"] = 0] = "kReadBytesOrError";
    StreamBaseStateFields1[StreamBaseStateFields1["kArrayBufferOffset"] = 1] = "kArrayBufferOffset";
    StreamBaseStateFields1[StreamBaseStateFields1["kBytesWritten"] = 2] = "kBytesWritten";
    StreamBaseStateFields1[StreamBaseStateFields1["kLastWriteWasAsync"] = 3] = "kLastWriteWasAsync";
    StreamBaseStateFields1[StreamBaseStateFields1["kNumStreamBaseStateFields"] = 4] = "kNumStreamBaseStateFields";
})(StreamBaseStateFields || (StreamBaseStateFields = {}));
const kReadBytesOrError = StreamBaseStateFields.kReadBytesOrError;
const kArrayBufferOffset = StreamBaseStateFields.kArrayBufferOffset;
const kBytesWritten = StreamBaseStateFields.kBytesWritten;
const kLastWriteWasAsync = StreamBaseStateFields.kLastWriteWasAsync;
const kNumStreamBaseStateFields = StreamBaseStateFields.kNumStreamBaseStateFields;
const streamBaseState = new Uint8Array(5);
streamBaseState[kLastWriteWasAsync] = 1;
class WriteWrap extends AsyncWrap {
    handle;
    oncomplete;
    async;
    bytes;
    buffer;
    callback;
    _chunks;
    constructor(){
        super(providerType.WRITEWRAP);
    }
}
class ShutdownWrap extends AsyncWrap {
    handle;
    oncomplete;
    callback;
    constructor(){
        super(providerType.SHUTDOWNWRAP);
    }
}
const kStreamBaseField = Symbol("kStreamBaseField");
const SUGGESTED_SIZE = 64 * 1024;
class LibuvStreamWrap extends HandleWrap {
    [kStreamBaseField];
    reading;
    #reading = false;
    #currentReads = new Set();
    #currentWrites = new Set();
    destroyed = false;
    writeQueueSize = 0;
    bytesRead = 0;
    bytesWritten = 0;
    onread;
    constructor(provider, stream){
        super(provider);
        this.#attachToObject(stream);
    }
    readStart() {
        if (!this.#reading) {
            this.#reading = true;
            const readPromise = this.#read();
            this.#currentReads.add(readPromise);
            readPromise.then(()=>this.#currentReads.delete(readPromise)
            , ()=>this.#currentReads.delete(readPromise)
            );
        }
        return 0;
    }
    readStop() {
        this.#reading = false;
        return 0;
    }
    shutdown(req) {
        (async ()=>{
            const status = await this._onClose();
            try {
                req.oncomplete(status);
            } catch  {}
        })();
        return 0;
    }
    useUserBuffer(_userBuf) {
        notImplemented();
    }
    writeBuffer(req, data12) {
        const currentWrite = this.#write(req, data12);
        this.#currentWrites.add(currentWrite);
        currentWrite.then(()=>this.#currentWrites.delete(currentWrite)
        , ()=>this.#currentWrites.delete(currentWrite)
        );
        return 0;
    }
    writev(_req, _chunks, _allBuffers) {
        notImplemented();
    }
    writeAsciiString(req, data13) {
        const buffer19 = new TextEncoder().encode(data13);
        return this.writeBuffer(req, buffer19);
    }
    writeUtf8String(req, data14) {
        const buffer20 = new TextEncoder().encode(data14);
        return this.writeBuffer(req, buffer20);
    }
    writeUcs2String(_req, _data) {
        notImplemented();
    }
    writeLatin1String(req, data15) {
        const buffer21 = Buffer1.from(data15, "latin1");
        return this.writeBuffer(req, buffer21);
    }
    async _onClose() {
        let status = 0;
        this.#reading = false;
        try {
            this[kStreamBaseField]?.close();
        } catch  {
            status = codeMap.get("ENOTCONN");
        }
        await Promise.allSettled(this.#currentWrites);
        await Promise.allSettled(this.#currentReads);
        return status;
    }
     #attachToObject(stream) {
        this[kStreamBaseField] = stream;
    }
    async #read() {
        let buf = new Uint8Array(SUGGESTED_SIZE);
        let nread;
        try {
            nread = await this[kStreamBaseField].read(buf);
        } catch (e) {
            if (e instanceof Deno.errors.Interrupted || e instanceof Deno.errors.BadResource) {
                nread = codeMap.get("EOF");
            } else {
                nread = codeMap.get("UNKNOWN");
            }
            buf = new Uint8Array(0);
        }
        nread ??= codeMap.get("EOF");
        streamBaseState[kReadBytesOrError] = nread;
        if (nread > 0) {
            this.bytesRead += nread;
        }
        buf = buf.slice(0, nread);
        streamBaseState[kArrayBufferOffset] = 0;
        try {
            this.onread(buf, nread);
        } catch  {}
        if (nread >= 0 && this.#reading) {
            const readPromise = this.#read();
            this.#currentReads.add(readPromise);
            readPromise.then(()=>this.#currentReads.delete(readPromise)
            , ()=>this.#currentReads.delete(readPromise)
            );
        }
    }
    async #write(req, data16) {
        const { byteLength  } = data16;
        try {
            await writeAll(this[kStreamBaseField], data16);
        } catch  {
            const status = codeMap.get("UNKNOWN");
            try {
                req.oncomplete(status);
            } catch  {}
            return;
        }
        streamBaseState[kBytesWritten] = byteLength;
        this.bytesWritten += byteLength;
        try {
            req.oncomplete(0);
        } catch  {}
        return;
    }
}
const mod30 = {
    kReadBytesOrError: kReadBytesOrError,
    kArrayBufferOffset: kArrayBufferOffset,
    kBytesWritten: kBytesWritten,
    kLastWriteWasAsync: kLastWriteWasAsync,
    kNumStreamBaseStateFields: kNumStreamBaseStateFields,
    streamBaseState: streamBaseState,
    WriteWrap: WriteWrap,
    ShutdownWrap: ShutdownWrap,
    kStreamBaseField: kStreamBaseField,
    LibuvStreamWrap: LibuvStreamWrap
};
class ConnectionWrap extends LibuvStreamWrap {
    onconnection = null;
    constructor(provider, object){
        super(provider, object);
    }
    afterConnect(req1, status) {
        const isSuccessStatus = !status;
        const readable = isSuccessStatus;
        const writable = isSuccessStatus;
        try {
            req1.oncomplete(status, this, req1, readable, writable);
        } catch  {}
        return;
    }
}
var socketType;
(function(socketType2) {
    socketType2[socketType2["SOCKET"] = 0] = "SOCKET";
    socketType2[socketType2["SERVER"] = 1] = "SERVER";
    socketType2[socketType2["IPC"] = 2] = "IPC";
})(socketType || (socketType = {}));
class Pipe extends ConnectionWrap {
    reading = false;
    ipc;
    constructor(type31){
        let provider;
        let ipc;
        switch(type31){
            case socketType.SOCKET:
                {
                    provider = providerType.PIPEWRAP;
                    ipc = false;
                    break;
                }
            case socketType.SERVER:
                {
                    provider = providerType.PIPESERVERWRAP;
                    ipc = false;
                    break;
                }
            case socketType.IPC:
                {
                    provider = providerType.PIPEWRAP;
                    ipc = true;
                    break;
                }
            default:
                {
                    unreachable();
                }
        }
        super(provider);
        this.ipc = ipc;
    }
    bind() {
        notImplemented();
    }
    listen() {
        notImplemented();
    }
    connect(_req, _address, _afterConnect) {
        notImplemented();
    }
    open(_fd) {
        notImplemented();
    }
    setPendingInstances(_instances) {
        notImplemented();
    }
    fchmod() {
        notImplemented();
    }
}
class PipeConnectWrap extends AsyncWrap {
    oncomplete;
    address;
    constructor(){
        super(providerType.PIPECONNECTWRAP);
    }
}
var constants2;
(function(constants11) {
    constants11[constants11["SOCKET"] = socketType.SOCKET] = "SOCKET";
    constants11[constants11["SERVER"] = socketType.SERVER] = "SERVER";
    constants11[constants11["IPC"] = socketType.IPC] = "IPC";
    constants11[constants11["UV_READABLE"] = 0] = "UV_READABLE";
    constants11[constants11["UV_WRITABLE"] = 1] = "UV_WRITABLE";
})(constants2 || (constants2 = {}));
const mod31 = {
    socketType: socketType,
    Pipe: Pipe,
    PipeConnectWrap: PipeConnectWrap,
    constants: constants2
};
const mod32 = {};
const mod33 = {};
const mod34 = {};
const mod35 = {};
const mod36 = {};
const mod37 = {};
const asyncIdSymbol = Symbol("asyncIdSymbol");
const ownerSymbol = Symbol("ownerSymbol");
const mod38 = {
    asyncIdSymbol: asyncIdSymbol,
    ownerSymbol: ownerSymbol
};
const mod39 = {};
var socketType1;
(function(socketType3) {
    socketType3[socketType3["SOCKET"] = 0] = "SOCKET";
    socketType3[socketType3["SERVER"] = 1] = "SERVER";
})(socketType1 || (socketType1 = {}));
const INITIAL_ACCEPT_BACKOFF_DELAY = 5;
const MAX_ACCEPT_BACKOFF_DELAY = 1000;
function _ceilPowOf2(n27) {
    const roundPowOf2 = 1 << 31 - Math.clz32(n27);
    return roundPowOf2 < n27 ? roundPowOf2 * 2 : roundPowOf2;
}
class TCPConnectWrap extends AsyncWrap {
    oncomplete;
    address;
    port;
    localAddress;
    localPort;
    constructor(){
        super(providerType.TCPCONNECTWRAP);
    }
}
var constants3;
(function(constants12) {
    constants12[constants12["SOCKET"] = socketType1.SOCKET] = "SOCKET";
    constants12[constants12["SERVER"] = socketType1.SERVER] = "SERVER";
    constants12[constants12["UV_TCP_IPV6ONLY"] = 0] = "UV_TCP_IPV6ONLY";
})(constants3 || (constants3 = {}));
class TCP extends ConnectionWrap {
    [ownerSymbol] = null;
    reading = false;
    #address;
    #port;
    #remoteAddress;
    #remoteFamily;
    #remotePort;
    #backlog;
    #listener;
    #connections = 0;
    #closed = false;
    #acceptBackoffDelay;
    constructor(type32, conn){
        let provider;
        switch(type32){
            case socketType1.SOCKET:
                {
                    provider = providerType.TCPWRAP;
                    break;
                }
            case socketType1.SERVER:
                {
                    provider = providerType.TCPSERVERWRAP;
                    break;
                }
            default:
                {
                    unreachable();
                }
        }
        super(provider, conn);
        if (conn && provider === providerType.TCPWRAP) {
            const localAddr = conn.localAddr;
            this.#address = localAddr.hostname;
            this.#port = localAddr.port;
            const remoteAddr = conn.remoteAddr;
            this.#remoteAddress = remoteAddr.hostname;
            this.#remotePort = remoteAddr.port;
            this.#remoteFamily = isIP(remoteAddr.hostname) === 6 ? "IPv6" : "IPv4";
        }
    }
    open(_fd) {
        notImplemented();
    }
    bind(address, port) {
        return this.#bind(address, port, 0);
    }
    bind6(address, port, flags) {
        return this.#bind(address, port, flags);
    }
    connect(req2, address, port) {
        return this.#connect(req2, address, port);
    }
    connect6(req3, address, port) {
        return this.#connect(req3, address, port);
    }
    listen(backlog) {
        this.#backlog = _ceilPowOf2(backlog + 1);
        const listenOptions = {
            hostname: this.#address,
            port: this.#port,
            transport: "tcp"
        };
        let listener;
        try {
            listener = Deno.listen(listenOptions);
        } catch (e16) {
            if (e16 instanceof Deno.errors.AddrInUse) {
                return codeMap.get("EADDRINUSE");
            } else if (e16 instanceof Deno.errors.AddrNotAvailable) {
                return codeMap.get("EADDRNOTAVAIL");
            }
            return codeMap.get("UNKNOWN");
        }
        const address = listener.addr;
        this.#address = address.hostname;
        this.#port = address.port;
        this.#listener = listener;
        this.#accept();
        return 0;
    }
    getsockname(sockname) {
        if (typeof this.#address === "undefined" || typeof this.#port === "undefined") {
            return codeMap.get("EADDRNOTAVAIL");
        }
        sockname.address = this.#address;
        sockname.port = this.#port;
        sockname.family = isIP(this.#address) === 6 ? "IPv6" : "IPv4";
        return 0;
    }
    getpeername(peername) {
        if (typeof this.#remoteAddress === "undefined" || typeof this.#remotePort === "undefined") {
            return codeMap.get("EADDRNOTAVAIL");
        }
        peername.address = this.#remoteAddress;
        peername.port = this.#remotePort;
        peername.family = this.#remoteFamily;
        return 0;
    }
    setNoDelay(_noDelay) {
        return 0;
    }
    setKeepAlive(_enable, _initialDelay) {
        return 0;
    }
    setSimultaneousAccepts(_enable) {
        notImplemented();
    }
     #bind(address, port, _flags) {
        this.#address = address;
        this.#port = port;
        return 0;
    }
     #connect(req4, address1, port1) {
        this.#remoteAddress = address1;
        this.#remotePort = port1;
        this.#remoteFamily = isIP(address1) === 6 ? "IPv6" : "IPv4";
        const connectOptions = {
            hostname: address1,
            port: port1,
            transport: "tcp"
        };
        Deno.connect(connectOptions).then((conn)=>{
            const localAddr = conn.localAddr;
            this.#address = req4.localAddress = localAddr.hostname;
            this.#port = req4.localPort = localAddr.port;
            this[kStreamBaseField] = conn;
            try {
                this.afterConnect(req4, 0);
            } catch  {}
        }, ()=>{
            try {
                this.afterConnect(req4, codeMap.get("ECONNREFUSED"));
            } catch  {}
        });
        return 0;
    }
    async #acceptBackoff() {
        if (!this.#acceptBackoffDelay) {
            this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY;
        } else {
            this.#acceptBackoffDelay *= 2;
        }
        if (this.#acceptBackoffDelay >= 1000) {
            this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY;
        }
        await delay(this.#acceptBackoffDelay);
        this.#accept();
    }
    async #accept() {
        if (this.#closed) {
            return;
        }
        if (this.#connections > this.#backlog) {
            this.#acceptBackoff();
            return;
        }
        let connection;
        try {
            connection = await this.#listener.accept();
        } catch (e) {
            if (e instanceof Deno.errors.BadResource && this.#closed) {
                return;
            }
            try {
                this.onconnection(codeMap.get("UNKNOWN"), undefined);
            } catch  {}
            this.#acceptBackoff();
            return;
        }
        this.#acceptBackoffDelay = undefined;
        const connectionHandle = new TCP(socketType1.SOCKET, connection);
        this.#connections++;
        try {
            this.onconnection(0, connectionHandle);
        } catch  {}
        return this.#accept();
    }
    async _onClose() {
        this.#closed = true;
        this.reading = false;
        this.#address = undefined;
        this.#port = undefined;
        this.#remoteAddress = undefined;
        this.#remoteFamily = undefined;
        this.#remotePort = undefined;
        this.#backlog = undefined;
        this.#connections = 0;
        this.#acceptBackoffDelay = undefined;
        if (this.provider === providerType.TCPSERVERWRAP) {
            try {
                this.#listener.close();
            } catch  {}
        }
        return await LibuvStreamWrap.prototype._onClose.call(this);
    }
}
const mod40 = {
    TCPConnectWrap: TCPConnectWrap,
    constants: constants3,
    TCP: TCP
};
const mod41 = {};
const mod42 = {};
const mod43 = {};
const mod44 = {};
const mod45 = {};
const mod46 = {};
const mod47 = {};
const mod48 = {};
const mod49 = {};
const modules = {
    "async_wrap": mod9,
    buffer: mod6,
    "cares_wrap": mod11,
    config: mod10,
    constants: mod3,
    contextify: mod12,
    credentials: mod14,
    crypto: mod13,
    errors: mod15,
    fs: mod16,
    "fs_dir": mod17,
    "fs_event_wrap": mod18,
    "heap_utils": mod19,
    "http_parser": mod20,
    icu: mod21,
    inspector: mod22,
    "js_stream": mod23,
    messaging: mod24,
    "module_wrap": mod25,
    "native_module": mod26,
    natives: mod27,
    options: mod28,
    os: mod29,
    performance: mod32,
    "pipe_wrap": mod31,
    "process_methods": mod33,
    report: mod34,
    serdes: mod35,
    "signal_wrap": mod36,
    "spawn_sync": mod37,
    "stream_wrap": mod30,
    "string_decoder": mod5,
    symbols: mod38,
    "task_queue": mod39,
    "tcp_wrap": mod40,
    timers: mod41,
    "tls_wrap": mod42,
    "trace_events": mod43,
    "tty_wrap": mod44,
    types: mod,
    "udp_wrap": mod45,
    url: mod46,
    util: mod2,
    uv: mod4,
    v8: mod47,
    worker: mod48,
    zlib: mod49
};
function getBinding(name42) {
    const mod63 = modules[name42];
    if (!mod63) {
        throw new Error(`No such module: ${name42}`);
    }
    return mod63;
}
const notImplementedEvents = [
    "beforeExit",
    "disconnect",
    "message",
    "multipleResolves",
    "rejectionHandled",
    "uncaughtException",
    "uncaughtExceptionMonitor",
    "unhandledRejection", 
];
const argv = [
    "",
    "",
    ...Deno.args
];
Object.defineProperty(argv, "0", {
    get: Deno.execPath
});
Object.defineProperty(argv, "1", {
    get: ()=>fromFileUrl2(Deno.mainModule)
});
const exit = (code36)=>{
    if (code36 || code36 === 0) {
        if (typeof code36 === "string") {
            const parsedCode = parseInt(code36);
            process1.exitCode = isNaN(parsedCode) ? undefined : parsedCode;
        } else {
            process1.exitCode = code36;
        }
    }
    if (!process1._exiting) {
        process1._exiting = true;
        process1.emit("exit", process1.exitCode || 0);
    }
    Deno.exit(process1.exitCode || 0);
};
function addReadOnlyProcessAlias(name43, option, enumerable = true) {
    const value = getOptionValue(option);
    if (value) {
        Object.defineProperty(process1, name43, {
            writable: false,
            configurable: true,
            enumerable,
            value
        });
    }
}
function createWarningObject(warning, type33, code37, ctor, detail) {
    assert1(typeof warning === "string");
    const warningErr = new Error(warning);
    warningErr.name = String(type33 || "Warning");
    if (code37 !== undefined) {
        warningErr.code = code37;
    }
    if (detail !== undefined) {
        warningErr.detail = detail;
    }
    Error.captureStackTrace(warningErr, ctor || process1.emitWarning);
    return warningErr;
}
function doEmitWarning(warning) {
    process1.emit("warning", warning);
}
function emitWarning(warning, type34, code38, ctor) {
    let detail;
    if (type34 !== null && typeof type34 === "object" && !Array.isArray(type34)) {
        ctor = type34.ctor;
        code38 = type34.code;
        if (typeof type34.detail === "string") {
            detail = type34.detail;
        }
        type34 = type34.type || "Warning";
    } else if (typeof type34 === "function") {
        ctor = type34;
        code38 = undefined;
        type34 = "Warning";
    }
    if (type34 !== undefined) {
        validateString(type34, "type");
    }
    if (typeof code38 === "function") {
        ctor = code38;
        code38 = undefined;
    } else if (code38 !== undefined) {
        validateString(code38, "code");
    }
    if (typeof warning === "string") {
        warning = createWarningObject(warning, type34, code38, ctor, detail);
    } else if (!(warning instanceof Error)) {
        throw new ERR_INVALID_ARG_TYPE("warning", [
            "Error",
            "string"
        ], warning);
    }
    if (warning.name === "DeprecationWarning") {
        if (process1.noDeprecation) {
            return;
        }
        if (process1.throwDeprecation) {
            return process1.nextTick(()=>{
                throw warning;
            });
        }
    }
    process1.nextTick(doEmitWarning, warning);
}
function hrtime1(time2) {
    const milli = performance.now();
    const sec = Math.floor(milli / 1000);
    const nano = Math.floor(milli * 1000000 - sec * 1000000000);
    if (!time2) {
        return [
            sec,
            nano
        ];
    }
    const [prevSec, prevNano] = time2;
    return [
        sec - prevSec,
        nano - prevNano
    ];
}
hrtime1.bigint = function() {
    const [sec, nano] = hrtime1();
    return BigInt(sec) * 1000000000n + BigInt(nano);
};
function memoryUsage1() {
    return {
        ...Deno.memoryUsage(),
        arrayBuffers: 0
    };
}
memoryUsage1.rss = function() {
    return memoryUsage1().rss;
};
class Process extends EventEmitter {
    constructor(){
        super();
        globalThis.addEventListener("unload", ()=>{
            if (!process1._exiting) {
                process1._exiting = true;
                super.emit("exit", process1.exitCode || 0);
            }
        });
    }
    arch = arch;
    argv = argv;
    chdir = chdir;
    config = {
        target_defaults: {},
        variables: {}
    };
    cwd = cwd;
    env = env;
    execArgv = [];
    exit = exit;
    _exiting = _exiting;
    exitCode = undefined;
    mainModule = undefined;
    nextTick = nextTick2;
    on(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.on("${event}")`);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                addSignalListener(event, listener);
            }
        } else {
            super.on(event, listener);
        }
        return this;
    }
    off(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.off("${event}")`);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                removeSignalListener(event, listener);
            }
        } else {
            super.off(event, listener);
        }
        return this;
    }
    pid = pid;
    platform = platform;
    removeAllListeners(eventName) {
        return super.removeAllListeners(eventName);
    }
    removeListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.removeListener("${event}")`);
            return this;
        }
        super.removeListener("exit", listener);
        return this;
    }
    hrtime = hrtime1;
    memoryUsage = memoryUsage1;
    stderr = stderr;
    stdin = stdin;
    stdout = stdout;
    version = version;
    versions = versions;
    emitWarning = emitWarning;
    binding(name44) {
        return getBinding(name44);
    }
    umask() {
        return 18;
    }
    getuid() {
        return NaN;
    }
    getgid() {
        return NaN;
    }
    _eval = undefined;
    get execPath() {
        return argv[0];
    }
    #startTime = Date.now();
    uptime() {
        return (Date.now() - this.#startTime) / 1000;
    }
}
const process1 = new Process();
Object.defineProperty(process1, Symbol.toStringTag, {
    enumerable: false,
    writable: true,
    configurable: false,
    value: "process"
});
addReadOnlyProcessAlias("noDeprecation", "--no-deprecation");
addReadOnlyProcessAlias("throwDeprecation", "--throw-deprecation");
process1.removeListener;
process1.removeAllListeners;
const TIMEOUT_MAX = 2 ** 31 - 1;
const kTimerId = Symbol("timerId");
const kTimeout = Symbol("timeout");
const kRefed = Symbol("refed");
function Timeout(id) {
    this[kTimerId] = id;
    this[kRefed] = true;
}
Timeout.prototype[inspect.custom] = function(_, options) {
    return inspect(this, {
        ...options,
        depth: 0,
        customInspect: false
    });
};
Timeout.prototype.refresh = function() {
    notImplemented();
};
Timeout.prototype.unref = function() {
    if (this[kRefed]) {
        this[kRefed] = false;
        Deno.unrefTimer(this[kTimerId]);
    }
    return this;
};
Timeout.prototype.ref = function() {
    if (!this[kRefed]) {
        this[kRefed] = true;
        Deno.refTimer(this[kTimerId]);
    }
    return this;
};
Timeout.prototype.hasRef = function() {
    return this[kRefed];
};
Timeout.prototype[Symbol.toPrimitive] = function() {
    return this[kTimerId];
};
function getTimerDuration(msecs, name45) {
    validateNumber(msecs, name45);
    if (msecs < 0 || !Number.isFinite(msecs)) {
        throw new ERR_OUT_OF_RANGE(name45, "a non-negative finite number", msecs);
    }
    if (msecs > TIMEOUT_MAX) {
        emitWarning(`${msecs} does not fit into a 32-bit signed integer.` + `\nTimer duration was truncated to ${TIMEOUT_MAX}.`, "TimeoutOverflowWarning");
        return TIMEOUT_MAX;
    }
    return msecs;
}
const __default14 = {
    TIMEOUT_MAX,
    kTimerId,
    kTimeout,
    Timeout,
    getTimerDuration
};
const setTimeout_ = globalThis.setTimeout;
const clearTimeout_ = globalThis.clearTimeout;
const setInterval_ = globalThis.setInterval;
const clearInterval_ = globalThis.clearInterval;
function setTimeout2(cb, timeout, ...args1) {
    validateCallback(cb);
    if (typeof timeout === "number" && timeout > TIMEOUT_MAX) {
        timeout = 1;
    }
    const timer = new Timeout(setTimeout_((...args)=>{
        cb.bind(timer)(...args);
    }, timeout, ...args1));
    return timer;
}
function setUnrefTimeout(cb, timeout, ...args) {
    setTimeout2(cb, timeout, ...args).unref();
}
function clearTimeout1(timeout) {
    if (timeout == null) {
        return;
    }
    clearTimeout_(+timeout);
}
function setInterval(cb, timeout, ...args2) {
    validateCallback(cb);
    if (typeof timeout === "number" && timeout > TIMEOUT_MAX) {
        timeout = 1;
    }
    const timer = new Timeout(setInterval_((...args)=>{
        cb.bind(timer)(...args);
    }, timeout, ...args2));
    return timer;
}
function clearInterval(timeout) {
    if (timeout == null) {
        return;
    }
    clearInterval_(+timeout);
}
const setImmediate = (cb, ...args)=>setTimeout2(cb, 0, ...args)
;
const clearImmediate = clearTimeout1;
const __default15 = {
    setTimeout: setTimeout2,
    clearTimeout: clearTimeout1,
    setInterval,
    clearInterval,
    setImmediate,
    clearImmediate
};
Object.defineProperty(globalThis, "global", {
    value: globalThis,
    writable: false,
    enumerable: false,
    configurable: true
});
Object.defineProperty(globalThis, "process", {
    value: process1,
    enumerable: false,
    writable: true,
    configurable: true
});
Object.defineProperty(globalThis, "Buffer", {
    value: Buffer1,
    enumerable: false,
    writable: true,
    configurable: true
});
Object.defineProperty(globalThis, "setImmediate", {
    value: __default15.setImmediate,
    enumerable: true,
    writable: true,
    configurable: true
});
Object.defineProperty(globalThis, "clearImmediate", {
    value: __default15.clearImmediate,
    enumerable: true,
    writable: true,
    configurable: true
});
const { kDefaultTriggerAsyncId  } = constants1;
function defaultTriggerAsyncIdScope(triggerAsyncId, block, ...args) {
    if (triggerAsyncId === undefined) {
        return block.apply(null, args);
    }
    const oldDefaultTriggerAsyncId = asyncIdFields[kDefaultTriggerAsyncId];
    asyncIdFields[kDefaultTriggerAsyncId] = triggerAsyncId;
    try {
        return block.apply(null, args);
    } finally{
        asyncIdFields[kDefaultTriggerAsyncId] = oldDefaultTriggerAsyncId;
    }
}
const kMaybeDestroy = Symbol("kMaybeDestroy");
const kUpdateTimer = Symbol("kUpdateTimer");
const kAfterAsyncWrite = Symbol("kAfterAsyncWrite");
const kHandle = Symbol("kHandle");
const kSession = Symbol("kSession");
const kBuffer = Symbol("kBuffer");
const kBufferGen = Symbol("kBufferGen");
const kBufferCb = Symbol("kBufferCb");
function handleWriteReq(req5, data17, encoding) {
    const { handle  } = req5;
    switch(encoding){
        case "buffer":
            {
                const ret = handle.writeBuffer(req5, data17);
                if (streamBaseState[kLastWriteWasAsync]) {
                    req5.buffer = data17;
                }
                return ret;
            }
        case "latin1":
        case "binary":
            return handle.writeLatin1String(req5, data17);
        case "utf8":
        case "utf-8":
            return handle.writeUtf8String(req5, data17);
        case "ascii":
            return handle.writeAsciiString(req5, data17);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return handle.writeUcs2String(req5, data17);
        default:
            {
                const buffer22 = Buffer1.from(data17, encoding);
                const ret = handle.writeBuffer(req5, buffer22);
                if (streamBaseState[kLastWriteWasAsync]) {
                    req5.buffer = buffer22;
                }
                return ret;
            }
    }
}
function onWriteComplete(status) {
    let stream1 = this.handle[ownerSymbol];
    if (stream1.constructor.name === "ReusedHandle") {
        stream1 = stream1.handle;
    }
    if (stream1.destroyed) {
        if (typeof this.callback === "function") {
            this.callback(null);
        }
        return;
    }
    if (status < 0) {
        const ex = errnoException(status, "write", this.error);
        if (typeof this.callback === "function") {
            this.callback(ex);
        } else {
            stream1.destroy(ex);
        }
        return;
    }
    stream1[kUpdateTimer]();
    stream1[kAfterAsyncWrite](this);
    if (typeof this.callback === "function") {
        this.callback(null);
    }
}
function createWriteWrap(handle, callback) {
    const req6 = new WriteWrap();
    req6.handle = handle;
    req6.oncomplete = onWriteComplete;
    req6.async = false;
    req6.bytes = 0;
    req6.buffer = null;
    req6.callback = callback;
    return req6;
}
function writevGeneric(owner, data18, cb) {
    const req7 = createWriteWrap(owner[kHandle], cb);
    const allBuffers = data18.allBuffers;
    let chunks;
    if (allBuffers) {
        chunks = data18;
        for(let i96 = 0; i96 < data18.length; i96++){
            data18[i96] = data18[i96].chunk;
        }
    } else {
        chunks = new Array(data18.length << 1);
        for(let i97 = 0; i97 < data18.length; i97++){
            const entry = data18[i97];
            chunks[i97 * 2] = entry.chunk;
            chunks[i97 * 2 + 1] = entry.encoding;
        }
    }
    const err81 = req7.handle.writev(req7, chunks, allBuffers);
    if (err81 === 0) {
        req7._chunks = chunks;
    }
    afterWriteDispatched(req7, err81, cb);
    return req7;
}
function writeGeneric(owner, data19, encoding, cb) {
    const req8 = createWriteWrap(owner[kHandle], cb);
    const err82 = handleWriteReq(req8, data19, encoding);
    afterWriteDispatched(req8, err82, cb);
    return req8;
}
function afterWriteDispatched(req9, err83, cb) {
    req9.bytes = streamBaseState[kBytesWritten];
    req9.async = !!streamBaseState[kLastWriteWasAsync];
    if (err83 !== 0) {
        return cb(errnoException(err83, "write", req9.error));
    }
    if (!req9.async && typeof req9.callback === "function") {
        req9.callback();
    }
}
function onStreamRead(arrayBuffer1, nread) {
    const handle = this;
    let stream2 = this[ownerSymbol];
    if (stream2.constructor.name === "ReusedHandle") {
        stream2 = stream2.handle;
    }
    stream2[kUpdateTimer]();
    if (nread > 0 && !stream2.destroyed) {
        let ret;
        let result;
        const userBuf = stream2[kBuffer];
        if (userBuf) {
            result = stream2[kBufferCb](nread, userBuf) !== false;
            const bufGen = stream2[kBufferGen];
            if (bufGen !== null) {
                const nextBuf = bufGen();
                if (isUint8Array(nextBuf)) {
                    stream2[kBuffer] = ret = nextBuf;
                }
            }
        } else {
            const offset = streamBaseState[kArrayBufferOffset];
            const buf = Buffer1.from(arrayBuffer1, offset, nread);
            result = stream2.push(buf);
        }
        if (!result) {
            handle.reading = false;
            if (!stream2.destroyed) {
                const err84 = handle.readStop();
                if (err84) {
                    stream2.destroy(errnoException(err84, "read"));
                }
            }
        }
        return ret;
    }
    if (nread === 0) {
        return;
    }
    if (nread !== codeMap.get("EOF")) {
        stream2.destroy(errnoException(nread, "read"));
        return;
    }
    if (stream2._readableState.endEmitted) {
        if (stream2[kMaybeDestroy]) {
            stream2[kMaybeDestroy]();
        }
    } else {
        if (stream2[kMaybeDestroy]) {
            stream2.on("end", stream2[kMaybeDestroy]);
        }
        if (handle.readStop) {
            const err85 = handle.readStop();
            if (err85) {
                stream2.destroy(errnoException(err85, "read"));
                return;
            }
        }
        stream2.push(null);
        stream2.read(0);
    }
}
function setStreamTimeout(msecs, callback) {
    if (this.destroyed) {
        return this;
    }
    this.timeout = msecs;
    msecs = getTimerDuration(msecs, "msecs");
    clearTimeout(this[kTimeout]);
    if (msecs === 0) {
        if (callback !== undefined) {
            validateCallback(callback);
            this.removeListener("timeout", callback);
        }
    } else {
        this[kTimeout] = setUnrefTimeout(this._onTimeout.bind(this), msecs);
        if (this[kSession]) {
            this[kSession][kUpdateTimer]();
        }
        if (callback !== undefined) {
            validateCallback(callback);
            this.once("timeout", callback);
        }
    }
    return this;
}
const { DTRACE_HTTP_CLIENT_REQUEST =(..._args)=>{} , DTRACE_HTTP_CLIENT_RESPONSE =(..._args)=>{} , DTRACE_HTTP_SERVER_REQUEST =(..._args)=>{} , DTRACE_HTTP_SERVER_RESPONSE =(..._args)=>{} , DTRACE_NET_SERVER_CONNECTION =(..._args)=>{} , DTRACE_NET_STREAM_END =(..._args)=>{} ,  } = {};
function validateHints(hints) {
    if ((hints & ~(AI_ADDRCONFIG | AI_ALL | AI_V4MAPPED)) !== 0) {
        throw new ERR_INVALID_ARG_VALUE("hints", hints, "is invalid");
    }
}
let invalidHostnameWarningEmitted = false;
function emitInvalidHostnameWarning(hostname5) {
    if (invalidHostnameWarningEmitted) {
        return;
    }
    invalidHostnameWarningEmitted = true;
    emitWarning(`The provided hostname "${hostname5}" is not a valid ` + "hostname, and is supported in the dns module solely for compatibility.", "DeprecationWarning", "DEP0118");
}
const dnsOrder = getOptionValue("--dns-result-order") || "ipv4first";
function getDefaultVerbatim() {
    switch(dnsOrder){
        case "verbatim":
            {
                return true;
            }
        case "ipv4first":
            {
                return false;
            }
        default:
            {
                return false;
            }
    }
}
"use strict";
const base = 36;
const damp = 700;
const delimiter3 = "-";
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7E]/;
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
const errors = {
    "overflow": "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
};
const baseMinusTMin = 36 - 1;
const floor = Math.floor;
function error(type35) {
    throw new RangeError(errors[type35]);
}
function mapDomain(str, fn) {
    const parts = str.split("@");
    let result = "";
    if (parts.length > 1) {
        result = parts[0] + "@";
        str = parts[1];
    }
    str = str.replace(regexSeparators, "\x2E");
    const labels = str.split(".");
    const encoded = labels.map(fn).join(".");
    return result + encoded;
}
function ucs2decode(str) {
    const output = [];
    let counter = 0;
    const length = str.length;
    while(counter < length){
        const value = str.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
            const extra = str.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
                output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
                output.push(value);
                counter--;
            }
        } else {
            output.push(value);
        }
    }
    return output;
}
function ucs2encode(array) {
    return String.fromCodePoint(...array);
}
const ucs2 = {
    decode: ucs2decode,
    encode: ucs2encode
};
function basicToDigit(codePoint) {
    if (codePoint - 48 < 10) {
        return codePoint - 22;
    }
    if (codePoint - 65 < 26) {
        return codePoint - 65;
    }
    if (codePoint - 97 < 26) {
        return codePoint - 97;
    }
    return 36;
}
function digitToBasic(digit, flag) {
    return digit + 22 + 75 * Number(digit < 26) - (Number(flag != 0) << 5);
}
function adapt(delta, numPoints, firstTime) {
    let k7 = 0;
    delta = firstTime ? Math.floor(delta / damp) : delta >> 1;
    delta += Math.floor(delta / numPoints);
    for(; delta > baseMinusTMin * 26 >> 1; k7 += base){
        delta = Math.floor(delta / baseMinusTMin);
    }
    return Math.floor(k7 + (baseMinusTMin + 1) * delta / (delta + 38));
}
function decode2(input) {
    const output = [];
    const inputLength = input.length;
    let i98 = 0;
    let n28 = 128;
    let bias = 72;
    let basic = input.lastIndexOf(delimiter3);
    if (basic < 0) {
        basic = 0;
    }
    for(let j = 0; j < basic; ++j){
        if (input.charCodeAt(j) >= 128) {
            error("not-basic");
        }
        output.push(input.charCodeAt(j));
    }
    for(let index8 = basic > 0 ? basic + 1 : 0; index8 < inputLength;){
        const oldi = i98;
        for(let w17 = 1, k8 = 36;; k8 += base){
            if (index8 >= inputLength) {
                error("invalid-input");
            }
            const digit = basicToDigit(input.charCodeAt(index8++));
            if (digit >= 36 || digit > floor((2147483647 - i98) / w17)) {
                error("overflow");
            }
            i98 += digit * w17;
            const t4 = k8 <= bias ? 1 : k8 >= bias + 26 ? 26 : k8 - bias;
            if (digit < t4) {
                break;
            }
            const baseMinusT = 36 - t4;
            if (w17 > floor(2147483647 / baseMinusT)) {
                error("overflow");
            }
            w17 *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i98 - oldi, out, oldi == 0);
        if (floor(i98 / out) > 2147483647 - n28) {
            error("overflow");
        }
        n28 += floor(i98 / out);
        i98 %= out;
        output.splice(i98++, 0, n28);
    }
    return String.fromCodePoint(...output);
}
function encode2(str) {
    const output = [];
    const input = ucs2decode(str);
    const inputLength = input.length;
    let n29 = 128;
    let delta = 0;
    let bias = 72;
    for (const currentValue of input){
        if (currentValue < 128) {
            output.push(String.fromCharCode(currentValue));
        }
    }
    const basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
        output.push(delimiter3);
    }
    while(handledCPCount < inputLength){
        let m10 = 2147483647;
        for (const currentValue of input){
            if (currentValue >= n29 && currentValue < m10) {
                m10 = currentValue;
            }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m10 - n29 > Math.floor((2147483647 - delta) / handledCPCountPlusOne)) {
            error("overflow");
        }
        delta += (m10 - n29) * handledCPCountPlusOne;
        n29 = m10;
        for (const currentValue1 of input){
            if (currentValue1 < n29 && ++delta > 2147483647) {
                error("overflow");
            }
            if (currentValue1 == n29) {
                let q1 = delta;
                for(let k9 = 36;; k9 += base){
                    const t5 = k9 <= bias ? 1 : k9 >= bias + 26 ? 26 : k9 - bias;
                    if (q1 < t5) {
                        break;
                    }
                    const qMinusT = q1 - t5;
                    const baseMinusT = 36 - t5;
                    output.push(String.fromCharCode(digitToBasic(t5 + qMinusT % baseMinusT, 0)));
                    q1 = Math.floor(qMinusT / baseMinusT);
                }
                output.push(String.fromCharCode(digitToBasic(q1, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
            }
        }
        ++delta;
        ++n29;
    }
    return output.join("");
}
function toUnicode(input) {
    return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
    });
}
function toASCII(input) {
    return mapDomain(input, function(str) {
        return regexNonASCII.test(str) ? "xn--" + encode2(str) : str;
    });
}
function _isLookupOptions(options) {
    return options !== null && typeof options === "object";
}
function _isLookupCallback(options) {
    return typeof options === "function";
}
function onlookup(code39, addresses) {
    if (code39) {
        return this.callback(dnsException(code39, "getaddrinfo", this.hostname));
    }
    this.callback(null, addresses[0], this.family || isIP(addresses[0]));
}
function onlookupall(code40, addresses) {
    if (code40) {
        return this.callback(dnsException(code40, "getaddrinfo", this.hostname));
    }
    const family = this.family;
    const parsedAddresses = [];
    for(let i99 = 0; i99 < addresses.length; i99++){
        const addr = addresses[i99];
        parsedAddresses[i99] = {
            address: addr,
            family: family || isIP(addr)
        };
    }
    this.callback(null, parsedAddresses);
}
function lookup(hostname6, options, callback) {
    let hints = 0;
    let family = -1;
    let all = false;
    let verbatim = getDefaultVerbatim();
    if (hostname6) {
        validateString(hostname6, "hostname");
    }
    if (_isLookupCallback(options)) {
        callback = options;
        family = 0;
    } else {
        validateCallback(callback);
        if (_isLookupOptions(options)) {
            hints = options.hints >>> 0;
            family = options.family >>> 0;
            all = options.all === true;
            if (typeof options.verbatim === "boolean") {
                verbatim = options.verbatim === true;
            }
            validateHints(hints);
        } else {
            family = options >>> 0;
        }
    }
    validateOneOf(family, "family", [
        0,
        4,
        6
    ]);
    if (!hostname6) {
        emitInvalidHostnameWarning(hostname6);
        if (all) {
            nextTick2(callback, null, []);
        } else {
            nextTick2(callback, null, null, family === 6 ? 6 : 4);
        }
        return {};
    }
    const matchedFamily = isIP(hostname6);
    if (matchedFamily) {
        if (all) {
            nextTick2(callback, null, [
                {
                    address: hostname6,
                    family: matchedFamily
                }
            ]);
        } else {
            nextTick2(callback, null, hostname6, matchedFamily);
        }
        return {};
    }
    const req10 = new GetAddrInfoReqWrap();
    req10.callback = callback;
    req10.family = family;
    req10.hostname = hostname6;
    req10.oncomplete = all ? onlookupall : onlookup;
    getaddrinfo(req10, toASCII(hostname6), family, hints, verbatim);
    return req10;
}
Object.defineProperty(lookup, customPromisifyArgs, {
    value: [
        "address",
        "family"
    ],
    enumerable: false
});
const NODATA = "ENODATA";
const FORMERR = "EFORMERR";
const SERVFAIL = "ESERVFAIL";
const NOTFOUND = "ENOTFOUND";
const NOTIMP = "ENOTIMP";
const REFUSED = "EREFUSED";
const BADQUERY = "EBADQUERY";
const BADNAME = "EBADNAME";
const BADFAMILY = "EBADFAMILY";
const BADRESP = "EBADRESP";
const CONNREFUSED = "ECONNREFUSED";
const TIMEOUT = "ETIMEOUT";
const EOF = "EOF";
const FILE = "EFILE";
const NOMEM = "ENOMEM";
const DESTRUCTION = "EDESTRUCTION";
const BADSTR = "EBADSTR";
const BADFLAGS = "EBADFLAGS";
const NONAME = "ENONAME";
const BADHINTS = "EBADHINTS";
const NOTINITIALIZED = "ENOTINITIALIZED";
const LOADIPHLPAPI = "ELOADIPHLPAPI";
const ADDRGETNETWORKPARAMS = "EADDRGETNETWORKPARAMS";
const CANCELLED = "ECANCELLED";
const __default16 = {
    ADDRCONFIG: AI_ADDRCONFIG,
    lookup,
    NODATA,
    FORMERR,
    SERVFAIL,
    NOTFOUND,
    NOTIMP,
    REFUSED,
    BADQUERY,
    BADNAME,
    BADFAMILY,
    BADRESP,
    CONNREFUSED,
    TIMEOUT,
    EOF,
    FILE,
    NOMEM,
    DESTRUCTION,
    BADSTR,
    BADFLAGS,
    NONAME,
    BADHINTS,
    NOTINITIALIZED,
    LOADIPHLPAPI,
    ADDRGETNETWORKPARAMS,
    CANCELLED
};
let debug1 = debuglog("net", (fn)=>{
    debug1 = fn;
});
const kLastWriteQueueSize = Symbol("lastWriteQueueSize");
const kSetNoDelay = Symbol("kSetNoDelay");
const kBytesRead = Symbol("kBytesRead");
const kBytesWritten1 = Symbol("kBytesWritten");
const DEFAULT_IPV4_ADDR = "0.0.0.0";
const DEFAULT_IPV6_ADDR = "::";
function _getNewAsyncId(handle) {
    return !handle || typeof handle.getAsyncId !== "function" ? newAsyncId() : handle.getAsyncId();
}
const _noop = (_arrayBuffer, _nread)=>{
    return;
};
function _toNumber(x28) {
    return (x28 = Number(x28)) >= 0 ? x28 : false;
}
function _isPipeName(s13) {
    return typeof s13 === "string" && _toNumber(s13) === false;
}
function _createHandle(fd, isServer) {
    validateInt32(fd, "fd", 0);
    const type36 = guessHandleType(fd);
    if (type36 === "PIPE") {
        return new Pipe(isServer ? constants2.SERVER : constants2.SOCKET);
    }
    if (type36 === "TCP") {
        return new TCP(isServer ? constants3.SERVER : constants3.SOCKET);
    }
    throw new ERR_INVALID_FD_TYPE(type36);
}
function _normalizeArgs(args) {
    let arr;
    if (args.length === 0) {
        arr = [
            {},
            null
        ];
        arr[normalizedArgsSymbol] = true;
        return arr;
    }
    const arg0 = args[0];
    let options = {};
    if (typeof arg0 === "object" && arg0 !== null) {
        options = arg0;
    } else if (_isPipeName(arg0)) {
        options.path = arg0;
    } else {
        options.port = arg0;
        if (args.length > 1 && typeof args[1] === "string") {
            options.host = args[1];
        }
    }
    const cb = args[args.length - 1];
    if (!_isConnectionListener(cb)) {
        arr = [
            options,
            null
        ];
    } else {
        arr = [
            options,
            cb
        ];
    }
    arr[normalizedArgsSymbol] = true;
    return arr;
}
function _isTCPConnectWrap(req11) {
    return "localAddress" in req11 && "localPort" in req11;
}
function _afterConnect(status, handle, req12, readable, writable) {
    let socket = handle[ownerSymbol];
    if (socket.constructor.name === "ReusedHandle") {
        socket = socket.handle;
    }
    if (socket.destroyed) {
        return;
    }
    debug1("afterConnect");
    assert1(socket.connecting);
    socket.connecting = false;
    socket._sockname = null;
    if (status === 0) {
        if (socket.readable && !readable) {
            socket.push(null);
            socket.read();
        }
        if (socket.writable && !writable) {
            socket.end();
        }
        socket._unrefTimer();
        socket.emit("connect");
        socket.emit("ready");
        if (readable && !socket.isPaused()) {
            socket.read(0);
        }
    } else {
        socket.connecting = false;
        let details;
        if (_isTCPConnectWrap(req12)) {
            details = req12.localAddress + ":" + req12.localPort;
        }
        const ex = exceptionWithHostPort(status, "connect", req12.address, req12.port, details);
        if (_isTCPConnectWrap(req12)) {
            ex.localAddress = req12.localAddress;
            ex.localPort = req12.localPort;
        }
        socket.destroy(ex);
    }
}
function _checkBindError(err86, port2, handle) {
    if (err86 === 0 && port2 > 0 && handle.getsockname) {
        const out = {};
        err86 = handle.getsockname(out);
        if (err86 === 0 && port2 !== out.port) {
            err86 = codeMap.get("EADDRINUSE");
        }
    }
    return err86;
}
function _isPipe(options) {
    return "path" in options && !!options.path;
}
function _connectErrorNT(socket, err87) {
    socket.destroy(err87);
}
function _internalConnect(socket, address2, port3, addressType, localAddress, localPort, flags) {
    assert1(socket.connecting);
    let err88;
    if (localAddress || localPort) {
        if (addressType === 4) {
            localAddress = localAddress || DEFAULT_IPV4_ADDR;
            err88 = socket._handle.bind(localAddress, localPort);
        } else {
            localAddress = localAddress || DEFAULT_IPV6_ADDR;
            err88 = socket._handle.bind6(localAddress, localPort, flags);
        }
        debug1("binding to localAddress: %s and localPort: %d (addressType: %d)", localAddress, localPort, addressType);
        err88 = _checkBindError(err88, localPort, socket._handle);
        if (err88) {
            const ex = exceptionWithHostPort(err88, "bind", localAddress, localPort);
            socket.destroy(ex);
            return;
        }
    }
    if (addressType === 6 || addressType === 4) {
        const req13 = new TCPConnectWrap();
        req13.oncomplete = _afterConnect;
        req13.address = address2;
        req13.port = port3;
        req13.localAddress = localAddress;
        req13.localPort = localPort;
        if (addressType === 4) {
            err88 = socket._handle.connect(req13, address2, port3);
        } else {
            err88 = socket._handle.connect6(req13, address2, port3);
        }
    } else {
        const req14 = new PipeConnectWrap();
        req14.oncomplete = _afterConnect;
        req14.address = address2;
        err88 = socket._handle.connect(req14, address2, _afterConnect);
    }
    if (err88) {
        let details = "";
        const sockname = socket._getsockname();
        if (sockname) {
            details = `${sockname.address}:${sockname.port}`;
        }
        const ex = exceptionWithHostPort(err88, "connect", address2, port3, details);
        socket.destroy(ex);
    }
}
function _writeAfterFIN(chunk, encoding, cb) {
    if (!this.writableEnded) {
        return Duplex.prototype.write.call(this, chunk, encoding, cb);
    }
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    const err89 = new NodeError("EPIPE", "This socket has been ended by the other party");
    if (typeof cb === "function") {
        defaultTriggerAsyncIdScope(this[asyncIdSymbol], nextTick2, cb, err89);
    }
    this.destroy(err89);
    return false;
}
function _tryReadStart(socket) {
    debug1("Socket._handle.readStart");
    socket._handle.reading = true;
    const err90 = socket._handle.readStart();
    if (err90) {
        socket.destroy(errnoException(err90, "read"));
    }
}
function _onReadableStreamEnd() {
    if (!this.allowHalfOpen) {
        this.write = _writeAfterFIN;
    }
}
function _initSocketHandle(socket) {
    socket._undestroy();
    socket._sockname = undefined;
    if (socket._handle) {
        socket._handle[ownerSymbol] = socket;
        socket._handle.onread = onStreamRead;
        socket[asyncIdSymbol] = _getNewAsyncId(socket._handle);
        let userBuf = socket[kBuffer];
        if (userBuf) {
            const bufGen = socket[kBufferGen];
            if (bufGen !== null) {
                userBuf = bufGen();
                if (!isUint8Array(userBuf)) {
                    return;
                }
                socket[kBuffer] = userBuf;
            }
            socket._handle.useUserBuffer(userBuf);
        }
    }
}
function _lookupAndConnect(self, options) {
    const { localAddress , localPort  } = options;
    const host = options.host || "localhost";
    let { port: port4  } = options;
    if (localAddress && !isIP(localAddress)) {
        throw new ERR_INVALID_IP_ADDRESS(localAddress);
    }
    if (localPort) {
        validateNumber(localPort, "options.localPort");
    }
    if (typeof port4 !== "undefined") {
        if (typeof port4 !== "number" && typeof port4 !== "string") {
            throw new ERR_INVALID_ARG_TYPE("options.port", [
                "number",
                "string"
            ], port4);
        }
        validatePort(port4);
    }
    port4 |= 0;
    const addressType1 = isIP(host);
    if (addressType1) {
        defaultTriggerAsyncIdScope(self[asyncIdSymbol], nextTick2, ()=>{
            if (self.connecting) {
                defaultTriggerAsyncIdScope(self[asyncIdSymbol], _internalConnect, self, host, port4, addressType1, localAddress, localPort);
            }
        });
        return;
    }
    if (options.lookup !== undefined) {
        validateFunction(options.lookup, "options.lookup");
    }
    const dnsOpts = {
        family: options.family,
        hints: options.hints || 0
    };
    if (!isWindows && dnsOpts.family !== 4 && dnsOpts.family !== 6 && dnsOpts.hints === 0) {
        dnsOpts.hints = AI_ADDRCONFIG;
    }
    debug1("connect: find host", host);
    debug1("connect: dns options", dnsOpts);
    self._host = host;
    const lookup1 = options.lookup || lookup;
    defaultTriggerAsyncIdScope(self[asyncIdSymbol], function() {
        lookup1(host, dnsOpts, function emitLookup(err91, ip, addressType) {
            self.emit("lookup", err91, ip, addressType, host);
            if (!self.connecting) {
                return;
            }
            if (err91) {
                nextTick2(_connectErrorNT, self, err91);
            } else if (!isIP(ip)) {
                err91 = new ERR_INVALID_IP_ADDRESS(ip);
                nextTick2(_connectErrorNT, self, err91);
            } else if (addressType !== 4 && addressType !== 6) {
                err91 = new ERR_INVALID_ADDRESS_FAMILY(`${addressType}`, options.host, options.port);
                nextTick2(_connectErrorNT, self, err91);
            } else {
                self._unrefTimer();
                defaultTriggerAsyncIdScope(self[asyncIdSymbol], _internalConnect, self, ip, port4, addressType, localAddress, localPort);
            }
        });
    });
}
function _afterShutdown() {
    const self = this.handle[ownerSymbol];
    debug1("afterShutdown destroyed=%j", self.destroyed, self._readableState);
    this.callback();
}
function _emitCloseNT(socket) {
    debug1("SERVER: emit close");
    socket.emit("close");
}
class Socket extends Duplex {
    [asyncIdSymbol] = -1;
    [kHandle] = null;
    [kSetNoDelay] = false;
    [kLastWriteQueueSize] = 0;
    [kTimeout] = null;
    [kBuffer] = null;
    [kBufferCb] = null;
    [kBufferGen] = null;
    [kBytesRead] = 0;
    [kBytesWritten1] = 0;
    server = null;
    _server = null;
    _peername;
    _sockname;
    _pendingData = null;
    _pendingEncoding = "";
    _host = null;
    _parent = null;
    constructor(options){
        if (typeof options === "number") {
            options = {
                fd: options
            };
        } else {
            options = {
                ...options
            };
        }
        options.allowHalfOpen = Boolean(options.allowHalfOpen);
        options.emitClose = false;
        options.autoDestroy = true;
        options.decodeStrings = false;
        super(options);
        if (options.handle) {
            this._handle = options.handle;
            this[asyncIdSymbol] = _getNewAsyncId(this._handle);
        } else if (options.fd !== undefined) {
            notImplemented();
        }
        const onread = options.onread;
        if (onread !== null && typeof onread === "object" && (isUint8Array(onread.buffer) || typeof onread.buffer === "function") && typeof onread.callback === "function") {
            if (typeof onread.buffer === "function") {
                this[kBuffer] = true;
                this[kBufferGen] = onread.buffer;
            } else {
                this[kBuffer] = onread.buffer;
            }
            this[kBufferCb] = onread.callback;
        }
        this.on("end", _onReadableStreamEnd);
        _initSocketHandle(this);
        if (this._handle && options.readable !== false) {
            if (options.pauseOnCreate) {
                this._handle.reading = false;
                this._handle.readStop();
                this.readableFlowing = false;
            } else if (!options.manualStart) {
                this.read(0);
            }
        }
    }
    connect(...args) {
        let normalized;
        if (Array.isArray(args[0]) && args[0][normalizedArgsSymbol]) {
            normalized = args[0];
        } else {
            normalized = _normalizeArgs(args);
        }
        const options = normalized[0];
        const cb = normalized[1];
        if (options.port === undefined && options.path == null) {
            throw new ERR_MISSING_ARGS([
                "options",
                "port",
                "path"
            ]);
        }
        if (this.write !== Socket.prototype.write) {
            this.write = Socket.prototype.write;
        }
        if (this.destroyed) {
            this._handle = null;
            this._peername = undefined;
            this._sockname = undefined;
        }
        const { path: path31  } = options;
        const pipe = _isPipe(options);
        debug1("pipe", pipe, path31);
        if (!this._handle) {
            this._handle = pipe ? new Pipe(constants2.SOCKET) : new TCP(constants3.SOCKET);
            _initSocketHandle(this);
        }
        if (cb !== null) {
            this.once("connect", cb);
        }
        this._unrefTimer();
        this.connecting = true;
        if (pipe) {
            validateString(path31, "options.path");
            defaultTriggerAsyncIdScope(this[asyncIdSymbol], _internalConnect, this, path31);
        } else {
            _lookupAndConnect(this, options);
        }
        return this;
    }
    pause() {
        if (this[kBuffer] && !this.connecting && this._handle && this._handle.reading) {
            this._handle.reading = false;
            if (!this.destroyed) {
                const err92 = this._handle.readStop();
                if (err92) {
                    this.destroy(errnoException(err92, "read"));
                }
            }
        }
        return Duplex.prototype.pause.call(this);
    }
    resume() {
        if (this[kBuffer] && !this.connecting && this._handle && !this._handle.reading) {
            _tryReadStart(this);
        }
        return Duplex.prototype.resume.call(this);
    }
    setTimeout = setStreamTimeout;
    setNoDelay(noDelay) {
        if (!this._handle) {
            this.once("connect", noDelay ? this.setNoDelay : ()=>this.setNoDelay(noDelay)
            );
            return this;
        }
        const newValue = noDelay === undefined ? true : !!noDelay;
        if ("setNoDelay" in this._handle && this._handle.setNoDelay && newValue !== this[kSetNoDelay]) {
            this[kSetNoDelay] = newValue;
            this._handle.setNoDelay(newValue);
        }
        return this;
    }
    setKeepAlive(enable, initialDelay) {
        if (!this._handle) {
            this.once("connect", ()=>this.setKeepAlive(enable, initialDelay)
            );
            return this;
        }
        if ("setKeepAlive" in this._handle) {
            this._handle.setKeepAlive(enable, ~~(initialDelay / 1000));
        }
        return this;
    }
    address() {
        return this._getsockname();
    }
    unref() {
        if (!this._handle) {
            this.once("connect", this.unref);
            return this;
        }
        if (typeof this._handle.unref === "function") {
            this._handle.unref();
        }
        return this;
    }
    ref() {
        if (!this._handle) {
            this.once("connect", this.ref);
            return this;
        }
        if (typeof this._handle.ref === "function") {
            this._handle.ref();
        }
        return this;
    }
    get bufferSize() {
        if (this._handle) {
            return this.writableLength;
        }
        return 0;
    }
    get bytesRead() {
        return this._handle ? this._handle.bytesRead : this[kBytesRead];
    }
    get bytesWritten() {
        let bytes = this._bytesDispatched;
        const data20 = this._pendingData;
        const encoding = this._pendingEncoding;
        const writableBuffer = this.writableBuffer;
        if (!writableBuffer) {
            return undefined;
        }
        for (const el of writableBuffer){
            bytes += el.chunk instanceof Buffer1 ? el.chunk.length : Buffer1.byteLength(el.chunk, el.encoding);
        }
        if (Array.isArray(data20)) {
            for(let i100 = 0; i100 < data20.length; i100++){
                const chunk = data20[i100];
                if (data20.allBuffers || chunk instanceof Buffer1) {
                    bytes += chunk.length;
                } else {
                    bytes += Buffer1.byteLength(chunk.chunk, chunk.encoding);
                }
            }
        } else if (data20) {
            if (typeof data20 !== "string") {
                bytes += data20.length;
            } else {
                bytes += Buffer1.byteLength(data20, encoding);
            }
        }
        return bytes;
    }
    connecting = false;
    get localAddress() {
        return this._getsockname().address;
    }
    get localPort() {
        return this._getsockname().port;
    }
    get remoteAddress() {
        return this._getpeername().address;
    }
    get remoteFamily() {
        return this._getpeername().family;
    }
    get remotePort() {
        return this._getpeername().port;
    }
    get pending() {
        return !this._handle || this.connecting;
    }
    get readyState() {
        if (this.connecting) {
            return "opening";
        } else if (this.readable && this.writable) {
            return "open";
        } else if (this.readable && !this.writable) {
            return "readOnly";
        } else if (!this.readable && this.writable) {
            return "writeOnly";
        }
        return "closed";
    }
    end(data21, encoding, cb) {
        Duplex.prototype.end.call(this, data21, encoding, cb);
        DTRACE_NET_STREAM_END(this);
        return this;
    }
    read(size) {
        if (this[kBuffer] && !this.connecting && this._handle && !this._handle.reading) {
            _tryReadStart(this);
        }
        return Duplex.prototype.read.call(this, size);
    }
    destroySoon() {
        if (this.writable) {
            this.end();
        }
        if (this.writableFinished) {
            this.destroy();
        } else {
            this.once("finish", this.destroy);
        }
    }
    _unrefTimer() {
        for(let s14 = this; s14 !== null; s14 = s14._parent){
            if (s14[kTimeout]) {
                s14[kTimeout].refresh();
            }
        }
    }
    _final = (cb)=>{
        if (this.pending) {
            debug1("_final: not yet connected");
            return this.once("connect", ()=>this._final(cb)
            );
        }
        if (!this._handle) {
            return cb();
        }
        debug1("_final: not ended, call shutdown()");
        const req15 = new ShutdownWrap();
        req15.oncomplete = _afterShutdown;
        req15.handle = this._handle;
        req15.callback = cb;
        const err93 = this._handle.shutdown(req15);
        if (err93 === 1 || err93 === codeMap.get("ENOTCONN")) {
            return cb();
        } else if (err93 !== 0) {
            return cb(errnoException(err93, "shutdown"));
        }
    };
    _onTimeout() {
        const handle = this._handle;
        const lastWriteQueueSize = this[kLastWriteQueueSize];
        if (lastWriteQueueSize > 0 && handle) {
            const { writeQueueSize  } = handle;
            if (lastWriteQueueSize !== writeQueueSize) {
                this[kLastWriteQueueSize] = writeQueueSize;
                this._unrefTimer();
                return;
            }
        }
        debug1("_onTimeout");
        this.emit("timeout");
    }
    _read(size) {
        debug1("_read");
        if (this.connecting || !this._handle) {
            debug1("_read wait for connection");
            this.once("connect", ()=>this._read(size)
            );
        } else if (!this._handle.reading) {
            _tryReadStart(this);
        }
    }
    _destroy(exception, cb) {
        debug1("destroy");
        this.connecting = false;
        for(let s15 = this; s15 !== null; s15 = s15._parent){
            clearTimeout(s15[kTimeout]);
        }
        debug1("close");
        if (this._handle) {
            debug1("close handle");
            const isException = exception ? true : false;
            this[kBytesRead] = this._handle.bytesRead;
            this[kBytesWritten1] = this._handle.bytesWritten;
            const that = this;
            this._handle.close(()=>{
                that._handle.onread = _noop;
                that._handle = null;
                that._sockname = undefined;
                cb(exception);
                debug1("emit close");
                this.emit("close", isException);
            });
        } else {
            cb(exception);
            nextTick2(_emitCloseNT, this);
        }
        if (this._server) {
            debug1("has server");
            this._server._connections--;
            if (this._server._emitCloseIfDrained) {
                this._server._emitCloseIfDrained();
            }
        }
    }
    _getpeername() {
        if (!this._handle || !("getpeername" in this._handle)) {
            return this._peername || {};
        } else if (!this._peername) {
            this._peername = {};
            this._handle.getpeername(this._peername);
        }
        return this._peername;
    }
    _getsockname() {
        if (!this._handle || !("getsockname" in this._handle)) {
            return {};
        } else if (!this._sockname) {
            this._sockname = {};
            this._handle.getsockname(this._sockname);
        }
        return this._sockname;
    }
    _writeGeneric(writev2, data22, encoding, cb) {
        if (this.connecting) {
            this._pendingData = data22;
            this._pendingEncoding = encoding;
            this.once("connect", function connect() {
                this._writeGeneric(writev2, data22, encoding, cb);
            });
            return;
        }
        this._pendingData = null;
        this._pendingEncoding = "";
        if (!this._handle) {
            cb(new ERR_SOCKET_CLOSED());
            return false;
        }
        this._unrefTimer();
        let req16;
        if (writev2) {
            req16 = writevGeneric(this, data22, cb);
        } else {
            req16 = writeGeneric(this, data22, encoding, cb);
        }
        if (req16.async) {
            this[kLastWriteQueueSize] = req16.bytes;
        }
    }
    _writev(chunks, cb) {
        this._writeGeneric(true, chunks, "", cb);
    }
    _write(data23, encoding, cb) {
        this._writeGeneric(false, data23, encoding, cb);
    }
    [kAfterAsyncWrite]() {
        this[kLastWriteQueueSize] = 0;
    }
    get [kUpdateTimer]() {
        return this._unrefTimer;
    }
    get _connecting() {
        return this.connecting;
    }
    get _bytesDispatched() {
        return this._handle ? this._handle.bytesWritten : this[kBytesWritten1];
    }
    get _handle() {
        return this[kHandle];
    }
    set _handle(v9) {
        this[kHandle] = v9;
    }
}
const Stream1 = Socket;
function connect(...args) {
    const normalized = _normalizeArgs(args);
    const options = normalized[0];
    debug1("createConnection", normalized);
    const socket = new Socket(options);
    if (options.timeout) {
        socket.setTimeout(options.timeout);
    }
    return socket.connect(normalized);
}
const createConnection = connect;
function _isServerSocketOptions(options) {
    return options === null || typeof options === "undefined" || typeof options === "object";
}
function _isConnectionListener(connectionListener) {
    return typeof connectionListener === "function";
}
function _getFlags(ipv6Only) {
    return ipv6Only === true ? constants3.UV_TCP_IPV6ONLY : 0;
}
function _listenInCluster(server, address3, port5, addressType, backlog, fd, exclusive, flags) {
    exclusive = !!exclusive;
    if (true || exclusive) {
        server._listen2(address3, port5, addressType, backlog, fd, flags);
        return;
    }
}
function _lookupAndListen(server, port6, address4, backlog, exclusive, flags) {
    lookup(address4, function doListen(err94, ip, addressType) {
        if (err94) {
            server.emit("error", err94);
        } else {
            addressType = ip ? addressType : 4;
            _listenInCluster(server, ip, port6, addressType, backlog, null, exclusive, flags);
        }
    });
}
function _addAbortSignalOption(server, options) {
    if (options?.signal === undefined) {
        return;
    }
    validateAbortSignal(options.signal, "options.signal");
    const { signal  } = options;
    const onAborted = ()=>{
        server.close();
    };
    if (signal.aborted) {
        nextTick2(onAborted);
    } else {
        signal.addEventListener("abort", onAborted);
        server.once("close", ()=>signal.removeEventListener("abort", onAborted)
        );
    }
}
function _createServerHandle(address5, port7, addressType, fd, flags) {
    let err95 = 0;
    let handle;
    let isTCP = false;
    if (typeof fd === "number" && fd >= 0) {
        try {
            handle = _createHandle(fd, true);
        } catch (e17) {
            debug1("listen invalid fd=%d:", fd, e17.message);
            return codeMap.get("EINVAL");
        }
        err95 = handle.open(fd);
        if (err95) {
            return err95;
        }
        assert1(!address5 && !port7);
    } else if (port7 === -1 && addressType === -1) {
        handle = new Pipe(constants2.SERVER);
        if (isWindows) {
            const instances = Number.parseInt(Deno.env.get("NODE_PENDING_PIPE_INSTANCES") ?? "");
            if (!Number.isNaN(instances)) {
                handle.setPendingInstances(instances);
            }
        }
    } else {
        handle = new TCP(constants3.SERVER);
        isTCP = true;
    }
    if (address5 || port7 || isTCP) {
        debug1("bind to", address5 || "any");
        if (!address5) {
            err95 = handle.bind6(DEFAULT_IPV6_ADDR, port7 ?? 0, flags ?? 0);
            if (err95) {
                handle.close();
                return _createServerHandle(DEFAULT_IPV4_ADDR, port7, 4, null, flags);
            }
        } else if (addressType === 6) {
            err95 = handle.bind6(address5, port7 ?? 0, flags ?? 0);
        } else {
            err95 = handle.bind(address5, port7 ?? 0);
        }
    }
    if (err95) {
        handle.close();
        return err95;
    }
    return handle;
}
function _emitErrorNT(server, err96) {
    server.emit("error", err96);
}
function _emitListeningNT(server) {
    if (server._handle) {
        server.emit("listening");
    }
}
function _onconnection(err97, clientHandle) {
    const handle = this;
    const self = handle[ownerSymbol];
    debug1("onconnection");
    if (err97) {
        self.emit("error", errnoException(err97, "accept"));
        return;
    }
    if (self.maxConnections && self._connections >= self.maxConnections) {
        clientHandle.close();
        return;
    }
    const socket = new Socket({
        handle: clientHandle,
        allowHalfOpen: self.allowHalfOpen,
        pauseOnCreate: self.pauseOnConnect,
        readable: true,
        writable: true
    });
    self._connections++;
    socket.server = self;
    socket._server = self;
    DTRACE_NET_SERVER_CONNECTION(socket);
    self.emit("connection", socket);
}
function _setupListenHandle(address6, port8, addressType, backlog, fd, flags) {
    debug1("setupListenHandle", address6, port8, addressType, backlog, fd);
    if (this._handle) {
        debug1("setupListenHandle: have a handle already");
    } else {
        debug1("setupListenHandle: create a handle");
        let rval = null;
        if (!address6 && typeof fd !== "number") {
            rval = _createServerHandle(DEFAULT_IPV6_ADDR, port8, 6, fd, flags);
            if (typeof rval === "number") {
                rval = null;
                address6 = DEFAULT_IPV4_ADDR;
                addressType = 4;
            } else {
                address6 = DEFAULT_IPV6_ADDR;
                addressType = 6;
            }
        }
        if (rval === null) {
            rval = _createServerHandle(address6, port8, addressType, fd, flags);
        }
        if (typeof rval === "number") {
            const error12 = uvExceptionWithHostPort(rval, "listen", address6, port8);
            nextTick2(_emitErrorNT, this, error12);
            return;
        }
        this._handle = rval;
    }
    this[asyncIdSymbol] = _getNewAsyncId(this._handle);
    this._handle.onconnection = _onconnection;
    this._handle[ownerSymbol] = this;
    const err98 = this._handle.listen(backlog || 511);
    if (err98) {
        const ex = uvExceptionWithHostPort(err98, "listen", address6, port8);
        this._handle.close();
        this._handle = null;
        defaultTriggerAsyncIdScope(this[asyncIdSymbol], nextTick2, _emitErrorNT, this, ex);
        return;
    }
    this._connectionKey = addressType + ":" + address6 + ":" + port8;
    if (this._unref) {
        this.unref();
    }
    defaultTriggerAsyncIdScope(this[asyncIdSymbol], nextTick2, _emitListeningNT, this);
}
class Server extends EventEmitter {
    [asyncIdSymbol] = -1;
    allowHalfOpen = false;
    pauseOnConnect = false;
    _handle = null;
    _connections = 0;
    _usingWorkers = false;
    _workers = [];
    _unref = false;
    _pipeName;
    _connectionKey;
    constructor(options, connectionListener){
        super();
        if (_isConnectionListener(options)) {
            this.on("connection", options);
        } else if (_isServerSocketOptions(options)) {
            this.allowHalfOpen = options?.allowHalfOpen || false;
            this.pauseOnConnect = !!options?.pauseOnConnect;
            if (_isConnectionListener(connectionListener)) {
                this.on("connection", connectionListener);
            }
        } else {
            throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
    }
    listen(...args) {
        const normalized = _normalizeArgs(args);
        let options = normalized[0];
        const cb = normalized[1];
        if (this._handle) {
            throw new ERR_SERVER_ALREADY_LISTEN();
        }
        if (cb !== null) {
            this.once("listening", cb);
        }
        const backlogFromArgs = _toNumber(args.length > 1 && args[1]) || _toNumber(args.length > 2 && args[2]);
        options = options._handle || options.handle || options;
        const flags = _getFlags(options.ipv6Only);
        if (options instanceof TCP) {
            this._handle = options;
            this[asyncIdSymbol] = this._handle.getAsyncId();
            _listenInCluster(this, null, -1, -1, backlogFromArgs);
            return this;
        }
        _addAbortSignalOption(this, options);
        if (typeof options.fd === "number" && options.fd >= 0) {
            _listenInCluster(this, null, null, null, backlogFromArgs, options.fd);
            return this;
        }
        if (args.length === 0 || typeof args[0] === "function" || typeof options.port === "undefined" && "port" in options || options.port === null) {
            options.port = 0;
        }
        let backlog;
        if (typeof options.port === "number" || typeof options.port === "string") {
            validatePort(options.port, "options.port");
            backlog = options.backlog || backlogFromArgs;
            if (options.host) {
                _lookupAndListen(this, options.port | 0, options.host, backlog, !!options.exclusive, flags);
            } else {
                _listenInCluster(this, null, options.port | 0, 4, backlog, undefined, options.exclusive);
            }
            return this;
        }
        if (options.path && _isPipeName(options.path)) {
            const pipeName = this._pipeName = options.path;
            backlog = options.backlog || backlogFromArgs;
            _listenInCluster(this, pipeName, -1, -1, backlog, undefined, options.exclusive);
            if (!this._handle) {
                return this;
            }
            let mode1 = 0;
            if (options.readableAll === true) {
                mode1 |= constants2.UV_READABLE;
            }
            if (options.writableAll === true) {
                mode1 |= constants2.UV_WRITABLE;
            }
            if (mode1 !== 0) {
                const err99 = this._handle.fchmod(mode1);
                if (err99) {
                    this._handle.close();
                    this._handle = null;
                    throw errnoException(err99, "uv_pipe_chmod");
                }
            }
            return this;
        }
        if (!("port" in options || "path" in options)) {
            throw new ERR_INVALID_ARG_VALUE("options", options, 'must have the property "port" or "path"');
        }
        throw new ERR_INVALID_ARG_VALUE("options", options);
    }
    close(cb) {
        if (typeof cb === "function") {
            if (!this._handle) {
                this.once("close", function close() {
                    cb(new ERR_SERVER_NOT_RUNNING());
                });
            } else {
                this.once("close", cb);
            }
        }
        if (this._handle) {
            this._handle.close();
            this._handle = null;
        }
        if (this._usingWorkers) {
            let left = this._workers.length;
            const onWorkerClose = ()=>{
                if (--left !== 0) {
                    return;
                }
                this._connections = 0;
                this._emitCloseIfDrained();
            };
            this._connections++;
            for(let n30 = 0; n30 < this._workers.length; n30++){
                this._workers[n30].close(onWorkerClose);
            }
        } else {
            this._emitCloseIfDrained();
        }
        return this;
    }
    address() {
        if (this._handle && this._handle.getsockname) {
            const out = {};
            const err100 = this._handle.getsockname(out);
            if (err100) {
                throw errnoException(err100, "address");
            }
            return out;
        } else if (this._pipeName) {
            return this._pipeName;
        }
        return null;
    }
    getConnections(cb) {
        const server = this;
        function end(err101, connections) {
            defaultTriggerAsyncIdScope(server[asyncIdSymbol], nextTick2, cb, err101, connections);
        }
        if (!this._usingWorkers) {
            end(null, this._connections);
            return this;
        }
        let left = this._workers.length;
        let total = this._connections;
        function oncount(err102, count4) {
            if (err102) {
                left = -1;
                return end(err102);
            }
            total += count4;
            if (--left === 0) {
                return end(null, total);
            }
        }
        for(let n31 = 0; n31 < this._workers.length; n31++){
            this._workers[n31].getConnections(oncount);
        }
        return this;
    }
    unref() {
        this._unref = true;
        if (this._handle) {
            this._handle.unref();
        }
        return this;
    }
    ref() {
        this._unref = false;
        if (this._handle) {
            this._handle.ref();
        }
        return this;
    }
    get listening() {
        return !!this._handle;
    }
    _listen2 = _setupListenHandle;
    _emitCloseIfDrained() {
        debug1("SERVER _emitCloseIfDrained");
        if (this._handle || this._connections) {
            debug1(`SERVER handle? ${!!this._handle}   connections? ${this._connections}`);
            return;
        }
        defaultTriggerAsyncIdScope(this[asyncIdSymbol], nextTick2, _emitCloseNT, this);
    }
    _setupWorker(socketList1) {
        this._usingWorkers = true;
        this._workers.push(socketList1);
        socketList1.once("exit", (socketList)=>{
            const index9 = this._workers.indexOf(socketList);
            this._workers.splice(index9, 1);
        });
    }
    [EventEmitter.captureRejectionSymbol](err103, event, sock) {
        switch(event){
            case "connection":
                {
                    sock.destroy(err103);
                    break;
                }
            default:
                {
                    this.emit("error", err103);
                }
        }
    }
}
function createServer(options, connectionListener) {
    return new Server(options, connectionListener);
}
const __default17 = {
    _createServerHandle,
    _normalizeArgs,
    isIP,
    isIPv4,
    isIPv6,
    connect,
    createConnection,
    createServer,
    Server,
    Socket,
    Stream: Stream1
};
const active_hooks = {
    array: [],
    call_depth: 0,
    tmp_array: null,
    tmp_fields: null
};
const registerDestroyHook1 = mod9.registerDestroyHook;
const { async_hook_fields , asyncIdFields: async_id_fields , constants: constants4  } = mod9;
const { kInit , kBefore , kAfter , kDestroy: kDestroy1 , kPromiseResolve , kTotals , kCheck , kAsyncIdCounter , kDefaultTriggerAsyncId: kDefaultTriggerAsyncId1 , kStackLength ,  } = constants4;
const resource_symbol = Symbol("resource");
const async_id_symbol = Symbol("trigger_async_id");
const trigger_async_id_symbol = Symbol("trigger_async_id");
const init_symbol = Symbol("init");
const before_symbol = Symbol("before");
const after_symbol = Symbol("after");
const destroy_symbol = Symbol("destroy");
const promise_resolve_symbol = Symbol("promiseResolve");
const symbols = {
    async_id_symbol,
    trigger_async_id_symbol,
    init_symbol,
    before_symbol,
    after_symbol,
    destroy_symbol,
    promise_resolve_symbol
};
function lookupPublicResource(resource) {
    if (typeof resource !== "object" || resource === null) return resource;
    const publicResource = resource[resource_symbol];
    if (publicResource !== undefined) {
        return publicResource;
    }
    return resource;
}
function emitInitNative(asyncId, type37, triggerAsyncId, resource) {
    active_hooks.call_depth += 1;
    resource = lookupPublicResource(resource);
    try {
        for(let i101 = 0; i101 < active_hooks.array.length; i101++){
            if (typeof active_hooks.array[i101][init_symbol] === "function") {
                active_hooks.array[i101][init_symbol](asyncId, type37, triggerAsyncId, resource);
            }
        }
    } catch (e18) {
        throw e18;
    } finally{
        active_hooks.call_depth -= 1;
    }
    if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {
        restoreActiveHooks();
    }
}
function copyHooks(destination, source) {
    destination[kInit] = source[kInit];
    destination[kBefore] = source[kBefore];
    destination[kAfter] = source[kAfter];
    destination[kDestroy1] = source[kDestroy1];
    destination[kPromiseResolve] = source[kPromiseResolve];
}
function restoreActiveHooks() {
    active_hooks.array = active_hooks.tmp_array;
    copyHooks(async_hook_fields, active_hooks.tmp_fields);
    active_hooks.tmp_array = null;
    active_hooks.tmp_fields = null;
}
function newAsyncId1() {
    return ++async_id_fields[kAsyncIdCounter];
}
function getDefaultTriggerAsyncId() {
    const defaultTriggerAsyncId = async_id_fields[mod9.UidFields.kDefaultTriggerAsyncId];
    if (defaultTriggerAsyncId < 0) {
        return async_id_fields[mod9.UidFields.kExecutionAsyncId];
    }
    return defaultTriggerAsyncId;
}
function defaultTriggerAsyncIdScope1(triggerAsyncId, block, ...args) {
    if (triggerAsyncId === undefined) {
        return block.apply(null, args);
    }
    const oldDefaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId1];
    async_id_fields[kDefaultTriggerAsyncId1] = triggerAsyncId;
    try {
        return block.apply(null, args);
    } finally{
        async_id_fields[kDefaultTriggerAsyncId1] = oldDefaultTriggerAsyncId;
    }
}
function hasHooks(key) {
    return async_hook_fields[key] > 0;
}
function enabledHooksExist() {
    return hasHooks(kCheck);
}
function initHooksExist() {
    return hasHooks(kInit);
}
function destroyHooksExist() {
    return hasHooks(kDestroy1);
}
function emitInitScript(asyncId, type38, triggerAsyncId, resource) {
    if (!hasHooks(kInit)) {
        return;
    }
    if (triggerAsyncId === null) {
        triggerAsyncId = getDefaultTriggerAsyncId();
    }
    emitInitNative(asyncId, type38, triggerAsyncId, resource);
}
function hasAsyncIdStack() {
    return hasHooks(kStackLength);
}
const destroyedSymbol = Symbol("destroyed");
class AsyncResource {
    [async_id_symbol];
    [trigger_async_id_symbol];
    [destroyedSymbol];
    constructor(type39, opts = {}){
        validateString(type39, "type");
        let triggerAsyncId;
        let requireManualDestroy = false;
        if (typeof opts !== "number") {
            triggerAsyncId = opts.triggerAsyncId === undefined ? getDefaultTriggerAsyncId() : opts.triggerAsyncId;
            requireManualDestroy = !!opts.requireManualDestroy;
        } else {
            triggerAsyncId = opts;
        }
        if (!Number.isSafeInteger(triggerAsyncId) || triggerAsyncId < -1) {
            throw new ERR_INVALID_ASYNC_ID("triggerAsyncId", triggerAsyncId);
        }
        const asyncId = newAsyncId1();
        this[async_id_symbol] = asyncId;
        this[trigger_async_id_symbol] = triggerAsyncId;
        if (initHooksExist()) {
            if (enabledHooksExist() && type39.length === 0) {
                throw new ERR_ASYNC_TYPE(type39);
            }
            emitInitScript(asyncId, type39, triggerAsyncId, this);
        }
        if (!requireManualDestroy && destroyHooksExist()) {
            const destroyed = {
                destroyed: false
            };
            this[destroyedSymbol] = destroyed;
            registerDestroyHook1(this, asyncId, destroyed);
        }
    }
    runInAsyncScope(fn, thisArg, ...args) {
        this[async_id_symbol];
        try {
            const ret = Reflect.apply(fn, thisArg, args);
            return ret;
        } finally{
            if (hasAsyncIdStack()) {}
        }
    }
    emitDestroy() {
        if (this[destroyedSymbol] !== undefined) {
            this[destroyedSymbol].destroyed = true;
        }
        return this;
    }
    asyncId() {
        return this[async_id_symbol];
    }
    triggerAsyncId() {
        return this[trigger_async_id_symbol];
    }
    bind(fn, thisArg = this) {
        validateFunction(fn, "fn");
        const ret = this.runInAsyncScope.bind(this, fn, thisArg);
        Object.defineProperties(ret, {
            "length": {
                configurable: true,
                enumerable: false,
                value: fn.length,
                writable: false
            },
            "asyncResource": {
                configurable: true,
                enumerable: true,
                value: this,
                writable: true
            }
        });
        return ret;
    }
    static bind(fn, type40, thisArg) {
        type40 = type40 || fn.name;
        return new AsyncResource(type40 || "bound-anonymous-fn").bind(fn, thisArg);
    }
}
function executionAsyncId() {
    return 1;
}
class AsyncHook {
    enable() {}
    disable() {}
}
function createHook() {
    return new AsyncHook();
}
const __default18 = {
    AsyncResource,
    executionAsyncId,
    createHook
};
let debug2 = debuglog("http", (fn)=>{
    debug2 = fn;
});
const { async_id_symbol: async_id_symbol1  } = symbols;
const kOnKeylog = Symbol("onkeylog");
const kRequestOptions = Symbol("requestOptions");
const kRequestAsyncResource = Symbol("requestAsyncResource");
class ReusedHandle {
    constructor(type41, handle){
        this.type = type41;
        this.handle = handle;
    }
}
function freeSocketErrorListener(err104) {
    const socket = this;
    debug2("SOCKET ERROR on FREE socket:", err104.message, err104.stack);
    socket.destroy();
    socket.emit("agentRemove");
}
function Agent(options1) {
    if (!(this instanceof Agent)) {
        return new Agent(options1);
    }
    EventEmitter.call(this);
    this.defaultPort = 80;
    this.protocol = "http:";
    this.options = {
        __proto__: null,
        ...options1
    };
    this.options.path = null;
    this.requests = Object.create(null);
    this.sockets = Object.create(null);
    this.freeSockets = Object.create(null);
    this.keepAliveMsecs = this.options.keepAliveMsecs || 1000;
    this.keepAlive = this.options.keepAlive || false;
    this.maxSockets = this.options.maxSockets || Agent.defaultMaxSockets;
    this.maxFreeSockets = this.options.maxFreeSockets || 256;
    this.scheduling = this.options.scheduling || "lifo";
    this.maxTotalSockets = this.options.maxTotalSockets;
    this.totalSocketCount = 0;
    validateOneOf(this.scheduling, "scheduling", [
        "fifo",
        "lifo"
    ]);
    if (this.maxTotalSockets !== undefined) {
        validateNumber(this.maxTotalSockets, "maxTotalSockets");
        if (this.maxTotalSockets <= 0 || Number.isNaN(this.maxTotalSockets)) {
            throw new ERR_OUT_OF_RANGE("maxTotalSockets", "> 0", this.maxTotalSockets);
        }
    } else {
        this.maxTotalSockets = Infinity;
    }
    this.on("free", (socket, options)=>{
        const name46 = this.getName(options);
        debug2("agent.on(free)", name46);
        if (!socket.writable) {
            socket.destroy();
            return;
        }
        const requests = this.requests[name46];
        if (requests && requests.length) {
            const req17 = requests.shift();
            const reqAsyncRes = req17[kRequestAsyncResource];
            if (reqAsyncRes) {
                reqAsyncRes.runInAsyncScope(()=>{
                    asyncResetHandle(socket);
                    setRequestSocket(this, req17, socket);
                });
                req17[kRequestAsyncResource] = null;
            } else {
                setRequestSocket(this, req17, socket);
            }
            if (requests.length === 0) {
                delete this.requests[name46];
            }
            return;
        }
        const req18 = socket._httpMessage;
        if (!req18 || !req18.shouldKeepAlive || !this.keepAlive) {
            socket.destroy();
            return;
        }
        const freeSockets = this.freeSockets[name46] || [];
        const freeLen = freeSockets.length;
        let count5 = freeLen;
        if (this.sockets[name46]) {
            count5 += this.sockets[name46].length;
        }
        if (this.totalSocketCount > this.maxTotalSockets || count5 > this.maxSockets || freeLen >= this.maxFreeSockets || !this.keepSocketAlive(socket)) {
            socket.destroy();
            return;
        }
        this.freeSockets[name46] = freeSockets;
        socket[async_id_symbol1] = -1;
        socket._httpMessage = null;
        this.removeSocket(socket, options);
        socket.once("error", freeSocketErrorListener);
        freeSockets.push(socket);
    });
    this.on("newListener", maybeEnableKeylog);
}
Object.setPrototypeOf(Agent.prototype, EventEmitter.prototype);
Object.setPrototypeOf(Agent, EventEmitter);
function maybeEnableKeylog(eventName) {
    if (eventName === "keylog") {
        this.removeListener("newListener", maybeEnableKeylog);
        const agent = this;
        this[kOnKeylog] = function onkeylog(keylog) {
            agent.emit("keylog", keylog, this);
        };
        const sockets = ObjectValues(this.sockets);
        for(let i102 = 0; i102 < sockets.length; i102++){
            sockets[i102].on("keylog", this[kOnKeylog]);
        }
    }
}
Agent.defaultMaxSockets = Infinity;
Agent.prototype.createConnection = createConnection;
Agent.prototype.getName = function getName(options) {
    let name47 = options.host || "localhost";
    name47 += ":";
    if (options.port) {
        name47 += options.port;
    }
    name47 += ":";
    if (options.localAddress) {
        name47 += options.localAddress;
    }
    if (options.family === 4 || options.family === 6) {
        name47 += `:${options.family}`;
    }
    if (options.socketPath) {
        name47 += `:${options.socketPath}`;
    }
    return name47;
};
Agent.prototype.addRequest = function addRequest(req19, options, port9, localAddress) {
    if (typeof options === "string") {
        options = {
            __proto__: null,
            host: options,
            port: port9,
            localAddress
        };
    }
    options = {
        __proto__: null,
        ...options,
        ...this.options
    };
    if (options.socketPath) {
        options.path = options.socketPath;
    }
    if (!options.servername && options.servername !== "") {
        options.servername = calculateServerName(options, req19);
    }
    const name48 = this.getName(options);
    if (!this.sockets[name48]) {
        this.sockets[name48] = [];
    }
    const freeSockets = this.freeSockets[name48];
    let socket1;
    if (freeSockets) {
        while(freeSockets.length && freeSockets[0].destroyed){
            freeSockets.shift();
        }
        socket1 = this.scheduling === "fifo" ? freeSockets.shift() : freeSockets.pop();
        if (!freeSockets.length) {
            delete this.freeSockets[name48];
        }
    }
    const freeLen = freeSockets ? freeSockets.length : 0;
    const sockLen = freeLen + this.sockets[name48].length;
    if (socket1) {
        asyncResetHandle(socket1);
        this.reuseSocket(socket1, req19);
        setRequestSocket(this, req19, socket1);
        this.sockets[name48].push(socket1);
    } else if (sockLen < this.maxSockets && this.totalSocketCount < this.maxTotalSockets) {
        debug2("call onSocket", sockLen, freeLen);
        this.createSocket(req19, options, (err105, socket)=>{
            if (err105) {
                req19.onSocket(socket, err105);
            } else {
                setRequestSocket(this, req19, socket);
            }
        });
    } else {
        debug2("wait for socket");
        if (!this.requests[name48]) {
            this.requests[name48] = [];
        }
        req19[kRequestOptions] = options;
        req19[kRequestAsyncResource] = new AsyncResource("QueuedRequest");
        this.requests[name48].push(req19);
    }
};
Agent.prototype.createSocket = function createSocket(req20, options, cb) {
    options = {
        __proto__: null,
        ...options,
        ...this.options
    };
    if (options.socketPath) {
        options.path = options.socketPath;
    }
    if (!options.servername && options.servername !== "") {
        options.servername = calculateServerName(options, req20);
    }
    const name49 = this.getName(options);
    options._agentKey = name49;
    debug2("createConnection", name49, options);
    options.encoding = null;
    const oncreate = once((err106, s16)=>{
        if (err106) {
            return cb(err106);
        }
        if (!this.sockets[name49]) {
            this.sockets[name49] = [];
        }
        this.sockets[name49].push(s16);
        this.totalSocketCount++;
        debug2("sockets", name49, this.sockets[name49].length, this.totalSocketCount);
        installListeners(this, s16, options);
        cb(null, s16);
    });
    const newSocket = this.createConnection(options, oncreate);
    if (newSocket) {
        oncreate(null, newSocket);
    }
};
function calculateServerName(options, req21) {
    let servername = options.host;
    const hostHeader = req21.getHeader("host");
    if (hostHeader) {
        validateString(hostHeader, "options.headers.host");
        if (hostHeader.startsWith("[")) {
            const index10 = hostHeader.indexOf("]");
            if (index10 === -1) {
                servername = hostHeader;
            } else {
                servername = hostHeader.substr(1, index10 - 1);
            }
        } else {
            servername = hostHeader.split(":", 1)[0];
        }
    }
    if (isIP(servername)) {
        servername = "";
    }
    return servername;
}
function installListeners(agent, s17, options) {
    function onFree() {
        debug2("CLIENT socket onFree");
        agent.emit("free", s17, options);
    }
    s17.on("free", onFree);
    function onClose(_err) {
        debug2("CLIENT socket onClose");
        agent.totalSocketCount--;
        agent.removeSocket(s17, options);
    }
    s17.on("close", onClose);
    function onTimeout() {
        debug2("CLIENT socket onTimeout");
        const sockets = agent.freeSockets;
        if (Object.keys(sockets).some((name50)=>sockets[name50].includes(s17)
        )) {
            return s17.destroy();
        }
    }
    s17.on("timeout", onTimeout);
    function onRemove() {
        debug2("CLIENT socket onRemove");
        agent.totalSocketCount--;
        agent.removeSocket(s17, options);
        s17.removeListener("close", onClose);
        s17.removeListener("free", onFree);
        s17.removeListener("timeout", onTimeout);
        s17.removeListener("agentRemove", onRemove);
    }
    s17.on("agentRemove", onRemove);
    if (agent[kOnKeylog]) {
        s17.on("keylog", agent[kOnKeylog]);
    }
}
Agent.prototype.removeSocket = function removeSocket(s18, options) {
    const name51 = this.getName(options);
    debug2("removeSocket", name51, "writable:", s18.writable);
    const sets = [
        this.sockets
    ];
    if (!s18.writable) {
        sets.push(this.freeSockets);
    }
    for(let sk = 0; sk < sets.length; sk++){
        const sockets = sets[sk];
        if (sockets[name51]) {
            const index11 = sockets[name51].indexOf(s18);
            if (index11 !== -1) {
                sockets[name51].splice(index11, 1);
                if (sockets[name51].length === 0) {
                    delete sockets[name51];
                }
            }
        }
    }
    let req22;
    if (this.requests[name51] && this.requests[name51].length) {
        debug2("removeSocket, have a request, make a socket");
        req22 = this.requests[name51][0];
    } else {
        const keys = Object.keys(this.requests);
        for(let i103 = 0; i103 < keys.length; i103++){
            const prop = keys[i103];
            if (this.sockets[prop] && this.sockets[prop].length) break;
            debug2("removeSocket, have a request with different origin," + " make a socket");
            req22 = this.requests[prop][0];
            options = req22[kRequestOptions];
            break;
        }
    }
    if (req22 && options) {
        req22[kRequestOptions] = undefined;
        this.createSocket(req22, options, (err107, socket)=>{
            if (err107) {
                req22.onSocket(socket, err107);
            } else {
                socket.emit("free");
            }
        });
    }
};
Agent.prototype.keepSocketAlive = function keepSocketAlive(socket) {
    socket.setKeepAlive(true, this.keepAliveMsecs);
    socket.unref();
    const agentTimeout = this.options.timeout || 0;
    if (socket.timeout !== agentTimeout) {
        socket.setTimeout(agentTimeout);
    }
    return true;
};
Agent.prototype.reuseSocket = function reuseSocket(socket, req23) {
    debug2("have free socket");
    socket.removeListener("error", freeSocketErrorListener);
    req23.reusedSocket = true;
    socket.ref();
};
Agent.prototype.destroy = function destroy() {
    const sets = [
        this.freeSockets,
        this.sockets
    ];
    for(let s19 = 0; s19 < sets.length; s19++){
        const set = sets[s19];
        const keys = Object.keys(set);
        for(let v10 = 0; v10 < keys.length; v10++){
            const setName = set[keys[v10]];
            for(let n32 = 0; n32 < setName.length; n32++){
                setName[n32].destroy();
            }
        }
    }
};
function setRequestSocket(agent, req24, socket) {
    req24.onSocket(socket);
    const agentTimeout = agent.options.timeout || 0;
    if (req24.timeout === undefined || req24.timeout === agentTimeout) {
        return;
    }
    socket.setTimeout(req24.timeout);
}
function asyncResetHandle(socket) {
    const handle = socket._handle;
    if (handle && typeof handle.asyncReset === "function") {
        handle.asyncReset(new ReusedHandle(handle.getProviderType(), handle));
        socket[async_id_symbol1] = handle.getAsyncId();
    }
}
const globalAgent = new Agent();
const __default19 = {
    Agent,
    globalAgent
};
function assert2(value, message) {
    if (!value) {
        throw new ERR_INTERNAL_ASSERTION(message);
    }
}
function fail(message) {
    throw new ERR_INTERNAL_ASSERTION(message);
}
assert2.fail = fail;
let utcCache;
function utcDate() {
    if (!utcCache) cache();
    return utcCache;
}
function cache() {
    const d7 = new Date();
    utcCache = d7.toUTCString();
    setUnrefTimeout(resetCache, 1000 - d7.getMilliseconds());
}
function resetCache() {
    utcCache = undefined;
}
function emitStatistics(_statistics) {
    notImplemented();
}
const kOutHeaders = Symbol("kOutHeaders");
const kNeedDrain = Symbol("kNeedDrain");
const __default20 = {
    utcDate,
    emitStatistics,
    kOutHeaders,
    kNeedDrain
};
const tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
function checkIsHttpToken(val) {
    return tokenRegExp.test(val);
}
const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
function checkInvalidHeaderChar(val) {
    return headerCharRegex.test(val);
}
const chunkExpression = /(?:^|\W)chunked(?:$|\W)/i;
const { async_id_symbol: async_id_symbol2  } = symbols;
let debug3 = debuglog("http", (fn)=>{
    debug3 = fn;
});
const HIGH_WATER_MARK = getDefaultHighWaterMark();
const kCorked = Symbol("corked");
const nop3 = ()=>{};
const RE_CONN_CLOSE = /(?:^|\W)close(?:$|\W)/i;
function isCookieField(s20) {
    return s20.length === 6 && s20.toLowerCase() === "cookie";
}
function OutgoingMessage() {
    Stream.call(this);
    this.outputData = [];
    this.outputSize = 0;
    this.writable = true;
    this.destroyed = false;
    this._last = false;
    this.chunkedEncoding = false;
    this.shouldKeepAlive = true;
    this.maxRequestsOnConnectionReached = false;
    this._defaultKeepAlive = true;
    this.useChunkedEncodingByDefault = true;
    this.sendDate = false;
    this._removedConnection = false;
    this._removedContLen = false;
    this._removedTE = false;
    this._contentLength = null;
    this._hasBody = true;
    this._trailer = "";
    this[kNeedDrain] = false;
    this.finished = false;
    this._headerSent = false;
    this[kCorked] = 0;
    this._closed = false;
    this.socket = null;
    this._header = null;
    this[kOutHeaders] = null;
    this._keepAliveTimeout = 0;
    this._onPendingData = nop3;
}
Object.setPrototypeOf(OutgoingMessage.prototype, Stream.prototype);
Object.setPrototypeOf(OutgoingMessage, Stream);
Object.defineProperty(OutgoingMessage.prototype, "writableFinished", {
    get () {
        return this.finished && this.outputSize === 0 && (!this.socket || this.socket.writableLength === 0);
    }
});
Object.defineProperty(OutgoingMessage.prototype, "writableObjectMode", {
    get () {
        return false;
    }
});
Object.defineProperty(OutgoingMessage.prototype, "writableLength", {
    get () {
        return this.outputSize + (this.socket ? this.socket.writableLength : 0);
    }
});
Object.defineProperty(OutgoingMessage.prototype, "writableHighWaterMark", {
    get () {
        return this.socket ? this.socket.writableHighWaterMark : HIGH_WATER_MARK;
    }
});
Object.defineProperty(OutgoingMessage.prototype, "writableCorked", {
    get () {
        const corked = this.socket ? this.socket.writableCorked : 0;
        return corked + this[kCorked];
    }
});
Object.defineProperty(OutgoingMessage.prototype, "_headers", {
    get: deprecate(function() {
        return this.getHeaders();
    }, "OutgoingMessage.prototype._headers is deprecated", "DEP0066"),
    set: deprecate(function(val) {
        if (val == null) {
            this[kOutHeaders] = null;
        } else if (typeof val === "object") {
            const headers = this[kOutHeaders] = Object.create(null);
            const keys = Object.keys(val);
            for(let i104 = 0; i104 < keys.length; ++i104){
                const name52 = keys[i104];
                headers[name52.toLowerCase()] = [
                    name52,
                    val[name52]
                ];
            }
        }
    }, "OutgoingMessage.prototype._headers is deprecated", "DEP0066")
});
Object.defineProperty(OutgoingMessage.prototype, "connection", {
    get: function() {
        return this.socket;
    },
    set: function(val) {
        this.socket = val;
    }
});
Object.defineProperty(OutgoingMessage.prototype, "_headerNames", {
    get: deprecate(function() {
        const headers = this[kOutHeaders];
        if (headers !== null) {
            const out = Object.create(null);
            const keys = Object.keys(headers);
            for(let i105 = 0; i105 < keys.length; ++i105){
                const key = keys[i105];
                const val = headers[key][0];
                out[key] = val;
            }
            return out;
        }
        return null;
    }, "OutgoingMessage.prototype._headerNames is deprecated", "DEP0066"),
    set: deprecate(function(val) {
        if (typeof val === "object" && val !== null) {
            const headers = this[kOutHeaders];
            if (!headers) {
                return;
            }
            const keys = Object.keys(val);
            for(let i106 = 0; i106 < keys.length; ++i106){
                const header = headers[keys[i106]];
                if (header) {
                    header[0] = val[keys[i106]];
                }
            }
        }
    }, "OutgoingMessage.prototype._headerNames is deprecated", "DEP0066")
});
OutgoingMessage.prototype._renderHeaders = function _renderHeaders() {
    if (this._header) {
        throw new ERR_HTTP_HEADERS_SENT("render");
    }
    const headersMap = this[kOutHeaders];
    const headers = {};
    if (headersMap !== null) {
        const keys = Object.keys(headersMap);
        for(let i107 = 0, l3 = keys.length; i107 < l3; i107++){
            const key = keys[i107];
            headers[headersMap[key][0]] = headersMap[key][1];
        }
    }
    return headers;
};
OutgoingMessage.prototype.cork = function() {
    if (this.socket) {
        this.socket.cork();
    } else {
        this[kCorked]++;
    }
};
OutgoingMessage.prototype.uncork = function() {
    if (this.socket) {
        this.socket.uncork();
    } else if (this[kCorked]) {
        this[kCorked]--;
    }
};
OutgoingMessage.prototype.setTimeout = function setTimeout(msecs, callback) {
    if (callback) {
        this.on("timeout", callback);
    }
    if (!this.socket) {
        this.once("socket", function socketSetTimeoutOnConnect(socket) {
            socket.setTimeout(msecs);
        });
    } else {
        this.socket.setTimeout(msecs);
    }
    return this;
};
OutgoingMessage.prototype.destroy = function destroy(error13) {
    if (this.destroyed) {
        return this;
    }
    this.destroyed = true;
    if (this.socket) {
        this.socket.destroy(error13);
    } else {
        this.once("socket", function socketDestroyOnConnect(socket) {
            socket.destroy(error13);
        });
    }
    return this;
};
OutgoingMessage.prototype._send = function _send(data24, encoding, callback) {
    if (!this._headerSent) {
        if (typeof data24 === "string" && (encoding === "utf8" || encoding === "latin1" || !encoding)) {
            data24 = this._header + data24;
        } else {
            const header = this._header;
            this.outputData.unshift({
                data: header,
                encoding: "latin1",
                callback: null
            });
            this.outputSize += header.length;
            this._onPendingData(header.length);
        }
        this._headerSent = true;
    }
    return this._writeRaw(data24, encoding, callback);
};
OutgoingMessage.prototype._writeRaw = _writeRaw;
function _writeRaw(data25, encoding, callback) {
    const conn = this.socket;
    if (conn && conn.destroyed) {
        return false;
    }
    if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
    }
    if (conn && conn._httpMessage === this && conn.writable) {
        if (this.outputData.length) {
            this._flushOutput(conn);
        }
        return conn.write(data25, encoding, callback);
    }
    this.outputData.push({
        data: data25,
        encoding,
        callback
    });
    this.outputSize += data25.length;
    this._onPendingData(data25.length);
    return this.outputSize < HIGH_WATER_MARK;
}
OutgoingMessage.prototype._storeHeader = _storeHeader;
function _storeHeader(firstLine, headers) {
    const state52 = {
        connection: false,
        contLen: false,
        te: false,
        date: false,
        expect: false,
        trailer: false,
        header: firstLine
    };
    if (headers) {
        if (headers === this[kOutHeaders]) {
            for(const key in headers){
                const entry = headers[key];
                processHeader(this, state52, entry[0], entry[1], false);
            }
        } else if (Array.isArray(headers)) {
            if (headers.length && Array.isArray(headers[0])) {
                for(let i108 = 0; i108 < headers.length; i108++){
                    const entry = headers[i108];
                    processHeader(this, state52, entry[0], entry[1], true);
                }
            } else {
                if (headers.length % 2 !== 0) {
                    throw new ERR_INVALID_ARG_VALUE("headers", headers);
                }
                for(let n33 = 0; n33 < headers.length; n33 += 2){
                    processHeader(this, state52, headers[n33 + 0], headers[n33 + 1], true);
                }
            }
        } else {
            for(const key in headers){
                if (Object.hasOwn(headers, key)) {
                    processHeader(this, state52, key, headers[key], true);
                }
            }
        }
    }
    let { header  } = state52;
    if (this.sendDate && !state52.date) {
        header += "Date: " + utcDate() + "\r\n";
    }
    if (this.chunkedEncoding && (this.statusCode === 204 || this.statusCode === 304)) {
        debug3(this.statusCode + " response should not use chunked encoding," + " closing connection.");
        this.chunkedEncoding = false;
        this.shouldKeepAlive = false;
    }
    if (this._removedConnection) {
        this._last = true;
        this.shouldKeepAlive = false;
    } else if (!state52.connection) {
        const shouldSendKeepAlive = this.shouldKeepAlive && (state52.contLen || this.useChunkedEncodingByDefault || this.agent);
        if (shouldSendKeepAlive && this.maxRequestsOnConnectionReached) {
            header += "Connection: close\r\n";
        } else if (shouldSendKeepAlive) {
            header += "Connection: keep-alive\r\n";
            if (this._keepAliveTimeout && this._defaultKeepAlive) {
                const timeoutSeconds = Math.floor(this._keepAliveTimeout / 1000);
                header += `Keep-Alive: timeout=${timeoutSeconds}\r\n`;
            }
        } else {
            this._last = true;
            header += "Connection: close\r\n";
        }
    }
    if (!state52.contLen && !state52.te) {
        if (!this._hasBody) {
            this.chunkedEncoding = false;
        } else if (!this.useChunkedEncodingByDefault) {
            this._last = true;
        } else if (!state52.trailer && !this._removedContLen && typeof this._contentLength === "number") {
            header += "Content-Length: " + this._contentLength + "\r\n";
        } else if (!this._removedTE) {
            header += "Transfer-Encoding: chunked\r\n";
            this.chunkedEncoding = true;
        } else {
            debug3("Both Content-Length and Transfer-Encoding are removed");
        }
    }
    if (this.chunkedEncoding !== true && state52.trailer) {
        throw new ERR_HTTP_TRAILER_INVALID();
    }
    this._header = header + "\r\n";
    this._headerSent = false;
    if (state52.expect) this._send("");
}
function processHeader(self, state53, key, value, validate) {
    if (validate) {
        validateHeaderName(key);
    }
    if (Array.isArray(value)) {
        if (value.length < 2 || !isCookieField(key)) {
            for(let i109 = 0; i109 < value.length; i109++){
                storeHeader(self, state53, key, value[i109], validate);
            }
            return;
        }
        value = value.join("; ");
    }
    storeHeader(self, state53, key, value, validate);
}
function storeHeader(self, state54, key, value, validate) {
    if (validate) {
        validateHeaderValue(key, value);
    }
    state54.header += key + ": " + value + "\r\n";
    matchHeader(self, state54, key, value);
}
function matchHeader(self, state55, field, value) {
    if (field.length < 4 || field.length > 17) {
        return;
    }
    field = field.toLowerCase();
    switch(field){
        case "connection":
            state55.connection = true;
            self._removedConnection = false;
            if (RE_CONN_CLOSE.test(value)) {
                self._last = true;
            } else {
                self.shouldKeepAlive = true;
            }
            break;
        case "transfer-encoding":
            state55.te = true;
            self._removedTE = false;
            if (chunkExpression.test(value)) {
                self.chunkedEncoding = true;
            }
            break;
        case "content-length":
            state55.contLen = true;
            self._removedContLen = false;
            break;
        case "date":
        case "expect":
        case "trailer":
            state55[field] = true;
            break;
        case "keep-alive":
            self._defaultKeepAlive = false;
            break;
    }
}
const validateHeaderName = hideStackFrames((name53)=>{
    if (typeof name53 !== "string" || !name53 || !checkIsHttpToken(name53)) {
        throw new ERR_INVALID_HTTP_TOKEN("Header name", name53);
    }
});
const validateHeaderValue = hideStackFrames((name54, value)=>{
    if (value === undefined) {
        throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name54);
    }
    if (checkInvalidHeaderChar(value)) {
        debug3('Header "%s" contains invalid characters', name54);
        throw new ERR_INVALID_CHAR("header content", name54);
    }
});
OutgoingMessage.prototype.setHeader = function setHeader(name55, value) {
    if (this._header) {
        throw new ERR_HTTP_HEADERS_SENT("set");
    }
    validateHeaderName(name55);
    validateHeaderValue(name55, value);
    let headers = this[kOutHeaders];
    if (headers === null) {
        this[kOutHeaders] = headers = Object.create(null);
    }
    headers[name55.toLowerCase()] = [
        name55,
        value
    ];
    return this;
};
OutgoingMessage.prototype.getHeader = function getHeader(name56) {
    validateString(name56, "name");
    const headers = this[kOutHeaders];
    if (headers === null) {
        return;
    }
    const entry = headers[name56.toLowerCase()];
    return entry && entry[1];
};
OutgoingMessage.prototype.getHeaderNames = function getHeaderNames() {
    return this[kOutHeaders] !== null ? Object.keys(this[kOutHeaders]) : [];
};
OutgoingMessage.prototype.getRawHeaderNames = function getRawHeaderNames() {
    const headersMap = this[kOutHeaders];
    if (headersMap === null) return [];
    const values = Object.values(headersMap);
    const headers = Array(values.length);
    for(let i110 = 0, l4 = values.length; i110 < l4; i110++){
        headers[i110] = values[i110][0];
    }
    return headers;
};
OutgoingMessage.prototype.getHeaders = function getHeaders() {
    const headers = this[kOutHeaders];
    const ret = Object.create(null);
    if (headers) {
        const keys = Object.keys(headers);
        for(let i111 = 0; i111 < keys.length; ++i111){
            const key = keys[i111];
            const val = headers[key][1];
            ret[key] = val;
        }
    }
    return ret;
};
OutgoingMessage.prototype.hasHeader = function hasHeader(name57) {
    validateString(name57, "name");
    return this[kOutHeaders] !== null && !!this[kOutHeaders][name57.toLowerCase()];
};
OutgoingMessage.prototype.removeHeader = function removeHeader(name58) {
    validateString(name58, "name");
    if (this._header) {
        throw new ERR_HTTP_HEADERS_SENT("remove");
    }
    const key = name58.toLowerCase();
    switch(key){
        case "connection":
            this._removedConnection = true;
            break;
        case "content-length":
            this._removedContLen = true;
            break;
        case "transfer-encoding":
            this._removedTE = true;
            break;
        case "date":
            this.sendDate = false;
            break;
    }
    if (this[kOutHeaders] !== null) {
        delete this[kOutHeaders][key];
    }
};
OutgoingMessage.prototype._implicitHeader = function _implicitHeader() {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_implicitHeader()");
};
Object.defineProperty(OutgoingMessage.prototype, "headersSent", {
    configurable: true,
    enumerable: true,
    get: function() {
        return !!this._header;
    }
});
Object.defineProperty(OutgoingMessage.prototype, "writableEnded", {
    get: function() {
        return this.finished;
    }
});
Object.defineProperty(OutgoingMessage.prototype, "writableNeedDrain", {
    get: function() {
        return !this.destroyed && !this.finished && this[kNeedDrain];
    }
});
const crlf_buf = Buffer1.from("\r\n");
OutgoingMessage.prototype.write = function write(chunk, encoding, callback) {
    if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
    }
    const ret = write_(this, chunk, encoding, callback, false);
    if (!ret) {
        this[kNeedDrain] = true;
    }
    return ret;
};
function onError(msg, err108, callback) {
    const triggerAsyncId = msg.socket ? msg.socket[async_id_symbol2] : undefined;
    defaultTriggerAsyncIdScope1(triggerAsyncId, globalThis.process.nextTick, emitErrorNt, msg, err108, callback);
}
function emitErrorNt(msg, err109, callback) {
    callback(err109);
    if (typeof msg.emit === "function" && !msg._closed) {
        msg.emit("error", err109);
    }
}
function write_(msg, chunk, encoding, callback, fromEnd) {
    if (typeof callback !== "function") {
        callback = nop3;
    }
    let len;
    if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk === "string") {
        len = Buffer1.byteLength(chunk, encoding);
    } else if (isUint8Array(chunk)) {
        len = chunk.length;
    } else {
        throw new ERR_INVALID_ARG_TYPE("chunk", [
            "string",
            "Buffer",
            "Uint8Array"
        ], chunk);
    }
    let err110;
    if (msg.finished) {
        err110 = new ERR_STREAM_WRITE_AFTER_END();
    } else if (msg.destroyed) {
        err110 = new ERR_STREAM_DESTROYED("write");
    }
    if (err110) {
        if (!msg.destroyed) {
            onError(msg, err110, callback);
        } else {
            globalThis.process.nextTick(callback, err110);
        }
        return false;
    }
    if (!msg._header) {
        if (fromEnd) {
            msg._contentLength = len;
        }
        msg._implicitHeader();
    }
    if (!msg._hasBody) {
        debug3("This type of response MUST NOT have a body. " + "Ignoring write() calls.");
        globalThis.process.nextTick(callback);
        return true;
    }
    if (!fromEnd && msg.socket && !msg.socket.writableCorked) {
        msg.socket.cork();
        globalThis.process.nextTick(connectionCorkNT, msg.socket);
    }
    let ret;
    if (msg.chunkedEncoding && chunk.length !== 0) {
        msg._send(len.toString(16), "latin1", null);
        msg._send(crlf_buf, null, null);
        msg._send(chunk, encoding, null);
        ret = msg._send(crlf_buf, null, callback);
    } else {
        ret = msg._send(chunk, encoding, callback);
    }
    debug3("write ret = " + ret);
    return ret;
}
function connectionCorkNT(conn) {
    conn.uncork();
}
OutgoingMessage.prototype.addTrailers = function addTrailers(headers) {
    this._trailer = "";
    const keys = Object.keys(headers);
    const isArray1 = Array.isArray(headers);
    for(let i112 = 0, l5 = keys.length; i112 < l5; i112++){
        let field, value;
        const key = keys[i112];
        if (isArray1) {
            field = headers[key][0];
            value = headers[key][1];
        } else {
            field = key;
            value = headers[key];
        }
        if (typeof field !== "string" || !field || !checkIsHttpToken(field)) {
            throw new ERR_INVALID_HTTP_TOKEN("Trailer name", field);
        }
        if (checkInvalidHeaderChar(value)) {
            debug3('Trailer "%s" contains invalid characters', field);
            throw new ERR_INVALID_CHAR("trailer content", field);
        }
        this._trailer += field + ": " + value + "\r\n";
    }
};
function onFinish(outmsg) {
    if (outmsg && outmsg.socket && outmsg.socket._hadError) return;
    outmsg.emit("finish");
}
OutgoingMessage.prototype.end = function end(chunk, encoding, callback) {
    if (typeof chunk === "function") {
        callback = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
    }
    if (chunk) {
        if (this.finished) {
            onError(this, new ERR_STREAM_WRITE_AFTER_END(), typeof callback !== "function" ? nop3 : callback);
            return this;
        }
        if (this.socket) {
            this.socket.cork();
        }
        write_(this, chunk, encoding, null, true);
    } else if (this.finished) {
        if (typeof callback === "function") {
            if (!this.writableFinished) {
                this.on("finish", callback);
            } else {
                callback(new ERR_STREAM_ALREADY_FINISHED("end"));
            }
        }
        return this;
    } else if (!this._header) {
        if (this.socket) {
            this.socket.cork();
        }
        this._contentLength = 0;
        this._implicitHeader();
    }
    if (typeof callback === "function") {
        this.once("finish", callback);
    }
    const finish3 = onFinish.bind(undefined, this);
    if (this._hasBody && this.chunkedEncoding) {
        this._send("0\r\n" + this._trailer + "\r\n", "latin1", finish3);
    } else if (!this._headerSent || this.writableLength || chunk) {
        this._send("", "latin1", finish3);
    } else {
        globalThis.process.nextTick(finish3);
    }
    if (this.socket) {
        this.socket._writableState.corked = 1;
        this.socket.uncork();
    }
    this[kCorked] = 0;
    this.finished = true;
    debug3("outgoing message end.");
    if (this.outputData.length === 0 && this.socket && this.socket._httpMessage === this) {
        this._finish();
    }
    return this;
};
OutgoingMessage.prototype._finish = function _finish() {
    assert2(this.socket);
    this.emit("prefinish");
};
OutgoingMessage.prototype._flush = function _flush() {
    const socket = this.socket;
    if (socket && socket.writable) {
        const ret = this._flushOutput(socket);
        if (this.finished) {
            this._finish();
        } else if (ret && this[kNeedDrain]) {
            this[kNeedDrain] = false;
            this.emit("drain");
        }
    }
};
OutgoingMessage.prototype._flushOutput = function _flushOutput(socket) {
    while(this[kCorked]){
        this[kCorked]--;
        socket.cork();
    }
    const outputLength = this.outputData.length;
    if (outputLength <= 0) {
        return undefined;
    }
    const outputData = this.outputData;
    socket.cork();
    let ret;
    for(let i113 = 0; i113 < outputLength; i113++){
        const { data: data26 , encoding , callback  } = outputData[i113];
        ret = socket.write(data26, encoding, callback);
    }
    socket.uncork();
    this.outputData = [];
    this._onPendingData(-this.outputSize);
    this.outputSize = 0;
    return ret;
};
OutgoingMessage.prototype.flushHeaders = function flushHeaders() {
    if (!this._header) {
        this._implicitHeader();
    }
    this._send("");
};
OutgoingMessage.prototype.pipe = function pipe() {
    this.emit("error", new ERR_STREAM_CANNOT_PIPE());
};
OutgoingMessage.prototype[EventEmitter.captureRejectionSymbol] = function(err111, _event) {
    this.destroy(err111);
};
const __default21 = {
    validateHeaderName,
    validateHeaderValue,
    OutgoingMessage
};
function getConsoleWidth() {
    try {
        return consoleSize(Deno.stderr.rid).columns;
    } catch  {
        return 80;
    }
}
const MathMax = Math.max;
const { Error: Error1  } = globalThis;
const { create: ObjectCreate , defineProperty: ObjectDefineProperty , getPrototypeOf: ObjectGetPrototypeOf , getOwnPropertyDescriptor: ObjectGetOwnPropertyDescriptor , keys: ObjectKeys ,  } = Object;
let blue = "";
let green1 = "";
let red1 = "";
let defaultColor = "";
const kReadableOperator = {
    deepStrictEqual: "Expected values to be strictly deep-equal:",
    strictEqual: "Expected values to be strictly equal:",
    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
    deepEqual: "Expected values to be loosely deep-equal:",
    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
    notIdentical: "Values have same structure but are not reference-equal:",
    notDeepEqualUnequal: "Expected values not to be loosely deep-equal:"
};
function copyError(source) {
    const keys = ObjectKeys(source);
    const target = ObjectCreate(ObjectGetPrototypeOf(source));
    for (const key of keys){
        const desc = ObjectGetOwnPropertyDescriptor(source, key);
        if (desc !== undefined) {
            ObjectDefineProperty(target, key, desc);
        }
    }
    ObjectDefineProperty(target, "message", {
        value: source.message
    });
    return target;
}
function inspectValue(val) {
    return inspect(val, {
        compact: true,
        customInspect: false,
        depth: 1000,
        maxArrayLength: Infinity,
        showHidden: false,
        showProxy: false,
        sorted: true,
        getters: true
    });
}
function createErrDiff(actual, expected, operator) {
    let other = "";
    let res = "";
    let end = "";
    let skipped = false;
    const actualInspected = inspectValue(actual);
    const actualLines = actualInspected.split("\n");
    const expectedLines = inspectValue(expected).split("\n");
    let i114 = 0;
    let indicator = "";
    if (operator === "strictEqual" && (typeof actual === "object" && actual !== null && typeof expected === "object" && expected !== null || typeof actual === "function" && typeof expected === "function")) {
        operator = "strictEqualObject";
    }
    if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
        const c16 = inspect.defaultOptions.colors;
        const actualRaw = c16 ? stripColor(actualLines[0]) : actualLines[0];
        const expectedRaw = c16 ? stripColor(expectedLines[0]) : expectedLines[0];
        const inputLength = actualRaw.length + expectedRaw.length;
        if (inputLength <= 12) {
            if ((typeof actual !== "object" || actual === null) && (typeof expected !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
                return `${kReadableOperator[operator]}\n\n` + `${actualLines[0]} !== ${expectedLines[0]}\n`;
            }
        } else if (operator !== "strictEqualObject") {
            const maxLength = Deno.isatty(Deno.stderr.rid) ? getConsoleWidth() : 80;
            if (inputLength < maxLength) {
                while(actualRaw[i114] === expectedRaw[i114]){
                    i114++;
                }
                if (i114 > 2) {
                    indicator = `\n  ${" ".repeat(i114)}^`;
                    i114 = 0;
                }
            }
        }
    }
    let a15 = actualLines[actualLines.length - 1];
    let b15 = expectedLines[expectedLines.length - 1];
    while(a15 === b15){
        if (i114++ < 3) {
            end = `\n  ${a15}${end}`;
        } else {
            other = a15;
        }
        actualLines.pop();
        expectedLines.pop();
        if (actualLines.length === 0 || expectedLines.length === 0) {
            break;
        }
        a15 = actualLines[actualLines.length - 1];
        b15 = expectedLines[expectedLines.length - 1];
    }
    const maxLines = MathMax(actualLines.length, expectedLines.length);
    if (maxLines === 0) {
        const actualLines = actualInspected.split("\n");
        if (actualLines.length > 50) {
            actualLines[46] = `${blue}...${defaultColor}`;
            while(actualLines.length > 47){
                actualLines.pop();
            }
        }
        return `${kReadableOperator.notIdentical}\n\n${actualLines.join("\n")}\n`;
    }
    if (i114 >= 5) {
        end = `\n${blue}...${defaultColor}${end}`;
        skipped = true;
    }
    if (other !== "") {
        end = `\n  ${other}${end}`;
        other = "";
    }
    let printedLines = 0;
    let identical = 0;
    const msg = kReadableOperator[operator] + `\n${green1}+ actual${defaultColor} ${red1}- expected${defaultColor}`;
    const skippedMsg = ` ${blue}...${defaultColor} Lines skipped`;
    let lines = actualLines;
    let plusMinus = `${green1}+${defaultColor}`;
    let maxLength = expectedLines.length;
    if (actualLines.length < maxLines) {
        lines = expectedLines;
        plusMinus = `${red1}-${defaultColor}`;
        maxLength = actualLines.length;
    }
    for(i114 = 0; i114 < maxLines; i114++){
        if (maxLength < i114 + 1) {
            if (identical > 2) {
                if (identical > 3) {
                    if (identical > 4) {
                        if (identical === 5) {
                            res += `\n  ${lines[i114 - 3]}`;
                            printedLines++;
                        } else {
                            res += `\n${blue}...${defaultColor}`;
                            skipped = true;
                        }
                    }
                    res += `\n  ${lines[i114 - 2]}`;
                    printedLines++;
                }
                res += `\n  ${lines[i114 - 1]}`;
                printedLines++;
            }
            identical = 0;
            if (lines === actualLines) {
                res += `\n${plusMinus} ${lines[i114]}`;
            } else {
                other += `\n${plusMinus} ${lines[i114]}`;
            }
            printedLines++;
        } else {
            const expectedLine = expectedLines[i114];
            let actualLine = actualLines[i114];
            let divergingLines = actualLine !== expectedLine && (!actualLine.endsWith(",") || actualLine.slice(0, -1) !== expectedLine);
            if (divergingLines && expectedLine.endsWith(",") && expectedLine.slice(0, -1) === actualLine) {
                divergingLines = false;
                actualLine += ",";
            }
            if (divergingLines) {
                if (identical > 2) {
                    if (identical > 3) {
                        if (identical > 4) {
                            if (identical === 5) {
                                res += `\n  ${actualLines[i114 - 3]}`;
                                printedLines++;
                            } else {
                                res += `\n${blue}...${defaultColor}`;
                                skipped = true;
                            }
                        }
                        res += `\n  ${actualLines[i114 - 2]}`;
                        printedLines++;
                    }
                    res += `\n  ${actualLines[i114 - 1]}`;
                    printedLines++;
                }
                identical = 0;
                res += `\n${green1}+${defaultColor} ${actualLine}`;
                other += `\n${red1}-${defaultColor} ${expectedLine}`;
                printedLines += 2;
            } else {
                res += other;
                other = "";
                identical++;
                if (identical <= 2) {
                    res += `\n  ${actualLine}`;
                    printedLines++;
                }
            }
        }
        if (printedLines > 50 && i114 < maxLines - 2) {
            return `${msg}${skippedMsg}\n${res}\n${blue}...${defaultColor}${other}\n` + `${blue}...${defaultColor}`;
        }
    }
    return `${msg}${skipped ? skippedMsg : ""}\n${res}${other}${end}${indicator}`;
}
class AssertionError1 extends Error1 {
    constructor(options){
        if (typeof options !== "object" || options === null) {
            throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        const { message , operator , stackStartFn , details , stackStartFunction ,  } = options;
        let { actual , expected ,  } = options;
        const limit = Error1.stackTraceLimit;
        Error1.stackTraceLimit = 0;
        if (message != null) {
            super(String(message));
        } else {
            if (Deno.isatty(Deno.stderr.rid)) {
                if (Deno.noColor) {
                    blue = "";
                    green1 = "";
                    defaultColor = "";
                    red1 = "";
                } else {
                    blue = "\u001b[34m";
                    green1 = "\u001b[32m";
                    defaultColor = "\u001b[39m";
                    red1 = "\u001b[31m";
                }
            }
            if (typeof actual === "object" && actual !== null && typeof expected === "object" && expected !== null && "stack" in actual && actual instanceof Error1 && "stack" in expected && expected instanceof Error1) {
                actual = copyError(actual);
                expected = copyError(expected);
            }
            if (operator === "deepStrictEqual" || operator === "strictEqual") {
                super(createErrDiff(actual, expected, operator));
            } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
                let base14 = kReadableOperator[operator];
                const res = inspectValue(actual).split("\n");
                if (operator === "notStrictEqual" && (typeof actual === "object" && actual !== null || typeof actual === "function")) {
                    base14 = kReadableOperator.notStrictEqualObject;
                }
                if (res.length > 50) {
                    res[46] = `${blue}...${defaultColor}`;
                    while(res.length > 47){
                        res.pop();
                    }
                }
                if (res.length === 1) {
                    super(`${base14}${res[0].length > 5 ? "\n\n" : " "}${res[0]}`);
                } else {
                    super(`${base14}\n\n${res.join("\n")}\n`);
                }
            } else {
                let res = inspectValue(actual);
                let other = inspectValue(expected);
                const knownOperator = kReadableOperator[operator ?? ""];
                if (operator === "notDeepEqual" && res === other) {
                    res = `${knownOperator}\n\n${res}`;
                    if (res.length > 1024) {
                        res = `${res.slice(0, 1021)}...`;
                    }
                    super(res);
                } else {
                    if (res.length > 512) {
                        res = `${res.slice(0, 509)}...`;
                    }
                    if (other.length > 512) {
                        other = `${other.slice(0, 509)}...`;
                    }
                    if (operator === "deepEqual") {
                        res = `${knownOperator}\n\n${res}\n\nshould loosely deep-equal\n\n`;
                    } else {
                        const newOp = kReadableOperator[`${operator}Unequal`];
                        if (newOp) {
                            res = `${newOp}\n\n${res}\n\nshould not loosely deep-equal\n\n`;
                        } else {
                            other = ` ${operator} ${other}`;
                        }
                    }
                    super(`${res}${other}`);
                }
            }
        }
        Error1.stackTraceLimit = limit;
        this.generatedMessage = !message;
        ObjectDefineProperty(this, "name", {
            value: "AssertionError [ERR_ASSERTION]",
            enumerable: false,
            writable: true,
            configurable: true
        });
        this.code = "ERR_ASSERTION";
        if (details) {
            this.actual = undefined;
            this.expected = undefined;
            this.operator = undefined;
            for(let i115 = 0; i115 < details.length; i115++){
                this["message " + i115] = details[i115].message;
                this["actual " + i115] = details[i115].actual;
                this["expected " + i115] = details[i115].expected;
                this["operator " + i115] = details[i115].operator;
                this["stack trace " + i115] = details[i115].stack;
            }
        } else {
            this.actual = actual;
            this.expected = expected;
            this.operator = operator;
        }
        Error1.captureStackTrace(this, stackStartFn || stackStartFunction);
        this.stack;
        this.name = "AssertionError";
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
    [inspect.custom](_recurseTimes, ctx) {
        const tmpActual = this.actual;
        const tmpExpected = this.expected;
        for (const name59 of [
            "actual",
            "expected"
        ]){
            if (typeof this[name59] === "string") {
                const value = this[name59];
                const lines = value.split("\n");
                if (lines.length > 10) {
                    lines.length = 10;
                    this[name59] = `${lines.join("\n")}\n...`;
                } else if (value.length > 512) {
                    this[name59] = `${value.slice(512)}...`;
                }
            }
        }
        const result = inspect(this, {
            ...ctx,
            customInspect: false,
            depth: 0
        });
        this.actual = tmpActual;
        this.expected = tmpExpected;
        return result;
    }
}
function createAssertionError(options) {
    const error14 = new AssertionError1(options);
    if (options.generatedMessage) {
        error14.generatedMessage = true;
    }
    return error14;
}
function toNode(fn, opts) {
    const { operator , message , actual , expected  } = opts || {};
    try {
        fn();
    } catch (e19) {
        if (e19 instanceof AssertionError) {
            if (typeof message === "string") {
                throw new AssertionError1({
                    operator,
                    message,
                    actual,
                    expected
                });
            } else if (message instanceof Error) {
                throw message;
            } else {
                throw new AssertionError1({
                    operator,
                    message: e19.message,
                    actual,
                    expected
                });
            }
        }
        throw e19;
    }
}
function assert3(actual, message) {
    if (arguments.length === 0) {
        throw new AssertionError1({
            message: "No value argument passed to `assert.ok()`"
        });
    }
    toNode(()=>assert(actual)
    , {
        message,
        actual,
        expected: true
    });
}
const ok = assert3;
function __throws(fn, error15, message) {
    if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", "function", fn);
    }
    if (typeof error15 === "object" && error15 !== null && Object.getPrototypeOf(error15) === Object.prototype && Object.keys(error15).length === 0) {
        throw new ERR_INVALID_ARG_VALUE("error", error15, "may not be an empty object");
    }
    if (typeof message === "string") {
        if (!(error15 instanceof RegExp) && typeof error15 !== "function" && !(error15 instanceof Error) && typeof error15 !== "object") {
            throw new ERR_INVALID_ARG_TYPE("error", [
                "Function",
                "Error",
                "RegExp",
                "Object", 
            ], error15);
        }
    } else {
        if (typeof error15 !== "undefined" && typeof error15 !== "string" && !(error15 instanceof RegExp) && typeof error15 !== "function" && !(error15 instanceof Error) && typeof error15 !== "object") {
            throw new ERR_INVALID_ARG_TYPE("error", [
                "Function",
                "Error",
                "RegExp",
                "Object", 
            ], error15);
        }
    }
    try {
        fn();
    } catch (e20) {
        if (validateThrownError(e20, error15, message, {
            operator: __throws
        })) {
            return;
        }
    }
    if (message) {
        let msg = `Missing expected exception: ${message}`;
        if (typeof error15 === "function" && error15?.name) {
            msg = `Missing expected exception (${error15.name}): ${message}`;
        }
        throw new AssertionError1({
            message: msg,
            operator: "throws",
            actual: undefined,
            expected: error15
        });
    } else if (typeof error15 === "string") {
        throw new AssertionError1({
            message: `Missing expected exception: ${error15}`,
            operator: "throws",
            actual: undefined,
            expected: undefined
        });
    } else if (typeof error15 === "function" && error15?.prototype !== undefined) {
        throw new AssertionError1({
            message: `Missing expected exception (${error15.name}).`,
            operator: "throws",
            actual: undefined,
            expected: error15
        });
    } else {
        throw new AssertionError1({
            message: "Missing expected exception.",
            operator: "throws",
            actual: undefined,
            expected: error15
        });
    }
}
function doesNotThrow(fn, expected, message) {
    if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", "function", fn);
    } else if (!(expected instanceof RegExp) && typeof expected !== "function" && typeof expected !== "string" && typeof expected !== "undefined") {
        throw new ERR_INVALID_ARG_TYPE("expected", [
            "Function",
            "RegExp"
        ], fn);
    }
    try {
        fn();
    } catch (e21) {
        gotUnwantedException(e21, expected, message, doesNotThrow);
    }
    return;
}
function equal1(actual, expected, message) {
    if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (actual == expected) {
        return;
    }
    if (Number.isNaN(actual) && Number.isNaN(expected)) {
        return;
    }
    if (typeof message === "string") {
        throw new AssertionError1({
            message
        });
    } else if (message instanceof Error) {
        throw message;
    }
    toNode(()=>assertStrictEquals(actual, expected)
    , {
        message: message || `${actual} == ${expected}`,
        operator: "==",
        actual,
        expected
    });
}
function notEqual(actual, expected, message) {
    if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (Number.isNaN(actual) && Number.isNaN(expected)) {
        throw new AssertionError1({
            message: `${actual} != ${expected}`,
            operator: "!=",
            actual,
            expected
        });
    }
    if (actual != expected) {
        return;
    }
    if (typeof message === "string") {
        throw new AssertionError1({
            message
        });
    } else if (message instanceof Error) {
        throw message;
    }
    toNode(()=>assertNotStrictEquals(actual, expected)
    , {
        message: message || `${actual} != ${expected}`,
        operator: "!=",
        actual,
        expected
    });
}
function strictEqual(actual, expected, message) {
    if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
    }
    toNode(()=>assertStrictEquals(actual, expected)
    , {
        message,
        operator: "strictEqual",
        actual,
        expected
    });
}
function notStrictEqual(actual, expected, message) {
    if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
    }
    toNode(()=>assertNotStrictEquals(actual, expected)
    , {
        message,
        actual,
        expected,
        operator: "notStrictEqual"
    });
}
function deepEqual() {
    if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
    }
    throw new Error("Not implemented");
}
function notDeepEqual() {
    if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
    }
    throw new Error("Not implemented");
}
function deepStrictEqual(actual, expected, message) {
    if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
    }
    toNode(()=>assertEquals(actual, expected)
    , {
        message,
        actual,
        expected,
        operator: "deepStrictEqual"
    });
}
function notDeepStrictEqual(actual, expected, message) {
    if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
    }
    toNode(()=>assertNotEquals(actual, expected)
    , {
        message,
        actual,
        expected,
        operator: "deepNotStrictEqual"
    });
}
function fail1(message) {
    if (typeof message === "string" || message == null) {
        throw createAssertionError({
            message: message ?? "Failed",
            operator: "fail",
            generatedMessage: message == null
        });
    } else {
        throw message;
    }
}
function match(actual, regexp, message) {
    if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "regexp");
    }
    if (!(regexp instanceof RegExp)) {
        throw new ERR_INVALID_ARG_TYPE("regexp", "RegExp", regexp);
    }
    toNode(()=>assertMatch(actual, regexp)
    , {
        message,
        actual,
        expected: regexp,
        operator: "match"
    });
}
function doesNotMatch(string, regexp, message) {
    if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("string", "regexp");
    }
    if (!(regexp instanceof RegExp)) {
        throw new ERR_INVALID_ARG_TYPE("regexp", "RegExp", regexp);
    }
    if (typeof string !== "string") {
        if (message instanceof Error) {
            throw message;
        }
        throw new AssertionError1({
            message: message || `The "string" argument must be of type string. Received type ${typeof string} (${inspect(string)})`,
            actual: string,
            expected: regexp,
            operator: "doesNotMatch"
        });
    }
    toNode(()=>assertNotMatch(string, regexp)
    , {
        message,
        actual: string,
        expected: regexp,
        operator: "doesNotMatch"
    });
}
function strict(actual, message) {
    if (arguments.length === 0) {
        throw new AssertionError1({
            message: "No value argument passed to `assert.ok()`"
        });
    }
    assert3(actual, message);
}
function rejects(asyncFn, error16, message1) {
    let promise;
    if (typeof asyncFn === "function") {
        try {
            promise = asyncFn();
        } catch (err112) {
            return Promise.reject(err112);
        }
        if (!isValidThenable(promise)) {
            return Promise.reject(new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", promise));
        }
    } else if (!isValidThenable(asyncFn)) {
        return Promise.reject(new ERR_INVALID_ARG_TYPE("promiseFn", [
            "function",
            "Promise"
        ], asyncFn));
    } else {
        promise = asyncFn;
    }
    function onFulfilled() {
        let message = "Missing expected rejection";
        if (typeof error16 === "string") {
            message += `: ${error16}`;
        } else if (typeof error16 === "function" && error16.prototype !== undefined) {
            message += ` (${error16.name}).`;
        } else {
            message += ".";
        }
        return Promise.reject(createAssertionError({
            message,
            operator: "rejects",
            generatedMessage: true
        }));
    }
    function rejects_onRejected(e22) {
        if (validateThrownError(e22, error16, message1, {
            operator: rejects,
            validationFunctionName: "validate"
        })) {
            return;
        }
    }
    return promise.then(onFulfilled, rejects_onRejected);
}
function doesNotReject(asyncFn, error17, message) {
    let promise;
    if (typeof asyncFn === "function") {
        try {
            const value = asyncFn();
            if (!isValidThenable(value)) {
                return Promise.reject(new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", value));
            }
            promise = value;
        } catch (e23) {
            return Promise.reject(e23);
        }
    } else if (!isValidThenable(asyncFn)) {
        return Promise.reject(new ERR_INVALID_ARG_TYPE("promiseFn", [
            "function",
            "Promise"
        ], asyncFn));
    } else {
        promise = asyncFn;
    }
    return promise.then(()=>{}, (e24)=>gotUnwantedException(e24, error17, message, doesNotReject)
    );
}
function gotUnwantedException(e25, expected, message, operator) {
    if (typeof expected === "string") {
        throw new AssertionError1({
            message: `Got unwanted exception: ${expected}\nActual message: "${e25.message}"`,
            operator: operator.name
        });
    } else if (typeof expected === "function" && expected.prototype !== undefined) {
        if (e25 instanceof expected) {
            let msg = `Got unwanted exception: ${e25.constructor?.name}`;
            if (message) {
                msg += ` ${String(message)}`;
            }
            throw new AssertionError1({
                message: msg,
                operator: operator.name
            });
        } else if (expected.prototype instanceof Error) {
            throw e25;
        } else {
            const result = expected(e25);
            if (result === true) {
                let msg = `Got unwanted rejection.\nActual message: "${e25.message}"`;
                if (message) {
                    msg += ` ${String(message)}`;
                }
                throw new AssertionError1({
                    message: msg,
                    operator: operator.name
                });
            }
        }
        throw e25;
    } else {
        if (message) {
            throw new AssertionError1({
                message: `Got unwanted exception: ${message}\nActual message: "${e25 ? e25.message : String(e25)}"`,
                operator: operator.name
            });
        }
        throw new AssertionError1({
            message: `Got unwanted exception.\nActual message: "${e25 ? e25.message : String(e25)}"`,
            operator: operator.name
        });
    }
}
function ifError(err113) {
    if (err113 !== null && err113 !== undefined) {
        let message = "ifError got unwanted exception: ";
        if (typeof err113 === "object" && typeof err113.message === "string") {
            if (err113.message.length === 0 && err113.constructor) {
                message += err113.constructor.name;
            } else {
                message += err113.message;
            }
        } else {
            message += inspect(err113);
        }
        const newErr = new AssertionError1({
            actual: err113,
            expected: null,
            operator: "ifError",
            message,
            stackStartFn: ifError
        });
        const origStack = err113.stack;
        if (typeof origStack === "string") {
            const tmp2 = origStack.split("\n");
            tmp2.shift();
            let tmp1 = newErr.stack?.split("\n");
            for (const errFrame of tmp2){
                const pos = tmp1?.indexOf(errFrame);
                if (pos !== -1) {
                    tmp1 = tmp1?.slice(0, pos);
                    break;
                }
            }
            newErr.stack = `${tmp1?.join("\n")}\n${tmp2.join("\n")}`;
        }
        throw newErr;
    }
}
function validateThrownError(e26, error18, message, options) {
    if (typeof error18 === "string") {
        if (message != null) {
            throw new ERR_INVALID_ARG_TYPE("error", [
                "Object",
                "Error",
                "Function",
                "RegExp"
            ], error18);
        } else if (typeof e26 === "object" && e26 !== null) {
            if (e26.message === error18) {
                throw new ERR_AMBIGUOUS_ARGUMENT("error/message", `The error message "${e26.message}" is identical to the message.`);
            }
        } else if (e26 === error18) {
            throw new ERR_AMBIGUOUS_ARGUMENT("error/message", `The error "${e26}" is identical to the message.`);
        }
        message = error18;
        error18 = undefined;
    }
    if (error18 instanceof Function && error18.prototype !== undefined && error18.prototype instanceof Error) {
        if (e26 instanceof error18) {
            return true;
        }
        throw createAssertionError({
            message: `The error is expected to be an instance of "${error18.name}". Received "${e26?.constructor?.name}"\n\nError message:\n\n${e26?.message}`,
            actual: e26,
            expected: error18,
            operator: options.operator.name,
            generatedMessage: true
        });
    }
    if (error18 instanceof Function) {
        const received = error18(e26);
        if (received === true) {
            return true;
        }
        throw createAssertionError({
            message: `The ${options.validationFunctionName ? `"${options.validationFunctionName}" validation` : "validation"} function is expected to return "true". Received ${inspect(received)}\n\nCaught error:\n\n${e26}`,
            actual: e26,
            expected: error18,
            operator: options.operator.name,
            generatedMessage: true
        });
    }
    if (error18 instanceof RegExp) {
        if (error18.test(String(e26))) {
            return true;
        }
        throw createAssertionError({
            message: `The input did not match the regular expression ${error18.toString()}. Input:\n\n'${String(e26)}'\n`,
            actual: e26,
            expected: error18,
            operator: options.operator.name,
            generatedMessage: true
        });
    }
    if (typeof error18 === "object" && error18 !== null) {
        const keys = Object.keys(error18);
        if (error18 instanceof Error) {
            keys.push("name", "message");
        }
        for (const k10 of keys){
            if (e26 == null) {
                throw createAssertionError({
                    message: message || "object is expected to thrown, but got null",
                    actual: e26,
                    expected: error18,
                    operator: options.operator.name,
                    generatedMessage: message == null
                });
            }
            if (typeof e26 === "string") {
                throw createAssertionError({
                    message: message || `object is expected to thrown, but got string: ${e26}`,
                    actual: e26,
                    expected: error18,
                    operator: options.operator.name,
                    generatedMessage: message == null
                });
            }
            if (typeof e26 === "number") {
                throw createAssertionError({
                    message: message || `object is expected to thrown, but got number: ${e26}`,
                    actual: e26,
                    expected: error18,
                    operator: options.operator.name,
                    generatedMessage: message == null
                });
            }
            if (!(k10 in e26)) {
                throw createAssertionError({
                    message: message || `A key in the expected object is missing: ${k10}`,
                    actual: e26,
                    expected: error18,
                    operator: options.operator.name,
                    generatedMessage: message == null
                });
            }
            const actual = e26[k10];
            const expected = error18[k10];
            if (typeof actual === "string" && expected instanceof RegExp) {
                match(actual, expected);
            } else {
                deepStrictEqual(actual, expected);
            }
        }
        return true;
    }
    if (typeof error18 === "undefined") {
        return true;
    }
    throw createAssertionError({
        message: `Invalid expectation: ${error18}`,
        operator: options.operator.name,
        generatedMessage: true
    });
}
function isValidThenable(maybeThennable) {
    if (!maybeThennable) {
        return false;
    }
    if (maybeThennable instanceof Promise) {
        return true;
    }
    const isThenable = typeof maybeThennable.then === "function" && typeof maybeThennable.catch === "function";
    return isThenable && typeof maybeThennable !== "function";
}
Object.assign(strict, {
    AssertionError: AssertionError1,
    deepEqual: deepStrictEqual,
    deepStrictEqual,
    doesNotMatch,
    doesNotReject,
    doesNotThrow,
    equal: strictEqual,
    fail: fail1,
    ifError,
    match,
    notDeepEqual: notDeepStrictEqual,
    notDeepStrictEqual,
    notEqual: notStrictEqual,
    notStrictEqual,
    ok,
    rejects,
    strict,
    strictEqual,
    throws: __throws
});
const __default22 = Object.assign(assert3, {
    AssertionError: AssertionError1,
    deepEqual,
    deepStrictEqual,
    doesNotMatch,
    doesNotReject,
    doesNotThrow,
    equal: equal1,
    fail: fail1,
    ifError,
    match,
    notDeepEqual,
    notDeepStrictEqual,
    notEqual,
    notStrictEqual,
    ok,
    rejects,
    strict,
    strictEqual,
    throws: __throws
});
function mapValues(record, transformer) {
    const ret = {};
    const entries = Object.entries(record);
    for (const [key, value] of entries){
        const mappedValue = transformer(value);
        ret[key] = mappedValue;
    }
    return ret;
}
function stdioStringToArray(stdio1, channel) {
    const options = [];
    switch(stdio1){
        case "ignore":
        case "overlapped":
        case "pipe":
            options.push(stdio1, stdio1, stdio1);
            break;
        case "inherit":
            options.push(stdio1, stdio1, stdio1);
            break;
        default:
            throw new ERR_INVALID_ARG_VALUE("stdio", stdio1);
    }
    if (channel) options.push(channel);
    return options;
}
class ChildProcess extends EventEmitter {
    exitCode = null;
    killed = false;
    pid;
    spawnargs;
    spawnfile;
    stdin = null;
    stdout = null;
    stderr = null;
    stdio = [
        null,
        null,
        null, 
    ];
    #process;
    #spawned = deferred();
    constructor(command, args, options){
        super();
        const { env: env1 = {} , stdio: stdio2 = [
            "pipe",
            "pipe",
            "pipe"
        ] , shell =false , signal ,  } = options || {};
        const [stdin1 = "pipe", stdout1 = "pipe", stderr1 = "pipe", _channel] = normalizeStdioOption(stdio2);
        const cmd = buildCommand(command, args || [], shell);
        this.spawnfile = cmd[0];
        this.spawnargs = cmd;
        const stringEnv = mapValues(env1, (value)=>value.toString()
        );
        try {
            this.#process = Deno.run({
                cmd,
                env: stringEnv,
                stdin: toDenoStdio(stdin1),
                stdout: toDenoStdio(stdout1),
                stderr: toDenoStdio(stderr1)
            });
            this.pid = this.#process.pid;
            if (stdin1 === "pipe") {
                assert1(this.#process.stdin);
                this.stdin = createWritableFromStdin(this.#process.stdin);
            }
            if (stdout1 === "pipe") {
                assert1(this.#process.stdout);
                this.stdout = createReadableFromReader(this.#process.stdout);
            }
            if (stderr1 === "pipe") {
                assert1(this.#process.stderr);
                this.stderr = createReadableFromReader(this.#process.stderr);
            }
            this.stdio[0] = this.stdin;
            this.stdio[1] = this.stdout;
            this.stdio[2] = this.stderr;
            nextTick2(()=>{
                this.emit("spawn");
                this.#spawned.resolve();
            });
            if (signal) {
                const onAbortListener = ()=>{
                    try {
                        if (this.kill()) {
                            this.emit("error", new AbortError());
                        }
                    } catch (err114) {
                        this.emit("error", err114);
                    }
                };
                if (signal.aborted) {
                    nextTick2(onAbortListener);
                } else {
                    signal.addEventListener("abort", onAbortListener, {
                        once: true
                    });
                    this.addListener("exit", ()=>signal.removeEventListener("abort", onAbortListener)
                    );
                }
            }
            (async ()=>{
                const status = await this.#process.status();
                this.exitCode = status.code;
                this.#spawned.then(async ()=>{
                    this.emit("exit", this.exitCode, status.signal ?? null);
                    await this._waitForChildStreamsToClose();
                    this.kill();
                    this.emit("close", this.exitCode, status.signal ?? null);
                });
            })();
        } catch (err115) {
            this._handleError(err115);
        }
    }
    kill(signal) {
        if (signal !== undefined) {
            notImplemented("`ChildProcess.kill()` with the `signal` parameter");
        }
        if (this.killed) {
            return this.killed;
        }
        if (this.#process.stdin) {
            assert1(this.stdin);
            ensureClosed(this.#process.stdin);
        }
        if (this.#process.stdout) {
            ensureClosed(this.#process.stdout);
        }
        if (this.#process.stderr) {
            ensureClosed(this.#process.stderr);
        }
        ensureClosed(this.#process);
        this.killed = true;
        return this.killed;
    }
    ref() {
        notImplemented("ChildProcess.ref()");
    }
    unref() {
        notImplemented("ChildProcess.unref()");
    }
    async _waitForChildStreamsToClose() {
        const promises1 = [];
        if (this.stdin && !this.stdin.destroyed) {
            assert1(this.stdin);
            this.stdin.destroy();
            promises1.push(waitForStreamToClose(this.stdin));
        }
        if (this.stdout && !this.stdout.destroyed) {
            promises1.push(waitForReadableToClose(this.stdout));
        }
        if (this.stderr && !this.stderr.destroyed) {
            promises1.push(waitForReadableToClose(this.stderr));
        }
        await Promise.all(promises1);
    }
    _handleError(err116) {
        nextTick2(()=>{
            this.emit("error", err116);
        });
    }
}
const supportedNodeStdioTypes = [
    "pipe",
    "ignore",
    "inherit"
];
function toDenoStdio(pipe) {
    if (!supportedNodeStdioTypes.includes(pipe) || typeof pipe === "number" || pipe instanceof Stream) {
        notImplemented();
    }
    switch(pipe){
        case "pipe":
        case undefined:
        case null:
            return "piped";
        case "ignore":
            return "null";
        case "inherit":
            return "inherit";
        default:
            notImplemented();
    }
}
function ensureClosed(closer) {
    try {
        closer.close();
    } catch (err117) {
        if (isAlreadyClosed(err117)) {
            return;
        }
        throw err117;
    }
}
function isAlreadyClosed(err118) {
    return err118 instanceof Deno.errors.BadResource || err118 instanceof Deno.errors.Interrupted;
}
function createReadableFromReader(reader) {
    return Readable.from(cloneIterator(iterateReader(reader)), {
        objectMode: false
    });
}
async function* cloneIterator(iterator) {
    try {
        for await (const chunk of iterator){
            yield new Buffer1(chunk);
        }
    } catch (e27) {
        if (isAlreadyClosed(e27)) {
            return;
        }
        throw e27;
    }
}
function createWritableFromStdin(stdin2) {
    const encoder = new TextEncoder();
    return new Writable({
        async write (chunk, encoding, callback) {
            try {
                if (encoding !== "buffer") {
                    chunk = encoder.encode(chunk);
                }
                if (!(chunk instanceof Uint8Array)) {
                    throw new TypeError(`Expected chunk to be of type Uint8Array, got ${typeof chunk}`);
                }
                await writeAll(stdin2, chunk);
                callback();
            } catch (err119) {
                callback(err119 instanceof Error ? err119 : new Error("[non-error thrown]"));
            }
        },
        final (callback) {
            try {
                ensureClosed(stdin2);
            } catch (err120) {
                callback(err120 instanceof Error ? err120 : new Error("[non-error thrown]"));
            }
        }
    });
}
function normalizeStdioOption(stdio3 = [
    "pipe",
    "pipe",
    "pipe", 
]) {
    if (Array.isArray(stdio3)) {
        return stdio3;
    } else {
        switch(stdio3){
            case "overlapped":
                if (isWindows) {
                    notImplemented();
                }
                return [
                    "pipe",
                    "pipe",
                    "pipe"
                ];
            case "pipe":
                return [
                    "pipe",
                    "pipe",
                    "pipe"
                ];
            case "inherit":
                return [
                    "inherit",
                    "inherit",
                    "inherit"
                ];
            case "ignore":
                return [
                    "ignore",
                    "ignore",
                    "ignore"
                ];
            default:
                notImplemented();
        }
    }
}
function waitForReadableToClose(readable) {
    readable.resume();
    return waitForStreamToClose(readable);
}
function waitForStreamToClose(stream3) {
    const promise = deferred();
    const cleanup = ()=>{
        stream3.removeListener("close", onClose);
        stream3.removeListener("error", onError1);
    };
    const onClose = ()=>{
        cleanup();
        promise.resolve();
    };
    const onError1 = (err121)=>{
        cleanup();
        promise.reject(err121);
    };
    stream3.once("close", onClose);
    stream3.once("error", onError1);
    return promise;
}
function buildCommand(file, args, shell) {
    const command = [
        file,
        ...args
    ].join(" ");
    if (shell) {
        if (isWindows) {
            if (typeof shell === "string") {
                file = shell;
            } else {
                file = Deno.env.get("comspec") || "cmd.exe";
            }
            if (/^(?:.*\\)?cmd(?:\.exe)?$/i.test(file)) {
                args = [
                    "/d",
                    "/s",
                    "/c",
                    `"${command}"`
                ];
            } else {
                args = [
                    "-c",
                    command
                ];
            }
        } else {
            if (typeof shell === "string") {
                file = shell;
            } else {
                file = "/bin/sh";
            }
            args = [
                "-c",
                command
            ];
        }
    }
    return [
        file,
        ...args
    ];
}
const MAX_BUFFER = 1024 * 1024;
const denoCompatArgv = [
    "run",
    "--compat",
    "--unstable",
    "--no-check",
    "--allow-all", 
];
function fork(modulePath) {
    validateString(modulePath, "modulePath");
    let execArgv;
    let options = {};
    let args = [];
    let pos = 1;
    if (pos < arguments.length && Array.isArray(arguments[pos])) {
        args = arguments[pos++];
    }
    if (pos < arguments.length && arguments[pos] == null) {
        pos++;
    }
    if (pos < arguments.length && arguments[pos] != null) {
        if (typeof arguments[pos] !== "object") {
            throw new ERR_INVALID_ARG_VALUE(`arguments[${pos}]`, arguments[pos]);
        }
        options = {
            ...arguments[pos++]
        };
    }
    execArgv = options.execArgv || process1.execArgv;
    if (execArgv === process1.execArgv && process1._eval != null) {
        const index12 = execArgv.lastIndexOf(process1._eval);
        if (index12 > 0) {
            execArgv = execArgv.slice(0);
            execArgv.splice(index12 - 1, 2);
        }
    }
    args = [
        ...denoCompatArgv,
        ...execArgv,
        modulePath,
        ...args
    ];
    if (typeof options.stdio === "string") {
        options.stdio = stdioStringToArray(options.stdio, "ipc");
    } else if (!Array.isArray(options.stdio)) {
        options.stdio = stdioStringToArray(options.silent ? "pipe" : "inherit", "ipc");
    } else if (!options.stdio.includes("ipc")) {
        throw new ERR_CHILD_PROCESS_IPC_REQUIRED("options.stdio");
    }
    options.execPath = options.execPath || Deno.execPath();
    options.shell = false;
    return spawn(options.execPath, args, options);
}
function spawn(command, argsOrOptions, maybeOptions) {
    const args = Array.isArray(argsOrOptions) ? argsOrOptions : [];
    const options = !Array.isArray(argsOrOptions) && argsOrOptions != null ? argsOrOptions : maybeOptions;
    return new ChildProcess(command, args, options);
}
class ExecFileError extends Error {
    code;
    constructor(message){
        super(message);
        this.code = "UNKNOWN";
    }
}
function execFile(file, argsOrOptionsOrCallback, optionsOrCallback, maybeCallback1) {
    let args = [];
    let options = {};
    let callback;
    if (Array.isArray(argsOrOptionsOrCallback)) {
        args = argsOrOptionsOrCallback;
    } else if (argsOrOptionsOrCallback instanceof Function) {
        callback = argsOrOptionsOrCallback;
    } else if (argsOrOptionsOrCallback) {
        options = argsOrOptionsOrCallback;
    }
    if (optionsOrCallback instanceof Function) {
        callback = optionsOrCallback;
    } else if (optionsOrCallback) {
        options = optionsOrCallback;
        callback = maybeCallback1;
    }
    const execOptions = {
        encoding: "utf8",
        timeout: 0,
        maxBuffer: MAX_BUFFER,
        killSignal: "SIGTERM",
        ...options
    };
    if (!Number.isInteger(execOptions.timeout) || execOptions.timeout < 0) {
        throw new ERR_OUT_OF_RANGE("timeout", "an unsigned integer", execOptions.timeout);
    }
    if (execOptions.maxBuffer < 0) {
        throw new ERR_OUT_OF_RANGE("options.maxBuffer", "a positive number", execOptions.maxBuffer);
    }
    const spawnOptions = {
        shell: false,
        ...options
    };
    const child = spawn(file, args, spawnOptions);
    let encoding1;
    const _stdout = [];
    const _stderr = [];
    if (execOptions.encoding !== "buffer" && Buffer1.isEncoding(execOptions.encoding)) {
        encoding1 = execOptions.encoding;
    } else {
        encoding1 = null;
    }
    let stdoutLen = 0;
    let stderrLen = 0;
    let exited = false;
    let timeoutId;
    let ex = null;
    let cmd = file;
    function exithandler(code41 = 0, signal) {
        if (exited) return;
        exited = true;
        if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = null;
        }
        if (!callback) return;
        let stdout2;
        let stderr2;
        if (encoding1 || child.stdout && child.stdout.readableEncoding) {
            stdout2 = _stdout.join("");
        } else {
            stdout2 = Buffer1.concat(_stdout);
        }
        if (encoding1 || child.stderr && child.stderr.readableEncoding) {
            stderr2 = _stderr.join("");
        } else {
            stderr2 = Buffer1.concat(_stderr);
        }
        if (!ex && code41 === 0 && signal === null) {
            callback(null, stdout2, stderr2);
            return;
        }
        if (args?.length) {
            cmd += ` ${args.join(" ")}`;
        }
        if (!ex) {
            ex = new ExecFileError("Command failed: " + cmd + "\n" + stderr2);
            ex.code = code41 < 0 ? getSystemErrorName(code41) : code41;
            ex.killed = child.killed;
            ex.signal = signal;
        }
        ex.cmd = cmd;
        callback(ex, stdout2, stderr2);
    }
    function errorhandler(e28) {
        ex = e28;
        if (child.stdout) {
            child.stdout.destroy();
        }
        if (child.stderr) {
            child.stderr.destroy();
        }
        exithandler();
    }
    function kill() {
        if (child.stdout) {
            child.stdout.destroy();
        }
        if (child.stderr) {
            child.stderr.destroy();
        }
        try {
            child.kill();
        } catch (e29) {
            if (e29) {
                ex = e29;
            }
            exithandler();
        }
    }
    if (execOptions.timeout > 0) {
        timeoutId = setTimeout(function delayedKill() {
            kill();
            timeoutId = null;
        }, execOptions.timeout);
    }
    if (child.stdout) {
        if (encoding1) {
            child.stdout.setEncoding(encoding1);
        }
        child.stdout.on("data", function onChildStdout(chunk) {
            const encoding = child.stdout?.readableEncoding;
            let chunkBuffer;
            if (Buffer1.isBuffer(chunk)) {
                chunkBuffer = chunk;
            } else {
                if (encoding) {
                    chunkBuffer = Buffer1.from(chunk, encoding);
                } else {
                    chunkBuffer = Buffer1.from("");
                }
            }
            const length = chunkBuffer.length;
            stdoutLen += length;
            if (stdoutLen > execOptions.maxBuffer) {
                const truncatedLen = execOptions.maxBuffer - (stdoutLen - length);
                const truncatedSlice = chunkBuffer.slice(0, truncatedLen).valueOf();
                _stdout.push(truncatedSlice);
                ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER("stdout");
                kill();
            } else {
                _stdout.push(chunkBuffer.valueOf());
            }
        });
    }
    if (child.stderr) {
        if (encoding1) {
            child.stderr.setEncoding(encoding1);
        }
        child.stderr.on("data", function onChildStderr(chunk) {
            const encoding = child.stderr?.readableEncoding;
            let chunkBuffer;
            if (Buffer1.isBuffer(chunk)) {
                chunkBuffer = chunk;
            } else {
                if (encoding) {
                    chunkBuffer = Buffer1.from(chunk, encoding);
                } else {
                    chunkBuffer = Buffer1.from("");
                }
            }
            const length = chunkBuffer.length;
            stderrLen += length;
            if (stderrLen > execOptions.maxBuffer) {
                const truncatedLen = execOptions.maxBuffer - (stderrLen - length);
                const truncatedSlice = chunkBuffer.slice(0, truncatedLen).valueOf();
                _stderr.push(truncatedSlice);
                ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER("stderr");
                kill();
            } else {
                _stderr.push(chunkBuffer.valueOf());
            }
        });
    }
    child.addListener("close", exithandler);
    child.addListener("error", errorhandler);
    return child;
}
const __default23 = {
    fork,
    spawn,
    execFile,
    ChildProcess
};
class Worker {
    constructor(){
        notImplemented();
    }
}
function disconnected() {
    notImplemented();
}
function fork1() {
    notImplemented();
}
const isPrimary = undefined;
const isWorker = undefined;
const isMaster = isPrimary;
const schedulingPolicy = undefined;
const settings = undefined;
function setupMaster() {
    notImplemented();
}
function setupPrimary() {
    notImplemented();
}
const worker = undefined;
const workers = undefined;
const __default24 = {
    Worker,
    disconnected,
    fork: fork1,
    isPrimary,
    isWorker,
    isMaster,
    schedulingPolicy,
    settings,
    setupMaster,
    setupPrimary,
    worker,
    workers
};
const { assert: assert4 , clear , count , countReset , debug: debug4 , dir , dirxml , error: error1 , group , groupCollapsed , groupEnd , info , log: log1 , table , time , timeEnd , timeLog , trace: trace1 , warn ,  } = console;
function isFileOptions(fileOptions) {
    if (!fileOptions) return false;
    return fileOptions.encoding != undefined || fileOptions.flag != undefined || fileOptions.signal != undefined || fileOptions.mode != undefined;
}
function getEncoding(optOrCallback) {
    if (!optOrCallback || typeof optOrCallback === "function") {
        return null;
    }
    const encoding = typeof optOrCallback === "string" ? optOrCallback : optOrCallback.encoding;
    if (!encoding) return null;
    return encoding;
}
function checkEncoding(encoding) {
    if (!encoding) return null;
    encoding = encoding.toLowerCase();
    if ([
        "utf8",
        "hex",
        "base64"
    ].includes(encoding)) return encoding;
    if (encoding === "utf-8") {
        return "utf8";
    }
    if (encoding === "binary") {
        return "binary";
    }
    const notImplementedEncodings = [
        "utf16le",
        "latin1",
        "ascii",
        "ucs2"
    ];
    if (notImplementedEncodings.includes(encoding)) {
        notImplemented(`"${encoding}" encoding`);
    }
    throw new Error(`The value "${encoding}" is invalid for option "encoding"`);
}
function getOpenOptions(flag) {
    if (!flag) {
        return {
            create: true,
            append: true
        };
    }
    let openOptions;
    switch(flag){
        case "a":
            {
                openOptions = {
                    create: true,
                    append: true
                };
                break;
            }
        case "ax":
            {
                openOptions = {
                    createNew: true,
                    write: true,
                    append: true
                };
                break;
            }
        case "a+":
            {
                openOptions = {
                    read: true,
                    create: true,
                    append: true
                };
                break;
            }
        case "ax+":
            {
                openOptions = {
                    read: true,
                    createNew: true,
                    append: true
                };
                break;
            }
        case "r":
            {
                openOptions = {
                    read: true
                };
                break;
            }
        case "r+":
            {
                openOptions = {
                    read: true,
                    write: true
                };
                break;
            }
        case "w":
            {
                openOptions = {
                    create: true,
                    write: true,
                    truncate: true
                };
                break;
            }
        case "wx":
            {
                openOptions = {
                    createNew: true,
                    write: true
                };
                break;
            }
        case "w+":
            {
                openOptions = {
                    create: true,
                    write: true,
                    truncate: true,
                    read: true
                };
                break;
            }
        case "wx+":
            {
                openOptions = {
                    createNew: true,
                    write: true,
                    read: true
                };
                break;
            }
        case "as":
            {
                openOptions = {
                    create: true,
                    append: true
                };
                break;
            }
        case "as+":
            {
                openOptions = {
                    create: true,
                    read: true,
                    append: true
                };
                break;
            }
        case "rs+":
            {
                openOptions = {
                    create: true,
                    read: true,
                    write: true
                };
                break;
            }
        default:
            {
                throw new Error(`Unrecognized file system flag: ${flag}`);
            }
    }
    return openOptions;
}
function maybeCallback(cb) {
    validateCallback(cb);
    return cb;
}
function makeCallback(cb) {
    validateCallback(cb);
    return (...args)=>Reflect.apply(cb, this, args)
    ;
}
const CHAR_FORWARD_SLASH1 = 47;
function assertPath1(path32) {
    if (typeof path32 !== "string") {
        throw new ERR_INVALID_ARG_TYPE("path", [
            "string"
        ], path32);
    }
}
function isPosixPathSeparator1(code42) {
    return code42 === 47;
}
function isPathSeparator1(code43) {
    return isPosixPathSeparator1(code43) || code43 === 92;
}
function isWindowsDeviceRoot1(code44) {
    return code44 >= 97 && code44 <= 122 || code44 >= 65 && code44 <= 90;
}
function normalizeString1(path33, allowAboveRoot, separator, isPathSeparator11) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code45;
    for(let i116 = 0, len = path33.length; i116 <= len; ++i116){
        if (i116 < len) code45 = path33.charCodeAt(i116);
        else if (isPathSeparator11(code45)) break;
        else code45 = CHAR_FORWARD_SLASH1;
        if (isPathSeparator11(code45)) {
            if (lastSlash === i116 - 1 || dots === 1) {} else if (lastSlash !== i116 - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i116;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i116;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path33.slice(lastSlash + 1, i116);
                else res = path33.slice(lastSlash + 1, i116);
                lastSegmentLength = i116 - lastSlash - 1;
            }
            lastSlash = i116;
            dots = 0;
        } else if (code45 === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format2(sep7, pathObject) {
    const dir11 = pathObject.dir || pathObject.root;
    const base15 = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir11) return base15;
    if (dir11 === pathObject.root) return dir11 + base15;
    return dir11 + sep7 + base15;
}
const WHITESPACE_ENCODINGS1 = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace1(string) {
    return string.replaceAll(/[\s]/g, (c17)=>{
        return WHITESPACE_ENCODINGS1[c17] ?? c17;
    });
}
const sep3 = "\\";
const delimiter4 = ";";
function resolve3(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i117 = pathSegments.length - 1; i117 >= -1; i117--){
        let path34;
        const { Deno  } = globalThis;
        if (i117 >= 0) {
            path34 = pathSegments[i117];
        } else if (!resolvedDevice) {
            if (typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path34 = Deno.cwd();
        } else {
            if (typeof Deno?.env?.get !== "function" || typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path34 = Deno.cwd();
            if (path34 === undefined || path34.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path34 = `${resolvedDevice}\\`;
            }
        }
        assertPath1(path34);
        const len = path34.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute11 = false;
        const code46 = path34.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator1(code46)) {
                isAbsolute11 = true;
                if (isPathSeparator1(path34.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator1(path34.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path34.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator1(path34.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator1(path34.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path34.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path34.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot1(code46)) {
                if (path34.charCodeAt(1) === 58) {
                    device = path34.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator1(path34.charCodeAt(2))) {
                            isAbsolute11 = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator1(code46)) {
            rootEnd = 1;
            isAbsolute11 = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path34.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute11;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString1(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator1);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize4(path35) {
    assertPath1(path35);
    const len = path35.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute21 = false;
    const code47 = path35.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code47)) {
            isAbsolute21 = true;
            if (isPathSeparator1(path35.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path35.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path35.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path35.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path35.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path35.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path35.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot1(code47)) {
            if (path35.charCodeAt(1) === 58) {
                device = path35.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path35.charCodeAt(2))) {
                        isAbsolute21 = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator1(code47)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString1(path35.slice(rootEnd), !isAbsolute21, "\\", isPathSeparator1);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute21) tail = ".";
    if (tail.length > 0 && isPathSeparator1(path35.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute21) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute21) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute3(path36) {
    assertPath1(path36);
    const len = path36.length;
    if (len === 0) return false;
    const code48 = path36.charCodeAt(0);
    if (isPathSeparator1(code48)) {
        return true;
    } else if (isWindowsDeviceRoot1(code48)) {
        if (len > 2 && path36.charCodeAt(1) === 58) {
            if (isPathSeparator1(path36.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join5(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i118 = 0; i118 < pathsCount; ++i118){
        const path37 = paths[i118];
        assertPath1(path37);
        if (path37.length > 0) {
            if (joined === undefined) joined = firstPart = path37;
            else joined += `\\${path37}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert1(firstPart != null);
    if (isPathSeparator1(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator1(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator1(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator1(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize4(joined);
}
function relative3(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    const fromOrig = resolve3(from);
    const toOrig = resolve3(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i119 = 0;
    for(; i119 <= length; ++i119){
        if (i119 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i119) === 92) {
                    return toOrig.slice(toStart + i119 + 1);
                } else if (i119 === 2) {
                    return toOrig.slice(toStart + i119);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i119) === 92) {
                    lastCommonSep = i119;
                } else if (i119 === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i119);
        const toCode = to.charCodeAt(toStart + i119);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i119;
    }
    if (i119 !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i119 = fromStart + lastCommonSep + 1; i119 <= fromEnd; ++i119){
        if (i119 === fromEnd || from.charCodeAt(i119) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath3(path38) {
    if (typeof path38 !== "string") return path38;
    if (path38.length === 0) return "";
    const resolvedPath = resolve3(path38);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code49 = resolvedPath.charCodeAt(2);
                if (code49 !== 63 && code49 !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot1(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path38;
}
function dirname3(path39) {
    assertPath1(path39);
    const len = path39.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code50 = path39.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code50)) {
            rootEnd = offset = 1;
            if (isPathSeparator1(path39.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path39.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path39.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path39.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path39;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code50)) {
            if (path39.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator1(path39.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator1(code50)) {
        return path39;
    }
    for(let i120 = len - 1; i120 >= offset; --i120){
        if (isPathSeparator1(path39.charCodeAt(i120))) {
            if (!matchedSlash) {
                end = i120;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path39.slice(0, end);
}
function basename3(path40, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new ERR_INVALID_ARG_TYPE("ext", [
            "string"
        ], ext);
    }
    assertPath1(path40);
    let start24 = 0;
    let end = -1;
    let matchedSlash = true;
    let i121;
    if (path40.length >= 2) {
        const drive = path40.charCodeAt(0);
        if (isWindowsDeviceRoot1(drive)) {
            if (path40.charCodeAt(1) === 58) start24 = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path40.length) {
        if (ext.length === path40.length && ext === path40) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i121 = path40.length - 1; i121 >= start24; --i121){
            const code51 = path40.charCodeAt(i121);
            if (isPathSeparator1(code51)) {
                if (!matchedSlash) {
                    start24 = i121 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i121 + 1;
                }
                if (extIdx >= 0) {
                    if (code51 === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i121;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start24 === end) end = firstNonSlashEnd;
        else if (end === -1) end = path40.length;
        return path40.slice(start24, end);
    } else {
        for(i121 = path40.length - 1; i121 >= start24; --i121){
            if (isPathSeparator1(path40.charCodeAt(i121))) {
                if (!matchedSlash) {
                    start24 = i121 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i121 + 1;
            }
        }
        if (end === -1) return "";
        return path40.slice(start24, end);
    }
}
function extname3(path41) {
    assertPath1(path41);
    let start25 = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path41.length >= 2 && path41.charCodeAt(1) === 58 && isWindowsDeviceRoot1(path41.charCodeAt(0))) {
        start25 = startPart = 2;
    }
    for(let i122 = path41.length - 1; i122 >= start25; --i122){
        const code52 = path41.charCodeAt(i122);
        if (isPathSeparator1(code52)) {
            if (!matchedSlash) {
                startPart = i122 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i122 + 1;
        }
        if (code52 === 46) {
            if (startDot === -1) startDot = i122;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path41.slice(startDot, end);
}
function format4(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new ERR_INVALID_ARG_TYPE("pathObject", [
            "Object"
        ], pathObject);
    }
    return _format2("\\", pathObject);
}
function parse4(path42) {
    assertPath1(path42);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path42.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code53 = path42.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code53)) {
            rootEnd = 1;
            if (isPathSeparator1(path42.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path42.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path42.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path42.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code53)) {
            if (path42.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path42.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path42;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path42;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator1(code53)) {
        ret.root = ret.dir = path42;
        return ret;
    }
    if (rootEnd > 0) ret.root = path42.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i123 = path42.length - 1;
    let preDotState = 0;
    for(; i123 >= rootEnd; --i123){
        code53 = path42.charCodeAt(i123);
        if (isPathSeparator1(code53)) {
            if (!matchedSlash) {
                startPart = i123 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i123 + 1;
        }
        if (code53 === 46) {
            if (startDot === -1) startDot = i123;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path42.slice(startPart, end);
        }
    } else {
        ret.name = path42.slice(startPart, startDot);
        ret.base = path42.slice(startPart, end);
        ret.ext = path42.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path42.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl3(url6) {
    url6 = url6 instanceof URL ? url6 : new URL(url6);
    if (url6.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path43 = decodeURIComponent(url6.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url6.hostname != "") {
        path43 = `\\\\${url6.hostname}${path43}`;
    }
    return path43;
}
function toFileUrl3(path44) {
    if (!isAbsolute3(path44)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname7, pathname] = path44.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url7 = new URL("file:///");
    url7.pathname = encodeWhitespace1(pathname.replace(/%/g, "%25"));
    if (hostname7 != null && hostname7 != "localhost") {
        url7.hostname = hostname7;
        if (!url7.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url7;
}
const __default25 = {
    basename: basename3,
    delimiter: delimiter4,
    dirname: dirname3,
    extname: extname3,
    format: format4,
    fromFileUrl: fromFileUrl3,
    isAbsolute: isAbsolute3,
    join: join5,
    normalize: normalize4,
    parse: parse4,
    relative: relative3,
    resolve: resolve3,
    sep: sep3,
    toFileUrl: toFileUrl3,
    toNamespacedPath: toNamespacedPath3
};
const mod50 = {
    sep: sep3,
    delimiter: delimiter4,
    resolve: resolve3,
    normalize: normalize4,
    isAbsolute: isAbsolute3,
    join: join5,
    relative: relative3,
    toNamespacedPath: toNamespacedPath3,
    dirname: dirname3,
    basename: basename3,
    extname: extname3,
    format: format4,
    parse: parse4,
    fromFileUrl: fromFileUrl3,
    toFileUrl: toFileUrl3,
    default: __default25
};
const sep4 = "/";
const delimiter5 = ":";
function resolve4(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i124 = pathSegments.length - 1; i124 >= -1 && !resolvedAbsolute; i124--){
        let path45;
        if (i124 >= 0) path45 = pathSegments[i124];
        else {
            const { Deno  } = globalThis;
            if (typeof Deno?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path45 = Deno.cwd();
        }
        assertPath1(path45);
        if (path45.length === 0) {
            continue;
        }
        resolvedPath = `${path45}/${resolvedPath}`;
        resolvedAbsolute = path45.charCodeAt(0) === CHAR_FORWARD_SLASH1;
    }
    resolvedPath = normalizeString1(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator1);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize5(path46) {
    assertPath1(path46);
    if (path46.length === 0) return ".";
    const isAbsolute12 = path46.charCodeAt(0) === 47;
    const trailingSeparator = path46.charCodeAt(path46.length - 1) === 47;
    path46 = normalizeString1(path46, !isAbsolute12, "/", isPosixPathSeparator1);
    if (path46.length === 0 && !isAbsolute12) path46 = ".";
    if (path46.length > 0 && trailingSeparator) path46 += "/";
    if (isAbsolute12) return `/${path46}`;
    return path46;
}
function isAbsolute4(path47) {
    assertPath1(path47);
    return path47.length > 0 && path47.charCodeAt(0) === 47;
}
function join6(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i125 = 0, len = paths.length; i125 < len; ++i125){
        const path48 = paths[i125];
        assertPath1(path48);
        if (path48.length > 0) {
            if (!joined) joined = path48;
            else joined += `/${path48}`;
        }
    }
    if (!joined) return ".";
    return normalize5(joined);
}
function relative4(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    from = resolve4(from);
    to = resolve4(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i126 = 0;
    for(; i126 <= length; ++i126){
        if (i126 === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i126) === 47) {
                    return to.slice(toStart + i126 + 1);
                } else if (i126 === 0) {
                    return to.slice(toStart + i126);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i126) === 47) {
                    lastCommonSep = i126;
                } else if (i126 === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i126);
        const toCode = to.charCodeAt(toStart + i126);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i126;
    }
    let out = "";
    for(i126 = fromStart + lastCommonSep + 1; i126 <= fromEnd; ++i126){
        if (i126 === fromEnd || from.charCodeAt(i126) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath4(path49) {
    return path49;
}
function dirname4(path50) {
    assertPath1(path50);
    if (path50.length === 0) return ".";
    const hasRoot = path50.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i127 = path50.length - 1; i127 >= 1; --i127){
        if (path50.charCodeAt(i127) === 47) {
            if (!matchedSlash) {
                end = i127;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path50.slice(0, end);
}
function basename4(path51, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new ERR_INVALID_ARG_TYPE("ext", [
            "string"
        ], ext);
    }
    assertPath1(path51);
    let start26 = 0;
    let end = -1;
    let matchedSlash = true;
    let i128;
    if (ext !== undefined && ext.length > 0 && ext.length <= path51.length) {
        if (ext.length === path51.length && ext === path51) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i128 = path51.length - 1; i128 >= 0; --i128){
            const code54 = path51.charCodeAt(i128);
            if (code54 === 47) {
                if (!matchedSlash) {
                    start26 = i128 + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i128 + 1;
                }
                if (extIdx >= 0) {
                    if (code54 === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i128;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start26 === end) end = firstNonSlashEnd;
        else if (end === -1) end = path51.length;
        return path51.slice(start26, end);
    } else {
        for(i128 = path51.length - 1; i128 >= 0; --i128){
            if (path51.charCodeAt(i128) === 47) {
                if (!matchedSlash) {
                    start26 = i128 + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i128 + 1;
            }
        }
        if (end === -1) return "";
        return path51.slice(start26, end);
    }
}
function extname4(path52) {
    assertPath1(path52);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i129 = path52.length - 1; i129 >= 0; --i129){
        const code55 = path52.charCodeAt(i129);
        if (code55 === 47) {
            if (!matchedSlash) {
                startPart = i129 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i129 + 1;
        }
        if (code55 === 46) {
            if (startDot === -1) startDot = i129;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path52.slice(startDot, end);
}
function format5(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new ERR_INVALID_ARG_TYPE("pathObject", [
            "Object"
        ], pathObject);
    }
    return _format2("/", pathObject);
}
function parse5(path53) {
    assertPath1(path53);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path53.length === 0) return ret;
    const isAbsolute22 = path53.charCodeAt(0) === 47;
    let start27;
    if (isAbsolute22) {
        ret.root = "/";
        start27 = 1;
    } else {
        start27 = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i130 = path53.length - 1;
    let preDotState = 0;
    for(; i130 >= start27; --i130){
        const code56 = path53.charCodeAt(i130);
        if (code56 === 47) {
            if (!matchedSlash) {
                startPart = i130 + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i130 + 1;
        }
        if (code56 === 46) {
            if (startDot === -1) startDot = i130;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute22) {
                ret.base = ret.name = path53.slice(1, end);
            } else {
                ret.base = ret.name = path53.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute22) {
            ret.name = path53.slice(1, startDot);
            ret.base = path53.slice(1, end);
        } else {
            ret.name = path53.slice(startPart, startDot);
            ret.base = path53.slice(startPart, end);
        }
        ret.ext = path53.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path53.slice(0, startPart - 1);
    else if (isAbsolute22) ret.dir = "/";
    return ret;
}
function fromFileUrl4(url8) {
    url8 = url8 instanceof URL ? url8 : new URL(url8);
    if (url8.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url8.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl4(path54) {
    if (!isAbsolute4(path54)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url9 = new URL("file:///");
    url9.pathname = encodeWhitespace1(path54.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url9;
}
const __default26 = {
    basename: basename4,
    delimiter: delimiter5,
    dirname: dirname4,
    extname: extname4,
    format: format5,
    fromFileUrl: fromFileUrl4,
    isAbsolute: isAbsolute4,
    join: join6,
    normalize: normalize5,
    parse: parse5,
    relative: relative4,
    resolve: resolve4,
    sep: sep4,
    toFileUrl: toFileUrl4,
    toNamespacedPath: toNamespacedPath4
};
const mod51 = {
    sep: sep4,
    delimiter: delimiter5,
    resolve: resolve4,
    normalize: normalize5,
    isAbsolute: isAbsolute4,
    join: join6,
    relative: relative4,
    toNamespacedPath: toNamespacedPath4,
    dirname: dirname4,
    basename: basename4,
    extname: extname4,
    format: format5,
    parse: parse5,
    fromFileUrl: fromFileUrl4,
    toFileUrl: toFileUrl4,
    default: __default26
};
const SEP = isWindows ? "\\" : "/";
const SEP_PATTERN = isWindows ? /[\\/]+/ : /\/+/;
function common(paths, sep8 = SEP) {
    const [first = "", ...remaining] = paths;
    if (first === "" || remaining.length === 0) {
        return first.substring(0, first.lastIndexOf(sep8) + 1);
    }
    const parts = first.split(sep8);
    let endOfPrefix = parts.length;
    for (const path55 of remaining){
        const compare2 = path55.split(sep8);
        for(let i131 = 0; i131 < endOfPrefix; i131++){
            if (compare2[i131] !== parts[i131]) {
                endOfPrefix = i131;
            }
        }
        if (endOfPrefix === 0) {
            return "";
        }
    }
    const prefix = parts.slice(0, endOfPrefix).join(sep8);
    return prefix.endsWith(sep8) ? prefix : `${prefix}${sep8}`;
}
const path2 = isWindows ? mod50 : mod51;
const { join: join7 , normalize: normalize6  } = path2;
const regExpEscapeChars = [
    "!",
    "$",
    "(",
    ")",
    "*",
    "+",
    ".",
    "=",
    "?",
    "[",
    "\\",
    "^",
    "{",
    "|", 
];
const rangeEscapeChars = [
    "-",
    "\\",
    "]"
];
function globToRegExp(glob, { extended =true , globstar: globstarOption = true , os: os1 = osType , caseInsensitive =false  } = {}) {
    if (glob == "") {
        return /(?!)/;
    }
    const sep9 = os1 == "windows" ? "(?:\\\\|/)+" : "/+";
    const sepMaybe = os1 == "windows" ? "(?:\\\\|/)*" : "/*";
    const seps = os1 == "windows" ? [
        "\\",
        "/"
    ] : [
        "/"
    ];
    const globstar = os1 == "windows" ? "(?:[^\\\\/]*(?:\\\\|/|$)+)*" : "(?:[^/]*(?:/|$)+)*";
    const wildcard = os1 == "windows" ? "[^\\\\/]*" : "[^/]*";
    const escapePrefix = os1 == "windows" ? "`" : "\\";
    let newLength = glob.length;
    for(; newLength > 1 && seps.includes(glob[newLength - 1]); newLength--);
    glob = glob.slice(0, newLength);
    let regExpString = "";
    for(let j = 0; j < glob.length;){
        let segment = "";
        const groupStack = [];
        let inRange = false;
        let inEscape = false;
        let endsWithSep = false;
        let i132 = j;
        for(; i132 < glob.length && !seps.includes(glob[i132]); i132++){
            if (inEscape) {
                inEscape = false;
                const escapeChars = inRange ? rangeEscapeChars : regExpEscapeChars;
                segment += escapeChars.includes(glob[i132]) ? `\\${glob[i132]}` : glob[i132];
                continue;
            }
            if (glob[i132] == escapePrefix) {
                inEscape = true;
                continue;
            }
            if (glob[i132] == "[") {
                if (!inRange) {
                    inRange = true;
                    segment += "[";
                    if (glob[i132 + 1] == "!") {
                        i132++;
                        segment += "^";
                    } else if (glob[i132 + 1] == "^") {
                        i132++;
                        segment += "\\^";
                    }
                    continue;
                } else if (glob[i132 + 1] == ":") {
                    let k11 = i132 + 1;
                    let value = "";
                    while(glob[k11 + 1] != null && glob[k11 + 1] != ":"){
                        value += glob[k11 + 1];
                        k11++;
                    }
                    if (glob[k11 + 1] == ":" && glob[k11 + 2] == "]") {
                        i132 = k11 + 2;
                        if (value == "alnum") segment += "\\dA-Za-z";
                        else if (value == "alpha") segment += "A-Za-z";
                        else if (value == "ascii") segment += "\x00-\x7F";
                        else if (value == "blank") segment += "\t ";
                        else if (value == "cntrl") segment += "\x00-\x1F\x7F";
                        else if (value == "digit") segment += "\\d";
                        else if (value == "graph") segment += "\x21-\x7E";
                        else if (value == "lower") segment += "a-z";
                        else if (value == "print") segment += "\x20-\x7E";
                        else if (value == "punct") {
                            segment += "!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_‘{|}~";
                        } else if (value == "space") segment += "\\s\v";
                        else if (value == "upper") segment += "A-Z";
                        else if (value == "word") segment += "\\w";
                        else if (value == "xdigit") segment += "\\dA-Fa-f";
                        continue;
                    }
                }
            }
            if (glob[i132] == "]" && inRange) {
                inRange = false;
                segment += "]";
                continue;
            }
            if (inRange) {
                if (glob[i132] == "\\") {
                    segment += `\\\\`;
                } else {
                    segment += glob[i132];
                }
                continue;
            }
            if (glob[i132] == ")" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
                segment += ")";
                const type42 = groupStack.pop();
                if (type42 == "!") {
                    segment += wildcard;
                } else if (type42 != "@") {
                    segment += type42;
                }
                continue;
            }
            if (glob[i132] == "|" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
                segment += "|";
                continue;
            }
            if (glob[i132] == "+" && extended && glob[i132 + 1] == "(") {
                i132++;
                groupStack.push("+");
                segment += "(?:";
                continue;
            }
            if (glob[i132] == "@" && extended && glob[i132 + 1] == "(") {
                i132++;
                groupStack.push("@");
                segment += "(?:";
                continue;
            }
            if (glob[i132] == "?") {
                if (extended && glob[i132 + 1] == "(") {
                    i132++;
                    groupStack.push("?");
                    segment += "(?:";
                } else {
                    segment += ".";
                }
                continue;
            }
            if (glob[i132] == "!" && extended && glob[i132 + 1] == "(") {
                i132++;
                groupStack.push("!");
                segment += "(?!";
                continue;
            }
            if (glob[i132] == "{") {
                groupStack.push("BRACE");
                segment += "(?:";
                continue;
            }
            if (glob[i132] == "}" && groupStack[groupStack.length - 1] == "BRACE") {
                groupStack.pop();
                segment += ")";
                continue;
            }
            if (glob[i132] == "," && groupStack[groupStack.length - 1] == "BRACE") {
                segment += "|";
                continue;
            }
            if (glob[i132] == "*") {
                if (extended && glob[i132 + 1] == "(") {
                    i132++;
                    groupStack.push("*");
                    segment += "(?:";
                } else {
                    const prevChar = glob[i132 - 1];
                    let numStars = 1;
                    while(glob[i132 + 1] == "*"){
                        i132++;
                        numStars++;
                    }
                    const nextChar = glob[i132 + 1];
                    if (globstarOption && numStars == 2 && [
                        ...seps,
                        undefined
                    ].includes(prevChar) && [
                        ...seps,
                        undefined
                    ].includes(nextChar)) {
                        segment += globstar;
                        endsWithSep = true;
                    } else {
                        segment += wildcard;
                    }
                }
                continue;
            }
            segment += regExpEscapeChars.includes(glob[i132]) ? `\\${glob[i132]}` : glob[i132];
        }
        if (groupStack.length > 0 || inRange || inEscape) {
            segment = "";
            for (const c18 of glob.slice(j, i132)){
                segment += regExpEscapeChars.includes(c18) ? `\\${c18}` : c18;
                endsWithSep = false;
            }
        }
        regExpString += segment;
        if (!endsWithSep) {
            regExpString += i132 < glob.length ? sep9 : sepMaybe;
            endsWithSep = true;
        }
        while(seps.includes(glob[i132]))i132++;
        if (!(i132 > j)) {
            throw new Error("Assertion failure: i > j (potential infinite loop)");
        }
        j = i132;
    }
    regExpString = `^${regExpString}$`;
    return new RegExp(regExpString, caseInsensitive ? "i" : "");
}
function isGlob(str) {
    const chars = {
        "{": "}",
        "(": ")",
        "[": "]"
    };
    const regex = /\\(.)|(^!|\*|\?|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
    if (str === "") {
        return false;
    }
    let match2;
    while(match2 = regex.exec(str)){
        if (match2[2]) return true;
        let idx = match2.index + match2[0].length;
        const open3 = match2[1];
        const close4 = open3 ? chars[open3] : null;
        if (open3 && close4) {
            const n34 = str.indexOf(close4, idx);
            if (n34 !== -1) {
                idx = n34 + 1;
            }
        }
        str = str.slice(idx);
    }
    return false;
}
function normalizeGlob(glob, { globstar =false  } = {}) {
    if (glob.match(/\0/g)) {
        throw new Error(`Glob contains invalid characters: "${glob}"`);
    }
    if (!globstar) {
        return normalize6(glob);
    }
    const s21 = SEP_PATTERN.source;
    const badParentPattern = new RegExp(`(?<=(${s21}|^)\\*\\*${s21})\\.\\.(?=${s21}|$)`, "g");
    return normalize6(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
}
function joinGlobs(globs, { extended =true , globstar =false  } = {}) {
    if (!globstar || globs.length == 0) {
        return join7(...globs);
    }
    if (globs.length === 0) return ".";
    let joined;
    for (const glob of globs){
        const path110 = glob;
        if (path110.length > 0) {
            if (!joined) joined = path110;
            else joined += `${SEP}${path110}`;
        }
    }
    if (!joined) return ".";
    return normalizeGlob(joined, {
        extended,
        globstar
    });
}
const path3 = isWindows ? __default25 : __default26;
const { basename: basename5 , delimiter: delimiter6 , dirname: dirname5 , extname: extname5 , format: format6 , fromFileUrl: fromFileUrl5 , isAbsolute: isAbsolute5 , join: join8 , normalize: normalize7 , parse: parse6 , relative: relative5 , resolve: resolve5 , sep: sep5 , toFileUrl: toFileUrl5 , toNamespacedPath: toNamespacedPath5 ,  } = path3;
const mod52 = {
    SEP: SEP,
    SEP_PATTERN: SEP_PATTERN,
    win32: __default25,
    posix: __default26,
    basename: basename5,
    delimiter: delimiter6,
    dirname: dirname5,
    extname: extname5,
    format: format6,
    fromFileUrl: fromFileUrl5,
    isAbsolute: isAbsolute5,
    join: join8,
    normalize: normalize7,
    parse: parse6,
    relative: relative5,
    resolve: resolve5,
    sep: sep5,
    toFileUrl: toFileUrl5,
    toNamespacedPath: toNamespacedPath5,
    common,
    globToRegExp,
    isGlob,
    normalizeGlob,
    joinGlobs
};
const __default27 = {
    ...mod52
};
const hexTable = new Array(256);
for(let i1 = 0; i1 < 256; ++i1){
    hexTable[i1] = "%" + ((i1 < 16 ? "0" : "") + i1.toString(16)).toUpperCase();
}
new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
]);
function encodeStr(str, noEscapeTable, hexTable1) {
    const len = str.length;
    if (len === 0) return "";
    let out = "";
    let lastPos = 0;
    for(let i133 = 0; i133 < len; i133++){
        let c19 = str.charCodeAt(i133);
        if (c19 < 128) {
            if (noEscapeTable[c19] === 1) continue;
            if (lastPos < i133) out += str.slice(lastPos, i133);
            lastPos = i133 + 1;
            out += hexTable1[c19];
            continue;
        }
        if (lastPos < i133) out += str.slice(lastPos, i133);
        if (c19 < 2048) {
            lastPos = i133 + 1;
            out += hexTable1[192 | c19 >> 6] + hexTable1[128 | c19 & 63];
            continue;
        }
        if (c19 < 55296 || c19 >= 57344) {
            lastPos = i133 + 1;
            out += hexTable1[224 | c19 >> 12] + hexTable1[128 | c19 >> 6 & 63] + hexTable1[128 | c19 & 63];
            continue;
        }
        ++i133;
        if (i133 >= len) throw new ERR_INVALID_URI();
        const c2 = str.charCodeAt(i133) & 1023;
        lastPos = i133 + 1;
        c19 = 65536 + ((c19 & 1023) << 10 | c2);
        out += hexTable1[240 | c19 >> 18] + hexTable1[128 | c19 >> 12 & 63] + hexTable1[128 | c19 >> 6 & 63] + hexTable1[128 | c19 & 63];
    }
    if (lastPos === 0) return str;
    if (lastPos < len) return out + str.slice(lastPos);
    return out;
}
const decode3 = parse7;
const encode3 = stringify;
function qsEscape(str) {
    if (typeof str !== "string") {
        if (typeof str === "object") {
            str = String(str);
        } else {
            str += "";
        }
    }
    return encodeStr(str, noEscape, hexTable);
}
const escape = qsEscape;
const isHexTable = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
]);
function charCodes(str) {
    const ret = new Array(str.length);
    for(let i134 = 0; i134 < str.length; ++i134){
        ret[i134] = str.charCodeAt(i134);
    }
    return ret;
}
function addKeyVal(obj, key, value, keyEncoded, valEncoded, decode11) {
    if (key.length > 0 && keyEncoded) {
        key = decode11(key);
    }
    if (value.length > 0 && valEncoded) {
        value = decode11(value);
    }
    if (obj[key] === undefined) {
        obj[key] = value;
    } else {
        const curValue = obj[key];
        if (curValue.pop) {
            curValue[curValue.length] = value;
        } else {
            obj[key] = [
                curValue,
                value
            ];
        }
    }
}
function parse7(str, sep10 = "&", eq = "=", { decodeURIComponent =unescape , maxKeys =1000  } = {}) {
    const obj = Object.create(null);
    if (typeof str !== "string" || str.length === 0) {
        return obj;
    }
    const sepCodes = !sep10 ? [
        38
    ] : charCodes(String(sep10));
    const eqCodes = !eq ? [
        61
    ] : charCodes(String(eq));
    const sepLen = sepCodes.length;
    const eqLen = eqCodes.length;
    let pairs = 1000;
    if (typeof maxKeys === "number") {
        pairs = maxKeys > 0 ? maxKeys : -1;
    }
    let decode21 = unescape;
    if (decodeURIComponent) {
        decode21 = decodeURIComponent;
    }
    const customDecode = decode21 !== unescape;
    let lastPos = 0;
    let sepIdx = 0;
    let eqIdx = 0;
    let key = "";
    let value = "";
    let keyEncoded = customDecode;
    let valEncoded = customDecode;
    const plusChar = customDecode ? "%20" : " ";
    let encodeCheck = 0;
    for(let i135 = 0; i135 < str.length; ++i135){
        const code57 = str.charCodeAt(i135);
        if (code57 === sepCodes[sepIdx]) {
            if (++sepIdx === sepLen) {
                const end = i135 - sepIdx + 1;
                if (eqIdx < eqLen) {
                    if (lastPos < end) {
                        key += str.slice(lastPos, end);
                    } else if (key.length === 0) {
                        if (--pairs === 0) {
                            return obj;
                        }
                        lastPos = i135 + 1;
                        sepIdx = eqIdx = 0;
                        continue;
                    }
                } else if (lastPos < end) {
                    value += str.slice(lastPos, end);
                }
                addKeyVal(obj, key, value, keyEncoded, valEncoded, decode21);
                if (--pairs === 0) {
                    return obj;
                }
                key = value = "";
                encodeCheck = 0;
                lastPos = i135 + 1;
                sepIdx = eqIdx = 0;
            }
        } else {
            sepIdx = 0;
            if (eqIdx < eqLen) {
                if (code57 === eqCodes[eqIdx]) {
                    if (++eqIdx === eqLen) {
                        const end = i135 - eqIdx + 1;
                        if (lastPos < end) {
                            key += str.slice(lastPos, end);
                        }
                        encodeCheck = 0;
                        lastPos = i135 + 1;
                    }
                    continue;
                } else {
                    eqIdx = 0;
                    if (!keyEncoded) {
                        if (code57 === 37) {
                            encodeCheck = 1;
                            continue;
                        } else if (encodeCheck > 0) {
                            if (isHexTable[code57] === 1) {
                                if (++encodeCheck === 3) {
                                    keyEncoded = true;
                                }
                                continue;
                            } else {
                                encodeCheck = 0;
                            }
                        }
                    }
                }
                if (code57 === 43) {
                    if (lastPos < i135) {
                        key += str.slice(lastPos, i135);
                    }
                    key += plusChar;
                    lastPos = i135 + 1;
                    continue;
                }
            }
            if (code57 === 43) {
                if (lastPos < i135) {
                    value += str.slice(lastPos, i135);
                }
                value += plusChar;
                lastPos = i135 + 1;
            } else if (!valEncoded) {
                if (code57 === 37) {
                    encodeCheck = 1;
                } else if (encodeCheck > 0) {
                    if (isHexTable[code57] === 1) {
                        if (++encodeCheck === 3) {
                            valEncoded = true;
                        }
                    } else {
                        encodeCheck = 0;
                    }
                }
            }
        }
    }
    if (lastPos < str.length) {
        if (eqIdx < eqLen) {
            key += str.slice(lastPos);
        } else if (sepIdx < sepLen) {
            value += str.slice(lastPos);
        }
    } else if (eqIdx === 0 && key.length === 0) {
        return obj;
    }
    addKeyVal(obj, key, value, keyEncoded, valEncoded, decode21);
    return obj;
}
const noEscape = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
]);
function stringifyPrimitive(v11) {
    if (typeof v11 === "string") {
        return v11;
    }
    if (typeof v11 === "number" && isFinite(v11)) {
        return "" + v11;
    }
    if (typeof v11 === "bigint") {
        return "" + v11;
    }
    if (typeof v11 === "boolean") {
        return v11 ? "true" : "false";
    }
    return "";
}
function encodeStringifiedCustom(v12, encode11) {
    return encode11(stringifyPrimitive(v12));
}
function encodeStringified(v13, encode21) {
    if (typeof v13 === "string") {
        return v13.length ? encode21(v13) : "";
    }
    if (typeof v13 === "number" && isFinite(v13)) {
        return Math.abs(v13) < 1000000000000000000000 ? "" + v13 : encode21("" + v13);
    }
    if (typeof v13 === "bigint") {
        return "" + v13;
    }
    if (typeof v13 === "boolean") {
        return v13 ? "true" : "false";
    }
    return "";
}
function stringify(obj, sep11, eq, options) {
    sep11 ||= "&";
    eq ||= "=";
    const encode31 = options ? options.encodeURIComponent : qsEscape;
    const convert = options ? encodeStringifiedCustom : encodeStringified;
    if (obj !== null && typeof obj === "object") {
        const keys = Object.keys(obj);
        const len = keys.length;
        let fields = "";
        for(let i136 = 0; i136 < len; ++i136){
            const k12 = keys[i136];
            const v14 = obj[k12];
            let ks = convert(k12, encode31);
            ks += eq;
            if (Array.isArray(v14)) {
                const vlen = v14.length;
                if (vlen === 0) continue;
                if (fields) {
                    fields += sep11;
                }
                for(let j = 0; j < vlen; ++j){
                    if (j) {
                        fields += sep11;
                    }
                    fields += ks;
                    fields += convert(v14[j], encode31);
                }
            } else {
                if (fields) {
                    fields += sep11;
                }
                fields += ks;
                fields += convert(v14, encode31);
            }
        }
        return fields;
    }
    return "";
}
const unhexTable = new Int8Array([
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    +0,
    +1,
    +2,
    +3,
    +4,
    +5,
    +6,
    +7,
    +8,
    +9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
]);
function unescapeBuffer(s22, decodeSpaces = false) {
    const out = new Buffer1(s22.length);
    let index13 = 0;
    let outIndex = 0;
    let currentChar;
    let nextChar;
    let hexHigh;
    let hexLow;
    const maxLength = s22.length - 2;
    let hasHex = false;
    while(index13 < s22.length){
        currentChar = s22.charCodeAt(index13);
        if (currentChar === 43 && decodeSpaces) {
            out[outIndex++] = 32;
            index13++;
            continue;
        }
        if (currentChar === 37 && index13 < maxLength) {
            currentChar = s22.charCodeAt(++index13);
            hexHigh = unhexTable[currentChar];
            if (!(hexHigh >= 0)) {
                out[outIndex++] = 37;
                continue;
            } else {
                nextChar = s22.charCodeAt(++index13);
                hexLow = unhexTable[nextChar];
                if (!(hexLow >= 0)) {
                    out[outIndex++] = 37;
                    index13--;
                } else {
                    hasHex = true;
                    currentChar = hexHigh * 16 + hexLow;
                }
            }
        }
        out[outIndex++] = currentChar;
        index13++;
    }
    return hasHex ? out.slice(0, outIndex) : out;
}
function qsUnescape(s23) {
    try {
        return decodeURIComponent(s23);
    } catch  {
        return unescapeBuffer(s23).toString();
    }
}
const unescape = qsUnescape;
const __default28 = {
    parse: parse7,
    stringify,
    decode: decode3,
    encode: encode3,
    unescape,
    escape,
    unescapeBuffer
};
const forwardSlashRegEx = /\//g;
const percentRegEx = /%/g;
const backslashRegEx = /\\/g;
const newlineRegEx = /\n/g;
const carriageReturnRegEx = /\r/g;
const tabRegEx = /\t/g;
const protocolPattern = /^[a-z0-9.+-]+:/i;
const portPattern = /:[0-9]*$/;
const hostPattern = /^\/\/[^@/]+@[^@/]+/;
const simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/;
const unsafeProtocol = new Set([
    "javascript",
    "javascript:"
]);
const hostlessProtocol = new Set([
    "javascript",
    "javascript:"
]);
const slashedProtocol = new Set([
    "http",
    "http:",
    "https",
    "https:",
    "ftp",
    "ftp:",
    "gopher",
    "gopher:",
    "file",
    "file:",
    "ws",
    "ws:",
    "wss",
    "wss:", 
]);
const noEscapeAuth = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
]);
class Url {
    protocol;
    slashes;
    auth;
    host;
    port;
    hostname;
    hash;
    search;
    query;
    pathname;
    path;
    href;
    constructor(){
        this.protocol = null;
        this.slashes = null;
        this.auth = null;
        this.host = null;
        this.port = null;
        this.hostname = null;
        this.hash = null;
        this.search = null;
        this.query = null;
        this.pathname = null;
        this.path = null;
        this.href = null;
    }
    parseHost() {
        let host = this.host || "";
        let port10 = portPattern.exec(host);
        if (port10) {
            port10 = port10[0];
            if (port10 !== ":") {
                this.port = port10.slice(1);
            }
            host = host.slice(0, host.length - port10.length);
        }
        if (host) this.hostname = host;
    }
    resolve(relative6) {
        return this.resolveObject(parse8(relative6, false, true)).format();
    }
    resolveObject(relative7) {
        if (typeof relative7 === "string") {
            const rel = new Url();
            rel.urlParse(relative7, false, true);
            relative7 = rel;
        }
        const result = new Url();
        const tkeys = Object.keys(this);
        for(let tk = 0; tk < tkeys.length; tk++){
            const tkey = tkeys[tk];
            result[tkey] = this[tkey];
        }
        result.hash = relative7.hash;
        if (relative7.href === "") {
            result.href = result.format();
            return result;
        }
        if (relative7.slashes && !relative7.protocol) {
            const rkeys = Object.keys(relative7);
            for(let rk = 0; rk < rkeys.length; rk++){
                const rkey = rkeys[rk];
                if (rkey !== "protocol") result[rkey] = relative7[rkey];
            }
            if (result.protocol && slashedProtocol.has(result.protocol) && result.hostname && !result.pathname) {
                result.path = result.pathname = "/";
            }
            result.href = result.format();
            return result;
        }
        if (relative7.protocol && relative7.protocol !== result.protocol) {
            if (!slashedProtocol.has(relative7.protocol)) {
                const keys = Object.keys(relative7);
                for(let v15 = 0; v15 < keys.length; v15++){
                    const k13 = keys[v15];
                    result[k13] = relative7[k13];
                }
                result.href = result.format();
                return result;
            }
            result.protocol = relative7.protocol;
            if (!relative7.host && !/^file:?$/.test(relative7.protocol) && !hostlessProtocol.has(relative7.protocol)) {
                const relPath = (relative7.pathname || "").split("/");
                while(relPath.length && !(relative7.host = relPath.shift() || null));
                if (!relative7.host) relative7.host = "";
                if (!relative7.hostname) relative7.hostname = "";
                if (relPath[0] !== "") relPath.unshift("");
                if (relPath.length < 2) relPath.unshift("");
                result.pathname = relPath.join("/");
            } else {
                result.pathname = relative7.pathname;
            }
            result.search = relative7.search;
            result.query = relative7.query;
            result.host = relative7.host || "";
            result.auth = relative7.auth;
            result.hostname = relative7.hostname || relative7.host;
            result.port = relative7.port;
            if (result.pathname || result.search) {
                const p15 = result.pathname || "";
                const s24 = result.search || "";
                result.path = p15 + s24;
            }
            result.slashes = result.slashes || relative7.slashes;
            result.href = result.format();
            return result;
        }
        const isSourceAbs = result.pathname && result.pathname.charAt(0) === "/";
        const isRelAbs = relative7.host || relative7.pathname && relative7.pathname.charAt(0) === "/";
        let mustEndAbs = isRelAbs || isSourceAbs || result.host && relative7.pathname;
        const removeAllDots = mustEndAbs;
        let srcPath = result.pathname && result.pathname.split("/") || [];
        const relPath = relative7.pathname && relative7.pathname.split("/") || [];
        const noLeadingSlashes = result.protocol && !slashedProtocol.has(result.protocol);
        if (noLeadingSlashes) {
            result.hostname = "";
            result.port = null;
            if (result.host) {
                if (srcPath[0] === "") srcPath[0] = result.host;
                else srcPath.unshift(result.host);
            }
            result.host = "";
            if (relative7.protocol) {
                relative7.hostname = null;
                relative7.port = null;
                result.auth = null;
                if (relative7.host) {
                    if (relPath[0] === "") relPath[0] = relative7.host;
                    else relPath.unshift(relative7.host);
                }
                relative7.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
        }
        if (isRelAbs) {
            if (relative7.host || relative7.host === "") {
                if (result.host !== relative7.host) result.auth = null;
                result.host = relative7.host;
                result.port = relative7.port;
            }
            if (relative7.hostname || relative7.hostname === "") {
                if (result.hostname !== relative7.hostname) result.auth = null;
                result.hostname = relative7.hostname;
            }
            result.search = relative7.search;
            result.query = relative7.query;
            srcPath = relPath;
        } else if (relPath.length) {
            if (!srcPath) srcPath = [];
            srcPath.pop();
            srcPath = srcPath.concat(relPath);
            result.search = relative7.search;
            result.query = relative7.query;
        } else if (relative7.search !== null && relative7.search !== undefined) {
            if (noLeadingSlashes) {
                result.hostname = result.host = srcPath.shift() || null;
                const authInHost = result.host && result.host.indexOf("@") > 0 && result.host.split("@");
                if (authInHost) {
                    result.auth = authInHost.shift() || null;
                    result.host = result.hostname = authInHost.shift() || null;
                }
            }
            result.search = relative7.search;
            result.query = relative7.query;
            if (result.pathname !== null || result.search !== null) {
                result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
            }
            result.href = result.format();
            return result;
        }
        if (!srcPath.length) {
            result.pathname = null;
            if (result.search) {
                result.path = "/" + result.search;
            } else {
                result.path = null;
            }
            result.href = result.format();
            return result;
        }
        let last = srcPath.slice(-1)[0];
        const hasTrailingSlash = (result.host || relative7.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
        let up = 0;
        for(let i137 = srcPath.length - 1; i137 >= 0; i137--){
            last = srcPath[i137];
            if (last === ".") {
                srcPath.splice(i137, 1);
            } else if (last === "..") {
                srcPath.splice(i137, 1);
                up++;
            } else if (up) {
                srcPath.splice(i137, 1);
                up--;
            }
        }
        if (!mustEndAbs && !removeAllDots) {
            while(up--){
                srcPath.unshift("..");
            }
        }
        if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
            srcPath.unshift("");
        }
        if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
            srcPath.push("");
        }
        const isAbsolute6 = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
        if (noLeadingSlashes) {
            result.hostname = result.host = isAbsolute6 ? "" : srcPath.length ? srcPath.shift() || null : "";
            const authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost) {
                result.auth = authInHost.shift() || null;
                result.host = result.hostname = authInHost.shift() || null;
            }
        }
        mustEndAbs = mustEndAbs || result.host && srcPath.length;
        if (mustEndAbs && !isAbsolute6) {
            srcPath.unshift("");
        }
        if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
        } else {
            result.pathname = srcPath.join("/");
        }
        if (result.pathname !== null || result.search !== null) {
            result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.auth = relative7.auth || result.auth;
        result.slashes = result.slashes || relative7.slashes;
        result.href = result.format();
        return result;
    }
    format() {
        let auth = this.auth || "";
        if (auth) {
            auth = encodeStr(auth, noEscapeAuth, hexTable);
            auth += "@";
        }
        let protocol = this.protocol || "";
        let pathname = this.pathname || "";
        let hash = this.hash || "";
        let host = "";
        let query = "";
        if (this.host) {
            host = auth + this.host;
        } else if (this.hostname) {
            host = auth + (this.hostname.includes(":") && !isIpv6Hostname(this.hostname) ? "[" + this.hostname + "]" : this.hostname);
            if (this.port) {
                host += ":" + this.port;
            }
        }
        if (this.query !== null && typeof this.query === "object") {
            query = __default28.stringify(this.query);
        }
        let search = this.search || query && "?" + query || "";
        if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58) {
            protocol += ":";
        }
        let newPathname = "";
        let lastPos = 0;
        for(let i138 = 0; i138 < pathname.length; ++i138){
            switch(pathname.charCodeAt(i138)){
                case 35:
                    if (i138 - lastPos > 0) {
                        newPathname += pathname.slice(lastPos, i138);
                    }
                    newPathname += "%23";
                    lastPos = i138 + 1;
                    break;
                case 63:
                    if (i138 - lastPos > 0) {
                        newPathname += pathname.slice(lastPos, i138);
                    }
                    newPathname += "%3F";
                    lastPos = i138 + 1;
                    break;
            }
        }
        if (lastPos > 0) {
            if (lastPos !== pathname.length) {
                pathname = newPathname + pathname.slice(lastPos);
            } else pathname = newPathname;
        }
        if (this.slashes || slashedProtocol.has(protocol)) {
            if (this.slashes || host) {
                if (pathname && pathname.charCodeAt(0) !== 47) {
                    pathname = "/" + pathname;
                }
                host = "//" + host;
            } else if (protocol.length >= 4 && protocol.charCodeAt(0) === 102 && protocol.charCodeAt(1) === 105 && protocol.charCodeAt(2) === 108 && protocol.charCodeAt(3) === 101) {
                host = "//";
            }
        }
        search = search.replace(/#/g, "%23");
        if (hash && hash.charCodeAt(0) !== 35) {
            hash = "#" + hash;
        }
        if (search && search.charCodeAt(0) !== 63) {
            search = "?" + search;
        }
        return protocol + host + pathname + search + hash;
    }
    urlParse(url10, parseQueryString, slashesDenoteHost) {
        let hasHash = false;
        let start28 = -1;
        let end = -1;
        let rest = "";
        let lastPos = 0;
        for(let i139 = 0, inWs = false, split = false; i139 < url10.length; ++i139){
            const code58 = url10.charCodeAt(i139);
            const isWs = code58 === 32 || code58 === 9 || code58 === 13 || code58 === 10 || code58 === 12 || code58 === 160 || code58 === 65279;
            if (start28 === -1) {
                if (isWs) continue;
                lastPos = start28 = i139;
            } else if (inWs) {
                if (!isWs) {
                    end = -1;
                    inWs = false;
                }
            } else if (isWs) {
                end = i139;
                inWs = true;
            }
            if (!split) {
                switch(code58){
                    case 35:
                        hasHash = true;
                    case 63:
                        split = true;
                        break;
                    case 92:
                        if (i139 - lastPos > 0) rest += url10.slice(lastPos, i139);
                        rest += "/";
                        lastPos = i139 + 1;
                        break;
                }
            } else if (!hasHash && code58 === 35) {
                hasHash = true;
            }
        }
        if (start28 !== -1) {
            if (lastPos === start28) {
                if (end === -1) {
                    if (start28 === 0) rest = url10;
                    else rest = url10.slice(start28);
                } else {
                    rest = url10.slice(start28, end);
                }
            } else if (end === -1 && lastPos < url10.length) {
                rest += url10.slice(lastPos);
            } else if (end !== -1 && lastPos < end) {
                rest += url10.slice(lastPos, end);
            }
        }
        if (!slashesDenoteHost && !hasHash) {
            const simplePath = simplePathPattern.exec(rest);
            if (simplePath) {
                this.path = rest;
                this.href = rest;
                this.pathname = simplePath[1];
                if (simplePath[2]) {
                    this.search = simplePath[2];
                    if (parseQueryString) {
                        this.query = __default28.parse(this.search.slice(1));
                    } else {
                        this.query = this.search.slice(1);
                    }
                } else if (parseQueryString) {
                    this.search = null;
                    this.query = Object.create(null);
                }
                return this;
            }
        }
        let proto = protocolPattern.exec(rest);
        let lowerProto = "";
        if (proto) {
            proto = proto[0];
            lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.slice(proto.length);
        }
        let slashes;
        if (slashesDenoteHost || proto || hostPattern.test(rest)) {
            slashes = rest.charCodeAt(0) === CHAR_FORWARD_SLASH && rest.charCodeAt(1) === CHAR_FORWARD_SLASH;
            if (slashes && !(proto && hostlessProtocol.has(lowerProto))) {
                rest = rest.slice(2);
                this.slashes = true;
            }
        }
        if (!hostlessProtocol.has(lowerProto) && (slashes || proto && !slashedProtocol.has(proto))) {
            let hostEnd = -1;
            let atSign = -1;
            let nonHost = -1;
            for(let i140 = 0; i140 < rest.length; ++i140){
                switch(rest.charCodeAt(i140)){
                    case 9:
                    case 10:
                    case 13:
                    case 32:
                    case 34:
                    case 37:
                    case 39:
                    case 59:
                    case 60:
                    case 62:
                    case 92:
                    case 94:
                    case 96:
                    case 123:
                    case 124:
                    case 125:
                        if (nonHost === -1) nonHost = i140;
                        break;
                    case 35:
                    case 47:
                    case 63:
                        if (nonHost === -1) nonHost = i140;
                        hostEnd = i140;
                        break;
                    case 64:
                        atSign = i140;
                        nonHost = -1;
                        break;
                }
                if (hostEnd !== -1) break;
            }
            start28 = 0;
            if (atSign !== -1) {
                this.auth = decodeURIComponent(rest.slice(0, atSign));
                start28 = atSign + 1;
            }
            if (nonHost === -1) {
                this.host = rest.slice(start28);
                rest = "";
            } else {
                this.host = rest.slice(start28, nonHost);
                rest = rest.slice(nonHost);
            }
            this.parseHost();
            if (typeof this.hostname !== "string") this.hostname = "";
            const hostname8 = this.hostname;
            const ipv6Hostname = isIpv6Hostname(hostname8);
            if (!ipv6Hostname) {
                rest = getHostname(this, rest, hostname8);
            }
            if (this.hostname.length > 255) {
                this.hostname = "";
            } else {
                this.hostname = this.hostname.toLowerCase();
            }
            if (!ipv6Hostname) {
                this.hostname = toASCII(this.hostname);
            }
            const p16 = this.port ? ":" + this.port : "";
            const h1 = this.hostname || "";
            this.host = h1 + p16;
            if (ipv6Hostname) {
                this.hostname = this.hostname.slice(1, -1);
                if (rest[0] !== "/") {
                    rest = "/" + rest;
                }
            }
        }
        if (!unsafeProtocol.has(lowerProto)) {
            rest = autoEscapeStr(rest);
        }
        let questionIdx = -1;
        let hashIdx = -1;
        for(let i141 = 0; i141 < rest.length; ++i141){
            const code59 = rest.charCodeAt(i141);
            if (code59 === 35) {
                this.hash = rest.slice(i141);
                hashIdx = i141;
                break;
            } else if (code59 === 63 && questionIdx === -1) {
                questionIdx = i141;
            }
        }
        if (questionIdx !== -1) {
            if (hashIdx === -1) {
                this.search = rest.slice(questionIdx);
                this.query = rest.slice(questionIdx + 1);
            } else {
                this.search = rest.slice(questionIdx, hashIdx);
                this.query = rest.slice(questionIdx + 1, hashIdx);
            }
            if (parseQueryString) {
                this.query = __default28.parse(this.query);
            }
        } else if (parseQueryString) {
            this.search = null;
            this.query = Object.create(null);
        }
        const useQuestionIdx = questionIdx !== -1 && (hashIdx === -1 || questionIdx < hashIdx);
        const firstIdx = useQuestionIdx ? questionIdx : hashIdx;
        if (firstIdx === -1) {
            if (rest.length > 0) this.pathname = rest;
        } else if (firstIdx > 0) {
            this.pathname = rest.slice(0, firstIdx);
        }
        if (slashedProtocol.has(lowerProto) && this.hostname && !this.pathname) {
            this.pathname = "/";
        }
        if (this.pathname || this.search) {
            const p17 = this.pathname || "";
            const s25 = this.search || "";
            this.path = p17 + s25;
        }
        this.href = this.format();
        return this;
    }
}
function format7(urlObject, options) {
    if (urlObject instanceof URL) {
        return formatWhatwg(urlObject, options);
    }
    if (typeof urlObject === "string") {
        urlObject = parse8(urlObject, true, false);
    }
    return urlObject.format();
}
function formatWhatwg(urlObject, options) {
    if (typeof urlObject === "string") {
        urlObject = new URL(urlObject);
    }
    if (options) {
        if (typeof options !== "object") {
            throw new ERR_INVALID_ARG_TYPE("options", "object", options);
        }
    }
    options = {
        auth: true,
        fragment: true,
        search: true,
        unicode: false,
        ...options
    };
    let ret = urlObject.protocol;
    if (urlObject.host !== null) {
        ret += "//";
        const hasUsername = !!urlObject.username;
        const hasPassword = !!urlObject.password;
        if (options.auth && (hasUsername || hasPassword)) {
            if (hasUsername) {
                ret += urlObject.username;
            }
            if (hasPassword) {
                ret += `:${urlObject.password}`;
            }
            ret += "@";
        }
        ret += urlObject.host;
        if (urlObject.port) {
            ret += `:${urlObject.port}`;
        }
    }
    ret += urlObject.pathname;
    if (options.search && urlObject.search) {
        ret += urlObject.search;
    }
    if (options.fragment && urlObject.hash) {
        ret += urlObject.hash;
    }
    return ret;
}
function isIpv6Hostname(hostname9) {
    return hostname9.charCodeAt(0) === 91 && hostname9.charCodeAt(hostname9.length - 1) === 93;
}
function getHostname(self, rest, hostname10) {
    for(let i142 = 0; i142 < hostname10.length; ++i142){
        const code60 = hostname10.charCodeAt(i142);
        const isValid = code60 >= 97 && code60 <= 122 || code60 === 46 || code60 >= 65 && code60 <= 90 || code60 >= 48 && code60 <= 57 || code60 === 45 || code60 === 43 || code60 === 95 || code60 > 127;
        if (!isValid) {
            self.hostname = hostname10.slice(0, i142);
            return `/${hostname10.slice(i142)}${rest}`;
        }
    }
    return rest;
}
const escapedCodes = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%09",
    "%0A",
    "",
    "",
    "%0D",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%20",
    "",
    "%22",
    "",
    "",
    "",
    "",
    "%27",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%3C",
    "",
    "%3E",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%5C",
    "",
    "%5E",
    "",
    "%60",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "%7B",
    "%7C",
    "%7D"
];
function autoEscapeStr(rest) {
    let escaped = "";
    let lastEscapedPos = 0;
    for(let i143 = 0; i143 < rest.length; ++i143){
        const escapedChar = escapedCodes[rest.charCodeAt(i143)];
        if (escapedChar) {
            if (i143 > lastEscapedPos) {
                escaped += rest.slice(lastEscapedPos, i143);
            }
            escaped += escapedChar;
            lastEscapedPos = i143 + 1;
        }
    }
    if (lastEscapedPos === 0) {
        return rest;
    }
    if (lastEscapedPos < rest.length) {
        escaped += rest.slice(lastEscapedPos);
    }
    return escaped;
}
function parse8(url11, parseQueryString, slashesDenoteHost) {
    if (url11 instanceof Url) return url11;
    const urlObject = new Url();
    urlObject.urlParse(url11, parseQueryString, slashesDenoteHost);
    return urlObject;
}
function resolve6(from, to) {
    return parse8(from, false, true).resolve(to);
}
function resolveObject(source, relative8) {
    if (!source) return relative8;
    return parse8(source, false, true).resolveObject(relative8);
}
function fileURLToPath(path111) {
    if (typeof path111 === "string") path111 = new URL(path111);
    else if (!(path111 instanceof URL)) {
        throw new ERR_INVALID_ARG_TYPE("path", [
            "string",
            "URL"
        ], path111);
    }
    if (path111.protocol !== "file:") {
        throw new ERR_INVALID_URL_SCHEME("file");
    }
    return isWindows ? getPathFromURLWin(path111) : getPathFromURLPosix(path111);
}
function getPathFromURLWin(url12) {
    const hostname11 = url12.hostname;
    let pathname = url12.pathname;
    for(let n35 = 0; n35 < pathname.length; n35++){
        if (pathname[n35] === "%") {
            const third = pathname.codePointAt(n35 + 2) | 32;
            if (pathname[n35 + 1] === "2" && third === 102 || pathname[n35 + 1] === "5" && third === 99) {
                throw new ERR_INVALID_FILE_URL_PATH("must not include encoded \\ or / characters");
            }
        }
    }
    pathname = pathname.replace(forwardSlashRegEx, "\\");
    pathname = decodeURIComponent(pathname);
    if (hostname11 !== "") {
        return `\\\\${hostname11}${pathname}`;
    } else {
        const letter = pathname.codePointAt(1) | 32;
        const sep12 = pathname[2];
        if (letter < 97 || letter > 122 || sep12 !== ":") {
            throw new ERR_INVALID_FILE_URL_PATH("must be absolute");
        }
        return pathname.slice(1);
    }
}
function getPathFromURLPosix(url13) {
    if (url13.hostname !== "") {
        throw new ERR_INVALID_FILE_URL_HOST(osType);
    }
    const pathname = url13.pathname;
    for(let n36 = 0; n36 < pathname.length; n36++){
        if (pathname[n36] === "%") {
            const third = pathname.codePointAt(n36 + 2) | 32;
            if (pathname[n36 + 1] === "2" && third === 102) {
                throw new ERR_INVALID_FILE_URL_PATH("must not include encoded / characters");
            }
        }
    }
    return decodeURIComponent(pathname);
}
function encodePathChars(filepath) {
    if (filepath.includes("%")) {
        filepath = filepath.replace(percentRegEx, "%25");
    }
    if (!isWindows && filepath.includes("\\")) {
        filepath = filepath.replace(backslashRegEx, "%5C");
    }
    if (filepath.includes("\n")) {
        filepath = filepath.replace(newlineRegEx, "%0A");
    }
    if (filepath.includes("\r")) {
        filepath = filepath.replace(carriageReturnRegEx, "%0D");
    }
    if (filepath.includes("\t")) {
        filepath = filepath.replace(tabRegEx, "%09");
    }
    return filepath;
}
function pathToFileURL(filepath) {
    const outURL = new URL("file://");
    if (isWindows && filepath.startsWith("\\\\")) {
        const paths = filepath.split("\\");
        if (paths.length <= 3) {
            throw new ERR_INVALID_ARG_VALUE("filepath", filepath, "Missing UNC resource path");
        }
        const hostname12 = paths[2];
        if (hostname12.length === 0) {
            throw new ERR_INVALID_ARG_VALUE("filepath", filepath, "Empty UNC servername");
        }
        outURL.hostname = hostname12;
        outURL.pathname = encodePathChars(paths.slice(3).join("/"));
    } else {
        let resolved = resolve5(filepath);
        const filePathLast = filepath.charCodeAt(filepath.length - 1);
        if ((filePathLast === 47 || isWindows && filePathLast === 92) && resolved[resolved.length - 1] !== sep5) {
            resolved += "/";
        }
        outURL.pathname = encodePathChars(resolved);
    }
    return outURL;
}
function urlToHttpOptions(url14) {
    const options = {
        protocol: url14.protocol,
        hostname: typeof url14.hostname === "string" && url14.hostname.startsWith("[") ? url14.hostname.slice(1, -1) : url14.hostname,
        hash: url14.hash,
        search: url14.search,
        pathname: url14.pathname,
        path: `${url14.pathname || ""}${url14.search || ""}`,
        href: url14.href
    };
    if (url14.port !== "") {
        options.port = Number(url14.port);
    }
    if (url14.username || url14.password) {
        options.auth = `${decodeURIComponent(url14.username)}:${decodeURIComponent(url14.password)}`;
    }
    return options;
}
const __default29 = {
    parse: parse8,
    format: format7,
    resolve: resolve6,
    resolveObject,
    fileURLToPath,
    pathToFileURL,
    urlToHttpOptions,
    Url,
    URL
};
Symbol("query");
function toPathIfFileURL(fileURLOrPath) {
    if (!(fileURLOrPath instanceof URL)) {
        return fileURLOrPath;
    }
    return fileURLToPath(fileURLOrPath);
}
function urlToHttpOptions1(url15) {
    const options = {
        protocol: url15.protocol,
        hostname: typeof url15.hostname === "string" && url15.hostname.startsWith("[") ? url15.hostname.slice(1, -1) : url15.hostname,
        hash: url15.hash,
        search: url15.search,
        pathname: url15.pathname,
        path: `${url15.pathname || ""}${url15.search || ""}`,
        href: url15.href
    };
    if (url15.port !== "") {
        options.port = Number(url15.port);
    }
    if (url15.username || url15.password) {
        options.auth = `${decodeURIComponent(url15.username)}:${decodeURIComponent(url15.password)}`;
    }
    return options;
}
function convertFileInfoToStats(origin) {
    return {
        dev: origin.dev,
        ino: origin.ino,
        mode: origin.mode,
        nlink: origin.nlink,
        uid: origin.uid,
        gid: origin.gid,
        rdev: origin.rdev,
        size: origin.size,
        blksize: origin.blksize,
        blocks: origin.blocks,
        mtime: origin.mtime,
        atime: origin.atime,
        birthtime: origin.birthtime,
        mtimeMs: origin.mtime?.getTime() || null,
        atimeMs: origin.atime?.getTime() || null,
        birthtimeMs: origin.birthtime?.getTime() || null,
        isFile: ()=>origin.isFile
        ,
        isDirectory: ()=>origin.isDirectory
        ,
        isSymbolicLink: ()=>origin.isSymlink
        ,
        isBlockDevice: ()=>false
        ,
        isFIFO: ()=>false
        ,
        isCharacterDevice: ()=>false
        ,
        isSocket: ()=>false
        ,
        ctime: origin.mtime,
        ctimeMs: origin.mtime?.getTime() || null
    };
}
function toBigInt(number) {
    if (number === null || number === undefined) return null;
    return BigInt(number);
}
function convertFileInfoToBigIntStats(origin) {
    return {
        dev: toBigInt(origin.dev),
        ino: toBigInt(origin.ino),
        mode: toBigInt(origin.mode),
        nlink: toBigInt(origin.nlink),
        uid: toBigInt(origin.uid),
        gid: toBigInt(origin.gid),
        rdev: toBigInt(origin.rdev),
        size: toBigInt(origin.size) || 0n,
        blksize: toBigInt(origin.blksize),
        blocks: toBigInt(origin.blocks),
        mtime: origin.mtime,
        atime: origin.atime,
        birthtime: origin.birthtime,
        mtimeMs: origin.mtime ? BigInt(origin.mtime.getTime()) : null,
        atimeMs: origin.atime ? BigInt(origin.atime.getTime()) : null,
        birthtimeMs: origin.birthtime ? BigInt(origin.birthtime.getTime()) : null,
        mtimeNs: origin.mtime ? BigInt(origin.mtime.getTime()) * 1000000n : null,
        atimeNs: origin.atime ? BigInt(origin.atime.getTime()) * 1000000n : null,
        birthtimeNs: origin.birthtime ? BigInt(origin.birthtime.getTime()) * 1000000n : null,
        isFile: ()=>origin.isFile
        ,
        isDirectory: ()=>origin.isDirectory
        ,
        isSymbolicLink: ()=>origin.isSymlink
        ,
        isBlockDevice: ()=>false
        ,
        isFIFO: ()=>false
        ,
        isCharacterDevice: ()=>false
        ,
        isSocket: ()=>false
        ,
        ctime: origin.mtime,
        ctimeMs: origin.mtime ? BigInt(origin.mtime.getTime()) : null,
        ctimeNs: origin.mtime ? BigInt(origin.mtime.getTime()) * 1000000n : null
    };
}
function CFISBIS(fileInfo, bigInt) {
    if (bigInt) return convertFileInfoToBigIntStats(fileInfo);
    return convertFileInfoToStats(fileInfo);
}
function stat(path56, optionsOrCallback, maybeCallback2) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback2;
    const options = typeof optionsOrCallback === "object" ? optionsOrCallback : {
        bigint: false
    };
    if (!callback) throw new Error("No callback function supplied");
    Deno.stat(path56).then((stat1)=>callback(null, CFISBIS(stat1, options.bigint))
    , (err122)=>callback(denoErrorToNodeError(err122, {
            syscall: "stat"
        }))
    );
}
function statSync(path57, options = {
    bigint: false,
    throwIfNoEntry: true
}) {
    try {
        const origin = Deno.statSync(path57);
        return CFISBIS(origin, options.bigint);
    } catch (err123) {
        if (options?.throwIfNoEntry === false && err123 instanceof Deno.errors.NotFound) {
            return;
        }
        if (err123 instanceof Error) {
            throw denoErrorToNodeError(err123, {
                syscall: "stat"
            });
        } else {
            throw err123;
        }
    }
}
function lstat(path58, optionsOrCallback, maybeCallback3) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback3;
    const options = typeof optionsOrCallback === "object" ? optionsOrCallback : {
        bigint: false
    };
    if (!callback) throw new Error("No callback function supplied");
    Deno.lstat(path58).then((stat2)=>callback(null, CFISBIS(stat2, options.bigint))
    , (err124)=>callback(err124)
    );
}
function lstatSync(path59, options) {
    const origin = Deno.lstatSync(path59);
    return CFISBIS(origin, options?.bigint || false);
}
"use strict";
const kType = Symbol("type");
const kStats = Symbol("stats");
const { F_OK =0 , W_OK =0 , R_OK =0 , X_OK =0 , COPYFILE_EXCL , COPYFILE_FICLONE , COPYFILE_FICLONE_FORCE , O_APPEND , O_CREAT , O_EXCL , O_RDONLY , O_RDWR , O_SYNC , O_TRUNC , O_WRONLY , S_IFBLK , S_IFCHR , S_IFDIR , S_IFIFO , S_IFLNK , S_IFMT , S_IFREG , S_IFSOCK , UV_FS_SYMLINK_DIR , UV_FS_SYMLINK_JUNCTION , UV_DIRENT_UNKNOWN , UV_DIRENT_FILE , UV_DIRENT_DIR , UV_DIRENT_LINK , UV_DIRENT_FIFO , UV_DIRENT_SOCKET , UV_DIRENT_CHAR , UV_DIRENT_BLOCK ,  } = fs;
const { errno: { EISDIR ,  } ,  } = os;
const kMinimumAccessMode = Math.min(F_OK, W_OK, R_OK, X_OK);
const kMaximumAccessMode = F_OK | W_OK | R_OK | X_OK;
const kDefaultCopyMode = 0;
const kMinimumCopyMode = Math.min(0, COPYFILE_EXCL, COPYFILE_FICLONE, COPYFILE_FICLONE_FORCE);
const kMaximumCopyMode = COPYFILE_EXCL | COPYFILE_FICLONE | COPYFILE_FICLONE_FORCE;
const kIoMaxLength = 2 ** 31 - 1;
const kReadFileUnknownBufferLength = 64 * 1024;
const kReadFileBufferLength = 512 * 1024;
const kWriteFileMaxChunkSize = 512 * 1024;
const kMaxUserId = 2 ** 32 - 1;
function assertEncoding(encoding) {
    if (encoding && !Buffer1.isEncoding(encoding)) {
        const reason = "is invalid encoding";
        throw new ERR_INVALID_ARG_VALUE(encoding, "encoding", reason);
    }
}
class Dirent {
    constructor(name1, type43){
        this.name = name1;
        this[kType] = type43;
    }
    isDirectory() {
        return this[kType] === UV_DIRENT_DIR;
    }
    isFile() {
        return this[kType] === UV_DIRENT_FILE;
    }
    isBlockDevice() {
        return this[kType] === UV_DIRENT_BLOCK;
    }
    isCharacterDevice() {
        return this[kType] === UV_DIRENT_CHAR;
    }
    isSymbolicLink() {
        return this[kType] === UV_DIRENT_LINK;
    }
    isFIFO() {
        return this[kType] === UV_DIRENT_FIFO;
    }
    isSocket() {
        return this[kType] === UV_DIRENT_SOCKET;
    }
}
class DirentFromStats extends Dirent {
    constructor(name2, stats){
        super(name2, null);
        this[kStats] = stats;
    }
}
for (const name of Reflect.ownKeys(Dirent.prototype)){
    if (name === "constructor") {
        continue;
    }
    DirentFromStats.prototype[name] = function() {
        return this[kStats][name]();
    };
}
function copyObject(source) {
    const target = {};
    for(const key in source){
        target[key] = source[key];
    }
    return target;
}
const bufferSep = Buffer1.from(__default27.sep);
function join9(path60, name3) {
    if ((typeof path60 === "string" || isUint8Array(path60)) && name3 === undefined) {
        return path60;
    }
    if (typeof path60 === "string" && isUint8Array(name3)) {
        const pathBuffer = Buffer1.from(__default27.join(path60, __default27.sep));
        return Buffer1.concat([
            pathBuffer,
            name3
        ]);
    }
    if (typeof path60 === "string" && typeof name3 === "string") {
        return __default27.join(path60, name3);
    }
    if (isUint8Array(path60) && isUint8Array(name3)) {
        return Buffer1.concat([
            path60,
            bufferSep,
            name3
        ]);
    }
    throw new ERR_INVALID_ARG_TYPE("path", [
        "string",
        "Buffer"
    ], path60);
}
function getDirents(path61, { 0: names , 1: types  }, callback) {
    let i144;
    if (typeof callback === "function") {
        const len = names.length;
        let toFinish = 0;
        callback = once(callback);
        for(i144 = 0; i144 < len; i144++){
            const type44 = types[i144];
            if (type44 === UV_DIRENT_UNKNOWN) {
                const name4 = names[i144];
                const idx = i144;
                toFinish++;
                let filepath;
                try {
                    filepath = join9(path61, name4);
                } catch (err1) {
                    callback(err1);
                    return;
                }
                lstat(filepath, (err125, stats)=>{
                    if (err125) {
                        callback(err125);
                        return;
                    }
                    names[idx] = new DirentFromStats(name4, stats);
                    if (--toFinish === 0) {
                        callback(null, names);
                    }
                });
            } else {
                names[i144] = new Dirent(names[i144], types[i144]);
            }
        }
        if (toFinish === 0) {
            callback(null, names);
        }
    } else {
        const len = names.length;
        for(i144 = 0; i144 < len; i144++){
            names[i144] = getDirent(path61, names[i144], types[i144]);
        }
        return names;
    }
}
function getDirent(path62, name5, type45, callback) {
    if (typeof callback === "function") {
        if (type45 === UV_DIRENT_UNKNOWN) {
            let filepath;
            try {
                filepath = join9(path62, name5);
            } catch (err5) {
                callback(err5);
                return;
            }
            lstat(filepath, (err126, stats)=>{
                if (err126) {
                    callback(err126);
                    return;
                }
                callback(null, new DirentFromStats(name5, stats));
            });
        } else {
            callback(null, new Dirent(name5, type45));
        }
    } else if (type45 === UV_DIRENT_UNKNOWN) {
        const stats = lstatSync(join9(path62, name5));
        return new DirentFromStats(name5, stats);
    } else {
        return new Dirent(name5, type45);
    }
}
function getOptions1(options, defaultOptions) {
    if (options === null || options === undefined || typeof options === "function") {
        return defaultOptions;
    }
    if (typeof options === "string") {
        defaultOptions = {
            ...defaultOptions
        };
        defaultOptions.encoding = options;
        options = defaultOptions;
    } else if (typeof options !== "object") {
        throw new ERR_INVALID_ARG_TYPE("options", [
            "string",
            "Object"
        ], options);
    }
    if (options.encoding !== "buffer") {
        assertEncoding(options.encoding);
    }
    if (options.signal !== undefined) {
        validateAbortSignal(options.signal, "options.signal");
    }
    return options;
}
function handleErrorFromBinding(ctx) {
    if (ctx.errno !== undefined) {
        const err127 = uvException(ctx);
        Error.captureStackTrace(err127, handleErrorFromBinding);
        throw err127;
    }
    if (ctx.error !== undefined) {
        Error.captureStackTrace(ctx.error, handleErrorFromBinding);
        throw ctx.error;
    }
}
const nullCheck = hideStackFrames((path63, propName, throwError = true)=>{
    const pathIsString = typeof path63 === "string";
    const pathIsUint8Array = isUint8Array(path63);
    if (!pathIsString && !pathIsUint8Array || pathIsString && !path63.includes("\u0000") || pathIsUint8Array && !path63.includes(0)) {
        return;
    }
    const err128 = new ERR_INVALID_ARG_VALUE(propName, path63, "must be a string or Uint8Array without null bytes");
    if (throwError) {
        throw err128;
    }
    return err128;
});
function preprocessSymlinkDestination(path64, type46, linkPath) {
    if (!isWindows) {
        return path64;
    }
    path64 = "" + path64;
    if (type46 === "junction") {
        path64 = __default27.resolve(linkPath, "..", path64);
        return __default27.toNamespacedPath(path64);
    }
    if (__default27.isAbsolute(path64)) {
        return __default27.toNamespacedPath(path64);
    }
    return path64.replace(/\//g, "\\");
}
function StatsBase(dev, mode2, nlink, uid, gid, rdev, blksize, ino, size, blocks) {
    this.dev = dev;
    this.mode = mode2;
    this.nlink = nlink;
    this.uid = uid;
    this.gid = gid;
    this.rdev = rdev;
    this.blksize = blksize;
    this.ino = ino;
    this.size = size;
    this.blocks = blocks;
}
StatsBase.prototype.isDirectory = function() {
    return this._checkModeProperty(S_IFDIR);
};
StatsBase.prototype.isFile = function() {
    return this._checkModeProperty(S_IFREG);
};
StatsBase.prototype.isBlockDevice = function() {
    return this._checkModeProperty(S_IFBLK);
};
StatsBase.prototype.isCharacterDevice = function() {
    return this._checkModeProperty(S_IFCHR);
};
StatsBase.prototype.isSymbolicLink = function() {
    return this._checkModeProperty(S_IFLNK);
};
StatsBase.prototype.isFIFO = function() {
    return this._checkModeProperty(S_IFIFO);
};
StatsBase.prototype.isSocket = function() {
    return this._checkModeProperty(S_IFSOCK);
};
const kNsPerMsBigInt = 10n ** 6n;
const kNsPerSecBigInt = 10n ** 9n;
const kMsPerSec = 10 ** 3;
const kNsPerMs = 10 ** 6;
function msFromTimeSpec(sec, nsec) {
    return sec * kMsPerSec + nsec / kNsPerMs;
}
function nsFromTimeSpecBigInt(sec, nsec) {
    return sec * kNsPerSecBigInt + nsec;
}
function dateFromMs(ms) {
    return new Date(Number(ms) + 0.5);
}
function BigIntStats(dev, mode3, nlink, uid, gid, rdev, blksize, ino, size, blocks, atimeNs, mtimeNs, ctimeNs, birthtimeNs) {
    Reflect.apply(StatsBase, this, [
        dev,
        mode3,
        nlink,
        uid,
        gid,
        rdev,
        blksize,
        ino,
        size,
        blocks, 
    ]);
    this.atimeMs = atimeNs / kNsPerMsBigInt;
    this.mtimeMs = mtimeNs / kNsPerMsBigInt;
    this.ctimeMs = ctimeNs / kNsPerMsBigInt;
    this.birthtimeMs = birthtimeNs / kNsPerMsBigInt;
    this.atimeNs = atimeNs;
    this.mtimeNs = mtimeNs;
    this.ctimeNs = ctimeNs;
    this.birthtimeNs = birthtimeNs;
    this.atime = dateFromMs(this.atimeMs);
    this.mtime = dateFromMs(this.mtimeMs);
    this.ctime = dateFromMs(this.ctimeMs);
    this.birthtime = dateFromMs(this.birthtimeMs);
}
Object.setPrototypeOf(BigIntStats.prototype, StatsBase.prototype);
Object.setPrototypeOf(BigIntStats, StatsBase);
BigIntStats.prototype._checkModeProperty = function(property) {
    if (isWindows && (property === S_IFIFO || property === S_IFBLK || property === S_IFSOCK)) {
        return false;
    }
    return (this.mode & BigInt(S_IFMT)) === BigInt(property);
};
function Stats(dev, mode4, nlink, uid, gid, rdev, blksize, ino, size, blocks, atimeMs, mtimeMs, ctimeMs, birthtimeMs) {
    StatsBase.call(this, dev, mode4, nlink, uid, gid, rdev, blksize, ino, size, blocks);
    this.atimeMs = atimeMs;
    this.mtimeMs = mtimeMs;
    this.ctimeMs = ctimeMs;
    this.birthtimeMs = birthtimeMs;
    this.atime = dateFromMs(atimeMs);
    this.mtime = dateFromMs(mtimeMs);
    this.ctime = dateFromMs(ctimeMs);
    this.birthtime = dateFromMs(birthtimeMs);
}
Object.setPrototypeOf(Stats.prototype, StatsBase.prototype);
Object.setPrototypeOf(Stats, StatsBase);
Stats.prototype.isFile = StatsBase.prototype.isFile;
Stats.prototype._checkModeProperty = function(property) {
    if (isWindows && (property === S_IFIFO || property === S_IFBLK || property === S_IFSOCK)) {
        return false;
    }
    return (this.mode & S_IFMT) === property;
};
function getStatsFromBinding(stats, offset = 0) {
    if (isBigUint64Array(stats)) {
        return new BigIntStats(stats[0 + offset], stats[1 + offset], stats[2 + offset], stats[3 + offset], stats[4 + offset], stats[5 + offset], stats[6 + offset], stats[7 + offset], stats[8 + offset], stats[9 + offset], nsFromTimeSpecBigInt(stats[10 + offset], stats[11 + offset]), nsFromTimeSpecBigInt(stats[12 + offset], stats[13 + offset]), nsFromTimeSpecBigInt(stats[14 + offset], stats[15 + offset]), nsFromTimeSpecBigInt(stats[16 + offset], stats[17 + offset]));
    }
    return new Stats(stats[0 + offset], stats[1 + offset], stats[2 + offset], stats[3 + offset], stats[4 + offset], stats[5 + offset], stats[6 + offset], stats[7 + offset], stats[8 + offset], stats[9 + offset], msFromTimeSpec(stats[10 + offset], stats[11 + offset]), msFromTimeSpec(stats[12 + offset], stats[13 + offset]), msFromTimeSpec(stats[14 + offset], stats[15 + offset]), msFromTimeSpec(stats[16 + offset], stats[17 + offset]));
}
function stringToFlags(flags, name6 = "flags") {
    if (typeof flags === "number") {
        validateInt32(flags, name6);
        return flags;
    }
    if (flags == null) {
        return O_RDONLY;
    }
    switch(flags){
        case "r":
            return O_RDONLY;
        case "rs":
        case "sr":
            return O_RDONLY | O_SYNC;
        case "r+":
            return O_RDWR;
        case "rs+":
        case "sr+":
            return O_RDWR | O_SYNC;
        case "w":
            return O_TRUNC | O_CREAT | O_WRONLY;
        case "wx":
        case "xw":
            return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;
        case "w+":
            return O_TRUNC | O_CREAT | O_RDWR;
        case "wx+":
        case "xw+":
            return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;
        case "a":
            return O_APPEND | O_CREAT | O_WRONLY;
        case "ax":
        case "xa":
            return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;
        case "as":
        case "sa":
            return O_APPEND | O_CREAT | O_WRONLY | O_SYNC;
        case "a+":
            return O_APPEND | O_CREAT | O_RDWR;
        case "ax+":
        case "xa+":
            return O_APPEND | O_CREAT | O_RDWR | O_EXCL;
        case "as+":
        case "sa+":
            return O_APPEND | O_CREAT | O_RDWR | O_SYNC;
    }
    throw new ERR_INVALID_ARG_VALUE("flags", flags);
}
const stringToSymlinkType = hideStackFrames((type47)=>{
    let flags = 0;
    if (typeof type47 === "string") {
        switch(type47){
            case "dir":
                flags |= UV_FS_SYMLINK_DIR;
                break;
            case "junction":
                flags |= UV_FS_SYMLINK_JUNCTION;
                break;
            case "file":
                break;
            default:
                throw new ERR_FS_INVALID_SYMLINK_TYPE(type47);
        }
    }
    return flags;
});
function toUnixTimestamp(time3, name7 = "time") {
    if (typeof time3 === "string" && +time3 == time3) {
        return +time3;
    }
    if (Number.isFinite(time3)) {
        if (time3 < 0) {
            return Date.now() / 1000;
        }
        return time3;
    }
    if (isDate1(time3)) {
        return Date.getTime(time3) / 1000;
    }
    throw new ERR_INVALID_ARG_TYPE(name7, [
        "Date",
        "Time in seconds"
    ], time3);
}
const validateOffsetLengthRead = hideStackFrames((offset, length, bufferLength)=>{
    if (offset < 0) {
        throw new ERR_OUT_OF_RANGE("offset", ">= 0", offset);
    }
    if (length < 0) {
        throw new ERR_OUT_OF_RANGE("length", ">= 0", length);
    }
    if (offset + length > bufferLength) {
        throw new ERR_OUT_OF_RANGE("length", `<= ${bufferLength - offset}`, length);
    }
});
const validateOffsetLengthWrite = hideStackFrames((offset, length, byteLength3)=>{
    if (offset > byteLength3) {
        throw new ERR_OUT_OF_RANGE("offset", `<= ${byteLength3}`, offset);
    }
    if (length > byteLength3 - offset) {
        throw new ERR_OUT_OF_RANGE("length", `<= ${byteLength3 - offset}`, length);
    }
    if (length < 0) {
        throw new ERR_OUT_OF_RANGE("length", ">= 0", length);
    }
    validateInt32(length, "length", 0);
});
const validatePath = hideStackFrames((path65, propName = "path")=>{
    if (typeof path65 !== "string" && !isUint8Array(path65)) {
        throw new ERR_INVALID_ARG_TYPE(propName, [
            "string",
            "Buffer",
            "URL"
        ], path65);
    }
    const err129 = nullCheck(path65, propName, false);
    if (err129 !== undefined) {
        throw err129;
    }
});
const getValidatedPath = hideStackFrames((fileURLOrPath, propName = "path")=>{
    const path66 = toPathIfFileURL(fileURLOrPath);
    validatePath(path66, propName);
    return path66;
});
const getValidatedFd = hideStackFrames((fd, propName = "fd")=>{
    if (Object.is(fd, -0)) {
        return 0;
    }
    validateInt32(fd, propName, 0);
    return fd;
});
const validateBufferArray = hideStackFrames((buffers, propName = "buffers")=>{
    if (!Array.isArray(buffers)) {
        throw new ERR_INVALID_ARG_TYPE(propName, "ArrayBufferView[]", buffers);
    }
    for(let i145 = 0; i145 < buffers.length; i145++){
        if (!isArrayBufferView(buffers[i145])) {
            throw new ERR_INVALID_ARG_TYPE(propName, "ArrayBufferView[]", buffers);
        }
    }
    return buffers;
});
let nonPortableTemplateWarn = true;
function warnOnNonPortableTemplate(template) {
    if (nonPortableTemplateWarn && template.endsWith("X")) {
        process1.emitWarning("mkdtemp() templates ending with X are not portable. " + "For details see: https://nodejs.org/api/fs.html");
        nonPortableTemplateWarn = false;
    }
}
const defaultCpOptions = {
    dereference: false,
    errorOnExist: false,
    filter: undefined,
    force: true,
    preserveTimestamps: false,
    recursive: false
};
const defaultRmOptions = {
    recursive: false,
    force: false,
    retryDelay: 100,
    maxRetries: 0
};
const defaultRmdirOptions = {
    retryDelay: 100,
    maxRetries: 0,
    recursive: false
};
const validateCpOptions = hideStackFrames((options)=>{
    if (options === undefined) {
        return {
            ...defaultCpOptions
        };
    }
    validateObject(options, "options");
    options = {
        ...defaultCpOptions,
        ...options
    };
    validateBoolean(options.dereference, "options.dereference");
    validateBoolean(options.errorOnExist, "options.errorOnExist");
    validateBoolean(options.force, "options.force");
    validateBoolean(options.preserveTimestamps, "options.preserveTimestamps");
    validateBoolean(options.recursive, "options.recursive");
    if (options.filter !== undefined) {
        validateFunction(options.filter, "options.filter");
    }
    return options;
});
const validateRmOptions = hideStackFrames((path67, options, expectDir, cb)=>{
    options = validateRmdirOptions(options, defaultRmOptions);
    validateBoolean(options.force, "options.force");
    stat(path67, (err130, stats)=>{
        if (err130) {
            if (options.force && err130.code === "ENOENT") {
                return cb(null, options);
            }
            return cb(err130, options);
        }
        if (expectDir && !stats.isDirectory()) {
            return cb(false);
        }
        if (stats.isDirectory() && !options.recursive) {
            return cb(new ERR_FS_EISDIR({
                code: "EISDIR",
                message: "is a directory",
                path: path67,
                syscall: "rm",
                errno: EISDIR
            }));
        }
        return cb(null, options);
    });
});
const validateRmOptionsSync = hideStackFrames((path68, options, expectDir)=>{
    options = validateRmdirOptions(options, defaultRmOptions);
    validateBoolean(options.force, "options.force");
    if (!options.force || expectDir || !options.recursive) {
        const isDirectory = statSync(path68, {
            throwIfNoEntry: !options.force
        })?.isDirectory();
        if (expectDir && !isDirectory) {
            return false;
        }
        if (isDirectory && !options.recursive) {
            throw new ERR_FS_EISDIR({
                code: "EISDIR",
                message: "is a directory",
                path: path68,
                syscall: "rm",
                errno: EISDIR
            });
        }
    }
    return options;
});
let recursiveRmdirWarned = process1.noDeprecation;
function emitRecursiveRmdirWarning() {
    if (!recursiveRmdirWarned) {
        process1.emitWarning("In future versions of Node.js, fs.rmdir(path, { recursive: true }) " + "will be removed. Use fs.rm(path, { recursive: true }) instead", "DeprecationWarning", "DEP0147");
        recursiveRmdirWarned = true;
    }
}
const validateRmdirOptions = hideStackFrames((options, defaults = defaultRmdirOptions)=>{
    if (options === undefined) {
        return defaults;
    }
    validateObject(options, "options");
    options = {
        ...defaults,
        ...options
    };
    validateBoolean(options.recursive, "options.recursive");
    validateInt32(options.retryDelay, "options.retryDelay", 0);
    validateUint32(options.maxRetries, "options.maxRetries");
    return options;
});
const getValidMode = hideStackFrames((mode5, type48)=>{
    let min23 = kMinimumAccessMode;
    let max = kMaximumAccessMode;
    let def = F_OK;
    if (type48 === "copyFile") {
        min23 = kMinimumCopyMode;
        max = kMaximumCopyMode;
        def = mode5 || kDefaultCopyMode;
    } else {
        assert2(type48 === "access");
    }
    if (mode5 == null) {
        return def;
    }
    if (Number.isInteger(mode5) && mode5 >= min23 && mode5 <= max) {
        return mode5;
    }
    if (typeof mode5 !== "number") {
        throw new ERR_INVALID_ARG_TYPE("mode", "integer", mode5);
    }
    throw new ERR_OUT_OF_RANGE("mode", `an integer >= ${min23} && <= ${max}`, mode5);
});
const validateStringAfterArrayBufferView = hideStackFrames((buffer23, name8)=>{
    if (typeof buffer23 === "string") {
        return;
    }
    if (typeof buffer23 === "object" && buffer23 !== null && typeof buffer23.toString === "function" && Object.prototype.hasOwnProperty.call(buffer23, "toString")) {
        return;
    }
    throw new ERR_INVALID_ARG_TYPE(name8, [
        "string",
        "Buffer",
        "TypedArray",
        "DataView"
    ], buffer23);
});
const validatePosition = hideStackFrames((position)=>{
    if (typeof position === "number") {
        validateInteger(position, "position");
    } else if (typeof position === "bigint") {
        if (!(position >= -(2n ** 63n) && position <= 2n ** 63n - 1n)) {
            throw new ERR_OUT_OF_RANGE("position", `>= ${-(2n ** 63n)} && <= ${2n ** 63n - 1n}`, position);
        }
    } else {
        throw new ERR_INVALID_ARG_TYPE("position", [
            "integer",
            "bigint"
        ], position);
    }
});
const __default30 = {
    constants: {
        kIoMaxLength,
        kMaxUserId,
        kReadFileBufferLength,
        kReadFileUnknownBufferLength,
        kWriteFileMaxChunkSize
    },
    assertEncoding,
    BigIntStats,
    copyObject,
    Dirent,
    emitRecursiveRmdirWarning,
    getDirent,
    getDirents,
    getOptions: getOptions1,
    getValidatedFd,
    getValidatedPath,
    getValidMode,
    handleErrorFromBinding,
    nullCheck,
    preprocessSymlinkDestination,
    realpathCacheKey: Symbol("realpathCacheKey"),
    getStatsFromBinding,
    stringToFlags,
    stringToSymlinkType,
    Stats,
    toUnixTimestamp,
    validateBufferArray,
    validateCpOptions,
    validateOffsetLengthRead,
    validateOffsetLengthWrite,
    validatePath,
    validatePosition,
    validateRmOptions,
    validateRmOptionsSync,
    validateRmdirOptions,
    validateStringAfterArrayBufferView,
    warnOnNonPortableTemplate
};
function access(path69, mode6, callback) {
    if (typeof mode6 === "function") {
        callback = mode6;
        mode6 = fs.F_OK;
    }
    path69 = getValidatedPath(path69).toString();
    mode6 = getValidMode(mode6, "access");
    const cb = makeCallback(callback);
    Deno.lstat(path69).then((info1)=>{
        const m11 = +mode6 || 0;
        let fileMode = +info1.mode || 0;
        if (Deno.build.os !== "windows" && info1.uid === getUid()) {
            fileMode >>= 6;
        }
        if ((m11 & fileMode) === m11) {
            cb(null);
        } else {
            const e30 = new Error(`EACCES: permission denied, access '${path69}'`);
            e30.path = path69;
            e30.syscall = "access";
            e30.errno = os.errno.EACCES;
            e30.code = "EACCES";
            cb(e30);
        }
    }, (err131)=>{
        if (err131 instanceof Deno.errors.NotFound) {
            const e31 = new Error(`ENOENT: no such file or directory, access '${path69}'`);
            e31.path = path69;
            e31.syscall = "access";
            e31.errno = os.errno.ENOENT;
            e31.code = "ENOENT";
            cb(e31);
        } else {
            cb(err131);
        }
    });
}
function accessSync(path70, mode7) {
    path70 = getValidatedPath(path70).toString();
    mode7 = getValidMode(mode7, "access");
    try {
        const info2 = Deno.lstatSync(path70.toString());
        const m12 = +mode7 || 0;
        const fileMode = +info2.mode || 0;
        if ((m12 & fileMode) === m12) {} else {
            const e32 = new Error(`EACCES: permission denied, access '${path70}'`);
            e32.path = path70;
            e32.syscall = "access";
            e32.errno = os.errno.EACCES;
            e32.code = "EACCES";
            throw e32;
        }
    } catch (err132) {
        if (err132 instanceof Deno.errors.NotFound) {
            const e33 = new Error(`ENOENT: no such file or directory, access '${path70}'`);
            e33.path = path70;
            e33.syscall = "access";
            e33.errno = os.errno.ENOENT;
            e33.code = "ENOENT";
            throw e33;
        } else {
            throw err132;
        }
    }
}
function writeFile(pathOrRid, data27, optOrCallback, callback) {
    const callbackFn = optOrCallback instanceof Function ? optOrCallback : callback;
    const options = optOrCallback instanceof Function ? undefined : optOrCallback;
    if (!callbackFn) {
        throw new TypeError("Callback must be a function.");
    }
    pathOrRid = pathOrRid instanceof URL ? fromFileUrl5(pathOrRid) : pathOrRid;
    const flag = isFileOptions(options) ? options.flag : undefined;
    const mode8 = isFileOptions(options) ? options.mode : undefined;
    const encoding = checkEncoding(getEncoding(options)) || "utf8";
    const openOptions = getOpenOptions(flag || "w");
    if (!ArrayBuffer.isView(data27)) {
        validateStringAfterArrayBufferView(data27, "data");
        data27 = Buffer1.from(String(data27), encoding);
    }
    const isRid = typeof pathOrRid === "number";
    let file;
    let error19 = null;
    (async ()=>{
        try {
            file = isRid ? new Deno.FsFile(pathOrRid) : await Deno.open(pathOrRid, openOptions);
            if (!isRid && mode8 && !isWindows) {
                await Deno.chmod(pathOrRid, mode8);
            }
            const signal = isFileOptions(options) ? options.signal : undefined;
            await writeAll1(file, data27, {
                signal
            });
        } catch (e34) {
            error19 = e34 instanceof Error ? denoErrorToNodeError(e34, {
                syscall: "write"
            }) : new Error("[non-error thrown]");
        } finally{
            if (!isRid && file) file.close();
            callbackFn(error19);
        }
    })();
}
function writeFileSync(pathOrRid, data28, options) {
    pathOrRid = pathOrRid instanceof URL ? fromFileUrl5(pathOrRid) : pathOrRid;
    const flag = isFileOptions(options) ? options.flag : undefined;
    const mode9 = isFileOptions(options) ? options.mode : undefined;
    const encoding = checkEncoding(getEncoding(options)) || "utf8";
    const openOptions = getOpenOptions(flag || "w");
    if (!ArrayBuffer.isView(data28)) {
        validateStringAfterArrayBufferView(data28, "data");
        data28 = Buffer1.from(String(data28), encoding);
    }
    const isRid = typeof pathOrRid === "number";
    let file;
    let error20 = null;
    try {
        file = isRid ? new Deno.FsFile(pathOrRid) : Deno.openSync(pathOrRid, openOptions);
        if (!isRid && mode9 && !isWindows) {
            Deno.chmodSync(pathOrRid, mode9);
        }
        writeAllSync(file, data28);
    } catch (e35) {
        error20 = e35 instanceof Error ? denoErrorToNodeError(e35, {
            syscall: "write"
        }) : new Error("[non-error thrown]");
    } finally{
        if (!isRid && file) file.close();
    }
    if (error20) throw error20;
}
async function writeAll1(w18, arr, options = {}) {
    const { offset =0 , length =arr.byteLength , signal  } = options;
    checkAborted(signal);
    const written = await w18.write(arr.subarray(offset, offset + length));
    if (written === length) {
        return;
    }
    await writeAll1(w18, arr, {
        offset: offset + written,
        length: length - written,
        signal
    });
}
function checkAborted(signal) {
    if (signal?.aborted) {
        throw new AbortError();
    }
}
function appendFile(path71, data29, options, callback) {
    callback = maybeCallback(callback || options);
    options = getOptions1(options, {
        encoding: "utf8",
        mode: 438,
        flag: "a"
    });
    options = copyObject(options);
    if (!options.flag || isUint32(path71)) {
        options.flag = "a";
    }
    writeFile(path71, data29, options, callback);
}
function appendFileSync(path72, data30, options) {
    options = getOptions1(options, {
        encoding: "utf8",
        mode: 438,
        flag: "a"
    });
    options = copyObject(options);
    if (!options.flag || isUint32(path72)) {
        options.flag = "a";
    }
    writeFileSync(path72, data30, options);
}
function chmod(path73, mode10, callback) {
    path73 = getValidatedPath(path73).toString();
    mode10 = parseFileMode(mode10, "mode");
    Deno.chmod(toNamespacedPath2(path73), mode10).then(()=>callback(null)
    , callback);
}
function chmodSync(path74, mode11) {
    path74 = getValidatedPath(path74).toString();
    mode11 = parseFileMode(mode11, "mode");
    Deno.chmodSync(toNamespacedPath2(path74), mode11);
}
function chown(path75, uid, gid, callback) {
    callback = makeCallback(callback);
    path75 = getValidatedPath(path75).toString();
    validateInteger(uid, "uid", -1, kMaxUserId);
    validateInteger(gid, "gid", -1, kMaxUserId);
    Deno.chown(toNamespacedPath2(path75), uid, gid).then(()=>callback(null)
    , callback);
}
function chownSync(path76, uid, gid) {
    path76 = getValidatedPath(path76).toString();
    validateInteger(uid, "uid", -1, kMaxUserId);
    validateInteger(gid, "gid", -1, kMaxUserId);
    Deno.chownSync(toNamespacedPath2(path76), uid, gid);
}
function close(fd, callback) {
    setTimeout(()=>{
        let error21 = null;
        try {
            Deno.close(fd);
        } catch (err133) {
            error21 = err133 instanceof Error ? err133 : new Error("[non-error thrown]");
        }
        callback(error21);
    }, 0);
}
function closeSync(fd) {
    Deno.close(fd);
}
const { F_OK: F_OK1 , R_OK: R_OK1 , W_OK: W_OK1 , X_OK: X_OK1 , S_IRUSR , S_IWUSR , S_IXUSR , S_IRGRP , S_IWGRP , S_IXGRP , S_IROTH , S_IWOTH , S_IXOTH , COPYFILE_EXCL: COPYFILE_EXCL1 , COPYFILE_FICLONE: COPYFILE_FICLONE1 , COPYFILE_FICLONE_FORCE: COPYFILE_FICLONE_FORCE1 , UV_FS_COPYFILE_EXCL , UV_FS_COPYFILE_FICLONE , UV_FS_COPYFILE_FICLONE_FORCE ,  } = fs;
const mod53 = {
    F_OK: F_OK1,
    R_OK: R_OK1,
    W_OK: W_OK1,
    X_OK: X_OK1,
    S_IRUSR: S_IRUSR,
    S_IWUSR: S_IWUSR,
    S_IXUSR: S_IXUSR,
    S_IRGRP: S_IRGRP,
    S_IWGRP: S_IWGRP,
    S_IXGRP: S_IXGRP,
    S_IROTH: S_IROTH,
    S_IWOTH: S_IWOTH,
    S_IXOTH: S_IXOTH,
    COPYFILE_EXCL: COPYFILE_EXCL1,
    COPYFILE_FICLONE: COPYFILE_FICLONE1,
    COPYFILE_FICLONE_FORCE: COPYFILE_FICLONE_FORCE1,
    UV_FS_COPYFILE_EXCL: UV_FS_COPYFILE_EXCL,
    UV_FS_COPYFILE_FICLONE: UV_FS_COPYFILE_FICLONE,
    UV_FS_COPYFILE_FICLONE_FORCE: UV_FS_COPYFILE_FICLONE_FORCE
};
function copyFile(src, dest, mode12, callback) {
    if (typeof mode12 === "function") {
        callback = mode12;
        mode12 = 0;
    }
    const srcStr = getValidatedPath(src, "src").toString();
    const destStr = getValidatedPath(dest, "dest").toString();
    const modeNum = getValidMode(mode12, "copyFile");
    const cb = makeCallback(callback);
    if ((modeNum & fs.COPYFILE_EXCL) === fs.COPYFILE_EXCL) {
        Deno.lstat(destStr).then(()=>{
            const e36 = new Error(`EEXIST: file already exists, copyfile '${srcStr}' -> '${destStr}'`);
            e36.syscall = "copyfile";
            e36.errno = os.errno.EEXIST;
            e36.code = "EEXIST";
            cb(e36);
        }, (e37)=>{
            if (e37 instanceof Deno.errors.NotFound) {
                Deno.copyFile(srcStr, destStr).then(()=>cb(null)
                , cb);
            }
            cb(e37);
        });
    } else {
        Deno.copyFile(srcStr, destStr).then(()=>cb(null)
        , cb);
    }
}
function copyFileSync(src, dest, mode13) {
    const srcStr = getValidatedPath(src, "src").toString();
    const destStr = getValidatedPath(dest, "dest").toString();
    const modeNum = getValidMode(mode13, "copyFile");
    if ((modeNum & fs.COPYFILE_EXCL) === fs.COPYFILE_EXCL) {
        try {
            Deno.lstatSync(destStr);
            throw new Error(`A file exists at the destination: ${destStr}`);
        } catch (e38) {
            if (e38 instanceof Deno.errors.NotFound) {
                Deno.copyFileSync(srcStr, destStr);
            }
            throw e38;
        }
    } else {
        Deno.copyFileSync(srcStr, destStr);
    }
}
class Dirent1 {
    entry;
    constructor(entry){
        this.entry = entry;
    }
    isBlockDevice() {
        notImplemented("Deno does not yet support identification of block devices");
        return false;
    }
    isCharacterDevice() {
        notImplemented("Deno does not yet support identification of character devices");
        return false;
    }
    isDirectory() {
        return this.entry.isDirectory;
    }
    isFIFO() {
        notImplemented("Deno does not yet support identification of FIFO named pipes");
        return false;
    }
    isFile() {
        return this.entry.isFile;
    }
    isSocket() {
        notImplemented("Deno does not yet support identification of sockets");
        return false;
    }
    isSymbolicLink() {
        return this.entry.isSymlink;
    }
    get name() {
        return this.entry.name;
    }
}
class Dir {
    dirPath;
    syncIterator;
    asyncIterator;
    constructor(path77){
        this.dirPath = path77;
    }
    get path() {
        if (this.dirPath instanceof Uint8Array) {
            return new TextDecoder().decode(this.dirPath);
        }
        return this.dirPath;
    }
    read(callback) {
        return new Promise((resolve18, reject)=>{
            if (!this.asyncIterator) {
                this.asyncIterator = Deno.readDir(this.path)[Symbol.asyncIterator]();
            }
            assert1(this.asyncIterator);
            this.asyncIterator.next().then(({ value  })=>{
                resolve18(value ? value : null);
                if (callback) {
                    callback(null, value ? value : null);
                }
            }, (err134)=>{
                if (callback) {
                    callback(err134);
                }
                reject(err134);
            });
        });
    }
    readSync() {
        if (!this.syncIterator) {
            this.syncIterator = Deno.readDirSync(this.path)[Symbol.iterator]();
        }
        const file = this.syncIterator.next().value;
        return file ? new Dirent1(file) : null;
    }
    close(callback) {
        return new Promise((resolve19)=>{
            if (callback) {
                callback(null);
            }
            resolve19();
        });
    }
    closeSync() {}
    async *[Symbol.asyncIterator]() {
        try {
            while(true){
                const dirent = await this.read();
                if (dirent === null) {
                    break;
                }
                yield dirent;
            }
        } finally{
            await this.close();
        }
    }
}
function exists(path78, callback) {
    path78 = path78 instanceof URL ? fromFileUrl5(path78) : path78;
    Deno.lstat(path78).then(()=>callback(true)
    , ()=>callback(false)
    );
}
function existsSync(path79) {
    path79 = path79 instanceof URL ? fromFileUrl5(path79) : path79;
    try {
        Deno.lstatSync(path79);
        return true;
    } catch (err135) {
        if (err135 instanceof Deno.errors.NotFound) {
            return false;
        }
        throw err135;
    }
}
function fdatasync(fd, callback) {
    Deno.fdatasync(fd).then(()=>callback(null)
    , callback);
}
function fdatasyncSync(fd) {
    Deno.fdatasyncSync(fd);
}
function fstat(fd, optionsOrCallback, maybeCallback4) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback4;
    const options = typeof optionsOrCallback === "object" ? optionsOrCallback : {
        bigint: false
    };
    if (!callback) throw new Error("No callback function supplied");
    Deno.fstat(fd).then((stat3)=>callback(null, CFISBIS(stat3, options.bigint))
    , (err136)=>callback(err136)
    );
}
function fstatSync(fd, options) {
    const origin = Deno.fstatSync(fd);
    return CFISBIS(origin, options?.bigint || false);
}
function fsync(fd, callback) {
    Deno.fsync(fd).then(()=>callback(null)
    , callback);
}
function fsyncSync(fd) {
    Deno.fsyncSync(fd);
}
function ftruncate(fd, lenOrCallback, maybeCallback5) {
    const len = typeof lenOrCallback === "number" ? lenOrCallback : undefined;
    const callback = typeof lenOrCallback === "function" ? lenOrCallback : maybeCallback5;
    if (!callback) throw new Error("No callback function supplied");
    Deno.ftruncate(fd, len).then(()=>callback(null)
    , callback);
}
function ftruncateSync(fd, len) {
    Deno.ftruncateSync(fd, len);
}
function getValidTime(time4, name60) {
    if (typeof time4 === "string") {
        time4 = Number(time4);
    }
    if (typeof time4 === "number" && (Number.isNaN(time4) || !Number.isFinite(time4))) {
        throw new Deno.errors.InvalidData(`invalid ${name60}, must not be infinity or NaN`);
    }
    return time4;
}
function futimes(fd, atime, mtime, callback) {
    if (!callback) {
        throw new Deno.errors.InvalidData("No callback function supplied");
    }
    atime = getValidTime(atime, "atime");
    mtime = getValidTime(mtime, "mtime");
    futime(fd, atime, mtime).then(()=>callback(null)
    , callback);
}
function futimesSync(fd, atime, mtime) {
    atime = getValidTime(atime, "atime");
    mtime = getValidTime(mtime, "mtime");
    futimeSync(fd, atime, mtime);
}
function link(existingPath, newPath, callback) {
    existingPath = existingPath instanceof URL ? fromFileUrl5(existingPath) : existingPath;
    newPath = newPath instanceof URL ? fromFileUrl5(newPath) : newPath;
    Deno.link(existingPath, newPath).then(()=>callback(null)
    , callback);
}
function linkSync(existingPath, newPath) {
    existingPath = existingPath instanceof URL ? fromFileUrl5(existingPath) : existingPath;
    newPath = newPath instanceof URL ? fromFileUrl5(newPath) : newPath;
    Deno.linkSync(existingPath, newPath);
}
function mkdir(path80, options, callback) {
    path80 = path80 instanceof URL ? fromFileUrl5(path80) : path80;
    let mode14 = 511;
    let recursive = false;
    if (typeof options == "function") {
        callback = options;
    } else if (typeof options === "number") {
        mode14 = options;
    } else if (typeof options === "boolean") {
        recursive = options;
    } else if (options) {
        if (options.recursive !== undefined) recursive = options.recursive;
        if (options.mode !== undefined) mode14 = options.mode;
    }
    if (typeof recursive !== "boolean") {
        throw new Deno.errors.InvalidData("invalid recursive option , must be a boolean");
    }
    Deno.mkdir(path80, {
        recursive,
        mode: mode14
    }).then(()=>{
        if (typeof callback === "function") {
            callback(null);
        }
    }, (err137)=>{
        if (typeof callback === "function") {
            callback(err137);
        }
    });
}
function mkdirSync(path81, options) {
    path81 = path81 instanceof URL ? fromFileUrl5(path81) : path81;
    let mode15 = 511;
    let recursive = false;
    if (typeof options === "number") {
        mode15 = options;
    } else if (typeof options === "boolean") {
        recursive = options;
    } else if (options) {
        if (options.recursive !== undefined) recursive = options.recursive;
        if (options.mode !== undefined) mode15 = options.mode;
    }
    if (typeof recursive !== "boolean") {
        throw new Deno.errors.InvalidData("invalid recursive option , must be a boolean");
    }
    Deno.mkdirSync(path81, {
        recursive,
        mode: mode15
    });
}
function mkdtemp(prefix, optionsOrCallback, maybeCallback6) {
    const callback = typeof optionsOrCallback == "function" ? optionsOrCallback : maybeCallback6;
    if (!callback) throw new ERR_INVALID_CALLBACK(callback);
    const encoding = parseEncoding(optionsOrCallback);
    const path82 = tempDirPath(prefix);
    mkdir(path82, {
        recursive: false,
        mode: 448
    }, (err138)=>{
        if (err138) callback(err138);
        else callback(null, decode4(path82, encoding));
    });
}
function mkdtempSync(prefix, options) {
    const encoding = parseEncoding(options);
    const path83 = tempDirPath(prefix);
    mkdirSync(path83, {
        recursive: false,
        mode: 448
    });
    return decode4(path83, encoding);
}
function parseEncoding(optionsOrCallback) {
    let encoding;
    if (typeof optionsOrCallback == "function") encoding = undefined;
    else if (optionsOrCallback instanceof Object) {
        encoding = optionsOrCallback?.encoding;
    } else encoding = optionsOrCallback;
    if (encoding) {
        try {
            new TextDecoder(encoding);
        } catch  {
            throw new ERR_INVALID_OPT_VALUE_ENCODING(encoding);
        }
    }
    return encoding;
}
function decode4(str, encoding) {
    if (!encoding) return str;
    else {
        const decoder = new TextDecoder(encoding);
        const encoder = new TextEncoder();
        return decoder.decode(encoder.encode(str));
    }
}
const CHARS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function randomName() {
    return [
        ...Array(6)
    ].map(()=>CHARS[Math.floor(Math.random() * CHARS.length)]
    ).join("");
}
function tempDirPath(prefix) {
    let path84;
    do {
        path84 = prefix + randomName();
    }while (existsSync(path84))
    return path84;
}
function existsSync1(filePath) {
    try {
        Deno.lstatSync(filePath);
        return true;
    } catch (err139) {
        if (err139 instanceof Deno.errors.NotFound) {
            return false;
        }
        throw err139;
    }
}
function convertFlagAndModeToOptions(flag, mode16) {
    if (!flag && !mode16) return undefined;
    if (!flag && mode16) return {
        mode: mode16
    };
    return {
        ...getOpenOptions(flag),
        mode: mode16
    };
}
function open(path85, flagsOrCallback, callbackOrMode, maybeCallback7) {
    const flags = typeof flagsOrCallback === "string" ? flagsOrCallback : undefined;
    const callback = typeof flagsOrCallback === "function" ? flagsOrCallback : typeof callbackOrMode === "function" ? callbackOrMode : maybeCallback7;
    const mode17 = typeof callbackOrMode === "number" ? callbackOrMode : undefined;
    path85 = path85 instanceof URL ? fromFileUrl5(path85) : path85;
    if (!callback) throw new Error("No callback function supplied");
    if ([
        "ax",
        "ax+",
        "wx",
        "wx+"
    ].includes(flags || "") && existsSync1(path85)) {
        const err140 = new Error(`EEXIST: file already exists, open '${path85}'`);
        callback(err140);
    } else {
        if (flags === "as" || flags === "as+") {
            let err141 = null, res;
            try {
                res = openSync(path85, flags, mode17);
            } catch (error22) {
                err141 = error22 instanceof Error ? error22 : new Error("[non-error thrown]");
            }
            if (err141) {
                callback(err141);
            } else {
                callback(null, res);
            }
            return;
        }
        Deno.open(path85, convertFlagAndModeToOptions(flags, mode17)).then((file)=>callback(null, file.rid)
        , (err142)=>callback(err142)
        );
    }
}
function openSync(path86, flagsOrMode, maybeMode) {
    const flags = typeof flagsOrMode === "string" ? flagsOrMode : undefined;
    const mode18 = typeof flagsOrMode === "number" ? flagsOrMode : maybeMode;
    path86 = path86 instanceof URL ? fromFileUrl5(path86) : path86;
    if ([
        "ax",
        "ax+",
        "wx",
        "wx+"
    ].includes(flags || "") && existsSync1(path86)) {
        throw new Error(`EEXIST: file already exists, open '${path86}'`);
    }
    return Deno.openSync(path86, convertFlagAndModeToOptions(flags, mode18)).rid;
}
function read(fd, optOrBuffer, offsetOrCallback, length, position, callback) {
    let cb;
    let offset = 0, buffer24;
    if (length == null) {
        length = 0;
    }
    if (typeof offsetOrCallback === "function") {
        cb = offsetOrCallback;
    } else if (typeof optOrBuffer === "function") {
        cb = optOrBuffer;
    } else {
        offset = offsetOrCallback;
        cb = callback;
    }
    if (!cb) throw new Error("No callback function supplied");
    if (optOrBuffer instanceof Buffer1 || optOrBuffer instanceof Uint8Array) {
        buffer24 = optOrBuffer;
    } else if (typeof optOrBuffer === "function") {
        offset = 0;
        buffer24 = Buffer1.alloc(16384);
        length = buffer24.byteLength;
        position = null;
    } else {
        const opt = optOrBuffer;
        offset = opt.offset ?? 0;
        buffer24 = opt.buffer ?? Buffer1.alloc(16384);
        length = opt.length ?? buffer24.byteLength;
        position = opt.position ?? null;
    }
    assert(offset >= 0, "offset should be greater or equal to 0");
    assert(offset + length <= buffer24.byteLength, `buffer doesn't have enough data: byteLength = ${buffer24.byteLength}, offset + length = ${offset + length}`);
    if (buffer24.byteLength == 0) {
        throw new ERR_INVALID_ARG_VALUE("buffer", buffer24, "is empty and cannot be written");
    }
    let err143 = null, numberOfBytesRead = null;
    if (position) {
        Deno.seekSync(fd, position, Deno.SeekMode.Current);
    }
    try {
        numberOfBytesRead = Deno.readSync(fd, buffer24);
    } catch (error23) {
        err143 = error23 instanceof Error ? error23 : new Error("[non-error thrown]");
    }
    if (err143) {
        callback(err143);
    } else {
        const data31 = Buffer1.from(buffer24.buffer, offset, length);
        cb(null, numberOfBytesRead, data31);
    }
    return;
}
function readSync(fd, buffer25, offsetOrOpt, length, position) {
    let offset = 0;
    if (length == null) {
        length = 0;
    }
    if (buffer25.byteLength == 0) {
        throw new ERR_INVALID_ARG_VALUE("buffer", buffer25, "is empty and cannot be written");
    }
    if (typeof offsetOrOpt === "number") {
        offset = offsetOrOpt;
    } else {
        const opt = offsetOrOpt;
        offset = opt.offset ?? 0;
        length = opt.length ?? buffer25.byteLength;
        position = opt.position ?? null;
    }
    assert(offset >= 0, "offset should be greater or equal to 0");
    assert(offset + length <= buffer25.byteLength, `buffer doesn't have enough data: byteLength = ${buffer25.byteLength}, offset + length = ${offset + length}`);
    if (position) {
        Deno.seekSync(fd, position, Deno.SeekMode.Current);
    }
    const numberOfBytesRead = Deno.readSync(fd, buffer25);
    return numberOfBytesRead ?? 0;
}
function asyncIterableToCallback(iter, callback, errCallback) {
    const iterator = iter[Symbol.asyncIterator]();
    function next() {
        iterator.next().then((obj)=>{
            if (obj.done) {
                callback(obj.value, true);
                return;
            }
            callback(obj.value);
            next();
        }, errCallback);
    }
    next();
}
function watch(filename, optionsOrListener, optionsOrListener2) {
    const listener = typeof optionsOrListener === "function" ? optionsOrListener : typeof optionsOrListener2 === "function" ? optionsOrListener2 : undefined;
    const options = typeof optionsOrListener === "object" ? optionsOrListener : typeof optionsOrListener2 === "object" ? optionsOrListener2 : undefined;
    filename = filename instanceof URL ? fromFileUrl5(filename) : filename;
    const iterator = Deno.watchFs(filename, {
        recursive: options?.recursive || false
    });
    if (!listener) throw new Error("No callback function supplied");
    const fsWatcher = new FSWatcher(()=>{
        if (iterator.return) iterator.return();
    });
    fsWatcher.on("change", listener);
    asyncIterableToCallback(iterator, (val, done)=>{
        if (done) return;
        fsWatcher.emit("change", val.kind, val.paths[0]);
    }, (e39)=>{
        fsWatcher.emit("error", e39);
    });
    return fsWatcher;
}
class FSWatcher extends EventEmitter {
    close;
    constructor(closer){
        super();
        this.close = closer;
    }
    ref() {
        notImplemented("FSWatcher.ref() is not implemented");
    }
    unref() {
        notImplemented("FSWatcher.unref() is not implemented");
    }
}
function toDirent(val) {
    return new Dirent1(val);
}
function readdir(path87, optionsOrCallback, maybeCallback8) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback8;
    const options = typeof optionsOrCallback === "object" ? optionsOrCallback : null;
    const result = [];
    path87 = getValidatedPath(path87);
    if (!callback) throw new Error("No callback function supplied");
    if (options?.encoding) {
        try {
            new TextDecoder(options.encoding);
        } catch  {
            throw new Error(`TypeError [ERR_INVALID_OPT_VALUE_ENCODING]: The value "${options.encoding}" is invalid for option "encoding"`);
        }
    }
    try {
        asyncIterableToCallback(Deno.readDir(path87.toString()), (val, done)=>{
            if (typeof path87 !== "string") return;
            if (done) {
                callback(null, result);
                return;
            }
            if (options?.withFileTypes) {
                result.push(toDirent(val));
            } else result.push(decode5(val.name));
        }, (e40)=>{
            callback(denoErrorToNodeError(e40, {
                syscall: "readdir"
            }));
        });
    } catch (e41) {
        callback(denoErrorToNodeError(e41, {
            syscall: "readdir"
        }));
    }
}
function decode5(str, encoding) {
    if (!encoding) return str;
    else {
        const decoder = new TextDecoder(encoding);
        const encoder = new TextEncoder();
        return decoder.decode(encoder.encode(str));
    }
}
function readdirSync(path88, options) {
    const result = [];
    path88 = getValidatedPath(path88);
    if (options?.encoding) {
        try {
            new TextDecoder(options.encoding);
        } catch  {
            throw new Error(`TypeError [ERR_INVALID_OPT_VALUE_ENCODING]: The value "${options.encoding}" is invalid for option "encoding"`);
        }
    }
    try {
        for (const file of Deno.readDirSync(path88.toString())){
            if (options?.withFileTypes) {
                result.push(toDirent(file));
            } else result.push(decode5(file.name));
        }
    } catch (e42) {
        throw denoErrorToNodeError(e42, {
            syscall: "readdir"
        });
    }
    return result;
}
function maybeDecode(data32, encoding) {
    const buffer26 = Buffer1.from(data32.buffer, data32.byteOffset, data32.byteLength);
    if (encoding && encoding !== "binary") return buffer26.toString(encoding);
    return buffer26;
}
function readFile(path89, optOrCallback, callback) {
    path89 = path89 instanceof URL ? fromFileUrl5(path89) : path89;
    let cb;
    if (typeof optOrCallback === "function") {
        cb = optOrCallback;
    } else {
        cb = callback;
    }
    const encoding = getEncoding(optOrCallback);
    const p18 = Deno.readFile(path89);
    if (cb) {
        p18.then((data33)=>{
            if (encoding && encoding !== "binary") {
                const text1 = maybeDecode(data33, encoding);
                return cb(null, text1);
            }
            const buffer27 = maybeDecode(data33, encoding);
            cb(null, buffer27);
        }, (err144)=>cb && cb(err144)
        );
    }
}
function readFileSync(path90, opt) {
    path90 = path90 instanceof URL ? fromFileUrl5(path90) : path90;
    const data34 = Deno.readFileSync(path90);
    const encoding = getEncoding(opt);
    if (encoding && encoding !== "binary") {
        const text2 = maybeDecode(data34, encoding);
        return text2;
    }
    const buffer28 = maybeDecode(data34, encoding);
    return buffer28;
}
function maybeEncode(data35, encoding) {
    if (encoding === "buffer") {
        return new TextEncoder().encode(data35);
    }
    return data35;
}
function getEncoding1(optOrCallback) {
    if (!optOrCallback || typeof optOrCallback === "function") {
        return null;
    } else {
        if (optOrCallback.encoding) {
            if (optOrCallback.encoding === "utf8" || optOrCallback.encoding === "utf-8") {
                return "utf8";
            } else if (optOrCallback.encoding === "buffer") {
                return "buffer";
            } else {
                notImplemented();
            }
        }
        return null;
    }
}
function readlink(path91, optOrCallback, callback) {
    path91 = path91 instanceof URL ? fromFileUrl5(path91) : path91;
    let cb;
    if (typeof optOrCallback === "function") {
        cb = optOrCallback;
    } else {
        cb = callback;
    }
    const encoding = getEncoding1(optOrCallback);
    intoCallbackAPIWithIntercept(Deno.readLink, (data36)=>maybeEncode(data36, encoding)
    , cb, path91);
}
function readlinkSync(path92, opt) {
    path92 = path92 instanceof URL ? fromFileUrl5(path92) : path92;
    return maybeEncode(Deno.readLinkSync(path92), getEncoding1(opt));
}
function realpath(path112, options, callback) {
    if (typeof options === "function") {
        callback = options;
    }
    if (!callback) {
        throw new Error("No callback function supplied");
    }
    Deno.realPath(path112).then((path93)=>callback(null, path93)
    , (err145)=>callback(err145)
    );
}
realpath.native = realpath;
function realpathSync(path94) {
    return Deno.realPathSync(path94);
}
realpathSync.native = realpathSync;
function rename(oldPath, newPath, callback) {
    oldPath = oldPath instanceof URL ? fromFileUrl5(oldPath) : oldPath;
    newPath = newPath instanceof URL ? fromFileUrl5(newPath) : newPath;
    if (!callback) throw new Error("No callback function supplied");
    Deno.rename(oldPath, newPath).then((_)=>callback()
    , callback);
}
function renameSync(oldPath, newPath) {
    oldPath = oldPath instanceof URL ? fromFileUrl5(oldPath) : oldPath;
    newPath = newPath instanceof URL ? fromFileUrl5(newPath) : newPath;
    Deno.renameSync(oldPath, newPath);
}
function rmdir(path95, optionsOrCallback, maybeCallback9) {
    path95 = toNamespacedPath5(getValidatedPath(path95));
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback9;
    const options1 = typeof optionsOrCallback === "object" ? optionsOrCallback : undefined;
    if (!callback) throw new Error("No callback function supplied");
    if (options1?.recursive) {
        emitRecursiveRmdirWarning();
        validateRmOptions(path95, {
            ...options1,
            force: false
        }, true, (err146, options)=>{
            if (err146 === false) {
                return callback(new ERR_FS_RMDIR_ENOTDIR(path95.toString()));
            }
            if (err146) {
                return callback(err146);
            }
            Deno.remove(path95, {
                recursive: options?.recursive
            }).then((_)=>callback()
            , callback);
        });
    } else {
        validateRmdirOptions(options1);
        Deno.remove(path95, {
            recursive: options1?.recursive
        }).then((_)=>callback()
        , (err147)=>{
            callback(err147 instanceof Error ? denoErrorToNodeError(err147, {
                syscall: "rmdir"
            }) : err147);
        });
    }
}
function rmdirSync(path96, options) {
    path96 = getValidatedPath(path96);
    if (options?.recursive) {
        emitRecursiveRmdirWarning();
        options = validateRmOptionsSync(path96, {
            ...options,
            force: false
        }, true);
        if (options === false) {
            throw new ERR_FS_RMDIR_ENOTDIR(path96.toString());
        }
    } else {
        validateRmdirOptions(options);
    }
    try {
        Deno.removeSync(toNamespacedPath5(path96), {
            recursive: options?.recursive
        });
    } catch (err148) {
        throw err148 instanceof Error ? denoErrorToNodeError(err148, {
            syscall: "rmdir"
        }) : err148;
    }
}
function rm(path97, optionsOrCallback, maybeCallback10) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback10;
    const options1 = typeof optionsOrCallback === "object" ? optionsOrCallback : undefined;
    if (!callback) throw new Error("No callback function supplied");
    validateRmOptions(path97, options1, false, (err1, options)=>{
        if (err1) {
            return callback(err1);
        }
        Deno.remove(path97, {
            recursive: options?.recursive
        }).then((_)=>callback(null)
        , (err149)=>{
            if (options?.force && err149 instanceof Deno.errors.NotFound) {
                callback(null);
            } else {
                callback(err149 instanceof Error ? denoErrorToNodeError(err149, {
                    syscall: "rm"
                }) : err149);
            }
        });
    });
}
function rmSync(path98, options) {
    options = validateRmOptionsSync(path98, options, false);
    try {
        Deno.removeSync(path98, {
            recursive: options?.recursive
        });
    } catch (err150) {
        if (options?.force && err150 instanceof Deno.errors.NotFound) {
            return;
        }
        if (err150 instanceof Error) {
            throw denoErrorToNodeError(err150, {
                syscall: "stat"
            });
        } else {
            throw err150;
        }
    }
}
function symlink(target, path99, typeOrCallback, maybeCallback11) {
    target = target instanceof URL ? fromFileUrl5(target) : target;
    path99 = path99 instanceof URL ? fromFileUrl5(path99) : path99;
    const type49 = typeof typeOrCallback === "string" ? typeOrCallback : "file";
    const callback = typeof typeOrCallback === "function" ? typeOrCallback : maybeCallback11;
    if (!callback) throw new Error("No callback function supplied");
    Deno.symlink(target, path99, {
        type: type49
    }).then(()=>callback(null)
    , callback);
}
function symlinkSync(target, path100, type50) {
    target = target instanceof URL ? fromFileUrl5(target) : target;
    path100 = path100 instanceof URL ? fromFileUrl5(path100) : path100;
    type50 = type50 || "file";
    Deno.symlinkSync(target, path100, {
        type: type50
    });
}
function truncate(path101, lenOrCallback, maybeCallback12) {
    path101 = path101 instanceof URL ? fromFileUrl5(path101) : path101;
    const len = typeof lenOrCallback === "number" ? lenOrCallback : undefined;
    const callback = typeof lenOrCallback === "function" ? lenOrCallback : maybeCallback12;
    if (!callback) throw new Error("No callback function supplied");
    Deno.truncate(path101, len).then(()=>callback(null)
    , callback);
}
function truncateSync(path102, len) {
    path102 = path102 instanceof URL ? fromFileUrl5(path102) : path102;
    Deno.truncateSync(path102, len);
}
function unlink(path103, callback) {
    if (!callback) throw new Error("No callback function supplied");
    Deno.remove(path103).then((_)=>callback()
    , callback);
}
function unlinkSync(path104) {
    Deno.removeSync(path104);
}
function getValidTime1(time5, name61) {
    if (typeof time5 === "string") {
        time5 = Number(time5);
    }
    if (typeof time5 === "number" && (Number.isNaN(time5) || !Number.isFinite(time5))) {
        throw new Deno.errors.InvalidData(`invalid ${name61}, must not be infinity or NaN`);
    }
    return time5;
}
function utimes(path105, atime, mtime, callback) {
    path105 = path105 instanceof URL ? fromFileUrl5(path105) : path105;
    if (!callback) {
        throw new Deno.errors.InvalidData("No callback function supplied");
    }
    atime = getValidTime1(atime, "atime");
    mtime = getValidTime1(mtime, "mtime");
    utime(path105, atime, mtime).then(()=>callback(null)
    , callback);
}
function utimesSync(path106, atime, mtime) {
    path106 = path106 instanceof URL ? fromFileUrl5(path106) : path106;
    atime = getValidTime1(atime, "atime");
    mtime = getValidTime1(mtime, "mtime");
    utimeSync(path106, atime, mtime);
}
function writeSync(fd1, buffer1, offset1, length1, position1) {
    fd1 = getValidatedFd(fd1);
    const innerWriteSync = (fd, buffer29, offset, length, position)=>{
        if (buffer29 instanceof DataView) {
            buffer29 = new Uint8Array(buffer29.buffer);
        }
        if (typeof position === "number") {
            Deno.seekSync(fd, position, Deno.SeekMode.Start);
        }
        let currentOffset = offset;
        while(currentOffset - offset < length){
            currentOffset += Deno.writeSync(fd, buffer29.subarray(currentOffset));
        }
        return currentOffset - offset;
    };
    if (isArrayBufferView(buffer1)) {
        if (position1 === undefined) {
            position1 = null;
        }
        if (offset1 == null) {
            offset1 = 0;
        } else {
            validateInteger(offset1, "offset", 0);
        }
        if (typeof length1 !== "number") {
            length1 = buffer1.byteLength - offset1;
        }
        validateOffsetLengthWrite(offset1, length1, buffer1.byteLength);
        return innerWriteSync(fd1, buffer1, offset1, length1, position1);
    }
    validateStringAfterArrayBufferView(buffer1, "buffer");
    validateEncoding(buffer1, length1);
    if (offset1 === undefined) {
        offset1 = null;
    }
    buffer1 = Buffer1.from(buffer1, length1);
    return innerWriteSync(fd1, buffer1, 0, buffer1.length, position1);
}
function write(fd2, buffer2, offset2, length2, position2, callback) {
    fd2 = getValidatedFd(fd2);
    const innerWrite = async (fd, buffer30, offset, length, position)=>{
        if (buffer30 instanceof DataView) {
            buffer30 = new Uint8Array(buffer30.buffer);
        }
        if (typeof position === "number") {
            await Deno.seek(fd, position, Deno.SeekMode.Start);
        }
        let currentOffset = offset;
        while(currentOffset - offset < length){
            currentOffset += await Deno.write(fd, buffer30.subarray(currentOffset));
        }
        return currentOffset - offset;
    };
    if (isArrayBufferView(buffer2)) {
        callback = maybeCallback(callback || position2 || length2 || offset2);
        if (offset2 == null || typeof offset2 === "function") {
            offset2 = 0;
        } else {
            validateInteger(offset2, "offset", 0);
        }
        if (typeof length2 !== "number") {
            length2 = buffer2.byteLength - offset2;
        }
        if (typeof position2 !== "number") {
            position2 = null;
        }
        validateOffsetLengthWrite(offset2, length2, buffer2.byteLength);
        innerWrite(fd2, buffer2, offset2, length2, position2).then((nwritten)=>{
            callback(null, nwritten, buffer2);
        }, (err151)=>callback(err151)
        );
        return;
    }
    validateStringAfterArrayBufferView(buffer2, "buffer");
    if (typeof position2 !== "function") {
        if (typeof offset2 === "function") {
            position2 = offset2;
            offset2 = null;
        } else {
            position2 = length2;
        }
        length2 = "utf-8";
    }
    const str = String(buffer2);
    validateEncoding(str, length2);
    callback = maybeCallback(position2);
    buffer2 = Buffer1.from(str, length2);
    innerWrite(fd2, buffer2, 0, buffer2.length, offset2, callback).then((nwritten)=>{
        callback(null, nwritten, buffer2);
    }, (err152)=>callback(err152)
    );
}
function writev(fd1, buffers1, position1, callback) {
    const innerWritev = async (fd, buffers, position)=>{
        const chunks = [];
        for(let i146 = 0; i146 < buffers.length; i146++){
            if (Buffer1.isBuffer(buffers[i146])) {
                chunks.push(buffers[i146]);
            } else {
                chunks.push(new Buffer1(buffers[i146]));
            }
        }
        if (typeof position === "number") {
            await Deno.seekSync(fd, position, Deno.SeekMode.Start);
        }
        const buffer31 = Buffer1.concat(chunks);
        let currentOffset = 0;
        while(currentOffset < buffer31.byteLength){
            currentOffset += await Deno.writeSync(fd, buffer31.subarray(currentOffset));
        }
        return currentOffset - 0;
    };
    fd1 = getValidatedFd(fd1);
    validateBufferArray(buffers1);
    callback = maybeCallback(callback || position1);
    if (buffers1.length === 0) {
        process.nextTick(callback, null, 0, buffers1);
        return;
    }
    if (typeof position1 !== "number") position1 = null;
    innerWritev(fd1, buffers1, position1).then((nwritten)=>{
        callback(null, nwritten, buffers1);
    }, (err153)=>callback(err153)
    );
}
const kFs = Symbol("kFs");
const kIsPerformingIO = Symbol("kIsPerformingIO");
const kIoDone = Symbol("kIoDone");
class WriteStreamClass extends Writable {
    fd = null;
    path;
    flags;
    mode;
    bytesWritten = 0;
    pos = 0;
    [kFs] = {
        open,
        write
    };
    [kIsPerformingIO] = false;
    constructor(path107, opts = {}){
        super(opts);
        this.path = toPathIfFileURL(path107);
        this.flags = opts.flags || "w";
        this.mode = opts.mode || 438;
        this[kFs] = opts.fs ?? {
            open,
            write,
            close
        };
        if (opts.encoding) {
            this.setDefaultEncoding(opts.encoding);
        }
    }
    _construct(callback) {
        this[kFs].open(this.path.toString(), this.flags, this.mode, (err154, fd)=>{
            if (err154) {
                callback(err154);
                return;
            }
            this.fd = fd;
            callback();
            this.emit("open", this.fd);
            this.emit("ready");
        });
    }
    _write(data37, _encoding, cb) {
        this[kIsPerformingIO] = true;
        this[kFs].write(this.fd, data37, 0, data37.length, this.pos, (er, bytes)=>{
            this[kIsPerformingIO] = false;
            if (this.destroyed) {
                cb(er);
                return this.emit(kIoDone, er);
            }
            if (er) {
                return cb(er);
            }
            this.bytesWritten += bytes;
            cb();
        });
        if (this.pos !== undefined) {
            this.pos += data37.length;
        }
    }
    _destroy(err155, cb) {
        if (this[kIsPerformingIO]) {
            this.once(kIoDone, (er)=>closeStream(this, err155 || er, cb)
            );
        } else {
            closeStream(this, err155, cb);
        }
    }
}
function closeStream(stream4, err156, cb) {
    if (!stream4.fd) {
        cb(err156);
    } else {
        stream4[kFs].close(stream4.fd, (er)=>{
            cb(er || err156);
        });
        stream4.fd = null;
    }
}
function WriteStream(path108, opts) {
    return new WriteStreamClass(path108, opts);
}
WriteStream.prototype = WriteStreamClass.prototype;
function createWriteStream(path109, opts) {
    return new WriteStreamClass(path109, opts);
}
const { F_OK: F_OK2 , R_OK: R_OK2 , W_OK: W_OK2 , X_OK: X_OK2 ,  } = mod53;
const promises = {
    access: promisify(access),
    copyFile: promisify(copyFile),
    open: promisify(open),
    rename: promisify(rename),
    truncate: promisify(truncate),
    rm: promisify(rm),
    rmdir: promisify(rmdir),
    mkdir: promisify(mkdir),
    readdir: promisify(readdir),
    readlink: promisify(readlink),
    symlink: promisify(symlink),
    lstat: promisify(lstat),
    stat: promisify(stat),
    link: promisify(link),
    unlink: promisify(unlink),
    chmod: promisify(chmod),
    chown: promisify(chown),
    utimes: promisify(utimes),
    realpath: promisify(realpath),
    mkdtemp: promisify(mkdtemp),
    writeFile: promisify(writeFile),
    appendFile: promisify(appendFile),
    readFile: promisify(readFile),
    watch: promisify(watch)
};
const __default31 = {
    access,
    accessSync,
    appendFile,
    appendFileSync,
    chmod,
    chmodSync,
    chown,
    chownSync,
    close,
    closeSync,
    constants: mod53,
    copyFile,
    copyFileSync,
    createWriteStream,
    Dir,
    Dirent: Dirent1,
    exists,
    existsSync,
    F_OK: F_OK2,
    fdatasync,
    fdatasyncSync,
    fstat,
    fstatSync,
    fsync,
    fsyncSync,
    ftruncate,
    ftruncateSync,
    futimes,
    futimesSync,
    link,
    linkSync,
    lstat,
    lstatSync,
    mkdir,
    mkdirSync,
    mkdtemp,
    mkdtempSync,
    open,
    openSync,
    read,
    readSync,
    promises,
    R_OK: R_OK2,
    readdir,
    readdirSync,
    readFile,
    readFileSync,
    readlink,
    readlinkSync,
    realpath,
    realpathSync,
    rename,
    renameSync,
    rmdir,
    rmdirSync,
    rm,
    rmSync,
    stat,
    Stats,
    statSync,
    symlink,
    symlinkSync,
    truncate,
    truncateSync,
    unlink,
    unlinkSync,
    utimes,
    utimesSync,
    W_OK: W_OK2,
    watch,
    watchFile: watch,
    write,
    writeFile,
    writev,
    writeFileSync,
    WriteStream,
    writeSync,
    X_OK: X_OK2
};
var EOL;
(function(EOL2) {
    EOL2["LF"] = "\n";
    EOL2["CRLF"] = "\r\n";
})(EOL || (EOL = {}));
const SEE_GITHUB_ISSUE = "See https://github.com/denoland/deno_std/issues/1436";
function arch1() {
    return process1.arch;
}
arch1[Symbol.toPrimitive] = ()=>process1.arch
;
endianness[Symbol.toPrimitive] = ()=>endianness()
;
freemem[Symbol.toPrimitive] = ()=>freemem()
;
homedir[Symbol.toPrimitive] = ()=>homedir()
;
hostname1[Symbol.toPrimitive] = ()=>hostname1()
;
platform1[Symbol.toPrimitive] = ()=>platform1()
;
release[Symbol.toPrimitive] = ()=>release()
;
totalmem[Symbol.toPrimitive] = ()=>totalmem()
;
type[Symbol.toPrimitive] = ()=>type()
;
uptime[Symbol.toPrimitive] = ()=>uptime()
;
function cpus() {
    return Array.from(Array(navigator.hardwareConcurrency)).map(()=>{
        return {
            model: "",
            speed: 0,
            times: {
                user: 0,
                nice: 0,
                sys: 0,
                idle: 0,
                irq: 0
            }
        };
    });
}
function endianness() {
    const buffer32 = new ArrayBuffer(2);
    new DataView(buffer32).setInt16(0, 256, true);
    return new Int16Array(buffer32)[0] === 256 ? "LE" : "BE";
}
function freemem() {
    return systemMemoryInfo().free;
}
function getPriority(pid1 = 0) {
    validateIntegerRange(pid1, "pid");
    notImplemented(SEE_GITHUB_ISSUE);
}
function homedir() {
    switch(osType){
        case "windows":
            return Deno.env.get("USERPROFILE") || null;
        case "linux":
        case "darwin":
            return Deno.env.get("HOME") || null;
        default:
            throw Error("unreachable");
    }
}
function hostname1() {
    return hostname();
}
function loadavg1() {
    if (isWindows) {
        return [
            0,
            0,
            0
        ];
    }
    return loadavg();
}
function networkInterfaces1() {
    const interfaces = {};
    for (const { name: name62 , address: address7 , netmask , family , mac , scopeid , cidr  } of networkInterfaces()){
        const addresses = interfaces[name62] ||= [];
        const networkAddress = {
            address: address7,
            netmask,
            family,
            mac,
            internal: family === "IPv4" && isIPv4LoopbackAddr(address7) || family === "IPv6" && isIPv6LoopbackAddr(address7),
            cidr
        };
        if (family === "IPv6") {
            networkAddress.scopeid = scopeid;
        }
        addresses.push(networkAddress);
    }
    return interfaces;
}
function isIPv4LoopbackAddr(addr) {
    return addr.startsWith("127");
}
function isIPv6LoopbackAddr(addr) {
    return addr === "::1" || addr === "fe80::1";
}
function platform1() {
    return process1.platform;
}
function release() {
    return osRelease();
}
function setPriority(pid2, priority) {
    if (priority === undefined) {
        priority = pid2;
        pid2 = 0;
    }
    validateIntegerRange(pid2, "pid");
    validateIntegerRange(priority, "priority", -20, 19);
    notImplemented(SEE_GITHUB_ISSUE);
}
function tmpdir() {
    if (isWindows) {
        const temp = Deno.env.get("TEMP") || Deno.env.get("TMP");
        if (temp) {
            return temp.replace(/(?<!:)[/\\]*$/, "");
        }
        const base16 = Deno.env.get("SYSTEMROOT") || Deno.env.get("WINDIR");
        if (base16) {
            return base16 + "\\temp";
        }
        return null;
    } else {
        const temp = Deno.env.get("TMPDIR") || Deno.env.get("TMP") || Deno.env.get("TEMP") || "/tmp";
        return temp.replace(/(?<!^)\/*$/, "");
    }
}
function totalmem() {
    return systemMemoryInfo().total;
}
function type() {
    switch(Deno.build.os){
        case "windows":
            return "Windows_NT";
        case "linux":
            return "Linux";
        case "darwin":
            return "Darwin";
        default:
            throw Error("unreachable");
    }
}
function uptime() {
    notImplemented(SEE_GITHUB_ISSUE);
}
function userInfo(options = {
    encoding: "utf-8"
}) {
    notImplemented(SEE_GITHUB_ISSUE);
}
const constants5 = {
    dlopen: {},
    errno: {},
    signals: {
        "SIGABRT": "SIGABRT",
        "SIGALRM": "SIGALRM",
        "SIGBUS": "SIGBUS",
        "SIGCHLD": "SIGCHLD",
        "SIGCONT": "SIGCONT",
        "SIGEMT": "SIGEMT",
        "SIGFPE": "SIGFPE",
        "SIGHUP": "SIGHUP",
        "SIGILL": "SIGILL",
        "SIGINFO": "SIGINFO",
        "SIGINT": "SIGINT",
        "SIGIO": "SIGIO",
        "SIGKILL": "SIGKILL",
        "SIGPIPE": "SIGPIPE",
        "SIGPROF": "SIGPROF",
        "SIGPWR": "SIGPWR",
        "SIGQUIT": "SIGQUIT",
        "SIGSEGV": "SIGSEGV",
        "SIGSTKFLT": "SIGSTKFLT",
        "SIGSTOP": "SIGSTOP",
        "SIGSYS": "SIGSYS",
        "SIGTERM": "SIGTERM",
        "SIGTRAP": "SIGTRAP",
        "SIGTSTP": "SIGTSTP",
        "SIGTTIN": "SIGTTIN",
        "SIGTTOU": "SIGTTOU",
        "SIGURG": "SIGURG",
        "SIGUSR1": "SIGUSR1",
        "SIGUSR2": "SIGUSR2",
        "SIGVTALRM": "SIGVTALRM",
        "SIGWINCH": "SIGWINCH",
        "SIGXCPU": "SIGXCPU",
        "SIGXFSZ": "SIGXFSZ"
    },
    priority: {}
};
const EOL1 = isWindows ? EOL.CRLF : EOL.LF;
const devNull = isWindows ? "\\\\.\\nul" : "/dev/null";
const __default32 = {
    arch: arch1,
    cpus,
    endianness,
    freemem,
    getPriority,
    homedir,
    hostname: hostname1,
    loadavg: loadavg1,
    networkInterfaces: networkInterfaces1,
    platform: platform1,
    release,
    setPriority,
    tmpdir,
    totalmem,
    type,
    uptime,
    userInfo,
    constants: constants5,
    EOL: EOL1,
    devNull
};
const __default33 = {
    ...mod53,
    ...constants5.dlopen,
    ...constants5.errno,
    ...constants5.signals,
    ...constants5.priority
};
const MAX_RANDOM_VALUES = 65536;
function generateRandomBytes(size) {
    if (size > 4294967295) {
        throw new RangeError(`The value of "size" is out of range. It must be >= 0 && <= ${4294967295}. Received ${size}`);
    }
    const bytes = Buffer1.allocUnsafe(size);
    if (size > 65536) {
        for(let generated = 0; generated < size; generated += MAX_RANDOM_VALUES){
            crypto.getRandomValues(bytes.slice(generated, generated + 65536));
        }
    } else {
        crypto.getRandomValues(bytes);
    }
    return bytes;
}
function randomBytes(size, cb) {
    if (typeof cb === "function") {
        let err157 = null, bytes;
        try {
            bytes = generateRandomBytes(size);
        } catch (e43) {
            if (e43 instanceof RangeError && e43.message.includes('The value of "size" is out of range')) {
                throw e43;
            } else if (e43 instanceof Error) {
                err157 = e43;
            } else {
                err157 = new Error("[non-error thrown]");
            }
        }
        setTimeout(()=>{
            if (err157) {
                cb(err157);
            } else {
                cb(null, bytes);
            }
        }, 0);
    } else {
        return generateRandomBytes(size);
    }
}
function assertOffset(offset, length) {
    if (offset > 4294967295 || offset < 0) {
        throw new TypeError("offset must be a uint32");
    }
    if (offset > 2147483647 || offset > length) {
        throw new RangeError("offset out of range");
    }
}
function assertSize1(size, offset, length) {
    if (size > 4294967295 || size < 0) {
        throw new TypeError("size must be a uint32");
    }
    if (size + offset > length || size > 2147483647) {
        throw new RangeError("buffer too small");
    }
}
function randomFill(buf, offset, size, cb) {
    if (typeof offset === "function") {
        cb = offset;
        offset = 0;
        size = buf.length;
    } else if (typeof size === "function") {
        cb = size;
        size = buf.length - Number(offset);
    }
    assertOffset(offset, buf.length);
    assertSize1(size, offset, buf.length);
    randomBytes(size, (err158, bytes)=>{
        if (err158) return cb(err158, buf);
        bytes?.copy(buf, offset);
        cb(null, buf);
    });
}
function randomFillSync(buf, offset = 0, size) {
    assertOffset(offset, buf.length);
    if (size === undefined) size = buf.length - offset;
    assertSize1(size, offset, buf.length);
    const bytes = randomBytes(size);
    bytes.copy(buf, offset);
    return buf;
}
function randomInt(max, min24, cb) {
    if (typeof max === "number" && typeof min24 === "number") {
        [max, min24] = [
            min24,
            max
        ];
    }
    if (min24 === undefined) min24 = 0;
    else if (typeof min24 === "function") {
        cb = min24;
        min24 = 0;
    }
    if (!Number.isSafeInteger(min24) || typeof max === "number" && !Number.isSafeInteger(max)) {
        throw new Error("max or min is not a Safe Number");
    }
    if (max - min24 > Math.pow(2, 48)) {
        throw new RangeError("max - min should be less than 2^48!");
    }
    if (min24 >= max) {
        throw new Error("Min is bigger than Max!");
    }
    const randomBuffer = new Uint32Array(1);
    crypto.getRandomValues(randomBuffer);
    const randomNumber = randomBuffer[0] / (4294967295 + 1);
    min24 = Math.ceil(min24);
    max = Math.floor(max);
    const result = Math.floor(randomNumber * (max - min24 + 1)) + min24;
    if (cb) {
        cb(null, result);
        return;
    }
    return result;
}
const data = decode("\
AGFzbQEAAAABo4GAgAAYYAAAYAABf2ABfwBgAX8Bf2ABfwF+YAJ/fwBgAn9/AX9gA39/fwBgA39/fw\
F/YAR/f39/AGAEf39/fwF/YAV/f39/fwBgBX9/f39/AX9gBn9/f39/fwBgBn9/f39/fwF/YAV/f39+\
fwBgB39/f35/f38Bf2ADf39+AGAFf399f38AYAV/f3x/fwBgAn9+AGAEf31/fwBgBH98f38AYAJ+fw\
F/AtKFgIAADRhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmdfbmV3X2E0YjYxYTBmNTQ4MjRj\
ZmQABhhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmluZGdlbl9vYmplY3RfZHJvcF9yZWYAAh\
hfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18hX193YmdfYnl0ZUxlbmd0aF8zZTI1MGI0MWE4OTE1NzU3\
AAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fIV9fd2JnX2J5dGVPZmZzZXRfNDIwNGVjYjI0YTZlNW\
RmOQADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXx1fX3diZ19idWZmZXJfZmFjZjAzOThhMjgxYzg1\
YgADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbm\
d0aF80YjliOGM0ZTNmNWFkYmZmAAgYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2xlbmd0\
aF8xZWI4ZmM2MDhhMGQ0Y2RiAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEV9fd2JpbmRnZW5fbW\
Vtb3J5AAEYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2J1ZmZlcl8zOTdlYWE0ZDcyZWU5\
NGRkAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld19hN2NlNDQ3ZjE1ZmY0OTZmAA\
MYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX3NldF85NjlhZDBhNjBlNTFkMzIwAAcYX193\
YmluZGdlbl9wbGFjZWhvbGRlcl9fEF9fd2JpbmRnZW5fdGhyb3cABRhfX3diaW5kZ2VuX3BsYWNlaG\
9sZGVyX18SX193YmluZGdlbl9yZXRocm93AAID7YCAgABsCQcJBwcRBQcHBQMHBw8DBwUQAgUFAgcF\
AggGBwcUDAgOBwcHBwYHBwgXDQUFCAkIDQkFCQYJBgYFBQUFBQUHBwcHBwAFAggKBwUDAgUODAsMCw\
sSEwkFCAgDBgYCBQAABgMGAAAFBQIEAAUCBIWAgIAAAXABFRUFg4CAgAABABEGiYCAgAABfwFBgIDA\
AAsHtoKAgAAOBm1lbW9yeQIABmRpZ2VzdAA3GF9fd2JnX2RpZ2VzdGNvbnRleHRfZnJlZQBSEWRpZ2\
VzdGNvbnRleHRfbmV3AEEUZGlnZXN0Y29udGV4dF91cGRhdGUAVhRkaWdlc3Rjb250ZXh0X2RpZ2Vz\
dAA+HGRpZ2VzdGNvbnRleHRfZGlnZXN0QW5kUmVzZXQAQBtkaWdlc3Rjb250ZXh0X2RpZ2VzdEFuZE\
Ryb3AAOxNkaWdlc3Rjb250ZXh0X3Jlc2V0ACITZGlnZXN0Y29udGV4dF9jbG9uZQAbH19fd2JpbmRn\
ZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXIAbhFfX3diaW5kZ2VuX21hbGxvYwBXEl9fd2JpbmRnZW5fcm\
VhbGxvYwBkD19fd2JpbmRnZW5fZnJlZQBqCZqAgIAAAQBBAQsUZ2hvd21bPVxdWmViXl9gYXhDRHUK\
g8yIgABsoH4CEn8CfiMAQbAlayIEJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAk\
ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgASgCAA4YAAECAwQcGxoZGBcWFRQTEhEQDw4N\
DAsKAAsgASgCBCEBQdABEBciBUUNBCAEQZASakE4aiABQThqKQMANwMAIARBkBJqQTBqIAFBMGopAw\
A3AwAgBEGQEmpBKGogAUEoaikDADcDACAEQZASakEgaiABQSBqKQMANwMAIARBkBJqQRhqIAFBGGop\
AwA3AwAgBEGQEmpBEGogAUEQaikDADcDACAEQZASakEIaiABQQhqKQMANwMAIAQgASkDADcDkBIgAS\
kDQCEWIARBkBJqQcgAaiABQcgAahBFIAQgFjcD0BIgBSAEQZASakHQARA6GkEAIQZBACEBDB8LIAEo\
AgQhAUHQARAXIgVFDQQgBEGQEmpBOGogAUE4aikDADcDACAEQZASakEwaiABQTBqKQMANwMAIARBkB\
JqQShqIAFBKGopAwA3AwAgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEYaiABQRhqKQMANwMAIARB\
kBJqQRBqIAFBEGopAwA3AwAgBEGQEmpBCGogAUEIaikDADcDACAEIAEpAwA3A5ASIAEpA0AhFiAEQZ\
ASakHIAGogAUHIAGoQRSAEIBY3A9ASIAUgBEGQEmpB0AEQOhpBASEBDBsLIAEoAgQhAUHQARAXIgVF\
DQQgBEGQEmpBOGogAUE4aikDADcDACAEQZASakEwaiABQTBqKQMANwMAIARBkBJqQShqIAFBKGopAw\
A3AwAgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEYaiABQRhqKQMANwMAIARBkBJqQRBqIAFBEGop\
AwA3AwAgBEGQEmpBCGogAUEIaikDADcDACAEIAEpAwA3A5ASIAEpA0AhFiAEQZASakHIAGogAUHIAG\
oQRSAEIBY3A9ASIAUgBEGQEmpB0AEQOhpBAiEBDBoLIAEoAgQhAUHwABAXIgVFDQQgBEGQEmpBIGog\
AUEgaikDADcDACAEQZASakEYaiABQRhqKQMANwMAIARBkBJqQRBqIAFBEGopAwA3AwAgBCABKQMINw\
OYEiABKQMAIRYgBEGQEmpBKGogAUEoahA5IAQgFjcDkBIgBSAEQZASakHwABA6GkEDIQEMGQsgASgC\
BCEBQfgOEBciBUUNBCAEQZASakGIAWogAUGIAWopAwA3AwAgBEGQEmpBgAFqIAFBgAFqKQMANwMAIA\
RBkBJqQfgAaiABQfgAaikDADcDACAEQZASakEQaiABQRBqKQMANwMAIARBkBJqQRhqIAFBGGopAwA3\
AwAgBEGQEmpBIGogAUEgaikDADcDACAEQZASakEwaiABQTBqKQMANwMAIARBkBJqQThqIAFBOGopAw\
A3AwAgBEGQEmpBwABqIAFBwABqKQMANwMAIARBkBJqQcgAaiABQcgAaikDADcDACAEQZASakHQAGog\
AUHQAGopAwA3AwAgBEGQEmpB2ABqIAFB2ABqKQMANwMAIARBkBJqQeAAaiABQeAAaikDADcDACAEIA\
EpA3A3A4ATIAQgASkDCDcDmBIgBCABKQMoNwO4EiABKQMAIRYgAS0AaiEHIAEtAGkhCCABLQBoIQkC\
QCABKAKQAUEFdCIKDQBBACEKDBsLIARBGGoiCyABQZQBaiIGQRhqKQAANwMAIARBEGoiDCAGQRBqKQ\
AANwMAIARBCGoiDSAGQQhqKQAANwMAIAQgBikAADcDACABQdQBaiEGQQAgCkFgakEFdmshDiAEQcQT\
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\
GkEGIQEMAgtB2AJBCEEAKAL41EAiBEEEIAQbEQUAAAsgASgCBCEBQeACEBciBUUNASAEQZASaiABQc\
gBEDoaIARBkBJqQcgBaiABQcgBahBKIAUgBEGQEmpB4AIQOhpBBSEBC0EAIQYMAgtB4AJBCEEAKAL4\
1EAiBEEEIAQbEQUAAAsgBCAKNgKgEyAEIAc6APoSIAQgCDoA+RIgBCAJOgD4EiAEIBY3A5ASIAUgBE\
GQEmpB+A4QOhpBBCEBQQEhBgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJA\
AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDgIBABELQSAhAi\
ABDhgBDwIPEAMPBAUGBgcHCA8JCgsPDA0QEA4BCyABQQJ0QZTUwABqKAIAIQMMDwtBwAAhAgwNC0Ew\
IQIMDAtBHCECDAsLQTAhAgwKC0HAACECDAkLQRAhAgwIC0EUIQIMBwtBHCECDAYLQTAhAgwFC0HAAC\
ECDAQLQRwhAgwDC0EwIQIMAgtBwAAhAgwBC0EYIQILIAIgA0YNACAAQa2BwAA2AgQgAEEBNgIAIABB\
CGpBOTYCAAJAIAZFDQAgBSgCkAFFDQAgBUEANgKQAQsgBRAfDAELAkACQAJAAkACQAJAAkACQAJAAk\
ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAQ4YAAECAwQFBgcICQoLDA0ODxAR\
EhMUFRYaAAsgBCAFQdABEDoiAUH4DmpBDGpCADcCACABQfgOakEUakIANwIAIAFB+A5qQRxqQgA3Ag\
AgAUH4DmpBJGpCADcCACABQfgOakEsakIANwIAIAFB+A5qQTRqQgA3AgAgAUH4DmpBPGpCADcCACAB\
QgA3AvwOIAFBwAA2AvgOIAFBkBJqIAFB+A5qQcQAEDoaIAFBuCJqQThqIgogAUGQEmpBPGopAgA3Aw\
AgAUG4ImpBMGoiAyABQZASakE0aikCADcDACABQbgiakEoaiIPIAFBkBJqQSxqKQIANwMAIAFBuCJq\
QSBqIgsgAUGQEmpBJGopAgA3AwAgAUG4ImpBGGoiDCABQZASakEcaikCADcDACABQbgiakEQaiINIA\
FBkBJqQRRqKQIANwMAIAFBuCJqQQhqIhAgAUGQEmpBDGopAgA3AwAgASABKQKUEjcDuCIgAUGQEmog\
AUHQARA6GiABIAEpA9ASIAFB2BNqLQAAIgatfDcD0BIgAUHYEmohAgJAIAZBgAFGDQAgAiAGakEAQY\
ABIAZrEDwaCyABQQA6ANgTIAFBkBJqIAJCfxASIAFB+A5qQQhqIgYgAUGQEmpBCGopAwA3AwAgAUH4\
DmpBEGoiAiABQZASakEQaikDADcDACABQfgOakEYaiIOIAFBkBJqQRhqKQMANwMAIAFB+A5qQSBqIg\
cgASkDsBI3AwAgAUH4DmpBKGoiCCABQZASakEoaikDADcDACABQfgOakEwaiIJIAFBkBJqQTBqKQMA\
NwMAIAFB+A5qQThqIhEgAUGQEmpBOGopAwA3AwAgASABKQOQEjcD+A4gECAGKQMANwMAIA0gAikDAD\
cDACAMIA4pAwA3AwAgCyAHKQMANwMAIA8gCCkDADcDACADIAkpAwA3AwAgCiARKQMANwMAIAEgASkD\
+A43A7giQcAAEBciBkUNHCAGIAEpA7giNwAAIAZBOGogAUG4ImpBOGopAwA3AAAgBkEwaiABQbgiak\
EwaikDADcAACAGQShqIAFBuCJqQShqKQMANwAAIAZBIGogAUG4ImpBIGopAwA3AAAgBkEYaiABQbgi\
akEYaikDADcAACAGQRBqIAFBuCJqQRBqKQMANwAAIAZBCGogAUG4ImpBCGopAwA3AABBwAAhAwwaCy\
AEIAVB0AEQOiIBQfgOakEcakIANwIAIAFB+A5qQRRqQgA3AgAgAUH4DmpBDGpCADcCACABQgA3AvwO\
IAFBIDYC+A4gAUGQEmpBGGoiCyABQfgOakEYaiICKQMANwMAIAFBkBJqQRBqIgwgAUH4DmpBEGoiCi\
kDADcDACABQZASakEIaiINIAFB+A5qQQhqIgMpAwA3AwAgAUGQEmpBIGogAUH4DmpBIGoiECgCADYC\
ACABIAEpA/gONwOQEiABQbgiakEQaiIOIAFBkBJqQRRqKQIANwMAIAFBuCJqQQhqIgcgAUGQEmpBDG\
opAgA3AwAgAUG4ImpBGGoiCCABQZASakEcaikCADcDACABIAEpApQSNwO4IiABQZASaiABQdABEDoa\
IAEgASkD0BIgAUHYE2otAAAiBq18NwPQEiABQdgSaiEPAkAgBkGAAUYNACAPIAZqQQBBgAEgBmsQPB\
oLIAFBADoA2BMgAUGQEmogD0J/EBIgAyANKQMANwMAIAogDCkDADcDACACIAspAwA3AwAgECABKQOw\
EjcDACABQfgOakEoaiABQZASakEoaikDADcDACABQfgOakEwaiABQZASakEwaikDADcDACABQfgOak\
E4aiABQZASakE4aikDADcDACABIAEpA5ASNwP4DiAHIAMpAwA3AwAgDiAKKQMANwMAIAggAikDADcD\
ACABIAEpA/gONwO4IkEgEBciBkUNHCAGIAEpA7giNwAAIAZBGGogAUG4ImpBGGopAwA3AAAgBkEQai\
ABQbgiakEQaikDADcAACAGQQhqIAFBuCJqQQhqKQMANwAAQSAhAwwZCyAEIAVB0AEQOiIBQfgOakEs\
akIANwIAIAFB+A5qQSRqQgA3AgAgAUH4DmpBHGpCADcCACABQfgOakEUakIANwIAIAFB+A5qQQxqQg\
A3AgAgAUIANwL8DiABQTA2AvgOIAFBkBJqQShqIg0gAUH4DmpBKGoiAikDADcDACABQZASakEgaiAB\
QfgOakEgaiIKKQMANwMAIAFBkBJqQRhqIhAgAUH4DmpBGGoiAykDADcDACABQZASakEQaiIOIAFB+A\
5qQRBqIg8pAwA3AwAgAUGQEmpBCGoiByABQfgOakEIaiILKQMANwMAIAFBkBJqQTBqIgggAUH4DmpB\
MGoiCSgCADYCACABIAEpA/gONwOQEiABQbgiakEgaiIRIAFBkBJqQSRqKQIANwMAIAFBuCJqQRhqIh\
IgAUGQEmpBHGopAgA3AwAgAUG4ImpBEGoiEyABQZASakEUaikCADcDACABQbgiakEIaiIUIAFBkBJq\
QQxqKQIANwMAIAFBuCJqQShqIhUgAUGQEmpBLGopAgA3AwAgASABKQKUEjcDuCIgAUGQEmogAUHQAR\
A6GiABIAEpA9ASIAFB2BNqLQAAIgatfDcD0BIgAUHYEmohDAJAIAZBgAFGDQAgDCAGakEAQYABIAZr\
EDwaCyABQQA6ANgTIAFBkBJqIAxCfxASIAsgBykDADcDACAPIA4pAwA3AwAgAyAQKQMANwMAIAogAS\
kDsBI3AwAgAiANKQMANwMAIAkgCCkDADcDACABQfgOakE4aiABQZASakE4aikDADcDACABIAEpA5AS\
NwP4DiAUIAspAwA3AwAgEyAPKQMANwMAIBIgAykDADcDACARIAopAwA3AwAgFSACKQMANwMAIAEgAS\
kD+A43A7giQTAQFyIGRQ0cIAYgASkDuCI3AAAgBkEoaiABQbgiakEoaikDADcAACAGQSBqIAFBuCJq\
QSBqKQMANwAAIAZBGGogAUG4ImpBGGopAwA3AAAgBkEQaiABQbgiakEQaikDADcAACAGQQhqIAFBuC\
JqQQhqKQMANwAAQTAhAwwYCyAEIAVB8AAQOiIBQfgOakEcakIANwIAIAFB+A5qQRRqQgA3AgAgAUH4\
DmpBDGpCADcCACABQgA3AvwOIAFBIDYC+A4gAUGQEmpBGGoiCiABQfgOakEYaikDADcDACABQZASak\
EQaiIDIAFB+A5qQRBqKQMANwMAIAFBkBJqQQhqIAFB+A5qQQhqIg8pAwA3AwAgAUGQEmpBIGoiCyAB\
QfgOakEgaigCADYCACABIAEpA/gONwOQEiABQegjakEQaiIMIAFBkBJqQRRqKQIANwMAIAFB6CNqQQ\
hqIg0gAUGQEmpBDGopAgA3AwAgAUHoI2pBGGoiECABQZASakEcaikCADcDACABIAEpApQSNwPoIyAB\
QZASaiABQfAAEDoaIAEgASkDkBIgAUH4EmotAAAiBq18NwOQEiABQbgSaiECAkAgBkHAAEYNACACIA\
ZqQQBBwAAgBmsQPBoLIAFBADoA+BIgAUGQEmogAkF/EBQgDyADKQMAIhY3AwAgDSAWNwMAIAwgCikD\
ADcDACAQIAspAwA3AwAgASABKQOYEiIWNwP4DiABIBY3A+gjQSAQFyIGRQ0cIAYgASkD6CM3AAAgBk\
EYaiABQegjakEYaikDADcAACAGQRBqIAFB6CNqQRBqKQMANwAAIAZBCGogAUHoI2pBCGopAwA3AABB\
ICEDDBcLIAQgBUH4DhA6IQEgA0EASA0SAkACQCADDQBBASEGDAELIAMQFyIGRQ0dIAZBfGotAABBA3\
FFDQAgBkEAIAMQPBoLIAFBkBJqIAFB+A4QOhogAUH4DmogAUGQEmoQJCABQfgOaiAGIAMQGQwWCyAE\
IAVB4AIQOiIKQZASaiAKQeACEDoaIApBkBJqIApB6BRqLQAAIgFqQcgBaiECAkAgAUGQAUYNACACQQ\
BBkAEgAWsQPBoLQQAhBiAKQQA6AOgUIAJBAToAACAKQecUaiIBIAEtAABBgAFyOgAAA0AgCkGQEmog\
BmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgIgAi0AACABQckBai0AAHM6AAAgAUECaiICIAItAA\
AgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIAFBywFqLQAAczoAACAGQQRqIgZBkAFHDQALIApBkBJq\
ECUgCkH4DmpBGGoiASAKQZASakEYaigCADYCACAKQfgOakEQaiICIApBkBJqQRBqKQMANwMAIApB+A\
5qQQhqIg8gCkGQEmpBCGopAwA3AwAgCiAKKQOQEjcD+A5BHCEDQRwQFyIGRQ0cIAYgCikD+A43AAAg\
BkEYaiABKAIANgAAIAZBEGogAikDADcAACAGQQhqIA8pAwA3AAAMFQsgBCAFQdgCEDoiCkGQEmogCk\
HYAhA6GiAKQZASaiAKQeAUai0AACIBakHIAWohAgJAIAFBiAFGDQAgAkEAQYgBIAFrEDwaC0EAIQYg\
CkEAOgDgFCACQQE6AAAgCkHfFGoiASABLQAAQYABcjoAAANAIApBkBJqIAZqIgEgAS0AACABQcgBai\
0AAHM6AAAgAUEBaiICIAItAAAgAUHJAWotAABzOgAAIAFBAmoiAiACLQAAIAFBygFqLQAAczoAACAB\
QQNqIgIgAi0AACABQcsBai0AAHM6AAAgBkEEaiIGQYgBRw0ACyAKQZASahAlIApB+A5qQRhqIgEgCk\
GQEmpBGGopAwA3AwAgCkH4DmpBEGoiAiAKQZASakEQaikDADcDACAKQfgOakEIaiIPIApBkBJqQQhq\
KQMANwMAIAogCikDkBI3A/gOQSAhA0EgEBciBkUNHCAGIAopA/gONwAAIAZBGGogASkDADcAACAGQR\
BqIAIpAwA3AAAgBkEIaiAPKQMANwAADBQLIAQgBUG4AhA6IgpBkBJqIApBuAIQOhogCkGQEmogCkHA\
FGotAAAiAWpByAFqIQICQCABQegARg0AIAJBAEHoACABaxA8GgtBACEGIApBADoAwBQgAkEBOgAAIA\
pBvxRqIgEgAS0AAEGAAXI6AAADQCAKQZASaiAGaiIBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAiAC\
LQAAIAFByQFqLQAAczoAACABQQJqIgIgAi0AACABQcoBai0AAHM6AAAgAUEDaiICIAItAAAgAUHLAW\
otAABzOgAAIAZBBGoiBkHoAEcNAAsgCkGQEmoQJSAKQfgOakEoaiIBIApBkBJqQShqKQMANwMAIApB\
+A5qQSBqIgIgCkGQEmpBIGopAwA3AwAgCkH4DmpBGGoiDyAKQZASakEYaikDADcDACAKQfgOakEQai\
ILIApBkBJqQRBqKQMANwMAIApB+A5qQQhqIgwgCkGQEmpBCGopAwA3AwAgCiAKKQOQEjcD+A5BMCED\
QTAQFyIGRQ0cIAYgCikD+A43AAAgBkEoaiABKQMANwAAIAZBIGogAikDADcAACAGQRhqIA8pAwA3AA\
AgBkEQaiALKQMANwAAIAZBCGogDCkDADcAAAwTCyAEIAVBmAIQOiIKQZASaiAKQZgCEDoaIApBkBJq\
IApBoBRqLQAAIgFqQcgBaiECAkAgAUHIAEYNACACQQBByAAgAWsQPBoLQQAhBiAKQQA6AKAUIAJBAT\
oAACAKQZ8UaiIBIAEtAABBgAFyOgAAA0AgCkGQEmogBmoiASABLQAAIAFByAFqLQAAczoAACABQQFq\
IgIgAi0AACABQckBai0AAHM6AAAgAUECaiICIAItAAAgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIA\
FBywFqLQAAczoAACAGQQRqIgZByABHDQALIApBkBJqECUgCkH4DmpBOGoiASAKQZASakE4aikDADcD\
ACAKQfgOakEwaiICIApBkBJqQTBqKQMANwMAIApB+A5qQShqIg8gCkGQEmpBKGopAwA3AwAgCkH4Dm\
pBIGoiCyAKQZASakEgaikDADcDACAKQfgOakEYaiIMIApBkBJqQRhqKQMANwMAIApB+A5qQRBqIg0g\
CkGQEmpBEGopAwA3AwAgCkH4DmpBCGoiECAKQZASakEIaikDADcDACAKIAopA5ASNwP4DkHAACEDQc\
AAEBciBkUNHCAGIAopA/gONwAAIAZBOGogASkDADcAACAGQTBqIAIpAwA3AAAgBkEoaiAPKQMANwAA\
IAZBIGogCykDADcAACAGQRhqIAwpAwA3AAAgBkEQaiANKQMANwAAIAZBCGogECkDADcAAAwSCyAEIA\
VB4AAQOiIBQfgOakEMakIANwIAIAFCADcC/A5BECEDIAFBEDYC+A4gAUGQEmpBEGogAUH4DmpBEGoo\
AgA2AgAgAUGQEmpBCGogAUH4DmpBCGopAwA3AwAgAUHoI2pBCGoiAiABQZASakEMaikCADcDACABIA\
EpA/gONwOQEiABIAEpApQSNwPoIyABQZASaiABQeAAEDoaIAFBkBJqIAFBqBJqIAFB6CNqEDBBEBAX\
IgZFDRwgBiABKQPoIzcAACAGQQhqIAIpAwA3AAAMEQsgBCAFQeAAEDoiAUH4DmpBDGpCADcCACABQg\
A3AvwOQRAhAyABQRA2AvgOIAFBkBJqQRBqIAFB+A5qQRBqKAIANgIAIAFBkBJqQQhqIAFB+A5qQQhq\
KQMANwMAIAFB6CNqQQhqIgIgAUGQEmpBDGopAgA3AwAgASABKQP4DjcDkBIgASABKQKUEjcD6CMgAU\
GQEmogAUHgABA6GiABQZASaiABQagSaiABQegjahAvQRAQFyIGRQ0cIAYgASkD6CM3AAAgBkEIaiAC\
KQMANwAADBALQRQhAyAEIAVB6AAQOiIBQfgOakEUakEANgIAIAFB+A5qQQxqQgA3AgAgAUEANgL4Di\
ABQgA3AvwOIAFBFDYC+A4gAUGQEmpBEGogAUH4DmpBEGopAwA3AwAgAUGQEmpBCGogAUH4DmpBCGop\
AwA3AwAgAUHoI2pBCGoiAiABQZASakEMaikCADcDACABQegjakEQaiIKIAFBkBJqQRRqKAIANgIAIA\
EgASkD+A43A5ASIAEgASkClBI3A+gjIAFBkBJqIAFB6AAQOhogAUGQEmogAUGwEmogAUHoI2oQLkEU\
EBciBkUNHCAGIAEpA+gjNwAAIAZBEGogCigCADYAACAGQQhqIAIpAwA3AAAMDwtBFCEDIAQgBUHoAB\
A6IgFB+A5qQRRqQQA2AgAgAUH4DmpBDGpCADcCACABQQA2AvgOIAFCADcC/A4gAUEUNgL4DiABQZAS\
akEQaiABQfgOakEQaikDADcDACABQZASakEIaiABQfgOakEIaikDADcDACABQegjakEIaiICIAFBkB\
JqQQxqKQIANwMAIAFB6CNqQRBqIgogAUGQEmpBFGooAgA2AgAgASABKQP4DjcDkBIgASABKQKUEjcD\
6CMgAUGQEmogAUHoABA6GiABQZASaiABQbASaiABQegjahApQRQQFyIGRQ0cIAYgASkD6CM3AAAgBk\
EQaiAKKAIANgAAIAZBCGogAikDADcAAAwOCyAEIAVB4AIQOiIKQZASaiAKQeACEDoaIApBkBJqIApB\
6BRqLQAAIgFqQcgBaiECAkAgAUGQAUYNACACQQBBkAEgAWsQPBoLQQAhBiAKQQA6AOgUIAJBBjoAAC\
AKQecUaiIBIAEtAABBgAFyOgAAA0AgCkGQEmogBmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgIg\
Ai0AACABQckBai0AAHM6AAAgAUECaiICIAItAAAgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIAFByw\
FqLQAAczoAACAGQQRqIgZBkAFHDQALIApBkBJqECUgCkH4DmpBGGoiASAKQZASakEYaigCADYCACAK\
QfgOakEQaiICIApBkBJqQRBqKQMANwMAIApB+A5qQQhqIg8gCkGQEmpBCGopAwA3AwAgCiAKKQOQEj\
cD+A5BHCEDQRwQFyIGRQ0cIAYgCikD+A43AAAgBkEYaiABKAIANgAAIAZBEGogAikDADcAACAGQQhq\
IA8pAwA3AAAMDQsgBCAFQdgCEDoiCkGQEmogCkHYAhA6GiAKQZASaiAKQeAUai0AACIBakHIAWohAg\
JAIAFBiAFGDQAgAkEAQYgBIAFrEDwaC0EAIQYgCkEAOgDgFCACQQY6AAAgCkHfFGoiASABLQAAQYAB\
cjoAAANAIApBkBJqIAZqIgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiICIAItAAAgAUHJAWotAABzOg\
AAIAFBAmoiAiACLQAAIAFBygFqLQAAczoAACABQQNqIgIgAi0AACABQcsBai0AAHM6AAAgBkEEaiIG\
QYgBRw0ACyAKQZASahAlIApB+A5qQRhqIgEgCkGQEmpBGGopAwA3AwAgCkH4DmpBEGoiAiAKQZASak\
EQaikDADcDACAKQfgOakEIaiIPIApBkBJqQQhqKQMANwMAIAogCikDkBI3A/gOQSAhA0EgEBciBkUN\
HCAGIAopA/gONwAAIAZBGGogASkDADcAACAGQRBqIAIpAwA3AAAgBkEIaiAPKQMANwAADAwLIAQgBU\
G4AhA6IgpBkBJqIApBuAIQOhogCkGQEmogCkHAFGotAAAiAWpByAFqIQICQCABQegARg0AIAJBAEHo\
ACABaxA8GgtBACEGIApBADoAwBQgAkEGOgAAIApBvxRqIgEgAS0AAEGAAXI6AAADQCAKQZASaiAGai\
IBIAEtAAAgAUHIAWotAABzOgAAIAFBAWoiAiACLQAAIAFByQFqLQAAczoAACABQQJqIgIgAi0AACAB\
QcoBai0AAHM6AAAgAUEDaiICIAItAAAgAUHLAWotAABzOgAAIAZBBGoiBkHoAEcNAAsgCkGQEmoQJS\
AKQfgOakEoaiIBIApBkBJqQShqKQMANwMAIApB+A5qQSBqIgIgCkGQEmpBIGopAwA3AwAgCkH4DmpB\
GGoiDyAKQZASakEYaikDADcDACAKQfgOakEQaiILIApBkBJqQRBqKQMANwMAIApB+A5qQQhqIgwgCk\
GQEmpBCGopAwA3AwAgCiAKKQOQEjcD+A5BMCEDQTAQFyIGRQ0cIAYgCikD+A43AAAgBkEoaiABKQMA\
NwAAIAZBIGogAikDADcAACAGQRhqIA8pAwA3AAAgBkEQaiALKQMANwAAIAZBCGogDCkDADcAAAwLCy\
AEIAVBmAIQOiIKQZASaiAKQZgCEDoaIApBkBJqIApBoBRqLQAAIgFqQcgBaiECAkAgAUHIAEYNACAC\
QQBByAAgAWsQPBoLQQAhBiAKQQA6AKAUIAJBBjoAACAKQZ8UaiIBIAEtAABBgAFyOgAAA0AgCkGQEm\
ogBmoiASABLQAAIAFByAFqLQAAczoAACABQQFqIgIgAi0AACABQckBai0AAHM6AAAgAUECaiICIAIt\
AAAgAUHKAWotAABzOgAAIAFBA2oiAiACLQAAIAFBywFqLQAAczoAACAGQQRqIgZByABHDQALIApBkB\
JqECUgCkH4DmpBOGoiASAKQZASakE4aikDADcDACAKQfgOakEwaiICIApBkBJqQTBqKQMANwMAIApB\
+A5qQShqIg8gCkGQEmpBKGopAwA3AwAgCkH4DmpBIGoiCyAKQZASakEgaikDADcDACAKQfgOakEYai\
IMIApBkBJqQRhqKQMANwMAIApB+A5qQRBqIg0gCkGQEmpBEGopAwA3AwAgCkH4DmpBCGoiECAKQZAS\
akEIaikDADcDACAKIAopA5ASNwP4DkHAACEDQcAAEBciBkUNHCAGIAopA/gONwAAIAZBOGogASkDAD\
cAACAGQTBqIAIpAwA3AAAgBkEoaiAPKQMANwAAIAZBIGogCykDADcAACAGQRhqIAwpAwA3AAAgBkEQ\
aiANKQMANwAAIAZBCGogECkDADcAAAwKCyAEIAVB8AAQOiIBQZASaiABQfAAEDoaQRwhAyABQegjak\
EcakIANwIAIAFB6CNqQRRqQgA3AgAgAUHoI2pBDGpCADcCACABQgA3AuwjIAFBIDYC6CMgAUH4DmpB\
GGoiAiABQegjakEYaikDADcDACABQfgOakEQaiIKIAFB6CNqQRBqKQMANwMAIAFB+A5qQQhqIg8gAU\
HoI2pBCGopAwA3AwAgAUH4DmpBIGogAUHoI2pBIGooAgA2AgAgASABKQPoIzcD+A4gAUG4ImpBEGoi\
BiABQfgOakEUaikCADcDACABQbgiakEIaiILIAFB+A5qQQxqKQIANwMAIAFBuCJqQRhqIgwgAUH4Dm\
pBHGopAgA3AwAgASABKQL8DjcDuCIgAUGQEmogAUG4EmogAUG4ImoQKCACIAwoAgA2AgAgCiAGKQMA\
NwMAIA8gCykDADcDACABIAEpA7giNwP4DkEcEBciBkUNHCAGIAEpA/gONwAAIAZBGGogAigCADYAAC\
AGQRBqIAopAwA3AAAgBkEIaiAPKQMANwAADAkLIAQgBUHwABA6IgFBkBJqIAFB8AAQOhogAUHoI2pB\
HGpCADcCACABQegjakEUakIANwIAIAFB6CNqQQxqQgA3AgAgAUIANwLsI0EgIQMgAUEgNgLoIyABQf\
gOakEgaiABQegjakEgaigCADYCACABQfgOakEYaiICIAFB6CNqQRhqKQMANwMAIAFB+A5qQRBqIgog\
AUHoI2pBEGopAwA3AwAgAUH4DmpBCGoiDyABQegjakEIaikDADcDACABIAEpA+gjNwP4DiABQbgiak\
EYaiIGIAFB+A5qQRxqKQIANwMAIAFBuCJqQRBqIgsgAUH4DmpBFGopAgA3AwAgAUG4ImpBCGoiDCAB\
QfgOakEMaikCADcDACABIAEpAvwONwO4IiABQZASaiABQbgSaiABQbgiahAoIAIgBikDADcDACAKIA\
spAwA3AwAgDyAMKQMANwMAIAEgASkDuCI3A/gOQSAQFyIGRQ0cIAYgASkD+A43AAAgBkEYaiACKQMA\
NwAAIAZBEGogCikDADcAACAGQQhqIA8pAwA3AAAMCAsgBCAFQdgBEDoiAUGQEmogAUHYARA6GiABQe\
gjakEMakIANwIAIAFB6CNqQRRqQgA3AgAgAUHoI2pBHGpCADcCACABQegjakEkakIANwIAIAFB6CNq\
QSxqQgA3AgAgAUHoI2pBNGpCADcCACABQegjakE8akIANwIAIAFCADcC7CMgAUHAADYC6CMgAUH4Dm\
ogAUHoI2pBxAAQOhogAUHwImogAUH4DmpBPGopAgA3AwBBMCEDIAFBuCJqQTBqIAFB+A5qQTRqKQIA\
NwMAIAFBuCJqQShqIgYgAUH4DmpBLGopAgA3AwAgAUG4ImpBIGoiAiABQfgOakEkaikCADcDACABQb\
giakEYaiIKIAFB+A5qQRxqKQIANwMAIAFBuCJqQRBqIg8gAUH4DmpBFGopAgA3AwAgAUG4ImpBCGoi\
CyABQfgOakEMaikCADcDACABIAEpAvwONwO4IiABQZASaiABQeASaiABQbgiahAjIAFB+A5qQShqIg\
wgBikDADcDACABQfgOakEgaiINIAIpAwA3AwAgAUH4DmpBGGoiAiAKKQMANwMAIAFB+A5qQRBqIgog\
DykDADcDACABQfgOakEIaiIPIAspAwA3AwAgASABKQO4IjcD+A5BMBAXIgZFDRwgBiABKQP4DjcAAC\
AGQShqIAwpAwA3AAAgBkEgaiANKQMANwAAIAZBGGogAikDADcAACAGQRBqIAopAwA3AAAgBkEIaiAP\
KQMANwAADAcLIAQgBUHYARA6IgFBkBJqIAFB2AEQOhogAUHoI2pBDGpCADcCACABQegjakEUakIANw\
IAIAFB6CNqQRxqQgA3AgAgAUHoI2pBJGpCADcCACABQegjakEsakIANwIAIAFB6CNqQTRqQgA3AgAg\
AUHoI2pBPGpCADcCACABQgA3AuwjQcAAIQMgAUHAADYC6CMgAUH4DmogAUHoI2pBxAAQOhogAUG4Im\
pBOGoiBiABQfgOakE8aikCADcDACABQbgiakEwaiICIAFB+A5qQTRqKQIANwMAIAFBuCJqQShqIgog\
AUH4DmpBLGopAgA3AwAgAUG4ImpBIGoiDyABQfgOakEkaikCADcDACABQbgiakEYaiILIAFB+A5qQR\
xqKQIANwMAIAFBuCJqQRBqIgwgAUH4DmpBFGopAgA3AwAgAUG4ImpBCGoiDSABQfgOakEMaikCADcD\
ACABIAEpAvwONwO4IiABQZASaiABQeASaiABQbgiahAjIAFB+A5qQThqIhAgBikDADcDACABQfgOak\
EwaiIOIAIpAwA3AwAgAUH4DmpBKGoiAiAKKQMANwMAIAFB+A5qQSBqIgogDykDADcDACABQfgOakEY\
aiIPIAspAwA3AwAgAUH4DmpBEGoiCyAMKQMANwMAIAFB+A5qQQhqIgwgDSkDADcDACABIAEpA7giNw\
P4DkHAABAXIgZFDRwgBiABKQP4DjcAACAGQThqIBApAwA3AAAgBkEwaiAOKQMANwAAIAZBKGogAikD\
ADcAACAGQSBqIAopAwA3AAAgBkEYaiAPKQMANwAAIAZBEGogCykDADcAACAGQQhqIAwpAwA3AAAMBg\
sgBEH4DmogBUH4AhA6GiADQQBIDQECQAJAIAMNAEEBIQYMAQsgAxAXIgZFDR0gBkF8ai0AAEEDcUUN\
ACAGQQAgAxA8GgsgBEGQEmogBEH4DmpB+AIQOhogBCAEQfgOakHIARA6Ig9ByAFqIA9BkBJqQcgBak\
GpARA6IQEgD0HoI2ogD0H4DmpByAEQOhogD0GIIWogAUGpARA6GiAPQYghaiAPLQCwIiIBaiEKAkAg\
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\
IQggDCAFfCEFIB8gBHwhBCABQYABaiIBIAJHDQALCyAAIAQ3AzggACAFNwMwIAAgBjcDKCAAIAc3Ay\
AgACAINwMYIAAgCTcDECAAIAo3AwggACALNwMAIANBgAFqJAAL+FsCDH8FfiMAQYAGayIEJAACQAJA\
AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAIOAgABAgsgASgCACICQQJ0QbTTwA\
BqKAIAIQMMEQtBICEFIAEoAgAiAg4YAQ8CDxADDwQFBgYHBwgPCQoLDwwNEBAOAQsgASgCACECDA8L\
QcAAIQUMDQtBMCEFDAwLQRwhBQwLC0EwIQUMCgtBwAAhBQwJC0EQIQUMCAtBFCEFDAcLQRwhBQwGC0\
EwIQUMBQtBwAAhBQwEC0EcIQUMAwtBMCEFDAILQcAAIQUMAQtBGCEFCyAFIANGDQBBASEBQTkhA0Gt\
gcAAIQIMAQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQA\
JAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAg4YAAEC\
AwQFBgcICQoLDA0ODxAREhMUFRYaAAsgASgCBCECIARB0ARqQQxqQgA3AgAgBEHQBGpBFGpCADcCAC\
AEQdAEakEcakIANwIAIARB0ARqQSRqQgA3AgAgBEHQBGpBLGpCADcCACAEQdAEakE0akIANwIAIARB\
0ARqQTxqQgA3AgAgBEIANwLUBCAEQcAANgLQBCAEQShqIARB0ARqQcQAEDoaIARBoANqQThqIgYgBE\
EoakE8aikCADcDACAEQaADakEwaiIHIARBKGpBNGopAgA3AwAgBEGgA2pBKGoiCCAEQShqQSxqKQIA\
NwMAIARBoANqQSBqIgkgBEEoakEkaikCADcDACAEQaADakEYaiIKIARBKGpBHGopAgA3AwAgBEGgA2\
pBEGoiCyAEQShqQRRqKQIANwMAIARBoANqQQhqIgwgBEEoakEMaikCADcDACAEIAQpAiw3A6ADIAIg\
AikDQCACQcgBaiIDLQAAIgGtfDcDQCACQcgAaiEFAkAgAUGAAUYNACAFIAFqQQBBgAEgAWsQPBoLQQ\
AhASADQQA6AAAgAiAFQn8QEiAEQShqQQhqIgUgAkEIaikDACIQNwMAIARBKGpBEGogAkEQaikDACIR\
NwMAIARBKGpBGGogAkEYaikDACISNwMAIARBKGpBIGogAikDICITNwMAIARBKGpBKGogAkEoaikDAC\
IUNwMAIAwgEDcDACALIBE3AwAgCiASNwMAIAkgEzcDACAIIBQ3AwAgByACQTBqKQMANwMAIAYgAkE4\
aikDADcDACAEIAIpAwAiEDcDKCAEIBA3A6ADIAVBwAAQUSACIAVByAAQOhogA0EAOgAAQcAAEBciAk\
UNGiACIAQpA6ADNwAAIAJBOGogBEGgA2pBOGopAwA3AAAgAkEwaiAEQaADakEwaikDADcAACACQShq\
IARBoANqQShqKQMANwAAIAJBIGogBEGgA2pBIGopAwA3AAAgAkEYaiAEQaADakEYaikDADcAACACQR\
BqIARBoANqQRBqKQMANwAAIAJBCGogBEGgA2pBCGopAwA3AABBwAAhAwwyCyABKAIEIQIgBEHQBGpB\
HGpCADcCACAEQdAEakEUakIANwIAIARB0ARqQQxqQgA3AgAgBEIANwLUBCAEQSA2AtAEIARBKGpBGG\
oiByAEQdAEakEYaikDADcDACAEQShqQRBqIgggBEHQBGpBEGopAwA3AwAgBEEoakEIaiIDIARB0ARq\
QQhqKQMANwMAIARBKGpBIGoiCSAEQdAEakEgaigCADYCACAEIAQpA9AENwMoIARBoANqQRBqIgogBE\
EoakEUaikCADcDACAEQaADakEIaiILIARBKGpBDGopAgA3AwAgBEGgA2pBGGoiDCAEQShqQRxqKQIA\
NwMAIAQgBCkCLDcDoAMgAiACKQNAIAJByAFqIgUtAAAiAa18NwNAIAJByABqIQYCQCABQYABRg0AIA\
YgAWpBAEGAASABaxA8GgtBACEBIAVBADoAACACIAZCfxASIAMgAkEIaikDACIQNwMAIAggAkEQaikD\
ACIRNwMAIAcgAkEYaikDACISNwMAIAkgAikDIDcDACAEQShqQShqIAJBKGopAwA3AwAgCyAQNwMAIA\
ogETcDACAMIBI3AwAgBCACKQMAIhA3AyggBCAQNwOgAyADQSAQUSACIANByAAQOhogBUEAOgAAQSAQ\
FyICRQ0aIAIgBCkDoAM3AAAgAkEYaiAEQaADakEYaikDADcAACACQRBqIARBoANqQRBqKQMANwAAIA\
JBCGogBEGgA2pBCGopAwA3AABBICEDDDELIAEoAgQhAiAEQdAEakEsakIANwIAIARB0ARqQSRqQgA3\
AgAgBEHQBGpBHGpCADcCACAEQdAEakEUakIANwIAIARB0ARqQQxqQgA3AgAgBEIANwLUBCAEQTA2At\
AEIARBKGpBKGoiByAEQdAEakEoaikDADcDACAEQShqQSBqIgggBEHQBGpBIGopAwA3AwAgBEEoakEY\
aiIJIARB0ARqQRhqKQMANwMAIARBKGpBEGoiCiAEQdAEakEQaikDADcDACAEQShqQQhqIgMgBEHQBG\
pBCGopAwA3AwAgBEEoakEwaiAEQdAEakEwaigCADYCACAEIAQpA9AENwMoIARBoANqQSBqIgsgBEEo\
akEkaikCADcDACAEQaADakEYaiIMIARBKGpBHGopAgA3AwAgBEGgA2pBEGoiDSAEQShqQRRqKQIANw\
MAIARBoANqQQhqIg4gBEEoakEMaikCADcDACAEQaADakEoaiIPIARBKGpBLGopAgA3AwAgBCAEKQIs\
NwOgAyACIAIpA0AgAkHIAWoiBS0AACIBrXw3A0AgAkHIAGohBgJAIAFBgAFGDQAgBiABakEAQYABIA\
FrEDwaC0EAIQEgBUEAOgAAIAIgBkJ/EBIgAyACQQhqKQMAIhA3AwAgCiACQRBqKQMAIhE3AwAgCSAC\
QRhqKQMAIhI3AwAgCCACKQMgIhM3AwAgByACQShqKQMAIhQ3AwAgDiAQNwMAIA0gETcDACAMIBI3Aw\
AgCyATNwMAIA8gFDcDACAEIAIpAwAiEDcDKCAEIBA3A6ADIANBMBBRIAIgA0HIABA6GiAFQQA6AABB\
MBAXIgJFDRogAiAEKQOgAzcAACACQShqIARBoANqQShqKQMANwAAIAJBIGogBEGgA2pBIGopAwA3AA\
AgAkEYaiAEQaADakEYaikDADcAACACQRBqIARBoANqQRBqKQMANwAAIAJBCGogBEGgA2pBCGopAwA3\
AABBMCEDDDALIAEoAgQhAiAEQdAEakEcakIANwIAIARB0ARqQRRqQgA3AgAgBEHQBGpBDGpCADcCAC\
AEQgA3AtQEIARBIDYC0AQgBEEoakEYaiIHIARB0ARqQRhqKQMANwMAIARBKGpBEGoiCCAEQdAEakEQ\
aikDADcDACAEQShqQQhqIgMgBEHQBGpBCGopAwA3AwAgBEEoakEgaiIJIARB0ARqQSBqKAIANgIAIA\
QgBCkD0AQ3AyggBEGgA2pBEGoiCiAEQShqQRRqKQIANwMAIARBoANqQQhqIgsgBEEoakEMaikCADcD\
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\
LQAAczoAACABQQNqIgMgAy0AACABQcsBai0AAHM6AAAgAkEEaiICQcgARw0ACyAFECUgBEEoakE4ai\
IGIAVBOGopAAA3AwAgBEEoakEwaiIHIAVBMGopAAA3AwAgBEEoakEoaiIIIAVBKGopAAA3AwAgBEEo\
akEgaiIJIAVBIGopAAA3AwAgBEEoakEYaiIKIAVBGGopAAA3AwAgBEEoakEQaiILIAVBEGopAAA3Aw\
AgBEEoakEIaiIMIAVBCGopAAA3AwAgBCAFKQAANwMoQQAhASAFQQBByAEQPEGQAmpBADoAAEHAACED\
QcAAEBciAkUNGiACIAQpAyg3AAAgAkE4aiAGKQMANwAAIAJBMGogBykDADcAACACQShqIAgpAwA3AA\
AgAkEgaiAJKQMANwAAIAJBGGogCikDADcAACACQRBqIAspAwA3AAAgAkEIaiAMKQMANwAADCoLIAEo\
AgQhAiAEQdAEakEMakIANwIAIARCADcC1ARBECEDIARBEDYC0AQgBEEoakEQaiAEQdAEakEQaigCAD\
YCACAEQShqQQhqIARB0ARqQQhqKQMANwMAIARBoANqQQhqIgUgBEEoakEMaikCADcDACAEIAQpA9AE\
NwMoIAQgBCkCLDcDoAMgAiACQRhqIARBoANqEDBBACEBIAJB2ABqQQA6AAAgAkEQakL+uevF6Y6VmR\
A3AwAgAkKBxpS6lvHq5m83AwggAkIANwMAQRAQFyICRQ0aIAIgBCkDoAM3AAAgAkEIaiAFKQMANwAA\
DCkLIAEoAgQhAiAEQdAEakEMakIANwIAIARCADcC1ARBECEDIARBEDYC0AQgBEEoakEQaiAEQdAEak\
EQaigCADYCACAEQShqQQhqIARB0ARqQQhqKQMANwMAIARBoANqQQhqIgUgBEEoakEMaikCADcDACAE\
IAQpA9AENwMoIAQgBCkCLDcDoAMgAiACQRhqIARBoANqEC9BACEBIAJB2ABqQQA6AAAgAkEQakL+ue\
vF6Y6VmRA3AwAgAkKBxpS6lvHq5m83AwggAkIANwMAQRAQFyICRQ0aIAIgBCkDoAM3AAAgAkEIaiAF\
KQMANwAADCgLIAEoAgQhAkEUIQNBACEBIARB0ARqQRRqQQA2AgAgBEHQBGpBDGpCADcCACAEQgA3At\
QEIARBFDYC0AQgBEEoakEQaiAEQdAEakEQaikDADcDACAEQShqQQhqIARB0ARqQQhqKQMANwMAIARB\
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\
IAQgBCkD0AQ3AyggBEGgA2pBGGoiASAEQShqQRxqKQIANwMAIARBoANqQRBqIgggBEEoakEUaikCAD\
cDACAEQaADakEIaiIJIARBKGpBDGopAgA3AwAgBCAEKQIsNwOgAyACIAJBKGogBEGgA2oQKCAFIAEp\
AwA3AwAgBiAIKQMANwMAIAcgCSkDADcDACAEIAQpA6ADNwMoIAJCADcDAEEAIQEgAkHoAGpBADoAAC\
ACQQApA/CNQDcDCCACQRBqQQApA/iNQDcDACACQRhqQQApA4COQDcDACACQSBqQQApA4iOQDcDAEEg\
EBciAkUNGiACIAQpAyg3AAAgAkEYaiAFKQMANwAAIAJBEGogBikDADcAACACQQhqIAcpAwA3AAAMIA\
sgASgCBCECIARB0ARqQQxqQgA3AgAgBEHQBGpBFGpCADcCACAEQdAEakEcakIANwIAIARB0ARqQSRq\
QgA3AgAgBEHQBGpBLGpCADcCACAEQdAEakE0akIANwIAIARB0ARqQTxqQgA3AgAgBEIANwLUBCAEQc\
AANgLQBCAEQShqIARB0ARqQcQAEDoaIARBoANqQThqIARBKGpBPGopAgA3AwBBMCEDIARBoANqQTBq\
IARBKGpBNGopAgA3AwAgBEGgA2pBKGoiASAEQShqQSxqKQIANwMAIARBoANqQSBqIgUgBEEoakEkai\
kCADcDACAEQaADakEYaiIGIARBKGpBHGopAgA3AwAgBEGgA2pBEGoiByAEQShqQRRqKQIANwMAIARB\
oANqQQhqIgggBEEoakEMaikCADcDACAEIAQpAiw3A6ADIAIgAkHQAGogBEGgA2oQIyAEQShqQShqIg\
kgASkDADcDACAEQShqQSBqIgogBSkDADcDACAEQShqQRhqIgUgBikDADcDACAEQShqQRBqIgYgBykD\
ADcDACAEQShqQQhqIgcgCCkDADcDACAEIAQpA6ADNwMoIAJByABqQgA3AwAgAkIANwNAQQAhASACQT\
hqQQApA6iPQDcDACACQTBqQQApA6CPQDcDACACQShqQQApA5iPQDcDACACQSBqQQApA5CPQDcDACAC\
QRhqQQApA4iPQDcDACACQRBqQQApA4CPQDcDACACQQhqQQApA/iOQDcDACACQQApA/COQDcDACACQd\
ABakEAOgAAQTAQFyICRQ0aIAIgBCkDKDcAACACQShqIAkpAwA3AAAgAkEgaiAKKQMANwAAIAJBGGog\
BSkDADcAACACQRBqIAYpAwA3AAAgAkEIaiAHKQMANwAADB8LIAEoAgQhAiAEQdAEakEMakIANwIAIA\
RB0ARqQRRqQgA3AgAgBEHQBGpBHGpCADcCACAEQdAEakEkakIANwIAIARB0ARqQSxqQgA3AgAgBEHQ\
BGpBNGpCADcCACAEQdAEakE8akIANwIAIARCADcC1ARBwAAhAyAEQcAANgLQBCAEQShqIARB0ARqQc\
QAEDoaIARBoANqQThqIgEgBEEoakE8aikCADcDACAEQaADakEwaiIFIARBKGpBNGopAgA3AwAgBEGg\
A2pBKGoiBiAEQShqQSxqKQIANwMAIARBoANqQSBqIgcgBEEoakEkaikCADcDACAEQaADakEYaiIIIA\
RBKGpBHGopAgA3AwAgBEGgA2pBEGoiCSAEQShqQRRqKQIANwMAIARBoANqQQhqIgogBEEoakEMaikC\
ADcDACAEIAQpAiw3A6ADIAIgAkHQAGogBEGgA2oQIyAEQShqQThqIgsgASkDADcDACAEQShqQTBqIg\
wgBSkDADcDACAEQShqQShqIgUgBikDADcDACAEQShqQSBqIgYgBykDADcDACAEQShqQRhqIgcgCCkD\
ADcDACAEQShqQRBqIgggCSkDADcDACAEQShqQQhqIgkgCikDADcDACAEIAQpA6ADNwMoIAJByABqQg\
A3AwAgAkIANwNAQQAhASACQThqQQApA+iOQDcDACACQTBqQQApA+COQDcDACACQShqQQApA9iOQDcD\
ACACQSBqQQApA9COQDcDACACQRhqQQApA8iOQDcDACACQRBqQQApA8COQDcDACACQQhqQQApA7iOQD\
cDACACQQApA7COQDcDACACQdABakEAOgAAQcAAEBciAkUNGiACIAQpAyg3AAAgAkE4aiALKQMANwAA\
IAJBMGogDCkDADcAACACQShqIAUpAwA3AAAgAkEgaiAGKQMANwAAIAJBGGogBykDADcAACACQRBqIA\
gpAwA3AAAgAkEIaiAJKQMANwAADB4LIANBAEgNASABKAIEIQcCQAJAIAMNAEEBIQIMAQsgAxAXIgJF\
DRsgAkF8ai0AAEEDcUUNACACQQAgAxA8GgsgByAHQfACaiIILQAAIgFqQcgBaiEGAkAgAUGoAUYNAC\
AGQQBBqAEgAWsQPBoLQQAhBSAIQQA6AAAgBkEfOgAAIAdB7wJqIgEgAS0AAEGAAXI6AAADQCAHIAVq\
IgEgAS0AACABQcgBai0AAHM6AAAgAUEBaiIGIAYtAAAgAUHJAWotAABzOgAAIAFBAmoiBiAGLQAAIA\
FBygFqLQAAczoAACABQQNqIgYgBi0AACABQcsBai0AAHM6AAAgBUEEaiIFQagBRw0ACyAHECUgBEEo\
aiAHQcgBEDoaQQAhASAHQQBByAEQPEHwAmpBADoAACAEQQA2AqADIARBoANqQQRyQQBBqAEQPBogBE\
GoATYCoAMgBEHQBGogBEGgA2pBrAEQOhogBEEoakHIAWogBEHQBGpBBHJBqAEQOhogBEEoakHwAmpB\
ADoAACAEQShqIAIgAxAzDB0LIANBAEgNACABKAIEIQcgAw0BQQEhAgwCCxBrAAsgAxAXIgJFDRggAk\
F8ai0AAEEDcUUNACACQQAgAxA8GgsgByAHQdACaiIILQAAIgFqQcgBaiEGAkAgAUGIAUYNACAGQQBB\
iAEgAWsQPBoLQQAhBSAIQQA6AAAgBkEfOgAAIAdBzwJqIgEgAS0AAEGAAXI6AAADQCAHIAVqIgEgAS\
0AACABQcgBai0AAHM6AAAgAUEBaiIGIAYtAAAgAUHJAWotAABzOgAAIAFBAmoiBiAGLQAAIAFBygFq\
LQAAczoAACABQQNqIgYgBi0AACABQcsBai0AAHM6AAAgBUEEaiIFQYgBRw0ACyAHECUgBEEoaiAHQc\
gBEDoaQQAhASAHQQBByAEQPEHQAmpBADoAACAEQQA2AqADIARBoANqQQRyQQBBiAEQPBogBEGIATYC\
oAMgBEHQBGogBEGgA2pBjAEQOhogBEEoakHIAWogBEHQBGpBBHJBiAEQOhogBEEoakHQAmpBADoAAC\
AEQShqIAIgAxA0DBkLIAEoAgQhAiAEQdAEakEUakIANwIAIARB0ARqQQxqQgA3AgAgBEIANwLUBEEY\
IQMgBEEYNgLQBCAEQShqQRBqIARB0ARqQRBqKQMANwMAIARBKGpBCGogBEHQBGpBCGopAwA3AwAgBE\
EoakEYaiAEQdAEakEYaigCADYCACAEQaADakEIaiIFIARBKGpBDGopAgA3AwAgBEGgA2pBEGoiBiAE\
QShqQRRqKQIANwMAIAQgBCkD0AQ3AyggBCAEKQIsNwOgAyACIAJBIGogBEGgA2oQMSACQgA3AwBBAC\
EBIAJB4ABqQQA6AAAgAkEAKQP4kUA3AwggAkEQakEAKQOAkkA3AwAgAkEYakEAKQOIkkA3AwBBGBAX\
IgJFDRcgAiAEKQOgAzcAACACQRBqIAYpAwA3AAAgAkEIaiAFKQMANwAADBgLQcAAQQFBACgC+NRAIg\
RBBCAEGxEFAAALQSBBAUEAKAL41EAiBEEEIAQbEQUAAAtBMEEBQQAoAvjUQCIEQQQgBBsRBQAAC0Eg\
QQFBACgC+NRAIgRBBCAEGxEFAAALIANBAUEAKAL41EAiBEEEIAQbEQUAAAtBHEEBQQAoAvjUQCIEQQ\
QgBBsRBQAAC0EgQQFBACgC+NRAIgRBBCAEGxEFAAALQTBBAUEAKAL41EAiBEEEIAQbEQUAAAtBwABB\
AUEAKAL41EAiBEEEIAQbEQUAAAtBEEEBQQAoAvjUQCIEQQQgBBsRBQAAC0EQQQFBACgC+NRAIgRBBC\
AEGxEFAAALQRRBAUEAKAL41EAiBEEEIAQbEQUAAAtBFEEBQQAoAvjUQCIEQQQgBBsRBQAAC0EcQQFB\
ACgC+NRAIgRBBCAEGxEFAAALQSBBAUEAKAL41EAiBEEEIAQbEQUAAAtBMEEBQQAoAvjUQCIEQQQgBB\
sRBQAAC0HAAEEBQQAoAvjUQCIEQQQgBBsRBQAAC0EcQQFBACgC+NRAIgRBBCAEGxEFAAALQSBBAUEA\
KAL41EAiBEEEIAQbEQUAAAtBMEEBQQAoAvjUQCIEQQQgBBsRBQAAC0HAAEEBQQAoAvjUQCIEQQQgBB\
sRBQAACyADQQFBACgC+NRAIgRBBCAEGxEFAAALIANBAUEAKAL41EAiBEEEIAQbEQUAAAtBGEEBQQAo\
AvjUQCIEQQQgBBsRBQAACyAAIAI2AgQgACABNgIAIABBCGogAzYCACAEQYAGaiQAC5xWAhp/An4jAE\
GwAmsiAyQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC\
QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAk\
ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCAA4YAAECAwQFBgcICQoLDA0O\
DxAREhMUFRYXAAsgACgCBCIAQcgAaiEEAkBBgAEgAEHIAWotAAAiBWsiBiACTw0AAkAgBUUNACAEIA\
VqIAEgBhA6GiAAIAApA0BCgAF8NwNAIAAgBEIAEBIgASAGaiEBIAIgBmshAgsgAiACQQd2IgYgAkEA\
RyACQf8AcUVxIgdrIgVBB3QiCGshAiAFRQ1FIAhFDUUgBkEAIAdrakEHdCEGIAEhBQNAIAAgACkDQE\
KAAXw3A0AgACAFQgAQEiAFQYABaiEFIAZBgH9qIgYNAAxGCwsgBCAFaiABIAIQOhogBSACaiECDEUL\
IAAoAgQiAEHIAGohBAJAQYABIABByAFqLQAAIgVrIgYgAk8NAAJAIAVFDQAgBCAFaiABIAYQOhogAC\
AAKQNAQoABfDcDQCAAIARCABASIAEgBmohASACIAZrIQILIAIgAkEHdiIGIAJBAEcgAkH/AHFFcSIH\
ayIFQQd0IghrIQIgBUUNQSAIRQ1BIAZBACAHa2pBB3QhBiABIQUDQCAAIAApA0BCgAF8NwNAIAAgBU\
IAEBIgBUGAAWohBSAGQYB/aiIGDQAMQgsLIAQgBWogASACEDoaIAUgAmohAgxBCyAAKAIEIgBByABq\
IQQCQEGAASAAQcgBai0AACIFayIGIAJPDQACQCAFRQ0AIAQgBWogASAGEDoaIAAgACkDQEKAAXw3A0\
AgACAEQgAQEiABIAZqIQEgAiAGayECCyACIAJBB3YiBiACQQBHIAJB/wBxRXEiB2siBUEHdCIIayEC\
IAVFDT0gCEUNPSAGQQAgB2tqQQd0IQYgASEFA0AgACAAKQNAQoABfDcDQCAAIAVCABASIAVBgAFqIQ\
UgBkGAf2oiBg0ADD4LCyAEIAVqIAEgAhA6GiAFIAJqIQIMPQsgACgCBCIAQShqIQQCQEHAACAAQegA\
ai0AACIFayIGIAJPDQACQCAFRQ0AIAQgBWogASAGEDoaIAAgACkDAELAAHw3AwAgACAEQQAQFCABIA\
ZqIQEgAiAGayECCyACIAJBBnYiBiACQQBHIAJBP3FFcSIHayIFQQZ0IghrIQIgBUUNOSAIRQ05IAZB\
ACAHa2pBBnQhBiABIQUDQCAAIAApAwBCwAB8NwMAIAAgBUEAEBQgBUHAAGohBSAGQUBqIgYNAAw6Cw\
sgBCAFaiABIAIQOhogBSACaiECDDkLIAAoAgQiCEHpAGotAABBBnQgCC0AaGoiAEUNNiAIIAEgAkGA\
CCAAayIAIAAgAksbIgUQNRogAiAFayICRQ1CIANB+ABqQRBqIAhBEGoiACkDADcDACADQfgAakEYai\
AIQRhqIgYpAwA3AwAgA0H4AGpBIGogCEEgaiIEKQMANwMAIANB+ABqQTBqIAhBMGopAwA3AwAgA0H4\
AGpBOGogCEE4aikDADcDACADQfgAakHAAGogCEHAAGopAwA3AwAgA0H4AGpByABqIAhByABqKQMANw\
MAIANB+ABqQdAAaiAIQdAAaikDADcDACADQfgAakHYAGogCEHYAGopAwA3AwAgA0H4AGpB4ABqIAhB\
4ABqKQMANwMAIAMgCCkDCDcDgAEgAyAIKQMoNwOgASAIQekAai0AACEHIAgtAGohCSADIAgtAGgiCj\
oA4AEgAyAIKQMAIh03A3ggAyAJIAdFckECciIHOgDhASADQegBakEYaiIJIAQpAgA3AwAgA0HoAWpB\
EGoiBCAGKQIANwMAIANB6AFqQQhqIgYgACkCADcDACADIAgpAgg3A+gBIANB6AFqIANB+ABqQShqIA\
ogHSAHEBogCSgCACEHIAQoAgAhBCAGKAIAIQkgAygChAIhCiADKAL8ASELIAMoAvQBIQwgAygC7AEh\
DSADKALoASEOIAggCCkDABAqIAgoApABIgZBN08NEyAIQZABaiAGQQV0aiIAQSBqIAo2AgAgAEEcai\
AHNgIAIABBGGogCzYCACAAQRRqIAQ2AgAgAEEQaiAMNgIAIABBDGogCTYCACAAQQhqIA02AgAgAEEE\
aiAONgIAIAggBkEBajYCkAEgCEEoaiIAQgA3AwAgAEEIakIANwMAIABBEGpCADcDACAAQRhqQgA3Aw\
AgAEEgakIANwMAIABBKGpCADcDACAAQTBqQgA3AwAgAEE4akIANwMAIAhBADsBaCAIQQhqIgAgCCkD\
cDcDACAAQQhqIAhB+ABqKQMANwMAIABBEGogCEGAAWopAwA3AwAgAEEYaiAIQYgBaikDADcDACAIIA\
gpAwBCAXw3AwAgASAFaiEBDDYLIAAoAgQiBEHIAWohCgJAQZABIARB2AJqLQAAIgBrIgggAksNAAJA\
IABFDQAgCiAAaiABIAgQOhogAiAIayECQQAhBQNAIAQgBWoiACAALQAAIABByAFqLQAAczoAACAAQQ\
FqIgYgBi0AACAAQckBai0AAHM6AAAgAEECaiIGIAYtAAAgAEHKAWotAABzOgAAIABBA2oiBiAGLQAA\
IABBywFqLQAAczoAACAFQQRqIgVBkAFHDQALIAQQJSABIAhqIQELIAEgAkGQAW5BkAFsIgBqIQcgAi\
AAayEJIAJBjwFNDTMgAEUNMwNAIAFBkAFqIQhBACEFA0AgBCAFaiIAIAAtAAAgASAFaiIGLQAAczoA\
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\
KQMANwMAIApBGGogGCkDADcDACAKQSBqIBkpAwA3AwAgCkEoaiAaKQMANwMAIApBMGogGykDADcDAC\
AKQThqIBwpAwA3AwAgAy0A4gEhDiADLQDhASEXIAMgAy0A4AEiGDoAcCADIAMpA3giHjcDCCADIA4g\
F0VyQQJyIg46AHEgA0HoAWpBGGoiFyAHKQIANwMAIANB6AFqQRBqIgcgBikCADcDACADQegBakEIai\
IGIAUpAgA3AwAgAyALKQIANwPoASADQegBaiAKIBggHiAOEBogFygCACEOIAcoAgAhByAGKAIAIRcg\
AygChAIhGCADKAL8ASEZIAMoAvQBIRogAygC7AEhGyADKALoASEcIAggCCkDABAqIAgoApABIgZBN0\
8NCSANIAZBBXRqIgUgGDYCHCAFIA42AhggBSAZNgIUIAUgBzYCECAFIBo2AgwgBSAXNgIIIAUgGzYC\
BCAFIBw2AgAgCCAGQQFqNgKQAQsgCCAIKQMAIB18Ih43AwAgAiAASQ0JIAEgAGohASACIABrIgJBgA\
hLDQALCyACRQ0TIAggASACEDUaIAggCCkDABAqDBMLIAAgAkGghcAAEEsACyAFQcAAQeCEwAAQSwAL\
IAZBwABB8ITAABBLAAsgBkEgQYCFwAAQSwALIANBkAJqQQhqIgEgGjYCACADQZACakEQaiIAIBg2Ag\
AgA0GQAmpBGGoiBSAONgIAIAMgGTYCnAIgA0GBAWoiBiABKQMANwAAIAMgFzYCpAIgA0GJAWoiASAA\
KQMANwAAIAMgBzYCrAIgA0GRAWoiACAFKQMANwAAIAMgGzYClAIgAyAcNgKQAiADIAMpA5ACNwB5IA\
NBCGpBGGogACkAADcDACADQQhqQRBqIAEpAAA3AwAgA0EIakEIaiAGKQAANwMAIAMgAykAeTcDCEGQ\
ksAAIANBCGpBgIbAAEH4hsAAEEIACyADQZACakEIaiIBIBQ2AgAgA0GQAmpBEGoiACASNgIAIANBkA\
JqQRhqIgUgEDYCACADIBM2ApwCIANBgQFqIgYgASkDADcAACADIBE2AqQCIANBiQFqIgEgACkDADcA\
ACADIA82AqwCIANBkQFqIgAgBSkDADcAACADIBU2ApQCIAMgFjYCkAIgAyADKQOQAjcAeSADQQhqQR\
hqIAApAAA3AwAgA0EIakEQaiABKQAANwMAIANBCGpBCGogBikAADcDACADIAMpAHk3AwhBkJLAACAD\
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\
QRh3Ii4gL2oiLyAac0EZdyIaIAggMCAiIBlzQRl3IhlqIBRqIiIgJiAoc0EYdyImc0EQdyIoICEgJ2\
oiIWoiJyAZc0EUdyIZICJqaiIiamoiMCANIAsgHiAhIBhzQRl3IhhqaiIeICpzQRB3IiEgJiApaiIm\
aiIpIBhzQRR3IhggHmpqIh4gIXNBGHciIXNBEHciKiAOICYgF3NBGXciFyAfaiAJaiIfICBzQRB3Ii\
AgMmoiJiAXc0EUdyIXIB9qaiIfICBzQRh3IiAgJmoiJmoiMiAac0EUdyIaIDBqaiIwICpzQRh3Iiog\
MmoiMiAac0EZdyIaIAwgMSAmIBdzQRl3IhdqIANqIiYgIiAoc0EYdyIic0EQdyIoICEgKWoiIWoiKS\
AXc0EUdyIXICZqaiImaiAGaiIxIAcgISAYc0EZdyIYIB9qIAZqIh8gLnNBEHciISAiICdqIiJqIicg\
GHNBFHciGCAfamoiHyAhc0EYdyIhc0EQdyIuIAUgIiAZc0EZdyIZIB5qaiIeICBzQRB3IiAgL2oiIi\
AZc0EUdyIZIB5qIAJqIh4gIHNBGHciICAiaiIiaiIvIBpzQRR3IhogMWpqIjEgLnNBGHciLiAvaiIv\
IBpzQRl3IhogByAPIDAgIiAZc0EZdyIZamoiIiAmIChzQRh3IiZzQRB3IiggISAnaiIhaiInIBlzQR\
R3IhkgImpqIiJqaiIwIAEgHiAhIBhzQRl3IhhqIANqIh4gKnNBEHciISAmIClqIiZqIikgGHNBFHci\
GCAeamoiHiAhc0EYdyIhc0EQdyIqIA4gJiAXc0EZdyIXIB9qaiIfICBzQRB3IiAgMmoiJiAXc0EUdy\
IXIB9qIAJqIh8gIHNBGHciICAmaiImaiIyIBpzQRR3IhogMGogCWoiMCAqc0EYdyIqIDJqIjIgGnNB\
GXciGiAIIAQgMSAmIBdzQRl3IhdqaiImICIgKHNBGHciInNBEHciKCAhIClqIiFqIikgF3NBFHciFy\
AmamoiJmogCmoiMSAFICEgGHNBGXciGCAfaiAUaiIfIC5zQRB3IiEgIiAnaiIiaiInIBhzQRR3Ihgg\
H2pqIh8gIXNBGHciIXNBEHciLiALICIgGXNBGXciGSAeamoiHiAgc0EQdyIgIC9qIiIgGXNBFHciGS\
AeaiAKaiIeICBzQRh3IiAgImoiImoiLyAac0EUdyIaIDFqaiIxIC5zQRh3Ii4gL2oiLyAac0EZdyIa\
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\
AhQgAyABQRxqKAAAIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZyciIKNgIcIAMgAUEgai\
gAACICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIiCzYCICADIAFBGGooAAAiAkEYdCAC\
QQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdnJyIgw2AhggAygCACENIAMoAgQhDiADKAIIIQ8gAygCEC\
EQIAMoAgwhESADKAIUIRIgAyABQSRqKAAAIgJBGHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZy\
ciITNgIkIAMgAUEoaigAACICQRh0IAJBCHRBgID8B3FyIAJBCHZBgP4DcSACQRh2cnIiFDYCKCADIA\
FBMGooAAAiAkEYdCACQQh0QYCA/AdxciACQQh2QYD+A3EgAkEYdnJyIhU2AjAgAyABQSxqKAAAIgJB\
GHQgAkEIdEGAgPwHcXIgAkEIdkGA/gNxIAJBGHZyciIWNgIsIAMgAUE0aigAACICQRh0IAJBCHRBgI\
D8B3FyIAJBCHZBgP4DcSACQRh2cnIiAjYCNCADIAFBOGooAAAiF0EYdCAXQQh0QYCA/AdxciAXQQh2\
QYD+A3EgF0EYdnJyIhc2AjggAyABQTxqKAAAIhhBGHQgGEEIdEGAgPwHcXIgGEEIdkGA/gNxIBhBGH\
ZyciIYNgI8IAggEyAKcyAYcyAMIBBzIBVzIBEgDnMgE3MgF3NBAXciGXNBAXciGnNBAXciGyAKIBJz\
IAJzIBAgD3MgFHMgGHNBAXciHHNBAXciHXMgGCACcyAdcyAVIBRzIBxzIBtzQQF3Ih5zQQF3Ih9zIB\
ogHHMgHnMgGSAYcyAbcyAXIBVzIBpzIBYgE3MgGXMgCyAMcyAXcyASIBFzIBZzIA8gDXMgC3MgAnNB\
AXciIHNBAXciIXNBAXciInNBAXciI3NBAXciJHNBAXciJXNBAXciJnNBAXciJyAdICFzIAIgFnMgIX\
MgFCALcyAgcyAdc0EBdyIoc0EBdyIpcyAcICBzIChzIB9zQQF3IipzQQF3IitzIB8gKXMgK3MgHiAo\
cyAqcyAnc0EBdyIsc0EBdyItcyAmICpzICxzICUgH3MgJ3MgJCAecyAmcyAjIBtzICVzICIgGnMgJH\
MgISAZcyAjcyAgIBdzICJzIClzQQF3Ii5zQQF3Ii9zQQF3IjBzQQF3IjFzQQF3IjJzQQF3IjNzQQF3\
IjRzQQF3IjUgKyAvcyApICNzIC9zICggInMgLnMgK3NBAXciNnNBAXciN3MgKiAucyA2cyAtc0EBdy\
I4c0EBdyI5cyAtIDdzIDlzICwgNnMgOHMgNXNBAXciOnNBAXciO3MgNCA4cyA6cyAzIC1zIDVzIDIg\
LHMgNHMgMSAncyAzcyAwICZzIDJzIC8gJXMgMXMgLiAkcyAwcyA3c0EBdyI8c0EBdyI9c0EBdyI+c0\
EBdyI/c0EBdyJAc0EBdyJBc0EBdyJCc0EBdyJDIDkgPXMgNyAxcyA9cyA2IDBzIDxzIDlzQQF3IkRz\
QQF3IkVzIDggPHMgRHMgO3NBAXciRnNBAXciR3MgOyBFcyBHcyA6IERzIEZzIENzQQF3IkhzQQF3Ik\
lzIEIgRnMgSHMgQSA7cyBDcyBAIDpzIEJzID8gNXMgQXMgPiA0cyBAcyA9IDNzID9zIDwgMnMgPnMg\
RXNBAXciSnNBAXciS3NBAXciTHNBAXciTXNBAXciTnNBAXciT3NBAXciUHNBAXdqIEYgSnMgRCA+cy\
BKcyBHc0EBdyJRcyBJc0EBdyJSIEUgP3MgS3MgUXNBAXciUyBMIEEgOiA5IDwgMSAmIB8gKCAhIBcg\
EyAQIAhBHnciVGogDiAFIAdBHnciECAGcyAIcSAGc2pqIA0gBCAIQQV3aiAGIAVzIAdxIAVzampBmf\
OJ1AVqIg5BBXdqQZnzidQFaiJVQR53IgggDkEedyINcyAGIA9qIA4gVCAQc3EgEHNqIFVBBXdqQZnz\
idQFaiIOcSANc2ogECARaiBVIA0gVHNxIFRzaiAOQQV3akGZ84nUBWoiEEEFd2pBmfOJ1AVqIhFBHn\
ciD2ogDCAIaiARIBBBHnciEyAOQR53IgxzcSAMc2ogEiANaiAMIAhzIBBxIAhzaiARQQV3akGZ84nU\
BWoiEUEFd2pBmfOJ1AVqIhJBHnciCCARQR53IhBzIAogDGogESAPIBNzcSATc2ogEkEFd2pBmfOJ1A\
VqIgpxIBBzaiALIBNqIBAgD3MgEnEgD3NqIApBBXdqQZnzidQFaiIMQQV3akGZ84nUBWoiD0EedyIL\
aiAVIApBHnciF2ogCyAMQR53IhNzIBQgEGogDCAXIAhzcSAIc2ogD0EFd2pBmfOJ1AVqIhRxIBNzai\
AWIAhqIA8gEyAXc3EgF3NqIBRBBXdqQZnzidQFaiIVQQV3akGZ84nUBWoiFiAVQR53IhcgFEEedyII\
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\
IANBhYHAACAEEFNFDQYgA0GMgcAAIAQQUw0KQdgBEBciBEUNHCACQQA2AgAgAkEEckEAQYABEDwaIA\
JBgAE2AgAgAkGwAWogAkGEARA6GiAEQdAAaiACQbABakEEckGAARA6GiAEQcgAakIANwMAIARCADcD\
QCAEQQA6ANABIARBACkDsI5ANwMAIARBCGpBACkDuI5ANwMAIARBEGpBACkDwI5ANwMAIARBGGpBAC\
kDyI5ANwMAIARBIGpBACkD0I5ANwMAIARBKGpBACkD2I5ANwMAIARBMGpBACkD4I5ANwMAIARBOGpB\
ACkD6I5ANwMAQRQhBQwjC0HwABAXIgRFDQwgAkGwAWpBCGoQWCAEQSBqIAJB2AFqKQMANwMAIARBGG\
ogAkGwAWpBIGopAwA3AwAgBEEQaiACQbABakEYaikDADcDACAEQQhqIAJBsAFqQRBqKQMANwMAIAQg\
AikDuAE3AwAgAkEMakIANwIAIAJBFGpCADcCACACQRxqQgA3AgAgAkEkakIANwIAIAJBLGpCADcCAC\
ACQTRqQgA3AgAgAkE8akIANwIAIAJCADcCBCACQcAANgIAIAJBsAFqIAJBxAAQOhogBEHgAGogAkGw\
AWpBPGopAgA3AAAgBEHYAGogAkGwAWpBNGopAgA3AAAgBEHQAGogAkGwAWpBLGopAgA3AAAgBEHIAG\
ogAkGwAWpBJGopAgA3AAAgBEHAAGogAkGwAWpBHGopAgA3AAAgBEE4aiACQbABakEUaikCADcAACAE\
QTBqIAJBsAFqQQxqKQIANwAAIAQgAikCtAE3ACggBEEAOgBoQQMhBQwiCwJAAkACQAJAIANBuoDAAE\
EKEFNFDQAgA0HEgMAAQQoQU0UNASADQc6AwABBChBTRQ0CIANB2IDAAEEKEFNFDQMgA0HogMAAQQoQ\
Uw0MQegAEBciBEUNFiACQQxqQgA3AgAgAkEUakIANwIAIAJBHGpCADcCACACQSRqQgA3AgAgAkEsak\
IANwIAIAJBNGpCADcCACACQTxqQgA3AgAgAkIANwIEIAJBwAA2AgAgAkGwAWogAkHEABA6GiAEQdgA\
aiACQbABakE8aikCADcAACAEQdAAaiACQbABakE0aikCADcAACAEQcgAaiACQbABakEsaikCADcAAC\
AEQcAAaiACQbABakEkaikCADcAACAEQThqIAJBsAFqQRxqKQIANwAAIARBMGogAkGwAWpBFGopAgA3\
AAAgBEEoaiACQbABakEMaikCADcAACAEIAIpArQBNwAgIARCADcDACAEQQA6AGAgBEEAKQPYjUA3Aw\
ggBEEQakEAKQPgjUA3AwAgBEEYakEAKALojUA2AgBBCyEFDCULQeACEBciBEUNDyAEQQBByAEQPCEF\
IAJBADYCACACQQRyQQBBkAEQPBogAkGQATYCACACQbABaiACQZQBEDoaIAVByAFqIAJBsAFqQQRyQZ\
ABEDoaIAVBADoA2AJBBSEFDCQLQdgCEBciBEUNDyAEQQBByAEQPCEFIAJBADYCACACQQRyQQBBiAEQ\
PBogAkGIATYCACACQbABaiACQYwBEDoaIAVByAFqIAJBsAFqQQRyQYgBEDoaIAVBADoA0AJBBiEFDC\
MLQbgCEBciBEUNDyAEQQBByAEQPCEFIAJBADYCACACQQRyQQBB6AAQPBogAkHoADYCACACQbABaiAC\
QewAEDoaIAVByAFqIAJBsAFqQQRyQegAEDoaIAVBADoAsAJBByEFDCILQZgCEBciBEUNDyAEQQBByA\
EQPCEFIAJBADYCACACQQRyQQBByAAQPBogAkHIADYCACACQbABaiACQcwAEDoaIAVByAFqIAJBsAFq\
QQRyQcgAEDoaIAVBADoAkAJBCCEFDCELAkAgA0HigMAAQQMQU0UNACADQeWAwABBAxBTDQhB4AAQFy\
IERQ0RIAJBDGpCADcCACACQRRqQgA3AgAgAkEcakIANwIAIAJBJGpCADcCACACQSxqQgA3AgAgAkE0\
akIANwIAIAJBPGpCADcCACACQgA3AgQgAkHAADYCACACQbABaiACQcQAEDoaIARB0ABqIAJBsAFqQT\
xqKQIANwAAIARByABqIAJBsAFqQTRqKQIANwAAIARBwABqIAJBsAFqQSxqKQIANwAAIARBOGogAkGw\
AWpBJGopAgA3AAAgBEEwaiACQbABakEcaikCADcAACAEQShqIAJBsAFqQRRqKQIANwAAIARBIGogAk\
GwAWpBDGopAgA3AAAgBCACKQK0ATcAGCAEQv6568XpjpWZEDcDECAEQoHGlLqW8ermbzcDCCAEQgA3\
AwAgBEEAOgBYQQohBQwhC0HgABAXIgRFDQ8gAkEMakIANwIAIAJBFGpCADcCACACQRxqQgA3AgAgAk\
EkakIANwIAIAJBLGpCADcCACACQTRqQgA3AgAgAkE8akIANwIAIAJCADcCBCACQcAANgIAIAJBsAFq\
IAJBxAAQOhogBEHQAGogAkGwAWpBPGopAgA3AAAgBEHIAGogAkGwAWpBNGopAgA3AAAgBEHAAGogAk\
GwAWpBLGopAgA3AAAgBEE4aiACQbABakEkaikCADcAACAEQTBqIAJBsAFqQRxqKQIANwAAIARBKGog\
AkGwAWpBFGopAgA3AAAgBEEgaiACQbABakEMaikCADcAACAEIAIpArQBNwAYIARC/rnrxemOlZkQNw\
MQIARCgcaUupbx6uZvNwMIIARCADcDACAEQQA6AFhBCSEFDCALAkACQAJAAkAgAykAAELTkIWa08WM\
mTRRDQAgAykAAELTkIWa08XMmjZRDQEgAykAAELTkIWa0+WMnDRRDQIgAykAAELTkIWa06XNmDJRDQ\
MgAykAAELTkIXa1KiMmThRDQcgAykAAELTkIXa1MjMmjZSDQpB2AIQFyIERQ0eIARBAEHIARA8IQUg\
AkEANgIAIAJBBHJBAEGIARA8GiACQYgBNgIAIAJBsAFqIAJBjAEQOhogBUHIAWogAkGwAWpBBHJBiA\
EQOhogBUEAOgDQAkEWIQUMIwtB4AIQFyIERQ0UIARBAEHIARA8IQUgAkEANgIAIAJBBHJBAEGQARA8\
GiACQZABNgIAIAJBsAFqIAJBlAEQOhogBUHIAWogAkGwAWpBBHJBkAEQOhogBUEAOgDYAkENIQUMIg\
tB2AIQFyIERQ0UIARBAEHIARA8IQUgAkEANgIAIAJBBHJBAEGIARA8GiACQYgBNgIAIAJBsAFqIAJB\
jAEQOhogBUHIAWogAkGwAWpBBHJBiAEQOhogBUEAOgDQAkEOIQUMIQtBuAIQFyIERQ0UIARBAEHIAR\
A8IQUgAkEANgIAIAJBBHJBAEHoABA8GiACQegANgIAIAJBsAFqIAJB7AAQOhogBUHIAWogAkGwAWpB\
BHJB6AAQOhogBUEAOgCwAkEPIQUMIAtBmAIQFyIERQ0UIARBAEHIARA8IQUgAkEANgIAIAJBBHJBAE\
HIABA8GiACQcgANgIAIAJBsAFqIAJBzAAQOhogBUHIAWogAkGwAWpBBHJByAAQOhogBUEAOgCQAkEQ\
IQUMHwtB8AAQFyIERQ0UIAJBDGpCADcCACACQRRqQgA3AgAgAkEcakIANwIAIAJBJGpCADcCACACQS\
xqQgA3AgAgAkE0akIANwIAIAJBPGpCADcCACACQgA3AgQgAkHAADYCACACQbABaiACQcQAEDoaIARB\
4ABqIAJBsAFqQTxqKQIANwAAIARB2ABqIAJBsAFqQTRqKQIANwAAIARB0ABqIAJBsAFqQSxqKQIANw\
AAIARByABqIAJBsAFqQSRqKQIANwAAIARBwABqIAJBsAFqQRxqKQIANwAAIARBOGogAkGwAWpBFGop\
AgA3AAAgBEEwaiACQbABakEMaikCADcAACAEIAIpArQBNwAoIARCADcDACAEQQA6AGggBEEAKQOQjk\
A3AwggBEEQakEAKQOYjkA3AwAgBEEYakEAKQOgjkA3AwAgBEEgakEAKQOojkA3AwBBESEFDB4LQfAA\
EBciBEUNFCACQQxqQgA3AgAgAkEUakIANwIAIAJBHGpCADcCACACQSRqQgA3AgAgAkEsakIANwIAIA\
JBNGpCADcCACACQTxqQgA3AgAgAkIANwIEIAJBwAA2AgAgAkGwAWogAkHEABA6GiAEQeAAaiACQbAB\
akE8aikCADcAACAEQdgAaiACQbABakE0aikCADcAACAEQdAAaiACQbABakEsaikCADcAACAEQcgAai\
ACQbABakEkaikCADcAACAEQcAAaiACQbABakEcaikCADcAACAEQThqIAJBsAFqQRRqKQIANwAAIARB\
MGogAkGwAWpBDGopAgA3AAAgBCACKQK0ATcAKCAEQgA3AwAgBEEAOgBoIARBACkD8I1ANwMIIARBEG\
pBACkD+I1ANwMAIARBGGpBACkDgI5ANwMAIARBIGpBACkDiI5ANwMAQRIhBQwdC0HYARAXIgRFDRQg\
AkEANgIAIAJBBHJBAEGAARA8GiACQYABNgIAIAJBsAFqIAJBhAEQOhogBEHQAGogAkGwAWpBBHJBgA\
EQOhogBEHIAGpCADcDACAEQgA3A0AgBEEAOgDQASAEQQApA/COQDcDACAEQQhqQQApA/iOQDcDACAE\
QRBqQQApA4CPQDcDACAEQRhqQQApA4iPQDcDACAEQSBqQQApA5CPQDcDACAEQShqQQApA5iPQDcDAC\
AEQTBqQQApA6CPQDcDACAEQThqQQApA6iPQDcDAEETIQUMHAtB+AIQFyIERQ0VIARBAEHIARA8IQUg\
AkEANgIAIAJBBHJBAEGoARA8GiACQagBNgIAIAJBsAFqIAJBrAEQOhogBUHIAWogAkGwAWpBBHJBqA\
EQOhogBUEAOgDwAkEVIQUMGwsgA0HygMAAQQUQU0UNFyADQZOBwABBBRBTDQFB6AAQFyIERQ0WIARC\
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\
QEEAQaTVwAA2AqzVQEEAQbTVwAA2AsDVQEEAQazVwAA2ArTVQEEAQbzVwAA2AsjVQEEAQbTVwAA2Ar\
zVQEEAQcTVwAA2AtDVQEEAQbzVwAA2AsTVQEEAQQA2ArjYQEEAQczVwAA2AtjVQEEAQcTVwAA2AszV\
QEEAQczVwAA2AtTVQEEAQdTVwAA2AuDVQEEAQdTVwAA2AtzVQEEAQdzVwAA2AujVQEEAQdzVwAA2Au\
TVQEEAQeTVwAA2AvDVQEEAQeTVwAA2AuzVQEEAQezVwAA2AvjVQEEAQezVwAA2AvTVQEEAQfTVwAA2\
AoDWQEEAQfTVwAA2AvzVQEEAQfzVwAA2AojWQEEAQfzVwAA2AoTWQEEAQYTWwAA2ApDWQEEAQYTWwA\
A2AozWQEEAQYzWwAA2ApjWQEEAQZTWwAA2AqDWQEEAQYzWwAA2ApTWQEEAQZzWwAA2AqjWQEEAQZTW\
wAA2ApzWQEEAQaTWwAA2ArDWQEEAQZzWwAA2AqTWQEEAQazWwAA2ArjWQEEAQaTWwAA2AqzWQEEAQb\
TWwAA2AsDWQEEAQazWwAA2ArTWQEEAQbzWwAA2AsjWQEEAQbTWwAA2ArzWQEEAQcTWwAA2AtDWQEEA\
QbzWwAA2AsTWQEEAQczWwAA2AtjWQEEAQcTWwAA2AszWQEEAQdTWwAA2AuDWQEEAQczWwAA2AtTWQE\
EAQdzWwAA2AujWQEEAQdTWwAA2AtzWQEEAQeTWwAA2AvDWQEEAQdzWwAA2AuTWQEEAQezWwAA2AvjW\
QEEAQeTWwAA2AuzWQEEAQfTWwAA2AoDXQEEAQezWwAA2AvTWQEEAQfzWwAA2AojXQEEAQfTWwAA2Av\
zWQEEAQYTXwAA2ApDXQEEAQfzWwAA2AoTXQEEAIAY2AqDYQEEAQYTXwAA2AozXQEEAIAhBWGoiADYC\
mNhAIAYgAEEBcjYCBCAIIAZqQVxqQSg2AgBBAEGAgIABNgK82EALQQAhAUEAKAKY2EAiACACTQ0AQQ\
AgACACayIBNgKY2EBBAEEAKAKg2EAiACACaiIFNgKg2EAgBSABQQFyNgIEIAAgAkEDcjYCBCAAQQhq\
DwsgAQu5JQIDfx5+IwBBwABrIgNBOGpCADcDACADQTBqQgA3AwAgA0EoakIANwMAIANBIGpCADcDAC\
ADQRhqQgA3AwAgA0EQakIANwMAIANBCGpCADcDACADQgA3AwACQCACRQ0AIAEgAkEGdGohBCAAKQMQ\
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\
OGogA0E4aikDADcDACABQQhqQTBqIANBMGopAwA3AwAgAUEIakEoaiADQShqKQMANwMAIAFBCGpBIG\
ogA0EgaikDADcDACABQQhqQRhqIANBGGopAwA3AwAgAUEIakEQaiADQRBqKQMANwMAIAFBCGpBCGog\
A0EIaikDADcDACABIAMpAwA3AwggAykDQCEPIAFBCGpByABqIANByABqEEUgASAPNwNIIAIgAUEIak\
HQARA6GkEAIQMMHwsgAigCBCEDQdABEBciAkUNBiABQQhqQThqIANBOGopAwA3AwAgAUEIakEwaiAD\
QTBqKQMANwMAIAFBCGpBKGogA0EoaikDADcDACABQQhqQSBqIANBIGopAwA3AwAgAUEIakEYaiADQR\
hqKQMANwMAIAFBCGpBEGogA0EQaikDADcDACABQQhqQQhqIANBCGopAwA3AwAgASADKQMANwMIIAMp\
A0AhDyABQQhqQcgAaiADQcgAahBFIAEgDzcDSCACIAFBCGpB0AEQOhpBASEDDB4LIAIoAgQhA0HQAR\
AXIgJFDQYgAUEIakE4aiADQThqKQMANwMAIAFBCGpBMGogA0EwaikDADcDACABQQhqQShqIANBKGop\
AwA3AwAgAUEIakEgaiADQSBqKQMANwMAIAFBCGpBGGogA0EYaikDADcDACABQQhqQRBqIANBEGopAw\
A3AwAgAUEIakEIaiADQQhqKQMANwMAIAEgAykDADcDCCADKQNAIQ8gAUEIakHIAGogA0HIAGoQRSAB\
IA83A0ggAiABQQhqQdABEDoaQQIhAwwdCyACKAIEIQNB8AAQFyICRQ0GIAFBCGpBIGogA0EgaikDAD\
cDACABQQhqQRhqIANBGGopAwA3AwAgAUEIakEQaiADQRBqKQMANwMAIAEgAykDCDcDECADKQMAIQ8g\
AUEIakEoaiADQShqEDkgASAPNwMIIAIgAUEIakHwABA6GkEDIQMMHAsgAigCBCEDQfgOEBciAkUNBi\
ABQQhqQYgBaiADQYgBaikDADcDACABQQhqQYABaiADQYABaikDADcDACABQQhqQfgAaiADQfgAaikD\
ADcDACABQQhqQRBqIANBEGopAwA3AwAgAUEIakEYaiADQRhqKQMANwMAIAFBCGpBIGogA0EgaikDAD\
cDACABQQhqQTBqIANBMGopAwA3AwAgAUEIakE4aiADQThqKQMANwMAIAFBCGpBwABqIANBwABqKQMA\
NwMAIAFBCGpByABqIANByABqKQMANwMAIAFBCGpB0ABqIANB0ABqKQMANwMAIAFBCGpB2ABqIANB2A\
BqKQMANwMAIAFBCGpB4ABqIANB4ABqKQMANwMAIAEgAykDcDcDeCABIAMpAwg3AxAgASADKQMoNwMw\
IAMpAwAhDyADLQBqIQQgAy0AaSEFIAMtAGghBgJAIAMoApABQQV0IgcNAEEAIQcMGwsgAUGAD2pBGG\
oiCCADQZQBaiIJQRhqKQAANwMAIAFBgA9qQRBqIgogCUEQaikAADcDACABQYAPakEIaiILIAlBCGop\
AAA3AwAgASAJKQAANwOADyADQdQBaiEJQQAgB0FgakEFdmshDCABQbwBaiEDQQIhBwNAIANBYGoiDS\
ABKQOADzcAACANQRhqIAgpAwA3AAAgDUEQaiAKKQMANwAAIA1BCGogCykDADcAAAJAAkAgDCAHaiIO\
QQJGDQAgCCAJQWBqIg1BGGopAAA3AwAgCiANQRBqKQAANwMAIAsgDUEIaikAADcDACABIA0pAAA3A4\
APIAdBOEcNARBsAAsgB0F/aiEHDBwLIAMgASkDgA83AAAgA0EYaiAIKQMANwAAIANBEGogCikDADcA\
ACADQQhqIAspAwA3AAAgDkEBRg0bIAggCUEYaikAADcDACAKIAlBEGopAAA3AwAgCyAJQQhqKQAANw\
MAIAEgCSkAADcDgA8gA0HAAGohAyAHQQJqIQcgCUHAAGohCQwACwsQcAALEHEAC0HQAUEIQQAoAvjU\
QCIBQQQgARsRBQAAC0HQAUEIQQAoAvjUQCIBQQQgARsRBQAAC0HQAUEIQQAoAvjUQCIBQQQgARsRBQ\
AAC0HwAEEIQQAoAvjUQCIBQQQgARsRBQAAC0H4DkEIQQAoAvjUQCIBQQQgARsRBQAACyACKAIEIQMC\
QEHoABAXIgJFDQAgAUEIakEQaiADQRBqKQMANwMAIAFBCGpBGGogA0EYaikDADcDACABIAMpAwg3Ax\
AgAykDACEPIAFBCGpBIGogA0EgahA5IAEgDzcDCCACIAFBCGpB6AAQOhpBFyEDDBQLQegAQQhBACgC\
+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQdgCEBciAkUNACABQQhqIANByAEQOhogAUEIakHIAWogA0\
HIAWoQRiACIAFBCGpB2AIQOhpBFiEDDBMLQdgCQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJA\
QfgCEBciAkUNACABQQhqIANByAEQOhogAUEIakHIAWogA0HIAWoQRyACIAFBCGpB+AIQOhpBFSEDDB\
ILQfgCQQhBACgC+NRAIgFBBCABGxEFAAALIAIoAgQhAwJAQdgBEBciAkUNACABQQhqQThqIANBOGop\
AwA3AwAgAUEIakEwaiADQTBqKQMANwMAIAFBCGpBKGogA0EoaikDADcDACABQQhqQSBqIANBIGopAw\
A3AwAgAUEIakEYaiADQRhqKQMANwMAIAFBCGpBEGogA0EQaikDADcDACABQQhqQQhqIANBCGopAwA3\
AwAgASADKQMANwMIIANByABqKQMAIQ8gAykDQCEQIAFBCGpB0ABqIANB0ABqEEUgAUEIakHIAGogDz\
cDACABIBA3A0ggAiABQQhqQdgBEDoaQRQhAwwRC0HYAUEIQQAoAvjUQCIBQQQgARsRBQAACyACKAIE\
IQMCQEHYARAXIgJFDQAgAUEIakE4aiADQThqKQMANwMAIAFBCGpBMGogA0EwaikDADcDACABQQhqQS\
hqIANBKGopAwA3AwAgAUEIakEgaiADQSBqKQMANwMAIAFBCGpBGGogA0EYaikDADcDACABQQhqQRBq\
IANBEGopAwA3AwAgAUEIakEIaiADQQhqKQMANwMAIAEgAykDADcDCCADQcgAaikDACEPIAMpA0AhEC\
ABQQhqQdAAaiADQdAAahBFIAFBCGpByABqIA83AwAgASAQNwNIIAIgAUEIakHYARA6GkETIQMMEAtB\
2AFBCEEAKAL41EAiAUEEIAEbEQUAAAsgAigCBCEDAkBB8AAQFyICRQ0AIAFBCGpBIGogA0EgaikDAD\
cDACABQQhqQRhqIANBGGopAwA3AwAgAUEIakEQaiADQRBqKQMANwMAIAEgAykDCDcDECADKQMAIQ8g\
AUEIakEoaiADQShqEDkgASAPNwMIIAIgAUEIakHwABA6GkESIQMMDwtB8ABBCEEAKAL41EAiAUEEIA\
EbEQUAAAsgAigCBCEDAkBB8AAQFyICRQ0AIAFBCGpBIGogA0EgaikDADcDACABQQhqQRhqIANBGGop\
AwA3AwAgAUEIakEQaiADQRBqKQMANwMAIAEgAykDCDcDECADKQMAIQ8gAUEIakEoaiADQShqEDkgAS\
APNwMIIAIgAUEIakHwABA6GkERIQMMDgtB8ABBCEEAKAL41EAiAUEEIAEbEQUAAAsgAigCBCEDAkBB\
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\
AgAMAwsgAEEAQRkgA0EBdmtBH3EgA0EfRht0IQIDQCAFIAJBHXZBBHFqQRBqIgYoAgAiA0UNAiACQQ\
F0IQIgAyEFIAMoAgRBeHEgAEcNAAsLIAMoAggiACABNgIMIAMgATYCCCABQRhqQQA2AgAgASADNgIM\
IAEgADYCCAwCCyAGIAE2AgAgAUEYaiAFNgIACyABIAE2AgwgASABNgIIC0EAQQAoAsTYQEF/aiIBNg\
LE2EAgAQ0DQQAoArTYQCIADQFB/x8hAQwCCyAAQQN2IgNBA3RBjNXAAGohAAJAAkBBACgChNVAIgJB\
ASADdCIDcUUNACAAKAIIIQMMAQtBACACIANyNgKE1UAgACEDCyAAIAE2AgggAyABNgIMIAEgADYCDC\
ABIAM2AggPC0EAIQEDQCABQQFqIQEgACgCCCIADQALIAFB/x8gAUH/H0sbIQELQQAgATYCxNhADwsL\
lQwBGH8jACECIAAoAgAhAyAAKAIIIQQgACgCDCEFIAAoAgQhBiACQcAAayICQRhqIgdCADcDACACQS\
BqIghCADcDACACQThqIglCADcDACACQTBqIgpCADcDACACQShqIgtCADcDACACQQhqIgwgASkACDcD\
ACACQRBqIg0gASkAEDcDACAHIAEoABgiDjYCACAIIAEoACAiDzYCACACIAEpAAA3AwAgAiABKAAcIh\
A2AhwgAiABKAAkIhE2AiQgCyABKAAoIhI2AgAgAiABKAAsIgs2AiwgCiABKAAwIhM2AgAgAiABKAA0\
Igo2AjQgCSABKAA4IhQ2AgAgAiABKAA8IhU2AjwgACADIBMgCyASIBEgDyAQIA4gBiAEIAUgBiADIA\
YgBHFqIAUgBkF/c3FqIAIoAgAiFmpBA3ciAXFqIAQgAUF/c3FqIAIoAgQiF2pBB3ciByABcWogBiAH\
QX9zcWogDCgCACIMakELdyIIIAdxaiABIAhBf3NxaiACKAIMIhhqQRN3IgkgCHEgAWogByAJQX9zcW\
ogDSgCACINakEDdyIBIAlxIAdqIAggAUF/c3FqIAIoAhQiGWpBB3ciAiABcSAIaiAJIAJBf3NxampB\
C3ciByACcSAJaiABIAdBf3NxampBE3ciCCAHcSABaiACIAhBf3NxampBA3ciASAIcSACaiAHIAFBf3\
NxampBB3ciAiABcSAHaiAIIAJBf3NxampBC3ciByACcSAIaiABIAdBf3NxampBE3ciCCAHcSABaiAC\
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\
IRQgAS0AaiEIIAJB4ABqIAQpAhg3AwAgAkHYAGogFDcDACACQdAAaiATNwMAIAJByABqIBI3AwBCAC\
ESIAJCADcDACAIQQRyIQkgAkEIaiEEDAELIAJBEGogAUEQaikDADcDACACQRhqIAFBGGopAwA3AwAg\
AkEgaiABQSBqKQMANwMAIAJBMGogAUEwaikDADcDACACQThqIAFBOGopAwA3AwAgAkHAAGogAUHAAG\
opAwA3AwAgAkHIAGogAUHIAGopAwA3AwAgAkHQAGogAUHQAGopAwA3AwAgAkHYAGogAUHYAGopAwA3\
AwAgAkHgAGogAUHgAGopAwA3AwAgAiABKQMINwMIIAIgASkDKDcDKCABLQBqIQggAiABKQMAIhI3Aw\
AgCCAERXJBAnIhCSACQQhqIQQgAyEGCyACIAk6AGkgAiAFOgBoAkACQCAGRQ0AIAFB8ABqIQogAkEo\
aiEHQQEgBmshCyAIQQRyIQggBkEFdCABakH0AGohASAGQX9qIANPIQwDQCAMDQIgAkHwAGpBGGoiBi\
AEQRhqIg0pAgA3AwAgAkHwAGpBEGoiDiAEQRBqIg8pAgA3AwAgAkHwAGpBCGoiECAEQQhqIhEpAgA3\
AwAgAiAEKQIANwNwIAJB8ABqIAcgBSASIAkQGiAQKQMAIRMgDikDACEUIAYpAwAhFSACKQNwIRYgB0\
EYaiABQRhqKQIANwIAIAdBEGogAUEQaikCADcCACAHQQhqIAFBCGopAgA3AgAgByABKQIANwIAIAQg\
CikDADcDACARIApBCGopAwA3AwAgDyAKQRBqKQMANwMAIA0gCkEYaikDADcDAEIAIRIgAkIANwMAIA\
IgFTcDYCACIBQ3A1ggAiATNwNQIAIgFjcDSCACIAg6AGlBwAAhBSACQcAAOgBoIAFBYGohASAIIQkg\
C0EBaiILQQFHDQALCyAAIAJB8AAQOhoMAgtBACALayADQdCFwAAQTwALIAAgASkDCDcDCCAAIAEpAy\
g3AyggAEEQaiABQRBqKQMANwMAIABBGGogAUEYaikDADcDACAAQSBqIAFBIGopAwA3AwAgAEEwaiAB\
QTBqKQMANwMAIABBOGogAUE4aikDADcDACAAQcAAaiABQcAAaikDADcDACAAQcgAaiABQcgAaikDAD\
cDACAAQdAAaiABQdAAaikDADcDACAAQdgAaiABQdgAaikDADcDACAAQeAAaiABQeAAaikDADcDACAB\
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\
AwAgA0HIAGogA0GoAWpBLGopAgA3AwAgA0HAAGogA0GoAWpBJGopAgA3AwAgA0E4aiADQagBakEcai\
kCADcDACADQTBqIANBqAFqQRRqKQIANwMAIANBKGogA0GoAWpBDGopAgA3AwAgAyADKQKsATcDICAD\
IAY3A1ggA0EIaiADQSBqQQEQFQsgAUHAAGpBADoAACACIAMoAggiAUEYdCABQQh0QYCA/AdxciABQQ\
h2QYD+A3EgAUEYdnJyNgAAIAIgAygCDCIBQRh0IAFBCHRBgID8B3FyIAFBCHZBgP4DcSABQRh2cnI2\
AAQgAiADKAIQIgFBGHQgAUEIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZycjYACCACIAMoAhQiAUEYdC\
ABQQh0QYCA/AdxciABQQh2QYD+A3EgAUEYdnJyNgAMIAIgAygCGCIBQRh0IAFBCHRBgID8B3FyIAFB\
CHZBgP4DcSABQRh2cnI2ABAgA0HwAWokAAuyBgEVfyMAQbABayICJAACQAJAAkAgACgCkAEiAyABe6\
ciBE0NACAAQfAAaiEFIAJBKGohBiACQQhqIQcgAkHwAGpBIGohCCADQX9qIQkgA0EFdCAAakHUAGoh\
CiADQX5qQTdJIQsDQCAAIAk2ApABIAlFDQIgACAJQX9qIgw2ApABIAAtAGohDSACQfAAakEYaiIDIA\
pBGGoiDikAADcDACACQfAAakEQaiIPIApBEGoiECkAADcDACACQfAAakEIaiIRIApBCGoiEikAADcD\
ACAIIApBIGopAAA3AAAgCEEIaiAKQShqKQAANwAAIAhBEGogCkEwaikAADcAACAIQRhqIApBOGopAA\
A3AAAgByAFKQMANwMAIAdBCGogBUEIaiITKQMANwMAIAdBEGogBUEQaiIUKQMANwMAIAdBGGogBUEY\
aiIVKQMANwMAIAIgCikAADcDcCAGQThqIAJB8ABqQThqKQMANwAAIAZBMGogAkHwAGpBMGopAwA3AA\
AgBkEoaiACQfAAakEoaikDADcAACAGQSBqIAgpAwA3AAAgBkEYaiADKQMANwAAIAZBEGogDykDADcA\
ACAGQQhqIBEpAwA3AAAgBiACKQNwNwAAIAJBwAA6AGggAiANQQRyIg06AGkgAkIANwMAIAMgFSkCAD\
cDACAPIBQpAgA3AwAgESATKQIANwMAIAIgBSkCADcDcCACQfAAaiAGQcAAQgAgDRAaIAMoAgAhAyAP\
KAIAIQ8gESgCACERIAIoAowBIQ0gAigChAEhEyACKAJ8IRQgAigCdCEVIAIoAnAhFiALRQ0DIAogFj\
YCACAKQRxqIA02AgAgDiADNgIAIApBFGogEzYCACAQIA82AgAgCkEMaiAUNgIAIBIgETYCACAKQQRq\
IBU2AgAgACAJNgKQASAKQWBqIQogDCEJIAwgBE8NAAsLIAJBsAFqJAAPC0GgkcAAQStBkIXAABBVAA\
sgAiANNgKMASACIAM2AogBIAIgEzYChAEgAiAPNgKAASACIBQ2AnwgAiARNgJ4IAIgFTYCdCACIBY2\
AnBBkJLAACACQfAAakGAhsAAQfiGwAAQQgALggUBB38gACgCACIFQQFxIgYgBGohBwJAAkAgBUEEcQ\
0AQQAhAQwBCwJAAkAgAg0AQQAhCAwBCwJAIAJBA3EiCQ0ADAELQQAhCCABIQoDQCAIIAosAABBv39K\
aiEIIApBAWohCiAJQX9qIgkNAAsLIAggB2ohBwtBK0GAgMQAIAYbIQYCQAJAIAAoAghBAUYNAEEBIQ\
ogACAGIAEgAhBUDQEgACgCGCADIAQgAEEcaigCACgCDBEIAA8LAkACQAJAAkACQCAAQQxqKAIAIggg\
B00NACAFQQhxDQRBACEKIAggB2siCSEFQQEgAC0AICIIIAhBA0YbQQNxDgMDAQIDC0EBIQogACAGIA\
EgAhBUDQQgACgCGCADIAQgAEEcaigCACgCDBEIAA8LQQAhBSAJIQoMAQsgCUEBdiEKIAlBAWpBAXYh\
BQsgCkEBaiEKIABBHGooAgAhCSAAKAIEIQggACgCGCEHAkADQCAKQX9qIgpFDQEgByAIIAkoAhARBg\
BFDQALQQEPC0EBIQogCEGAgMQARg0BIAAgBiABIAIQVA0BIAcgAyAEIAkoAgwRCAANAUEAIQoCQANA\
AkAgBSAKRw0AIAUhCgwCCyAKQQFqIQogByAIIAkoAhARBgBFDQALIApBf2ohCgsgCiAFSSEKDAELIA\
AoAgQhBSAAQTA2AgQgAC0AICELQQEhCiAAQQE6ACAgACAGIAEgAhBUDQAgCCAHa0EBaiEKIABBHGoo\
AgAhCCAAKAIYIQkCQANAIApBf2oiCkUNASAJQTAgCCgCEBEGAEUNAAtBAQ8LQQEhCiAJIAMgBCAIKA\
IMEQgADQAgACALOgAgIAAgBTYCBEEADwsgCguPBQEKfyMAQTBrIgMkACADQSRqIAE2AgAgA0EDOgAo\
IANCgICAgIAENwMIIAMgADYCIEEAIQQgA0EANgIYIANBADYCEAJAAkACQAJAIAIoAggiBQ0AIAJBFG\
ooAgAiBkUNASACKAIAIQEgAigCECEAIAZBA3RBeGpBA3ZBAWoiBCEGA0ACQCABQQRqKAIAIgdFDQAg\
AygCICABKAIAIAcgAygCJCgCDBEIAA0ECyAAKAIAIANBCGogAEEEaigCABEGAA0DIABBCGohACABQQ\
hqIQEgBkF/aiIGDQAMAgsLIAJBDGooAgAiAEUNACAAQQV0IghBYGpBBXZBAWohBCACKAIAIQFBACEG\
A0ACQCABQQRqKAIAIgBFDQAgAygCICABKAIAIAAgAygCJCgCDBEIAA0DCyADIAUgBmoiAEEcai0AAD\
oAKCADIABBBGopAgBCIIk3AwggAEEYaigCACEJIAIoAhAhCkEAIQtBACEHAkACQAJAIABBFGooAgAO\
AwEAAgELIAlBA3QhDEEAIQcgCiAMaiIMKAIEQQVHDQEgDCgCACgCACEJC0EBIQcLIAMgCTYCFCADIA\
c2AhAgAEEQaigCACEHAkACQAJAIABBDGooAgAOAwEAAgELIAdBA3QhCSAKIAlqIgkoAgRBBUcNASAJ\
KAIAKAIAIQcLQQEhCwsgAyAHNgIcIAMgCzYCGCAKIAAoAgBBA3RqIgAoAgAgA0EIaiAAKAIEEQYADQ\
IgAUEIaiEBIAggBkEgaiIGRw0ACwtBACEAIAQgAigCBEkiAUUNASADKAIgIAIoAgAgBEEDdGpBACAB\
GyIBKAIAIAEoAgQgAygCJCgCDBEIAEUNAQtBASEACyADQTBqJAAgAAuPBAEJfyMAQTBrIgYkAEEAIQ\
cgBkEANgIIAkAgAUFAcSIIRQ0AQQEhByAGQQE2AgggBiAANgIAIAhBwABGDQBBAiEHIAZBAjYCCCAG\
IABBwABqNgIEIAhBgAFGDQAgBiAAQYABajYCEEGQksAAIAZBEGpBkIbAAEH4hsAAEEIACyABQT9xIQ\
kCQCAFQQV2IgEgByAHIAFLGyIBRQ0AIANBBHIhCiABQQV0IQtBACEBIAYhAwNAIAMoAgAhByAGQRBq\
QRhqIgwgAkEYaikCADcDACAGQRBqQRBqIg0gAkEQaikCADcDACAGQRBqQQhqIg4gAkEIaikCADcDAC\
AGIAIpAgA3AxAgBkEQaiAHQcAAQgAgChAaIAQgAWoiB0EYaiAMKQMANwAAIAdBEGogDSkDADcAACAH\
QQhqIA4pAwA3AAAgByAGKQMQNwAAIANBBGohAyALIAFBIGoiAUcNAAsgBigCCCEHCwJAAkACQAJAIA\
lFDQAgB0EFdCICIAVLDQEgBSACayIBQR9NDQIgCUEgRw0DIAQgAmoiAiAAIAhqIgEpAAA3AAAgAkEY\
aiABQRhqKQAANwAAIAJBEGogAUEQaikAADcAACACQQhqIAFBCGopAAA3AAAgB0EBaiEHCyAGQTBqJA\
AgBw8LIAIgBUGwhMAAEEwAC0EgIAFBsITAABBLAAtBICAJQeSLwAAQTgALgQQCA38CfiMAQfABayID\
JAAgACkDACEGIAEgAUHAAGotAAAiBGoiBUGAAToAACADQQhqQRBqIABBGGooAgA2AgAgA0EQaiAAQR\
BqKQIANwMAIAMgACkCCDcDCCAGQgmGIQYgBK1CA4YhBwJAIARBP3MiAEUNACAFQQFqQQAgABA8Ggsg\
BiAHhCEGAkACQCAEQThxQThGDQAgAUE4aiAGNwAAIANBCGogARATDAELIANBCGogARATIANB4ABqQQ\
xqQgA3AgAgA0HgAGpBFGpCADcCACADQeAAakEcakIANwIAIANB4ABqQSRqQgA3AgAgA0HgAGpBLGpC\
ADcCACADQeAAakE0akIANwIAIANBnAFqQgA3AgAgA0IANwJkIANBwAA2AmAgA0GoAWogA0HgAGpBxA\
AQOhogA0HQAGogA0GoAWpBNGopAgA3AwAgA0HIAGogA0GoAWpBLGopAgA3AwAgA0HAAGogA0GoAWpB\
JGopAgA3AwAgA0E4aiADQagBakEcaikCADcDACADQTBqIANBqAFqQRRqKQIANwMAIANBKGogA0GoAW\
pBDGopAgA3AwAgAyADKQKsATcDICADIAY3A1ggA0EIaiADQSBqEBMLIAIgAygCCDYAACACIAMpAgw3\
AAQgAiADKQIUNwAMIAFBwABqQQA6AAAgA0HwAWokAAvwAwIDfwJ+IwBB8AFrIgMkACABQcAAai0AAC\
EEIAApAwAhBiADQRBqIABBEGopAgA3AwAgAyAAKQIINwMIIAEgBGoiAEGAAToAACAGQgmGIQYgBK1C\
A4YhByADIANBCGo2AhwCQCAEQT9zIgVFDQAgAEEBakEAIAUQPBoLIAcgBoQhBgJAAkAgBEE4cUE4Rg\
0AIAFBOGogBjcAACADQRxqIAEQHQwBCyADQRxqIAEQHSADQeAAakEMakIANwIAIANB4ABqQRRqQgA3\
AgAgA0HgAGpBHGpCADcCACADQeAAakEkakIANwIAIANB4ABqQSxqQgA3AgAgA0HgAGpBNGpCADcCAC\
ADQZwBakIANwIAIANCADcCZCADQcAANgJgIANBqAFqIANB4ABqQcQAEDoaIANB0ABqIANBqAFqQTRq\
KQIANwMAIANByABqIANBqAFqQSxqKQIANwMAIANBwABqIANBqAFqQSRqKQIANwMAIANBOGogA0GoAW\
pBHGopAgA3AwAgA0EwaiADQagBakEUaikCADcDACADQShqIANBqAFqQQxqKQIANwMAIAMgAykCrAE3\
AyAgAyAGNwNYIANBHGogA0EgahAdCyABQcAAakEAOgAAIAIgAykDCDcAACACIAMpAxA3AAggA0HwAW\
okAAvZAwIDfwJ+IwBB4AFrIgMkACAAKQMAIQYgASABQcAAai0AACIEaiIFQYABOgAAIANBCGogAEEQ\
aikCADcDACADIAApAgg3AwAgBkIJhiEGIAStQgOGIQcCQCAEQT9zIgBFDQAgBUEBakEAIAAQPBoLIA\
cgBoQhBgJAAkAgBEE4cUE4Rg0AIAFBOGogBjcAACADIAEQIAwBCyADIAEQICADQdAAakEMakIANwIA\
IANB0ABqQRRqQgA3AgAgA0HQAGpBHGpCADcCACADQdAAakEkakIANwIAIANB0ABqQSxqQgA3AgAgA0\
HQAGpBNGpCADcCACADQYwBakIANwIAIANCADcCVCADQcAANgJQIANBmAFqIANB0ABqQcQAEDoaIANB\
wABqIANBmAFqQTRqKQIANwMAIANBOGogA0GYAWpBLGopAgA3AwAgA0EwaiADQZgBakEkaikCADcDAC\
ADQShqIANBmAFqQRxqKQIANwMAIANBIGogA0GYAWpBFGopAgA3AwAgA0EYaiADQZgBakEMaikCADcD\
ACADIAMpApwBNwMQIAMgBjcDSCADIANBEGoQIAsgAiADKQMANwAAIAIgAykDCDcACCABQcAAakEAOg\
AAIANB4AFqJAAL1AMCBH8CfiMAQdABayIDJAAgASABQcAAai0AACIEaiIFQQE6AAAgACkDAEIJhiEH\
IAStQgOGIQgCQCAEQT9zIgZFDQAgBUEBakEAIAYQPBoLIAcgCIQhBwJAAkAgBEE4cUE4Rg0AIAFBOG\
ogBzcAACAAQQhqIAFBARAYDAELIABBCGoiBCABQQEQGCADQcAAakEMakIANwIAIANBwABqQRRqQgA3\
AgAgA0HAAGpBHGpCADcCACADQcAAakEkakIANwIAIANBwABqQSxqQgA3AgAgA0HAAGpBNGpCADcCAC\
ADQfwAakIANwIAIANCADcCRCADQcAANgJAIANBiAFqIANBwABqQcQAEDoaIANBMGogA0GIAWpBNGop\
AgA3AwAgA0EoaiADQYgBakEsaikCADcDACADQSBqIANBiAFqQSRqKQIANwMAIANBGGogA0GIAWpBHG\
opAgA3AwAgA0EQaiADQYgBakEUaikCADcDACADQQhqIANBiAFqQQxqKQIANwMAIAMgAykCjAE3AwAg\
AyAHNwM4IAQgA0EBEBgLIAFBwABqQQA6AAAgAiAAKQMINwAAIAIgAEEQaikDADcACCACIABBGGopAw\
A3ABAgA0HQAWokAAuJAwEFfwJAAkACQCABQQlJDQBBACECQc3/eyABQRAgAUEQSxsiAWsgAE0NASAB\
QRAgAEELakF4cSAAQQtJGyIDakEMahAXIgBFDQEgAEF4aiECAkACQCABQX9qIgQgAHENACACIQEMAQ\
sgAEF8aiIFKAIAIgZBeHEgBCAAakEAIAFrcUF4aiIAQQAgASAAIAJrQRBLG2oiASACayIAayEEAkAg\
BkEDcUUNACABIAEoAgRBAXEgBHJBAnI2AgQgBCABakEEaiIEIAQoAgBBAXI2AgAgBSAFKAIAQQFxIA\
ByQQJyNgIAIAAgAmpBBGoiBCAEKAIAQQFyNgIAIAIgABAhDAELIAIoAgAhAiABIAQ2AgQgASACIABq\
NgIACyABKAIEIgBBA3FFDQIgAEF4cSICIANBEGpNDQIgASAAQQFxIANyQQJyNgIEIAEgA2oiACACIA\
NrIgJBA3I2AgQgACACQQRyaiIDIAMoAgBBAXI2AgAgACACECEMAgsgABAXIQILIAIPCyABQQhqC5cD\
AQV/IwBBkARrIgMkACAAQcgBaiEEAkACQAJAAkACQCAAQfACai0AACIFRQ0AQagBIAVrIgYgAksNAS\
ABIAQgBWogBhA6IAZqIQEgAiAGayECCyACIAJBqAFuIgVBqAFsIgdJDQEgAiAHayEGAkAgBUGoAWwi\
AkUNACABIQUDQCADQeACaiAAQagBEDoaIAAQJSAFIANB4AJqQagBEDpBqAFqIQUgAkHYfmoiAg0ACw\
sCQCAGDQBBACEGDAQLIANBADYCsAEgA0GwAWpBBHJBAEGoARA8GiADQagBNgKwASADQeACaiADQbAB\
akGsARA6GiADQQhqIANB4AJqQQRyQagBEDoaIANB4AJqIABBqAEQOhogABAlIANBCGogA0HgAmpBqA\
EQOhogBkGpAU8NAiABIAdqIANBCGogBhA6GiAEIANBCGpBqAEQOhoMAwsgASAEIAVqIAIQOhogBSAC\
aiEGDAILQaGNwABBI0HEjcAAEFUACyAGQagBQcSMwAAQSwALIABB8AJqIAY6AAAgA0GQBGokAAuXAw\
EFfyMAQbADayIDJAAgAEHIAWohBAJAAkACQAJAAkAgAEHQAmotAAAiBUUNAEGIASAFayIGIAJLDQEg\
ASAEIAVqIAYQOiAGaiEBIAIgBmshAgsgAiACQYgBbiIFQYgBbCIHSQ0BIAIgB2shBgJAIAVBiAFsIg\
JFDQAgASEFA0AgA0GgAmogAEGIARA6GiAAECUgBSADQaACakGIARA6QYgBaiEFIAJB+H5qIgINAAsL\
AkAgBg0AQQAhBgwECyADQQA2ApABIANBkAFqQQRyQQBBiAEQPBogA0GIATYCkAEgA0GgAmogA0GQAW\
pBjAEQOhogA0EIaiADQaACakEEckGIARA6GiADQaACaiAAQYgBEDoaIAAQJSADQQhqIANBoAJqQYgB\
EDoaIAZBiQFPDQIgASAHaiADQQhqIAYQOhogBCADQQhqQYgBEDoaDAMLIAEgBCAFaiACEDoaIAUgAm\
ohBgwCC0GhjcAAQSNBxI3AABBVAAsgBkGIAUHEjMAAEEsACyAAQdACaiAGOgAAIANBsANqJAALggMB\
A38CQAJAAkACQCAALQBoIgNFDQACQCADQcEATw0AIAAgA2pBKGogASACQcAAIANrIgMgAyACSxsiAx\
A6GiAAIAAtAGggA2oiBDoAaCABIANqIQECQCACIANrIgINAEEAIQIMAwsgAEEIaiAAQShqIgRBwAAg\
ACkDACAALQBqIABB6QBqIgMtAABFchAaIARBAEHBABA8GiADIAMtAABBAWo6AAAMAQsgA0HAAEGQhM\
AAEEwACwJAIAJBwABLDQAgAkHAACACQcAASRshAkEAIQMMAgsgAEEIaiEFIABB6QBqIgMtAAAhBANA\
IAUgAUHAACAAKQMAIAAtAGogBEH/AXFFchAaIAMgAy0AAEEBaiIEOgAAIAFBwABqIQEgAkFAaiICQc\
AASw0ACyAALQBoIQQLIARB/wFxIgNBwQBPDQEgAkHAACADayIEIAQgAksbIQILIAAgA2pBKGogASAC\
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\
IAJBGGoQLCEBIAJBMGokACABC3QBAn8jAEGQAmsiAiQAQQAhAyACQQA2AgADQCACIANqQQRqIAEgA2\
ooAAA2AgAgA0EEaiIDQYABRw0ACyACQYABNgIAIAJBiAFqIAJBhAEQOhogACACQYgBakEEckGAARA6\
IAEtAIABOgCAASACQZACaiQAC3QBAn8jAEGgAmsiAiQAQQAhAyACQQA2AgADQCACIANqQQRqIAEgA2\
ooAAA2AgAgA0EEaiIDQYgBRw0ACyACQYgBNgIAIAJBkAFqIAJBjAEQOhogACACQZABakEEckGIARA6\
IAEtAIgBOgCIASACQaACaiQAC3QBAn8jAEHgAmsiAiQAQQAhAyACQQA2AgADQCACIANqQQRqIAEgA2\
ooAAA2AgAgA0EEaiIDQagBRw0ACyACQagBNgIAIAJBsAFqIAJBrAEQOhogACACQbABakEEckGoARA6\
IAEtAKgBOgCoASACQeACaiQAC3IBAn8jAEGgAWsiAiQAQQAhAyACQQA2AgADQCACIANqQQRqIAEgA2\
ooAAA2AgAgA0EEaiIDQcgARw0ACyACQcgANgIAIAJB0ABqIAJBzAAQOhogACACQdAAakEEckHIABA6\
IAEtAEg6AEggAkGgAWokAAtyAQJ/IwBB4AFrIgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKA\
AANgIAIANBBGoiA0HoAEcNAAsgAkHoADYCACACQfAAaiACQewAEDoaIAAgAkHwAGpBBHJB6AAQOiAB\
LQBoOgBoIAJB4AFqJAALdAECfyMAQbACayICJABBACEDIAJBADYCAANAIAIgA2pBBGogASADaigAAD\
YCACADQQRqIgNBkAFHDQALIAJBkAE2AgAgAkGYAWogAkGUARA6GiAAIAJBmAFqQQRyQZABEDogAS0A\
kAE6AJABIAJBsAJqJAALbAEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQ\
M2AgAgA0ICNwIMIANByIrAADYCCCADQQM2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EI\
aiACEFkAC2wBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEDNgIAIANCAj\
cCDCADQaiKwAA2AgggA0EDNgIkIAMgA0EgajYCGCADIANBBGo2AiggAyADNgIgIANBCGogAhBZAAts\
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\
NEJMQUtFMlNCTEFLRTNLRUNDQUstMjI0S0VDQ0FLLTI1NktFQ0NBSy0zODRLRUNDQUstNTEyTUQ0TU\
Q1UklQRU1ELTE2MFNIQS0xU0hBLTIyNFNIQS0yNTZTSEEtMzg0U0hBLTUxMlRJR0VSdW5zdXBwb3J0\
ZWQgYWxnb3JpdGhtbm9uLWRlZmF1bHQgbGVuZ3RoIHNwZWNpZmllZCBmb3Igbm9uLWV4dGVuZGFibG\
UgYWxnb3JpdGhtbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc2NhcGFjaXR5IG92ZXJmbG93AOYA\
EAAcAAAAMgIAAAUAAABBcnJheVZlYzogY2FwYWNpdHkgZXhjZWVkZWQgaW4gZXh0ZW5kL2Zyb21faX\
Rlcn4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvYXJyYXl2\
ZWMtMC43LjIvc3JjL2FycmF5dmVjLnJzAFMBEABQAAAAAQQAAAUAAABUBhAATQAAAAEGAAAJAAAAfi\
8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9ibGFrZTMtMS4z\
LjAvc3JjL2xpYi5ycwAAAMQBEABJAAAAuQEAAAkAAADEARAASQAAAF8CAAAKAAAAxAEQAEkAAACNAg\
AACQAAAMQBEABJAAAA3QIAAAoAAADEARAASQAAANYCAAAJAAAAxAEQAEkAAAABAwAAGQAAAMQBEABJ\
AAAAAwMAAAkAAADEARAASQAAAAMDAAA4AAAAxAEQAEkAAAD4AwAAMgAAAMQBEABJAAAAqgQAABYAAA\
DEARAASQAAALwEAAAWAAAAxAEQAEkAAADtBAAAEgAAAMQBEABJAAAA9wQAABIAAADEARAASQAAAGkF\
AAAhAAAAEQAAAAQAAAAEAAAAEgAAABEAAAAgAAAAAQAAABMAAAARAAAABAAAAAQAAAASAAAAfi8uY2\
FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9hcnJheXZlYy0wLjcu\
Mi9zcmMvYXJyYXl2ZWNfaW1wbC5ycwAAACADEABVAAAAJwAAACAAAABDYXBhY2l0eUVycm9yAAAAiA\
MQAA0AAABpbnN1ZmZpY2llbnQgY2FwYWNpdHkAAACgAxAAFQAAABEAAAAAAAAAAQAAABQAAABpbmRl\
eCBvdXQgb2YgYm91bmRzOiB0aGUgbGVuIGlzICBidXQgdGhlIGluZGV4IGlzIAAA0AMQACAAAADwAx\
AAEgAAADogAACgCBAAAAAAABQEEAACAAAAKTAwMDEwMjAzMDQwNTA2MDcwODA5MTAxMTEyMTMxNDE1\
MTYxNzE4MTkyMDIxMjIyMzI0MjUyNjI3MjgyOTMwMzEzMjMzMzQzNTM2MzczODM5NDA0MTQyNDM0ND\
Q1NDY0NzQ4NDk1MDUxNTI1MzU0NTU1NjU3NTg1OTYwNjE2MjYzNjQ2NTY2Njc2ODY5NzA3MTcyNzM3\
NDc1NzY3Nzc4Nzk4MDgxODI4Mzg0ODU4Njg3ODg4OTkwOTE5MjkzOTQ5NTk2OTc5ODk5cmFuZ2Ugc3\
RhcnQgaW5kZXggIG91dCBvZiByYW5nZSBmb3Igc2xpY2Ugb2YgbGVuZ3RoIAAAAPEEEAASAAAAAwUQ\
ACIAAAByYW5nZSBlbmQgaW5kZXggOAUQABAAAAADBRAAIgAAAHNsaWNlIGluZGV4IHN0YXJ0cyBhdC\
AgYnV0IGVuZHMgYXQgAFgFEAAWAAAAbgUQAA0AAABzb3VyY2Ugc2xpY2UgbGVuZ3RoICgpIGRvZXMg\
bm90IG1hdGNoIGRlc3RpbmF0aW9uIHNsaWNlIGxlbmd0aCAojAUQABUAAAChBRAAKwAAACgEEAABAA\
AAVAYQAE0AAAAQDAAADQAAAH4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5\
ZGI5ZWM4MjMvYmxvY2stYnVmZmVyLTAuMTAuMC9zcmMvbGliLnJz9AUQAFAAAAD8AAAAJwAAAC9ydX\
N0Yy9mMWVkZDA0Mjk1ODJkZDI5Y2NjYWNhZjUwZmQxMzRiMDU1OTNiZDljL2xpYnJhcnkvY29yZS9z\
cmMvc2xpY2UvbW9kLnJzYXNzZXJ0aW9uIGZhaWxlZDogbWlkIDw9IHNlbGYubGVuKClUBhAATQAAAB\
8GAAAJAAAAAAAAAAEjRWeJq83v/ty6mHZUMhDw4dLDAAAAAGfmCWqFrme7cvNuPDr1T6V/Ug5RjGgF\
m6vZgx8ZzeBb2J4FwQfVfDYX3XAwOVkO9zELwP8RFVhop4/5ZKRP+r4IybzzZ+YJajunyoSFrme7K/\
iU/nLzbjzxNh1fOvVPpdGC5q1/Ug5RH2w+K4xoBZtrvUH7q9mDH3khfhMZzeBb2J4FwV2du8sH1Xw2\
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\
7K2QVDo6BtknPCsAv6IwgISjrn7AAyDtbTICxoZAqWl9KKeDinr1MMtfesV55+t55ERotem83AUPtH\
Oj4g5XiG54Gteg9ui9zbqchy+jZMG80WqXi9dmll7iIas8w+XlqmMQkJCNaUhEsxiYu4oePq6HZOO0\
3DuJMfm9rxnVu1/coEVjymWUmyb+KIbsUZw/YAFdHrdJUKEGQORNsct29+VwbL/tK1Xv8hgSQaM2Wn\
AIBwzLRGCYT3UUTecOKKgOQ9lWzWVQX1PXkSXBlu8KcvEjMsgfpWNzbzmgw251bGwgcG9pbnRlciBw\
YXNzZWQgdG8gcnVzdHJlY3Vyc2l2ZSB1c2Ugb2YgYW4gb2JqZWN0IGRldGVjdGVkIHdoaWNoIHdvdW\
xkIGxlYWQgdG8gdW5zYWZlIGFsaWFzaW5nIGluIHJ1c3QAAAQAAAAAAAAAQAAAACAAAAAwAAAAIAAA\
ACAAAAAcAAAAIAAAADAAAABAAAAAEAAAABAAAAAUAAAAFAAAABwAAAAgAAAAMAAAAEAAAAAcAAAAIA\
AAADAAAABAAAAAIAAAAEAAAAAYAAAAQAAAACAAAAAwAAAAIAAAACAAAAAcAAAAIAAAADAAAABAAAAA\
EAAAABAAAAAUAAAAFAAAABwAAAAgAAAAMAAAAEAAAAAcAAAAIAAAADAAAABAAAAAIAAAAEAAAAAYAA\
AAALq4gIAABG5hbWUBr7iAgAB5AEVqc19zeXM6OlR5cGVFcnJvcjo6bmV3OjpfX3diZ19uZXdfYTRi\
NjFhMGY1NDgyNGNmZDo6aGQwZmM0NjMyMGI3ZGQ5OWEBO3dhc21fYmluZGdlbjo6X193YmluZGdlbl\
9vYmplY3RfZHJvcF9yZWY6OmhkZGYxZjhlODllMjczZjBkAlVqc19zeXM6OlVpbnQ4QXJyYXk6OmJ5\
dGVfbGVuZ3RoOjpfX3diZ19ieXRlTGVuZ3RoXzNlMjUwYjQxYTg5MTU3NTc6Omg1ZGQ4ZjQyMDFmYT\
A0NGU2A1Vqc19zeXM6OlVpbnQ4QXJyYXk6OmJ5dGVfb2Zmc2V0OjpfX3diZ19ieXRlT2Zmc2V0XzQy\
MDRlY2IyNGE2ZTVkZjk6Omg2MDEyMWZmY2ViMDUyYjQ4BExqc19zeXM6OlVpbnQ4QXJyYXk6OmJ1Zm\
Zlcjo6X193YmdfYnVmZmVyX2ZhY2YwMzk4YTI4MWM4NWI6OmhiMDZhZjNlYzc5OTA3ZWY2BXlqc19z\
eXM6OlVpbnQ4QXJyYXk6Om5ld193aXRoX2J5dGVfb2Zmc2V0X2FuZF9sZW5ndGg6Ol9fd2JnX25ld3\
dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoXzRiOWI4YzRlM2Y1YWRiZmY6OmgwNzFlZmZhMTYwOTM5NjJj\
Bkxqc19zeXM6OlVpbnQ4QXJyYXk6Omxlbmd0aDo6X193YmdfbGVuZ3RoXzFlYjhmYzYwOGEwZDRjZG\
I6Omg4NjE2OGQxNDEzMTJkOWQ3BzJ3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fbWVtb3J5OjpoNzA2\
NmYxYTQ1YzJkNzg4YQhVanNfc3lzOjpXZWJBc3NlbWJseTo6TWVtb3J5OjpidWZmZXI6Ol9fd2JnX2\
J1ZmZlcl8zOTdlYWE0ZDcyZWU5NGRkOjpoOGVjMDRmOWE1ZDgzYjZhMwlGanNfc3lzOjpVaW50OEFy\
cmF5OjpuZXc6Ol9fd2JnX25ld19hN2NlNDQ3ZjE1ZmY0OTZmOjpoYjNiYTQwNGE1ZDgzYjNkMgpGan\
Nfc3lzOjpVaW50OEFycmF5OjpzZXQ6Ol9fd2JnX3NldF85NjlhZDBhNjBlNTFkMzIwOjpoODQyYjZh\
YjRkODFiN2ZkYwsxd2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX3Rocm93OjpoYjNjZDc3YTExYWFhMD\
UwMgwzd2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX3JldGhyb3c6OmgxYjVhNzgwMjNiZTU0MzExDUBk\
ZW5vX3N0ZF93YXNtX2NyeXB0bzo6ZGlnZXN0OjpDb250ZXh0OjpkaWdlc3Q6OmgyYmNjMTg3MGQ5YW\
IzODNjDixzaGEyOjpzaGE1MTI6OmNvbXByZXNzNTEyOjpoNmIxMGMzM2FkMDVjMzVmNg9KZGVub19z\
dGRfd2FzbV9jcnlwdG86OmRpZ2VzdDo6Q29udGV4dDo6ZGlnZXN0X2FuZF9yZXNldDo6aDQ0ZjRiNj\
M5NjUyZDdlMTcQQGRlbm9fc3RkX3dhc21fY3J5cHRvOjpkaWdlc3Q6OkNvbnRleHQ6OnVwZGF0ZTo6\
aGUwZjdjN2YyMmZjYjkzYTIRLHNoYTI6OnNoYTI1Njo6Y29tcHJlc3MyNTY6OmhlODc4MDI5Y2NmZG\
QzZGY0EjNibGFrZTI6OkJsYWtlMmJWYXJDb3JlOjpjb21wcmVzczo6aDlmODdhNzZhOGZiZWUyMmIT\
KXJpcGVtZDo6YzE2MDo6Y29tcHJlc3M6OmgxODljNDc5ZmJkNjdhZmFkFDNibGFrZTI6OkJsYWtlMn\
NWYXJDb3JlOjpjb21wcmVzczo6aDlkZGE5YzJhMmI2MTc2ODkVK3NoYTE6OmNvbXByZXNzOjpjb21w\
cmVzczo6aDUwZTVkODNlOTFkNjU0YWEWO2Rlbm9fc3RkX3dhc21fY3J5cHRvOjpEaWdlc3RDb250ZX\
h0OjpuZXc6Omg4NTJmMGUyNTRkYTI0NDJhFzpkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+\
OjptYWxsb2M6OmgyYTI3MjA3ZWU5YWY3ZmU5GCx0aWdlcjo6Y29tcHJlc3M6OmNvbXByZXNzOjpoNm\
QyNThmYmY3NTQ4YmZlMRktYmxha2UzOjpPdXRwdXRSZWFkZXI6OmZpbGw6OmhhOWMyNzBjOWI3ZmY0\
MWVlGjZibGFrZTM6OnBvcnRhYmxlOjpjb21wcmVzc19pbl9wbGFjZTo6aGM0YWQ3NDc3Y2JmNTJmMG\
UbE2RpZ2VzdGNvbnRleHRfY2xvbmUcZTxkaWdlc3Q6OmNvcmVfYXBpOjp3cmFwcGVyOjpDb3JlV3Jh\
cHBlcjxUPiBhcyBkaWdlc3Q6OlVwZGF0ZT46OnVwZGF0ZTo6e3tjbG9zdXJlfX06OmhlMWZhYWExOW\
M5MTM0ODllHWg8bWQ1OjpNZDVDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29y\
ZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6Ont7Y2xvc3VyZX19OjpoNTZjODcxYTc1MGM1MTgwZB4wYm\
xha2UzOjpjb21wcmVzc19zdWJ0cmVlX3dpZGU6Omg5OTVmOTJhMDk5ZDk4NjM0HzhkbG1hbGxvYzo6\
ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjpmcmVlOjpoY2I3OTQ3YTlhN2UyODJjYSAgbWQ0Ojpjb21wcm\
Vzczo6aDkwZDU0MDM2Y2E2MzNlM2MhQWRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46OmRp\
c3Bvc2VfY2h1bms6OmgyZjkwYmRkZmFiOWZkYWY5IhNkaWdlc3Rjb250ZXh0X3Jlc2V0I3I8c2hhMj\
o6Y29yZV9hcGk6OlNoYTUxMlZhckNvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6VmFyaWFibGVPdXRw\
dXRDb3JlPjo6ZmluYWxpemVfdmFyaWFibGVfY29yZTo6aDllYTRhMjE1OGUwNzAzM2IkL2JsYWtlMz\
o6SGFzaGVyOjpmaW5hbGl6ZV94b2Y6OmhiODgzZTZjNWM0ZTVkNDBiJSBrZWNjYWs6OmYxNjAwOjpo\
YTgyNTc5MGNmMjVhNWY1ZSYsY29yZTo6Zm10OjpGb3JtYXR0ZXI6OnBhZDo6aDQ5ZDJjZmNjYWZiYm\
RlNGQnDl9fcnVzdF9yZWFsbG9jKHI8c2hhMjo6Y29yZV9hcGk6OlNoYTI1NlZhckNvcmUgYXMgZGln\
ZXN0Ojpjb3JlX2FwaTo6VmFyaWFibGVPdXRwdXRDb3JlPjo6ZmluYWxpemVfdmFyaWFibGVfY29yZT\
o6aDAzYTkzMGI4Yzc0YzllZDUpXTxzaGExOjpTaGExQ29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpG\
aXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoYjVkOWVjNzAyNDhlMTgyMCoxYm\
xha2UzOjpIYXNoZXI6Om1lcmdlX2N2X3N0YWNrOjpoNDdiNmUyNGU2N2UyMTY1Yis1Y29yZTo6Zm10\
OjpGb3JtYXR0ZXI6OnBhZF9pbnRlZ3JhbDo6aGM2Njk0N2IxZGVkNTc4YWEsI2NvcmU6OmZtdDo6d3\
JpdGU6OmhiYmFmMzlmMDliZjQ5ZWZiLTRibGFrZTM6OmNvbXByZXNzX3BhcmVudHNfcGFyYWxsZWw6\
OmhhMDczMmZhY2IxMjc2OWJiLmQ8cmlwZW1kOjpSaXBlbWQxNjBDb3JlIGFzIGRpZ2VzdDo6Y29yZV\
9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6OmhkZThmYzJhZjcxMWYx\
ODVmL1s8bWQ1OjpNZDVDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46Om\
ZpbmFsaXplX2ZpeGVkX2NvcmU6OmgwYjMwMDNlNDg0MjlhYzNkMFs8bWQ0OjpNZDRDb3JlIGFzIGRp\
Z2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6OmgzZT\
JiMzAwNzMwYWE4YWYwMV88dGlnZXI6OlRpZ2VyQ29yZSBhcyBkaWdlc3Q6OmNvcmVfYXBpOjpGaXhl\
ZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoNDU3M2E0MGViYzU0Y2E1MzIwZGxtYW\
xsb2M6OkRsbWFsbG9jPEE+OjptYWxsb2M6OmgxODlmYmNhMDM3M2FiODI4M2U8ZGlnZXN0Ojpjb3Jl\
X2FwaTo6eG9mX3JlYWRlcjo6WG9mUmVhZGVyQ29yZVdyYXBwZXI8VD4gYXMgZGlnZXN0OjpYb2ZSZW\
FkZXI+OjpyZWFkOjpoOGE2ZDliYzFkOGM4YTc0NTRlPGRpZ2VzdDo6Y29yZV9hcGk6OnhvZl9yZWFk\
ZXI6OlhvZlJlYWRlckNvcmVXcmFwcGVyPFQ+IGFzIGRpZ2VzdDo6WG9mUmVhZGVyPjo6cmVhZDo6aD\
c0YzJhMGFkMGJjOGFmODU1LWJsYWtlMzo6Q2h1bmtTdGF0ZTo6dXBkYXRlOjpoYzU4OGE4Y2Q3YzI2\
Y2VmNTYvY29yZTo6Zm10OjpudW06OmltcDo6Zm10X3U2NDo6aDY2MjhhM2U3MjI3ZTg1NTM3BmRpZ2\
VzdDg+ZGVub19zdGRfd2FzbV9jcnlwdG86OkRpZ2VzdENvbnRleHQ6OnVwZGF0ZTo6aGJkOTQ0YWQ2\
M2Y2MjlkYTE5WzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3\
JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDFlNjc5OGM0NDQwOWIxM2M6Bm1lbWNweTsbZGlnZXN0\
Y29udGV4dF9kaWdlc3RBbmREcm9wPAZtZW1zZXQ9P3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3\
VyZXM6Omludm9rZTNfbXV0OjpoNGE4M2FkMzFhZDllYjlkOT4UZGlnZXN0Y29udGV4dF9kaWdlc3Q/\
LWpzX3N5czo6VWludDhBcnJheTo6dG9fdmVjOjpoNmVhOWI5MWQ1MjIzZGJiZEAcZGlnZXN0Y29udG\
V4dF9kaWdlc3RBbmRSZXNldEERZGlnZXN0Y29udGV4dF9uZXdCLmNvcmU6OnJlc3VsdDo6dW53cmFw\
X2ZhaWxlZDo6aGQ1ODRlZmI3Yjg0YmYzMjZDUDxhcnJheXZlYzo6ZXJyb3JzOjpDYXBhY2l0eUVycm\
9yPFQ+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6Omg4Y2EzNjljOTgxMGMyMjI5RFA8YXJyYXl2\
ZWM6OmVycm9yczo6Q2FwYWNpdHlFcnJvcjxUPiBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoYW\
JkMmI2NDNkZDBlY2QyY0VbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+\
IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoMzFiOWEwZGUxMGRmODY4OUZbPGJsb2NrX2\
J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46\
OmNsb25lOjpoNmQ1ZmZjMTIxNjVhNDVlZkdbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2\
tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoZTQ1NzhiZDExMWQ2NDYw\
N0hbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb2\
5lOjpDbG9uZT46OmNsb25lOjpoNzY2ZWMwMWYwODU4YjU3OElbPGJsb2NrX2J1ZmZlcjo6QmxvY2tC\
dWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFzIGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoMzg2Nz\
U4YmUyNWRiYzlmYUpbPGJsb2NrX2J1ZmZlcjo6QmxvY2tCdWZmZXI8QmxvY2tTaXplLEtpbmQ+IGFz\
IGNvcmU6OmNsb25lOjpDbG9uZT46OmNsb25lOjpoMzhlMzdmZDQxYjU4ZTJmNks/Y29yZTo6c2xpY2\
U6OmluZGV4OjpzbGljZV9lbmRfaW5kZXhfbGVuX2ZhaWw6OmhjM2UwZGNmNmQ4NjZlMWJlTEFjb3Jl\
OjpzbGljZTo6aW5kZXg6OnNsaWNlX3N0YXJ0X2luZGV4X2xlbl9mYWlsOjpoNmMxMDlhYzg1ODdmMj\
kxMU09Y29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9pbmRleF9vcmRlcl9mYWlsOjpoZDI3ZGMzODVh\
N2VjMTNjMU5OY29yZTo6c2xpY2U6OjxpbXBsIFtUXT46OmNvcHlfZnJvbV9zbGljZTo6bGVuX21pc2\
1hdGNoX2ZhaWw6OmhlZGQxMGM1YmNjMDI2MTBjTzZjb3JlOjpwYW5pY2tpbmc6OnBhbmljX2JvdW5k\
c19jaGVjazo6aGNlMDUwMmY2MzcxMWZhZDhQN3N0ZDo6cGFuaWNraW5nOjpydXN0X3BhbmljX3dpdG\
hfaG9vazo6aDYwNmQ3YzdmN2E0MjNiOThROmJsYWtlMjo6Qmxha2UyYlZhckNvcmU6Om5ld193aXRo\
X3BhcmFtczo6aDU4N2Y5YTcyNzlmMzcxNmRSGF9fd2JnX2RpZ2VzdGNvbnRleHRfZnJlZVMGbWVtY2\
1wVENjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6cGFkX2ludGVncmFsOjp3cml0ZV9wcmVmaXg6OmhhYTBh\
ZGYwMGNiNjdkZWQ3VSljb3JlOjpwYW5pY2tpbmc6OnBhbmljOjpoZWMxZmMwNTdiZDBiYWYwYlYUZG\
lnZXN0Y29udGV4dF91cGRhdGVXEV9fd2JpbmRnZW5fbWFsbG9jWDpibGFrZTI6OkJsYWtlMnNWYXJD\
b3JlOjpuZXdfd2l0aF9wYXJhbXM6Omg1ZmY0NTlmMjMxYWI4ZDY4WS1jb3JlOjpwYW5pY2tpbmc6On\
BhbmljX2ZtdDo6aDYzMTRiNWM5MWFiZTczNDlaP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3Vy\
ZXM6Omludm9rZTRfbXV0OjpoMGRhMGY0NDM1YWYyZTNlYVs/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0Oj\
pjbG9zdXJlczo6aW52b2tlM19tdXQ6OmgwMDg1MjE2YzlhMTJhZWRmXD93YXNtX2JpbmRnZW46OmNv\
bnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDNmMGUyMmI1ODczODUwMDZdP3dhc21fYmluZG\
dlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoMzJlNGU5MGYwYzA4MjM5MF4/d2Fz\
bV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6OmhiNWQ0MWNhNmRjZDZiMz\
Q4Xz93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDczZGIzMGMw\
OGZiNWJjZDBgP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoOT\
k0MDdiYzUzNzNkMzBmOWE/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19t\
dXQ6OmhmODAzN2M3ZmFjMTc4MDllYj93YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbn\
Zva2UyX211dDo6aDkxMTRjMzZhYmJlNDBmNzljQ3N0ZDo6cGFuaWNraW5nOjpiZWdpbl9wYW5pY19o\
YW5kbGVyOjp7e2Nsb3N1cmV9fTo6aDliOTg1YTI5M2FhYzRjZTFkEl9fd2JpbmRnZW5fcmVhbGxvY2\
U/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlMV9tdXQ6OmhkMWIyODM5MTNl\
Y2RiMGQxZjJjb3JlOjpvcHRpb246Ok9wdGlvbjxUPjo6dW53cmFwOjpoNWE3ZGY5MWI1ZDYwOTBjYm\
cwPCZUIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmgwZDljZDYyNmRhYmFhMWVmaDI8JlQgYXMg\
Y29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoZDMwM2JjMTZhZWU1NTkxMGkRcnVzdF9iZWdpbl91bn\
dpbmRqD19fd2JpbmRnZW5fZnJlZWs0YWxsb2M6OnJhd192ZWM6OmNhcGFjaXR5X292ZXJmbG93Ojpo\
NGI0OTAxNDgzMGNhZmU2M2wzYXJyYXl2ZWM6OmFycmF5dmVjOjpleHRlbmRfcGFuaWM6OmgzN2Q1OT\
hkNzVkMGQyZTZmbTljb3JlOjpvcHM6OmZ1bmN0aW9uOjpGbk9uY2U6OmNhbGxfb25jZTo6aDJhYjg2\
NzY3ZWMxN2M1MGRuH19fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXJvTmNvcmU6OmZtdDo6bn\
VtOjppbXA6OjxpbXBsIGNvcmU6OmZtdDo6RGlzcGxheSBmb3IgdTMyPjo6Zm10OjpoMDQ2ZWNjNWVh\
YWIzNGNkNXAxd2FzbV9iaW5kZ2VuOjpfX3J0Ojp0aHJvd19udWxsOjpoZGE3OGMxMGZhOTdiYTRjOH\
Eyd2FzbV9iaW5kZ2VuOjpfX3J0Ojpib3Jyb3dfZmFpbDo6aDU0MzNjYzM4Zjk0MTk1ZmZyKndhc21f\
YmluZGdlbjo6dGhyb3dfc3RyOjpoYTdhZjVhZTY3MjEyZjIxYXNJc3RkOjpzeXNfY29tbW9uOjpiYW\
NrdHJhY2U6Ol9fcnVzdF9lbmRfc2hvcnRfYmFja3RyYWNlOjpoYTAzYWJlZjAyYThiNzBmZHQqd2Fz\
bV9iaW5kZ2VuOjp0aHJvd192YWw6OmgwNWYxN2ZkOTc3Nzc3YjlkdTE8VCBhcyBjb3JlOjphbnk6Ok\
FueT46OnR5cGVfaWQ6OmhhMGM0NDkyMjE2ZDRkMmU3dgpydXN0X3BhbmljdzdzdGQ6OmFsbG9jOjpk\
ZWZhdWx0X2FsbG9jX2Vycm9yX2hvb2s6OmhmOWMzOTNiYTNjZDI4N2UxeG9jb3JlOjpwdHI6OmRyb3\
BfaW5fcGxhY2U8JmNvcmU6Oml0ZXI6OmFkYXB0ZXJzOjpjb3BpZWQ6OkNvcGllZDxjb3JlOjpzbGlj\
ZTo6aXRlcjo6SXRlcjx1OD4+Pjo6aDYzYzJlMTQ5N2I1MmYzZDcA74CAgAAJcHJvZHVjZXJzAghsYW\
5ndWFnZQEEUnVzdAAMcHJvY2Vzc2VkLWJ5AwVydXN0Yx0xLjU3LjAgKGYxZWRkMDQyOSAyMDIxLTEx\
LTI5KQZ3YWxydXMGMC4xOS4wDHdhc20tYmluZGdlbgYwLjIuNzg=\
");
const heap = new Array(32).fill(undefined);
heap.push(undefined, null, true, false);
function getObject(idx) {
    return heap[idx];
}
let heap_next = heap.length;
function dropObject(idx) {
    if (idx < 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
}
function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}
function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];
    heap[idx] = obj;
    return idx;
}
let cachedTextDecoder = new TextDecoder("utf-8", {
    ignoreBOM: true,
    fatal: true
});
cachedTextDecoder.decode();
let cachegetUint8Memory0 = null;
function getUint8Memory0() {
    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachegetUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
let WASM_VECTOR_LEN = 0;
let cachedTextEncoder = new TextEncoder("utf-8");
const encodeString = function(arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
};
function passStringToWasm0(arg, malloc, realloc) {
    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length);
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }
    let len = arg.length;
    let ptr = malloc(len);
    const mem = getUint8Memory0();
    let offset = 0;
    for(; offset < len; offset++){
        const code61 = arg.charCodeAt(offset);
        if (code61 > 127) break;
        mem[ptr + offset] = code61;
    }
    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3);
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);
        offset += ret.written;
    }
    WASM_VECTOR_LEN = offset;
    return ptr;
}
function isLikeNone(x29) {
    return x29 === undefined || x29 === null;
}
let cachegetInt32Memory0 = null;
function getInt32Memory0() {
    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachegetInt32Memory0;
}
function getArrayU8FromWasm0(ptr, len) {
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
function digest(algorithm, data38, length) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        var ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.digest(retptr, ptr0, len0, addHeapObject(data38), !isLikeNone(length), isLikeNone(length) ? 0 : length);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var v1 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_free(r0, r1 * 1);
        return v1;
    } finally{
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}
const DigestContextFinalization = new FinalizationRegistry((ptr)=>wasm.__wbg_digestcontext_free(ptr)
);
class DigestContext {
    static __wrap(ptr) {
        const obj = Object.create(DigestContext.prototype);
        obj.ptr = ptr;
        DigestContextFinalization.register(obj, obj.ptr, obj);
        return obj;
    }
    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DigestContextFinalization.unregister(this);
        return ptr;
    }
    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_digestcontext_free(ptr);
    }
    constructor(algorithm){
        var ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.digestcontext_new(ptr0, len0);
        return DigestContext.__wrap(ret);
    }
    update(data39) {
        wasm.digestcontext_update(this.ptr, addHeapObject(data39));
    }
    digest(length) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digest(retptr, this.ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    digestAndReset(length) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digestAndReset(retptr, this.ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    digestAndDrop(length) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digestAndDrop(retptr, ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    reset() {
        wasm.digestcontext_reset(this.ptr);
    }
    clone() {
        var ret = wasm.digestcontext_clone(this.ptr);
        return DigestContext.__wrap(ret);
    }
}
const imports = {
    __wbindgen_placeholder__: {
        __wbg_new_a4b61a0f54824cfd: function(arg0, arg1) {
            var ret = new TypeError(getStringFromWasm0(arg0, arg1));
            return addHeapObject(ret);
        },
        __wbindgen_object_drop_ref: function(arg0) {
            takeObject(arg0);
        },
        __wbg_byteLength_3e250b41a8915757: function(arg0) {
            var ret = getObject(arg0).byteLength;
            return ret;
        },
        __wbg_byteOffset_4204ecb24a6e5df9: function(arg0) {
            var ret = getObject(arg0).byteOffset;
            return ret;
        },
        __wbg_buffer_facf0398a281c85b: function(arg0) {
            var ret = getObject(arg0).buffer;
            return addHeapObject(ret);
        },
        __wbg_newwithbyteoffsetandlength_4b9b8c4e3f5adbff: function(arg0, arg1, arg2) {
            var ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
            return addHeapObject(ret);
        },
        __wbg_length_1eb8fc608a0d4cdb: function(arg0) {
            var ret = getObject(arg0).length;
            return ret;
        },
        __wbindgen_memory: function() {
            var ret = wasm.memory;
            return addHeapObject(ret);
        },
        __wbg_buffer_397eaa4d72ee94dd: function(arg0) {
            var ret = getObject(arg0).buffer;
            return addHeapObject(ret);
        },
        __wbg_new_a7ce447f15ff496f: function(arg0) {
            var ret = new Uint8Array(getObject(arg0));
            return addHeapObject(ret);
        },
        __wbg_set_969ad0a60e51d320: function(arg0, arg1, arg2) {
            getObject(arg0).set(getObject(arg1), arg2 >>> 0);
        },
        __wbindgen_throw: function(arg0, arg1) {
            throw new Error(getStringFromWasm0(arg0, arg1));
        },
        __wbindgen_rethrow: function(arg0) {
            throw takeObject(arg0);
        }
    }
};
const wasmModule = new WebAssembly.Module(data);
const wasmInstance = new WebAssembly.Instance(wasmModule, imports);
const wasm = wasmInstance.exports;
const _wasm = wasm;
const _wasmModule = wasmModule;
const _wasmInstance = wasmInstance;
const mod54 = {
    digest: digest,
    DigestContext: DigestContext,
    _wasm: _wasm,
    _wasmModule: _wasmModule,
    _wasmInstance: _wasmInstance,
    _wasmBytes: data
};
const digestAlgorithms = [
    "BLAKE2B-256",
    "BLAKE2B-384",
    "BLAKE2B",
    "BLAKE2S",
    "BLAKE3",
    "KECCAK-224",
    "KECCAK-256",
    "KECCAK-384",
    "KECCAK-512",
    "SHA-384",
    "SHA3-224",
    "SHA3-256",
    "SHA3-384",
    "SHA3-512",
    "SHAKE128",
    "SHAKE256",
    "TIGER",
    "RIPEMD-160",
    "SHA-224",
    "SHA-256",
    "SHA-512",
    "MD4",
    "MD5",
    "SHA-1", 
];
const hexTable1 = new TextEncoder().encode("0123456789abcdef");
function encode4(src) {
    const dst = new Uint8Array(src.length * 2);
    for(let i147 = 0; i147 < dst.length; i147++){
        const v16 = src[i147];
        dst[i147 * 2] = hexTable1[v16 >> 4];
        dst[i147 * 2 + 1] = hexTable1[v16 & 15];
    }
    return dst;
}
const coerceToBytes = (data40)=>{
    if (data40 instanceof Uint8Array) {
        return data40;
    } else if (typeof data40 === "string") {
        return new TextEncoder().encode(data40);
    } else if (ArrayBuffer.isView(data40)) {
        return new Uint8Array(data40.buffer, data40.byteOffset, data40.byteLength);
    } else if (data40 instanceof ArrayBuffer) {
        return new Uint8Array(data40);
    } else {
        throw new TypeError("expected data to be string | BufferSource");
    }
};
class Hash extends Transform {
    #context;
    constructor(algorithm, _opts){
        super({
            transform (chunk, _encoding, callback) {
                context.update(coerceToBytes(chunk));
                callback();
            },
            flush (callback) {
                this.push(context.digest(undefined));
                callback();
            }
        });
        if (typeof algorithm === "string") {
            algorithm = algorithm.toUpperCase();
            if (opensslToWebCryptoDigestNames[algorithm]) {
                algorithm = opensslToWebCryptoDigestNames[algorithm];
            }
            this.#context = new mod54.DigestContext(algorithm);
        } else {
            this.#context = algorithm;
        }
        const context = this.#context;
    }
    copy() {
        return new Hash(this.#context.clone());
    }
    update(data41, _encoding) {
        let bytes;
        if (typeof data41 === "string") {
            data41 = new TextEncoder().encode(data41);
            bytes = coerceToBytes(data41);
        } else {
            bytes = coerceToBytes(data41);
        }
        this.#context.update(bytes);
        return this;
    }
    digest(encoding) {
        const digest1 = this.#context.digest(undefined);
        if (encoding === undefined) {
            return Buffer1.from(digest1);
        }
        switch(encoding){
            case "hex":
                return new TextDecoder().decode(encode4(new Uint8Array(digest1)));
            case "binary":
                return String.fromCharCode(...digest1);
            case "base64":
                return encode(digest1);
            default:
                throw new Error(`The output encoding for hash digest is not implemented: ${encoding}`);
        }
    }
}
const opensslToWebCryptoDigestNames = {
    BLAKE2B512: "BLAKE2B",
    BLAKE2S256: "BLAKE2S",
    RIPEMD160: "RIPEMD-160",
    RMD160: "RIPEMD-160",
    SHA1: "SHA-1",
    SHA224: "SHA-224",
    SHA256: "SHA-256",
    SHA384: "SHA-384",
    SHA512: "SHA-512"
};
function createHash(algorithm, opts) {
    return new Hash(algorithm, opts);
}
function getHashes() {
    return digestAlgorithms;
}
const MAX_ALLOC = Math.pow(2, 30) - 1;
const createHasher = (algorithm)=>(value)=>Buffer1.from(createHash(algorithm).update(value).digest())
;
function getZeroes(zeros1) {
    return Buffer1.alloc(zeros1);
}
const sizes = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
};
function toBuffer(bufferable) {
    if (bufferable instanceof Uint8Array || typeof bufferable === "string") {
        return Buffer1.from(bufferable);
    } else {
        return Buffer1.from(bufferable.buffer);
    }
}
class Hmac {
    hash;
    ipad1;
    opad;
    alg;
    blocksize;
    size;
    ipad2;
    constructor(alg, key, saltLen){
        this.hash = createHasher(alg);
        const blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
        if (key.length > blocksize) {
            key = this.hash(key);
        } else if (key.length < blocksize) {
            key = Buffer1.concat([
                key,
                getZeroes(blocksize - key.length)
            ], blocksize);
        }
        const ipad = Buffer1.allocUnsafe(blocksize + sizes[alg]);
        const opad = Buffer1.allocUnsafe(blocksize + sizes[alg]);
        for(let i148 = 0; i148 < blocksize; i148++){
            ipad[i148] = key[i148] ^ 54;
            opad[i148] = key[i148] ^ 92;
        }
        const ipad1 = Buffer1.allocUnsafe(blocksize + saltLen + 4);
        ipad.copy(ipad1, 0, 0, blocksize);
        this.ipad1 = ipad1;
        this.ipad2 = ipad;
        this.opad = opad;
        this.alg = alg;
        this.blocksize = blocksize;
        this.size = sizes[alg];
    }
    run(data42, ipad) {
        data42.copy(ipad, this.blocksize);
        const h2 = this.hash(ipad);
        h2.copy(this.opad, this.blocksize);
        return this.hash(this.opad);
    }
}
function pbkdf2Sync(password, salt, iterations, keylen, digest2 = "sha1") {
    if (typeof iterations !== "number" || iterations < 0) {
        throw new TypeError("Bad iterations");
    }
    if (typeof keylen !== "number" || keylen < 0 || keylen > MAX_ALLOC) {
        throw new TypeError("Bad key length");
    }
    const bufferedPassword = toBuffer(password);
    const bufferedSalt = toBuffer(salt);
    const hmac = new Hmac(digest2, bufferedPassword, bufferedSalt.length);
    const DK = Buffer1.allocUnsafe(keylen);
    const block1 = Buffer1.allocUnsafe(bufferedSalt.length + 4);
    bufferedSalt.copy(block1, 0, 0, bufferedSalt.length);
    let destPos = 0;
    const hLen = sizes[digest2];
    const l6 = Math.ceil(keylen / hLen);
    for(let i149 = 1; i149 <= l6; i149++){
        block1.writeUInt32BE(i149, bufferedSalt.length);
        const T = hmac.run(block1, hmac.ipad1);
        let U = T;
        for(let j = 1; j < iterations; j++){
            U = hmac.run(U, hmac.ipad2);
            for(let k14 = 0; k14 < hLen; k14++)T[k14] ^= U[k14];
        }
        T.copy(DK, destPos);
        destPos += hLen;
    }
    return DK;
}
function pbkdf2(password, salt, iterations, keylen, digest3 = "sha1", callback) {
    setTimeout(()=>{
        let err159 = null, res;
        try {
            res = pbkdf2Sync(password, salt, iterations, keylen, digest3);
        } catch (e44) {
            err159 = e44;
        }
        if (err159) {
            callback(err159 instanceof Error ? err159 : new Error("[non-error thrown]"));
        } else {
            callback(null, res);
        }
    }, 0);
}
const fixOpts = (opts)=>{
    const out = {
        N: 16384,
        p: 1,
        r: 8,
        maxmem: 32 << 20
    };
    if (!opts) return out;
    if (opts.N) out.N = opts.N;
    else if (opts.cost) out.N = opts.cost;
    if (opts.p) out.p = opts.p;
    else if (opts.parallelization) out.p = opts.parallelization;
    if (opts.r) out.r = opts.r;
    else if (opts.blockSize) out.r = opts.blockSize;
    if (opts.maxmem) out.maxmem = opts.maxmem;
    return out;
};
function blockxor(S, Si, D, Di, len) {
    let i150 = -1;
    while(++i150 < len)D[Di + i150] ^= S[Si + i150];
}
function arraycopy(src, srcPos, dest, destPos, length) {
    src.copy(dest, destPos, srcPos, srcPos + length);
}
const R = (a16, b16)=>a16 << b16 | a16 >>> 32 - b16
;
class ScryptRom {
    B;
    r;
    N;
    p;
    XY;
    V;
    B32;
    x;
    _X;
    constructor(b17, r22, N, p19){
        this.B = b17;
        this.r = r22;
        this.N = N;
        this.p = p19;
        this.XY = Buffer1.allocUnsafe(256 * r22);
        this.V = Buffer1.allocUnsafe(128 * r22 * N);
        this.B32 = new Int32Array(16);
        this.x = new Int32Array(16);
        this._X = Buffer1.allocUnsafe(64);
    }
    run() {
        const p20 = this.p | 0;
        const r23 = this.r | 0;
        for(let i151 = 0; i151 < p20; i151++)this.scryptROMix(i151, r23);
        return this.B;
    }
    scryptROMix(i152, r24) {
        const blockStart = i152 * 128 * r24;
        const offset = (2 * r24 - 1) * 64;
        const blockLen = 128 * r24;
        const B = this.B;
        const N = this.N | 0;
        const V = this.V;
        const XY = this.XY;
        B.copy(XY, 0, blockStart, blockStart + blockLen);
        for(let i153 = 0; i153 < N; i153++){
            XY.copy(V, i153 * blockLen, 0, blockLen);
            this.blockmix_salsa8(blockLen);
        }
        let j;
        for(let i2 = 0; i2 < N; i2++){
            j = XY.readUInt32LE(offset) & N - 1;
            blockxor(V, j * blockLen, XY, 0, blockLen);
            this.blockmix_salsa8(blockLen);
        }
        XY.copy(B, blockStart, 0, blockLen);
    }
    blockmix_salsa8(blockLen) {
        const BY = this.XY;
        const r25 = this.r;
        const _X = this._X;
        arraycopy(BY, (2 * r25 - 1) * 64, _X, 0, 64);
        let i154;
        for(i154 = 0; i154 < 2 * r25; i154++){
            blockxor(BY, i154 * 64, _X, 0, 64);
            this.salsa20_8();
            arraycopy(_X, 0, BY, blockLen + i154 * 64, 64);
        }
        for(i154 = 0; i154 < r25; i154++){
            arraycopy(BY, blockLen + i154 * 2 * 64, BY, i154 * 64, 64);
            arraycopy(BY, blockLen + (i154 * 2 + 1) * 64, BY, (i154 + r25) * 64, 64);
        }
    }
    salsa20_8() {
        const B32 = this.B32;
        const B = this._X;
        const x30 = this.x;
        let i155;
        for(i155 = 0; i155 < 16; i155++){
            B32[i155] = (B[i155 * 4 + 0] & 255) << 0;
            B32[i155] |= (B[i155 * 4 + 1] & 255) << 8;
            B32[i155] |= (B[i155 * 4 + 2] & 255) << 16;
            B32[i155] |= (B[i155 * 4 + 3] & 255) << 24;
        }
        for(i155 = 0; i155 < 16; i155++)x30[i155] = B32[i155];
        for(i155 = 0; i155 < 4; i155++){
            x30[4] ^= R(x30[0] + x30[12], 7);
            x30[8] ^= R(x30[4] + x30[0], 9);
            x30[12] ^= R(x30[8] + x30[4], 13);
            x30[0] ^= R(x30[12] + x30[8], 18);
            x30[9] ^= R(x30[5] + x30[1], 7);
            x30[13] ^= R(x30[9] + x30[5], 9);
            x30[1] ^= R(x30[13] + x30[9], 13);
            x30[5] ^= R(x30[1] + x30[13], 18);
            x30[14] ^= R(x30[10] + x30[6], 7);
            x30[2] ^= R(x30[14] + x30[10], 9);
            x30[6] ^= R(x30[2] + x30[14], 13);
            x30[10] ^= R(x30[6] + x30[2], 18);
            x30[3] ^= R(x30[15] + x30[11], 7);
            x30[7] ^= R(x30[3] + x30[15], 9);
            x30[11] ^= R(x30[7] + x30[3], 13);
            x30[15] ^= R(x30[11] + x30[7], 18);
            x30[1] ^= R(x30[0] + x30[3], 7);
            x30[2] ^= R(x30[1] + x30[0], 9);
            x30[3] ^= R(x30[2] + x30[1], 13);
            x30[0] ^= R(x30[3] + x30[2], 18);
            x30[6] ^= R(x30[5] + x30[4], 7);
            x30[7] ^= R(x30[6] + x30[5], 9);
            x30[4] ^= R(x30[7] + x30[6], 13);
            x30[5] ^= R(x30[4] + x30[7], 18);
            x30[11] ^= R(x30[10] + x30[9], 7);
            x30[8] ^= R(x30[11] + x30[10], 9);
            x30[9] ^= R(x30[8] + x30[11], 13);
            x30[10] ^= R(x30[9] + x30[8], 18);
            x30[12] ^= R(x30[15] + x30[14], 7);
            x30[13] ^= R(x30[12] + x30[15], 9);
            x30[14] ^= R(x30[13] + x30[12], 13);
            x30[15] ^= R(x30[14] + x30[13], 18);
        }
        for(i155 = 0; i155 < 16; i155++)B32[i155] += x30[i155];
        let bi;
        for(i155 = 0; i155 < 16; i155++){
            bi = i155 * 4;
            B[bi + 0] = B32[i155] >> 0 & 255;
            B[bi + 1] = B32[i155] >> 8 & 255;
            B[bi + 2] = B32[i155] >> 16 & 255;
            B[bi + 3] = B32[i155] >> 24 & 255;
        }
    }
    clean() {
        this.XY.fill(0);
        this.V.fill(0);
        this._X.fill(0);
        this.B.fill(0);
        for(let i156 = 0; i156 < 16; i156++){
            this.B32[i156] = 0;
            this.x[i156] = 0;
        }
    }
}
function scryptSync(password, salt, keylen, _opts) {
    const { N , r: r26 , p: p21 , maxmem  } = fixOpts(_opts);
    const blen = p21 * 128 * r26;
    if (32 * r26 * (N + 2) * 4 + blen > maxmem) {
        throw new Error("excedes max memory");
    }
    const b18 = pbkdf2Sync(password, salt, 1, blen, "sha256");
    const scryptRom = new ScryptRom(b18, r26, N, p21);
    const out = scryptRom.run();
    const fin = pbkdf2Sync(password, out, 1, keylen, "sha256");
    scryptRom.clean();
    return fin;
}
function scrypt(password, salt, keylen, _opts, cb) {
    if (!cb) {
        cb = _opts;
        _opts = null;
    }
    const { N , r: r27 , p: p22 , maxmem  } = fixOpts(_opts);
    const blen = p22 * 128 * r27;
    if (32 * r27 * (N + 2) * 4 + blen > maxmem) {
        throw new Error("excedes max memory");
    }
    try {
        const b19 = pbkdf2Sync(password, salt, 1, blen, "sha256");
        const scryptRom = new ScryptRom(b19, r27, N, p22);
        const out = scryptRom.run();
        const result = pbkdf2Sync(password, out, 1, keylen, "sha256");
        scryptRom.clean();
        cb(null, result);
    } catch (err160) {
        return cb(err160);
    }
}
const timingSafeEqual = (a17, b20)=>{
    if (a17 instanceof DataView) a17 = Buffer1.from(a17.buffer);
    if (b20 instanceof DataView) b20 = Buffer1.from(b20.buffer);
    if (a17 instanceof ArrayBuffer) a17 = Buffer1.from(a17);
    if (b20 instanceof ArrayBuffer) b20 = Buffer1.from(b20);
    let result = 0;
    if (a17.byteLength !== b20.byteLength) {
        b20 = a17;
        result = 1;
    }
    for(let i157 = 0; i157 < a17.byteLength; i157++){
        result |= a17[i157] ^ b20[i157];
    }
    return result === 0;
};
function assert5(val, msg) {
    if (!val) throw new Error(msg || "Assertion failed");
}
function inherits1(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
}
function BN(number, base17, endian) {
    if (BN.isBN(number)) {
        return number;
    }
    this.negative = 0;
    this.words = null;
    this.length = 0;
    this.red = null;
    if (number !== null) {
        if (base17 === "le" || base17 === "be") {
            endian = base17;
            base17 = 10;
        }
        this._init(number || 0, base17 || 10, endian || "be");
    }
}
BN.BN = BN;
BN.wordSize = 26;
BN.isBN = function isBN(num) {
    if (num instanceof BN) {
        return true;
    }
    return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
};
BN.max = function max(left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
};
BN.min = function min(left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
};
BN.prototype._init = function init(number, base18, endian) {
    if (typeof number === "number") {
        return this._initNumber(number, base18, endian);
    }
    if (typeof number === "object") {
        return this._initArray(number, base18, endian);
    }
    if (base18 === "hex") {
        base18 = 16;
    }
    assert5(base18 === (base18 | 0) && base18 >= 2 && base18 <= 36);
    number = number.toString().replace(/\s+/g, "");
    var start29 = 0;
    if (number[0] === "-") {
        start29++;
        this.negative = 1;
    }
    if (start29 < number.length) {
        if (base18 === 16) {
            this._parseHex(number, start29, endian);
        } else {
            this._parseBase(number, base18, start29);
            if (endian === "le") {
                this._initArray(this.toArray(), base18, endian);
            }
        }
    }
};
BN.prototype._initNumber = function _initNumber(number, base19, endian) {
    if (number < 0) {
        this.negative = 1;
        number = -number;
    }
    if (number < 67108864) {
        this.words = [
            number & 67108863
        ];
        this.length = 1;
    } else if (number < 4503599627370496) {
        this.words = [
            number & 67108863,
            number / 67108864 & 67108863, 
        ];
        this.length = 2;
    } else {
        assert5(number < 9007199254740992);
        this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1, 
        ];
        this.length = 3;
    }
    if (endian !== "le") return;
    this._initArray(this.toArray(), base19, endian);
};
BN.prototype._initArray = function _initArray(number, base, endian) {
    assert5(typeof number.length === "number");
    if (number.length <= 0) {
        this.words = [
            0
        ];
        this.length = 1;
        return this;
    }
    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for(var i158 = 0; i158 < this.length; i158++){
        this.words[i158] = 0;
    }
    var j, w19;
    var off = 0;
    if (endian === "be") {
        for(i158 = number.length - 1, j = 0; i158 >= 0; i158 -= 3){
            w19 = number[i158] | number[i158 - 1] << 8 | number[i158 - 2] << 16;
            this.words[j] |= w19 << off & 67108863;
            this.words[j + 1] = w19 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
    } else if (endian === "le") {
        for(i158 = 0, j = 0; i158 < number.length; i158 += 3){
            w19 = number[i158] | number[i158 + 1] << 8 | number[i158 + 2] << 16;
            this.words[j] |= w19 << off & 67108863;
            this.words[j + 1] = w19 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
    }
    return this._strip();
};
function parseHex4Bits(string, index14) {
    var c20 = string.charCodeAt(index14);
    if (c20 >= 48 && c20 <= 57) {
        return c20 - 48;
    } else if (c20 >= 65 && c20 <= 70) {
        return c20 - 55;
    } else if (c20 >= 97 && c20 <= 102) {
        return c20 - 87;
    } else {
        assert5(false, "Invalid character in " + string);
    }
}
function parseHexByte(string, lowerBound, index15) {
    var r28 = parseHex4Bits(string, index15);
    if (index15 - 1 >= lowerBound) {
        r28 |= parseHex4Bits(string, index15 - 1) << 4;
    }
    return r28;
}
BN.prototype._parseHex = function _parseHex(number, start30, endian) {
    this.length = Math.ceil((number.length - start30) / 6);
    this.words = new Array(this.length);
    for(var i159 = 0; i159 < this.length; i159++){
        this.words[i159] = 0;
    }
    var off = 0;
    var j = 0;
    var w20;
    if (endian === "be") {
        for(i159 = number.length - 1; i159 >= start30; i159 -= 2){
            w20 = parseHexByte(number, start30, i159) << off;
            this.words[j] |= w20 & 67108863;
            if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w20 >>> 26;
            } else {
                off += 8;
            }
        }
    } else {
        var parseLength = number.length - start30;
        for(i159 = parseLength % 2 === 0 ? start30 + 1 : start30; i159 < number.length; i159 += 2){
            w20 = parseHexByte(number, start30, i159) << off;
            this.words[j] |= w20 & 67108863;
            if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w20 >>> 26;
            } else {
                off += 8;
            }
        }
    }
    this._strip();
};
function parseBase(str, start31, end, mul) {
    var r29 = 0;
    var b21 = 0;
    var len = Math.min(str.length, end);
    for(var i160 = start31; i160 < len; i160++){
        var c21 = str.charCodeAt(i160) - 48;
        r29 *= mul;
        if (c21 >= 49) {
            b21 = c21 - 49 + 10;
        } else if (c21 >= 17) {
            b21 = c21 - 17 + 10;
        } else {
            b21 = c21;
        }
        assert5(c21 >= 0 && b21 < mul, "Invalid character");
        r29 += b21;
    }
    return r29;
}
BN.prototype._parseBase = function _parseBase(number, base20, start32) {
    this.words = [
        0
    ];
    this.length = 1;
    for(var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base20){
        limbLen++;
    }
    limbLen--;
    limbPow = limbPow / base20 | 0;
    var total = number.length - start32;
    var mod64 = total % limbLen;
    var end = Math.min(total, total - mod64) + start32;
    var word = 0;
    for(var i161 = start32; i161 < end; i161 += limbLen){
        word = parseBase(number, i161, i161 + limbLen, base20);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
            this.words[0] += word;
        } else {
            this._iaddn(word);
        }
    }
    if (mod64 !== 0) {
        var pow = 1;
        word = parseBase(number, i161, number.length, base20);
        for(i161 = 0; i161 < mod64; i161++){
            pow *= base20;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
            this.words[0] += word;
        } else {
            this._iaddn(word);
        }
    }
    this._strip();
};
BN.prototype.copy = function copy(dest) {
    dest.words = new Array(this.length);
    for(var i162 = 0; i162 < this.length; i162++){
        dest.words[i162] = this.words[i162];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
};
function move(dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
}
BN.prototype._move = function _move(dest) {
    move(dest, this);
};
BN.prototype.clone = function clone() {
    var r30 = new BN(null);
    this.copy(r30);
    return r30;
};
BN.prototype._expand = function _expand(size) {
    while(this.length < size){
        this.words[this.length++] = 0;
    }
    return this;
};
BN.prototype._strip = function strip() {
    while(this.length > 1 && this.words[this.length - 1] === 0){
        this.length--;
    }
    return this._normSign();
};
BN.prototype._normSign = function _normSign() {
    if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
    }
    return this;
};
if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
    try {
        BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect1;
    } catch (e) {
        BN.prototype.inspect = inspect1;
    }
} else {
    BN.prototype.inspect = inspect1;
}
function inspect1() {
    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
}
var zeros = [
    "",
    "0",
    "00",
    "000",
    "0000",
    "00000",
    "000000",
    "0000000",
    "00000000",
    "000000000",
    "0000000000",
    "00000000000",
    "000000000000",
    "0000000000000",
    "00000000000000",
    "000000000000000",
    "0000000000000000",
    "00000000000000000",
    "000000000000000000",
    "0000000000000000000",
    "00000000000000000000",
    "000000000000000000000",
    "0000000000000000000000",
    "00000000000000000000000",
    "000000000000000000000000",
    "0000000000000000000000000", 
];
var groupSizes = [
    0,
    0,
    25,
    16,
    12,
    11,
    10,
    9,
    8,
    8,
    7,
    7,
    7,
    7,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5, 
];
var groupBases = [
    0,
    0,
    33554432,
    43046721,
    16777216,
    48828125,
    60466176,
    40353607,
    16777216,
    43046721,
    10000000,
    19487171,
    35831808,
    62748517,
    7529536,
    11390625,
    16777216,
    24137569,
    34012224,
    47045881,
    64000000,
    4084101,
    5153632,
    6436343,
    7962624,
    9765625,
    11881376,
    14348907,
    17210368,
    20511149,
    24300000,
    28629151,
    33554432,
    39135393,
    45435424,
    52521875,
    60466176, 
];
BN.prototype.toString = function toString(base21, padding) {
    base21 = base21 || 10;
    padding = padding | 0 || 1;
    var out;
    if (base21 === 16 || base21 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for(var i163 = 0; i163 < this.length; i163++){
            var w21 = this.words[i163];
            var word = ((w21 << off | carry) & 16777215).toString(16);
            carry = w21 >>> 24 - off & 16777215;
            if (carry !== 0 || i163 !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
            } else {
                out = word + out;
            }
            off += 2;
            if (off >= 26) {
                off -= 26;
                i163--;
            }
        }
        if (carry !== 0) {
            out = carry.toString(16) + out;
        }
        while(out.length % padding !== 0){
            out = "0" + out;
        }
        if (this.negative !== 0) {
            out = "-" + out;
        }
        return out;
    }
    if (base21 === (base21 | 0) && base21 >= 2 && base21 <= 36) {
        var groupSize = groupSizes[base21];
        var groupBase = groupBases[base21];
        out = "";
        var c22 = this.clone();
        c22.negative = 0;
        while(!c22.isZero()){
            var r31 = c22.modrn(groupBase).toString(base21);
            c22 = c22.idivn(groupBase);
            if (!c22.isZero()) {
                out = zeros[groupSize - r31.length] + r31 + out;
            } else {
                out = r31 + out;
            }
        }
        if (this.isZero()) {
            out = "0" + out;
        }
        while(out.length % padding !== 0){
            out = "0" + out;
        }
        if (this.negative !== 0) {
            out = "-" + out;
        }
        return out;
    }
    assert5(false, "Base should be between 2 and 36");
};
BN.prototype.toNumber = function toNumber() {
    var ret = this.words[0];
    if (this.length === 2) {
        ret += this.words[1] * 67108864;
    } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
    } else if (this.length > 2) {
        assert5(false, "Number can only safely store up to 53 bits");
    }
    return this.negative !== 0 ? -ret : ret;
};
BN.prototype.toJSON = function toJSON() {
    return this.toString(16, 2);
};
if (Buffer1) {
    BN.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer1, endian, length);
    };
}
BN.prototype.toArray = function toArray(endian, length) {
    return this.toArrayLike(Array, endian, length);
};
var allocate = function allocate(ArrayType, size) {
    if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
};
BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
    this._strip();
    var byteLength4 = this.byteLength();
    var reqLength = length || Math.max(1, byteLength4);
    assert5(byteLength4 <= reqLength, "byte array longer than desired length");
    assert5(reqLength > 0, "Requested array length <= 0");
    var res = allocate(ArrayType, reqLength);
    var postfix = endian === "le" ? "LE" : "BE";
    this["_toArrayLike" + postfix](res, byteLength4);
    return res;
};
BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
    var position = 0;
    var carry = 0;
    for(var i164 = 0, shift = 0; i164 < this.length; i164++){
        var word = this.words[i164] << shift | carry;
        res[position++] = word & 255;
        if (position < res.length) {
            res[position++] = word >> 8 & 255;
        }
        if (position < res.length) {
            res[position++] = word >> 16 & 255;
        }
        if (shift === 6) {
            if (position < res.length) {
                res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
        } else {
            carry = word >>> 24;
            shift += 2;
        }
    }
    if (position < res.length) {
        res[position++] = carry;
        while(position < res.length){
            res[position++] = 0;
        }
    }
};
BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
    var position = res.length - 1;
    var carry = 0;
    for(var i165 = 0, shift = 0; i165 < this.length; i165++){
        var word = this.words[i165] << shift | carry;
        res[position--] = word & 255;
        if (position >= 0) {
            res[position--] = word >> 8 & 255;
        }
        if (position >= 0) {
            res[position--] = word >> 16 & 255;
        }
        if (shift === 6) {
            if (position >= 0) {
                res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
        } else {
            carry = word >>> 24;
            shift += 2;
        }
    }
    if (position >= 0) {
        res[position--] = carry;
        while(position >= 0){
            res[position--] = 0;
        }
    }
};
if (Math.clz32) {
    BN.prototype._countBits = function _countBits(w22) {
        return 32 - Math.clz32(w22);
    };
} else {
    BN.prototype._countBits = function _countBits(w23) {
        var t6 = w23;
        var r32 = 0;
        if (t6 >= 4096) {
            r32 += 13;
            t6 >>>= 13;
        }
        if (t6 >= 64) {
            r32 += 7;
            t6 >>>= 7;
        }
        if (t6 >= 8) {
            r32 += 4;
            t6 >>>= 4;
        }
        if (t6 >= 2) {
            r32 += 2;
            t6 >>>= 2;
        }
        return r32 + t6;
    };
}
BN.prototype._zeroBits = function _zeroBits(w24) {
    if (w24 === 0) return 26;
    var t7 = w24;
    var r33 = 0;
    if ((t7 & 8191) === 0) {
        r33 += 13;
        t7 >>>= 13;
    }
    if ((t7 & 127) === 0) {
        r33 += 7;
        t7 >>>= 7;
    }
    if ((t7 & 15) === 0) {
        r33 += 4;
        t7 >>>= 4;
    }
    if ((t7 & 3) === 0) {
        r33 += 2;
        t7 >>>= 2;
    }
    if ((t7 & 1) === 0) {
        r33++;
    }
    return r33;
};
BN.prototype.bitLength = function bitLength() {
    var w25 = this.words[this.length - 1];
    var hi = this._countBits(w25);
    return (this.length - 1) * 26 + hi;
};
function toBitArray(num) {
    var w26 = new Array(num.bitLength());
    for(var bit = 0; bit < w26.length; bit++){
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w26[bit] = num.words[off] >>> wbit & 1;
    }
    return w26;
}
BN.prototype.zeroBits = function zeroBits() {
    if (this.isZero()) return 0;
    var r34 = 0;
    for(var i166 = 0; i166 < this.length; i166++){
        var b22 = this._zeroBits(this.words[i166]);
        r34 += b22;
        if (b22 !== 26) break;
    }
    return r34;
};
BN.prototype.byteLength = function byteLength() {
    return Math.ceil(this.bitLength() / 8);
};
BN.prototype.toTwos = function toTwos(width) {
    if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
};
BN.prototype.fromTwos = function fromTwos(width) {
    if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
};
BN.prototype.isNeg = function isNeg() {
    return this.negative !== 0;
};
BN.prototype.neg = function neg() {
    return this.clone().ineg();
};
BN.prototype.ineg = function ineg() {
    if (!this.isZero()) {
        this.negative ^= 1;
    }
    return this;
};
BN.prototype.iuor = function iuor(num) {
    while(this.length < num.length){
        this.words[this.length++] = 0;
    }
    for(var i167 = 0; i167 < num.length; i167++){
        this.words[i167] = this.words[i167] | num.words[i167];
    }
    return this._strip();
};
BN.prototype.ior = function ior(num) {
    assert5((this.negative | num.negative) === 0);
    return this.iuor(num);
};
BN.prototype.or = function or(num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
};
BN.prototype.uor = function uor(num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
};
BN.prototype.iuand = function iuand(num) {
    var b23;
    if (this.length > num.length) {
        b23 = num;
    } else {
        b23 = this;
    }
    for(var i168 = 0; i168 < b23.length; i168++){
        this.words[i168] = this.words[i168] & num.words[i168];
    }
    this.length = b23.length;
    return this._strip();
};
BN.prototype.iand = function iand(num) {
    assert5((this.negative | num.negative) === 0);
    return this.iuand(num);
};
BN.prototype.and = function and(num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
};
BN.prototype.uand = function uand(num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
};
BN.prototype.iuxor = function iuxor(num) {
    var a18;
    var b24;
    if (this.length > num.length) {
        a18 = this;
        b24 = num;
    } else {
        a18 = num;
        b24 = this;
    }
    for(var i169 = 0; i169 < b24.length; i169++){
        this.words[i169] = a18.words[i169] ^ b24.words[i169];
    }
    if (this !== a18) {
        for(; i169 < a18.length; i169++){
            this.words[i169] = a18.words[i169];
        }
    }
    this.length = a18.length;
    return this._strip();
};
BN.prototype.ixor = function ixor(num) {
    assert5((this.negative | num.negative) === 0);
    return this.iuxor(num);
};
BN.prototype.xor = function xor(num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
};
BN.prototype.uxor = function uxor(num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
};
BN.prototype.inotn = function inotn(width) {
    assert5(typeof width === "number" && width >= 0);
    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;
    this._expand(bytesNeeded);
    if (bitsLeft > 0) {
        bytesNeeded--;
    }
    for(var i170 = 0; i170 < bytesNeeded; i170++){
        this.words[i170] = ~this.words[i170] & 67108863;
    }
    if (bitsLeft > 0) {
        this.words[i170] = ~this.words[i170] & 67108863 >> 26 - bitsLeft;
    }
    return this._strip();
};
BN.prototype.notn = function notn(width) {
    return this.clone().inotn(width);
};
BN.prototype.setn = function setn(bit, val) {
    assert5(typeof bit === "number" && bit >= 0);
    var off = bit / 26 | 0;
    var wbit = bit % 26;
    this._expand(off + 1);
    if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
    } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
    }
    return this._strip();
};
BN.prototype.iadd = function iadd(num) {
    var r35;
    if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r35 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
    } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r35 = this.isub(num);
        num.negative = 1;
        return r35._normSign();
    }
    var a19, b25;
    if (this.length > num.length) {
        a19 = this;
        b25 = num;
    } else {
        a19 = num;
        b25 = this;
    }
    var carry = 0;
    for(var i171 = 0; i171 < b25.length; i171++){
        r35 = (a19.words[i171] | 0) + (b25.words[i171] | 0) + carry;
        this.words[i171] = r35 & 67108863;
        carry = r35 >>> 26;
    }
    for(; carry !== 0 && i171 < a19.length; i171++){
        r35 = (a19.words[i171] | 0) + carry;
        this.words[i171] = r35 & 67108863;
        carry = r35 >>> 26;
    }
    this.length = a19.length;
    if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
    } else if (a19 !== this) {
        for(; i171 < a19.length; i171++){
            this.words[i171] = a19.words[i171];
        }
    }
    return this;
};
BN.prototype.add = function add(num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
    } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
    }
    if (this.length > num.length) return this.clone().iadd(num);
    return num.clone().iadd(this);
};
BN.prototype.isub = function isub(num) {
    if (num.negative !== 0) {
        num.negative = 0;
        var r36 = this.iadd(num);
        num.negative = 1;
        return r36._normSign();
    } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
    }
    var cmp = this.cmp(num);
    if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
    }
    var a20, b26;
    if (cmp > 0) {
        a20 = this;
        b26 = num;
    } else {
        a20 = num;
        b26 = this;
    }
    var carry = 0;
    for(var i172 = 0; i172 < b26.length; i172++){
        r36 = (a20.words[i172] | 0) - (b26.words[i172] | 0) + carry;
        carry = r36 >> 26;
        this.words[i172] = r36 & 67108863;
    }
    for(; carry !== 0 && i172 < a20.length; i172++){
        r36 = (a20.words[i172] | 0) + carry;
        carry = r36 >> 26;
        this.words[i172] = r36 & 67108863;
    }
    if (carry === 0 && i172 < a20.length && a20 !== this) {
        for(; i172 < a20.length; i172++){
            this.words[i172] = a20.words[i172];
        }
    }
    this.length = Math.max(this.length, i172);
    if (a20 !== this) {
        this.negative = 1;
    }
    return this._strip();
};
BN.prototype.sub = function sub(num) {
    return this.clone().isub(num);
};
function smallMulTo(self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = self.length + num.length | 0;
    out.length = len;
    len = len - 1 | 0;
    var a21 = self.words[0] | 0;
    var b27 = num.words[0] | 0;
    var r37 = a21 * b27;
    var lo = r37 & 67108863;
    var carry = r37 / 67108864 | 0;
    out.words[0] = lo;
    for(var k15 = 1; k15 < len; k15++){
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k15, num.length - 1);
        for(var j = Math.max(0, k15 - self.length + 1); j <= maxJ; j++){
            var i173 = k15 - j | 0;
            a21 = self.words[i173] | 0;
            b27 = num.words[j] | 0;
            r37 = a21 * b27 + rword;
            ncarry += r37 / 67108864 | 0;
            rword = r37 & 67108863;
        }
        out.words[k15] = rword | 0;
        carry = ncarry | 0;
    }
    if (carry !== 0) {
        out.words[k15] = carry | 0;
    } else {
        out.length--;
    }
    return out._strip();
}
var comb10MulTo = function comb10MulTo(self, num, out) {
    var a22 = self.words;
    var b28 = num.words;
    var o4 = out.words;
    var c23 = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a22[0] | 0;
    var al0 = a0 & 8191;
    var ah0 = a0 >>> 13;
    var a1 = a22[1] | 0;
    var al1 = a1 & 8191;
    var ah1 = a1 >>> 13;
    var a2 = a22[2] | 0;
    var al2 = a2 & 8191;
    var ah2 = a2 >>> 13;
    var a3 = a22[3] | 0;
    var al3 = a3 & 8191;
    var ah3 = a3 >>> 13;
    var a4 = a22[4] | 0;
    var al4 = a4 & 8191;
    var ah4 = a4 >>> 13;
    var a5 = a22[5] | 0;
    var al5 = a5 & 8191;
    var ah5 = a5 >>> 13;
    var a6 = a22[6] | 0;
    var al6 = a6 & 8191;
    var ah6 = a6 >>> 13;
    var a7 = a22[7] | 0;
    var al7 = a7 & 8191;
    var ah7 = a7 >>> 13;
    var a8 = a22[8] | 0;
    var al8 = a8 & 8191;
    var ah8 = a8 >>> 13;
    var a9 = a22[9] | 0;
    var al9 = a9 & 8191;
    var ah9 = a9 >>> 13;
    var b0 = b28[0] | 0;
    var bl0 = b0 & 8191;
    var bh0 = b0 >>> 13;
    var b1 = b28[1] | 0;
    var bl1 = b1 & 8191;
    var bh1 = b1 >>> 13;
    var b2 = b28[2] | 0;
    var bl2 = b2 & 8191;
    var bh2 = b2 >>> 13;
    var b3 = b28[3] | 0;
    var bl3 = b3 & 8191;
    var bh3 = b3 >>> 13;
    var b4 = b28[4] | 0;
    var bl4 = b4 & 8191;
    var bh4 = b4 >>> 13;
    var b5 = b28[5] | 0;
    var bl5 = b5 & 8191;
    var bh5 = b5 >>> 13;
    var b6 = b28[6] | 0;
    var bl6 = b6 & 8191;
    var bh6 = b6 >>> 13;
    var b7 = b28[7] | 0;
    var bl7 = b7 & 8191;
    var bh7 = b7 >>> 13;
    var b8 = b28[8] | 0;
    var bl8 = b8 & 8191;
    var bh8 = b8 >>> 13;
    var b9 = b28[9] | 0;
    var bl9 = b9 & 8191;
    var bh9 = b9 >>> 13;
    out.negative = self.negative ^ num.negative;
    out.length = 19;
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = mid + Math.imul(ah0, bl0) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (c23 + lo | 0) + ((mid & 8191) << 13) | 0;
    c23 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
    w0 &= 67108863;
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = mid + Math.imul(ah1, bl0) | 0;
    hi = Math.imul(ah1, bh0);
    lo = lo + Math.imul(al0, bl1) | 0;
    mid = mid + Math.imul(al0, bh1) | 0;
    mid = mid + Math.imul(ah0, bl1) | 0;
    hi = hi + Math.imul(ah0, bh1) | 0;
    var w1 = (c23 + lo | 0) + ((mid & 8191) << 13) | 0;
    c23 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
    w1 &= 67108863;
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = mid + Math.imul(ah2, bl0) | 0;
    hi = Math.imul(ah2, bh0);
    lo = lo + Math.imul(al1, bl1) | 0;
    mid = mid + Math.imul(al1, bh1) | 0;
    mid = mid + Math.imul(ah1, bl1) | 0;
    hi = hi + Math.imul(ah1, bh1) | 0;
    lo = lo + Math.imul(al0, bl2) | 0;
    mid = mid + Math.imul(al0, bh2) | 0;
    mid = mid + Math.imul(ah0, bl2) | 0;
    hi = hi + Math.imul(ah0, bh2) | 0;
    var w2 = (c23 + lo | 0) + ((mid & 8191) << 13) | 0;
    c23 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
    w2 &= 67108863;
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = mid + Math.imul(ah3, bl0) | 0;
    hi = Math.imul(ah3, bh0);
    lo = lo + Math.imul(al2, bl1) | 0;
    mid = mid + Math.imul(al2, bh1) | 0;
    mid = mid + Math.imul(ah2, bl1) | 0;
    hi = hi + Math.imul(ah2, bh1) | 0;
    lo = lo + Math.imul(al1, bl2) | 0;
    mid = mid + Math.imul(al1, bh2) | 0;
    mid = mid + Math.imul(ah1, bl2) | 0;
    hi = hi + Math.imul(ah1, bh2) | 0;
    lo = lo + Math.imul(al0, bl3) | 0;
    mid = mid + Math.imul(al0, bh3) | 0;
    mid = mid + Math.imul(ah0, bl3) | 0;
    hi = hi + Math.imul(ah0, bh3) | 0;
    var w3 = (c23 + lo | 0) + ((mid & 8191) << 13) | 0;
    c23 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
    w3 &= 67108863;
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = mid + Math.imul(ah4, bl0) | 0;
    hi = Math.imul(ah4, bh0);
    lo = lo + Math.imul(al3, bl1) | 0;
    mid = mid + Math.imul(al3, bh1) | 0;
    mid = mid + Math.imul(ah3, bl1) | 0;
    hi = hi + Math.imul(ah3, bh1) | 0;
    lo = lo + Math.imul(al2, bl2) | 0;
    mid = mid + Math.imul(al2, bh2) | 0;
    mid = mid + Math.imul(ah2, bl2) | 0;
    hi = hi + Math.imul(ah2, bh2) | 0;
    lo = lo + Math.imul(al1, bl3) | 0;
    mid = mid + Math.imul(al1, bh3) | 0;
    mid = mid + Math.imul(ah1, bl3) | 0;
    hi = hi + Math.imul(ah1, bh3) | 0;
    lo = lo + Math.imul(al0, bl4) | 0;
    mid = mid + Math.imul(al0, bh4) | 0;
    mid = mid + Math.imul(ah0, bl4) | 0;
    hi = hi + Math.imul(ah0, bh4) | 0;
    var w4 = (c23 + lo | 0) + ((mid & 8191) << 13) | 0;
    c23 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
    w4 &= 67108863;
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = mid + Math.imul(ah5, bl0) | 0;
    hi = Math.imul(ah5, bh0);
    lo = lo + Math.imul(al4, bl1) | 0;
    mid = mid + Math.imul(al4, bh1) | 0;
    mid = mid + Math.imul(ah4, bl1) | 0;
    hi = hi + Math.imul(ah4, bh1) | 0;
    lo = lo + Math.imul(al3, bl2) | 0;
    mid = mid + Math.imul(al3, bh2) | 0;
    mid = mid + Math.imul(ah3, bl2) | 0;
    hi = hi + Math.imul(ah3, bh2) | 0;
    lo = lo + Math.imul(al2, bl3) | 0;
    mid = mid + Math.imul(al2, bh3) | 0;
    mid = mid + Math.imul(ah2, bl3) | 0;
    hi = hi + Math.imul(ah2, bh3) | 0;
    lo = lo + Math.imul(al1, bl4) | 0;
    mid = mid + Math.imul(al1, bh4) | 0;
    mid = mid + Math.imul(ah1, bl4) | 0;
    hi = hi + Math.imul(ah1, bh4) | 0;
    lo = lo + Math.imul(al0, bl5) | 0;
    mid = mid + Math.imul(al0, bh5) | 0;
    mid = mid + Math.imul(ah0, bl5) | 0;
    hi = hi + Math.imul(ah0, bh5) | 0;
    var w5 = (c23 + lo | 0) + ((mid & 8191) << 13) | 0;
    c23 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
    w5 &= 67108863;
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = mid + Math.imul(ah6, bl0) | 0;
    hi = Math.imul(ah6, bh0);
    lo = lo + Math.imul(al5, bl1) | 0;
    mid = mid + Math.imul(al5, bh1) | 0;
    mid = mid + Math.imul(ah5, bl1) | 0;
    hi = hi + Math.imul(ah5, bh1) | 0;
    lo = lo + Math.imul(al4, bl2) | 0;
    mid = mid + Math.imul(al4, bh2) | 0;
    mid = mid + Math.imul(ah4, bl2) | 0;
    hi = hi + Math.imul(ah4, bh2) | 0;
    lo = lo + Math.imul(al3, bl3) | 0;
    mid = mid + Math.imul(al3, bh3) | 0;
    mid = mid + Math.imul(ah3, bl3) | 0;
    hi = hi + Math.imul(ah3, bh3) | 0;
    lo = lo + Math.imul(al2, bl4) | 0;
    mid = mid + Math.imul(al2, bh4) | 0;
    mid = mid + Math.imul(ah2, bl4) | 0;
    hi = hi + Math.imul(ah2, bh4) | 0;
    lo = lo + Math.imul(al1, bl5) | 0;
    mid = mid + Math.imul(al1, bh5) | 0;
    mid = mid + Math.imul(ah1, bl5) | 0;
    hi = hi + Math.imul(ah1, bh5) | 0;
    lo = lo + Math.imul(al0, bl6) | 0;
    mid = mid + Math.imul(al0, bh6) | 0;
    mid = mid + Math.imul(ah0, bl6) | 0;
    hi = hi + Math.imul(ah0, bh6) | 0;
    var w6 = (c23 + lo | 0) + ((mid & 8191) << 13) | 0;
    c23 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
    w6 &= 67108863;
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = mid + Math.imul(ah7, bl0) | 0;
    hi = Math.imul(ah7, bh0);
    lo = lo + Math.imul(al6, bl1) | 0;
    mid = mid + Math.imul(al6, bh1) | 0;
    mid = mid + Math.imul(ah6, bl1) | 0;
    hi = hi + Math.imul(ah6, bh1) | 0;
    lo = lo + Math.imul(al5, bl2) | 0;
    mid = mid + Math.imul(al5, bh2) | 0;
    mid = mid + Math.imul(ah5, bl2) | 0;
    hi = hi + Math.imul(ah5, bh2) | 0;
    lo = lo + Math.imul(al4, bl3) | 0;
    mid = mid + Math.imul(al4, bh3) | 0;
    mid = mid + Math.imul(ah4, bl3) | 0;
    hi = hi + Math.imul(ah4, bh3) | 0;
    lo = lo + Math.imul(al3, bl4) | 0;
    mid = mid + Math.imul(al3, bh4) | 0;
    mid = mid + Math.imul(ah3, bl4) | 0;
    hi = hi + Math.imul(ah3, bh4) | 0;
    lo = lo + Math.imul(al2, bl5) | 0;
    mid = mid + Math.imul(al2, bh5) | 0;
    mid = mid + Math.imul(ah2, bl5) | 0;
    hi = hi + Math.imul(ah2, bh5) | 0;
    lo = lo + Math.imul(al1, bl6) | 0;
    mid = mid + Math.imul(al1, bh6) | 0;
    mid = mid + Math.imul(ah1, bl6) | 0;
    hi = hi + Math.imul(ah1, bh6) | 0;
    lo = lo + Math.imul(al0, bl7) | 0;
    mid = mid + Math.imul(al0, bh7) | 0;
    mid = mid + Math.imul(ah0, bl7) | 0;
    hi = hi + Math.imul(ah0, bh7) | 0;
    var w7 = (c23 + lo | 0) + ((mid & 8191) << 13) | 0;
    c23 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
    w7 &= 67108863;
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = mid + Math.imul(ah8, bl0) | 0;
    hi = Math.imul(ah8, bh0);
    lo = lo + Math.imul(al7, bl1) | 0;
    mid = mid + Math.imul(al7, bh1) | 0;
    mid = mid + Math.imul(ah7, bl1) | 0;
    hi = hi + Math.imul(ah7, bh1) | 0;
    lo = lo + Math.imul(al6, bl2) | 0;
    mid = mid + Math.imul(al6, bh2) | 0;
    mid = mid + Math.imul(ah6, bl2) | 0;
    hi = hi + Math.imul(ah6, bh2) | 0;
    lo = lo + Math.imul(al5, bl3) | 0;
    mid = mid + Math.imul(al5, bh3) | 0;
    mid = mid + Math.imul(ah5, bl3) | 0;
    hi = hi + Math.imul(ah5, bh3) | 0;
    lo = lo + Math.imul(al4, bl4) | 0;
    mid = mid + Math.imul(al4, bh4) | 0;
    mid = mid + Math.imul(ah4, bl4) | 0;
    hi = hi + Math.imul(ah4, bh4) | 0;
    lo = lo + Math.imul(al3, bl5) | 0;
    mid = mid + Math.imul(al3, bh5) | 0;
    mid = mid + Math.imul(ah3, bl5) | 0;
    hi = hi + Math.imul(ah3, bh5) | 0;
    lo = lo + Math.imul(al2, bl6) | 0;
    mid = mid + Math.imul(al2, bh6) | 0;
    mid = mid + Math.imul(ah2, bl6) | 0;
    hi = hi + Math.imul(ah2, bh6) | 0;
    lo = lo + Math.imul(al1, bl7) | 0;
    mid = mid + Math.imul(al1, bh7) | 0;
    mid = mid + Math.imul(ah1, bl7) | 0;
    hi = hi + Math.imul(ah1, bh7) | 0;
    lo = lo + Math.imul(al0, bl8) | 0;
    mid = mid + Math.imul(al0, bh8) | 0;
    mid = mid + Math.imul(ah0, bl8) | 0;
    hi = hi + Math.imul(ah0, bh8) | 0;
    var w8 = (c23 + lo | 0) + ((mid & 8191) << 13) | 0;
    c23 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
    w8 &= 67108863;
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = mid + Math.imul(ah9, bl0) | 0;
    hi = Math.imul(ah9, bh0);
    lo = lo + Math.imul(al8, bl1) | 0;
    mid = mid + Math.imul(al8, bh1) | 0;
    mid = mid + Math.imul(ah8, bl1) | 0;
    hi = hi + Math.imul(ah8, bh1) | 0;
    lo = lo + Math.imul(al7, bl2) | 0;
    mid = mid + Math.imul(al7, bh2) | 0;
    mid = mid + Math.imul(ah7, bl2) | 0;
    hi = hi + Math.imul(ah7, bh2) | 0;
    lo = lo + Math.imul(al6, bl3) | 0;
    mid = mid + Math.imul(al6, bh3) | 0;
    mid = mid + Math.imul(ah6, bl3) | 0;
    hi = hi + Math.imul(ah6, bh3) | 0;
    lo = lo + Math.imul(al5, bl4) | 0;
    mid = mid + Math.imul(al5, bh4) | 0;
    mid = mid + Math.imul(ah5, bl4) | 0;
    hi = hi + Math.imul(ah5, bh4) | 0;
    lo = lo + Math.imul(al4, bl5) | 0;
    mid = mid + Math.imul(al4, bh5) | 0;
    mid = mid + Math.imul(ah4, bl5) | 0;
    hi = hi + Math.imul(ah4, bh5) | 0;
    lo = lo + Math.imul(al3, bl6) | 0;
    mid = mid + Math.imul(al3, bh6) | 0;
    mid = mid + Math.imul(ah3, bl6) | 0;
    hi = hi + Math.imul(ah3, bh6) | 0;
    lo = lo + Math.imul(al2, bl7) | 0;
    mid = mid + Math.imul(al2, bh7) | 0;
    mid = mid + Math.imul(ah2, bl7) | 0;
    hi = hi + Math.imul(ah2, bh7) | 0;
    lo = lo + Math.imul(al1, bl8) | 0;
    mid = mid + Math.imul(al1, bh8) | 0;
    mid = mid + Math.imul(ah1, bl8) | 0;
    hi = hi + Math.imul(ah1, bh8) | 0;
    lo = lo + Math.imul(al0, bl9) | 0;
    mid = mid + Math.imul(al0, bh9) | 0;
    mid = mid + Math.imul(ah0, bl9) | 0;
    hi = hi + Math.imul(ah0, bh9) | 0;
    var w9 = (c23 + lo | 0) + ((mid & 8191) << 13) | 0;
    c23 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
    w9 &= 67108863;
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = mid + Math.imul(ah9, bl1) | 0;
    hi = Math.imul(ah9, bh1);
    lo = lo + Math.imul(al8, bl2) | 0;
    mid = mid + Math.imul(al8, bh2) | 0;
    mid = mid + Math.imul(ah8, bl2) | 0;
    hi = hi + Math.imul(ah8, bh2) | 0;
    lo = lo + Math.imul(al7, bl3) | 0;
    mid = mid + Math.imul(al7, bh3) | 0;
    mid = mid + Math.imul(ah7, bl3) | 0;
    hi = hi + Math.imul(ah7, bh3) | 0;
    lo = lo + Math.imul(al6, bl4) | 0;
    mid = mid + Math.imul(al6, bh4) | 0;
    mid = mid + Math.imul(ah6, bl4) | 0;
    hi = hi + Math.imul(ah6, bh4) | 0;
    lo = lo + Math.imul(al5, bl5) | 0;
    mid = mid + Math.imul(al5, bh5) | 0;
    mid = mid + Math.imul(ah5, bl5) | 0;
    hi = hi + Math.imul(ah5, bh5) | 0;
    lo = lo + Math.imul(al4, bl6) | 0;
    mid = mid + Math.imul(al4, bh6) | 0;
    mid = mid + Math.imul(ah4, bl6) | 0;
    hi = hi + Math.imul(ah4, bh6) | 0;
    lo = lo + Math.imul(al3, bl7) | 0;
    mid = mid + Math.imul(al3, bh7) | 0;
    mid = mid + Math.imul(ah3, bl7) | 0;
    hi = hi + Math.imul(ah3, bh7) | 0;
    lo = lo + Math.imul(al2, bl8) | 0;
    mid = mid + Math.imul(al2, bh8) | 0;
    mid = mid + Math.imul(ah2, bl8) | 0;
    hi = hi + Math.imul(ah2, bh8) | 0;
    lo = lo + Math.imul(al1, bl9) | 0;
    mid = mid + Math.imul(al1, bh9) | 0;
    mid = mid + Math.imul(ah1, bl9) | 0;
    hi = hi + Math.imul(ah1, bh9) | 0;
    var w10 = (c23 + lo | 0) + ((mid & 8191) << 13) | 0;
    c23 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
    w10 &= 67108863;
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = mid + Math.imul(ah9, bl2) | 0;
    hi = Math.imul(ah9, bh2);
    lo = lo + Math.imul(al8, bl3) | 0;
    mid = mid + Math.imul(al8, bh3) | 0;
    mid = mid + Math.imul(ah8, bl3) | 0;
    hi = hi + Math.imul(ah8, bh3) | 0;
    lo = lo + Math.imul(al7, bl4) | 0;
    mid = mid + Math.imul(al7, bh4) | 0;
    mid = mid + Math.imul(ah7, bl4) | 0;
    hi = hi + Math.imul(ah7, bh4) | 0;
    lo = lo + Math.imul(al6, bl5) | 0;
    mid = mid + Math.imul(al6, bh5) | 0;
    mid = mid + Math.imul(ah6, bl5) | 0;
    hi = hi + Math.imul(ah6, bh5) | 0;
    lo = lo + Math.imul(al5, bl6) | 0;
    mid = mid + Math.imul(al5, bh6) | 0;
    mid = mid + Math.imul(ah5, bl6) | 0;
    hi = hi + Math.imul(ah5, bh6) | 0;
    lo = lo + Math.imul(al4, bl7) | 0;
    mid = mid + Math.imul(al4, bh7) | 0;
    mid = mid + Math.imul(ah4, bl7) | 0;
    hi = hi + Math.imul(ah4, bh7) | 0;
    lo = lo + Math.imul(al3, bl8) | 0;
    mid = mid + Math.imul(al3, bh8) | 0;
    mid = mid + Math.imul(ah3, bl8) | 0;
    hi = hi + Math.imul(ah3, bh8) | 0;
    lo = lo + Math.imul(al2, bl9) | 0;
    mid = mid + Math.imul(al2, bh9) | 0;
    mid = mid + Math.imul(ah2, bl9) | 0;
    hi = hi + Math.imul(ah2, bh9) | 0;
    var w11 = (c23 + lo | 0) + ((mid & 8191) << 13) | 0;
    c23 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
    w11 &= 67108863;
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = mid + Math.imul(ah9, bl3) | 0;
    hi = Math.imul(ah9, bh3);
    lo = lo + Math.imul(al8, bl4) | 0;
    mid = mid + Math.imul(al8, bh4) | 0;
    mid = mid + Math.imul(ah8, bl4) | 0;
    hi = hi + Math.imul(ah8, bh4) | 0;
    lo = lo + Math.imul(al7, bl5) | 0;
    mid = mid + Math.imul(al7, bh5) | 0;
    mid = mid + Math.imul(ah7, bl5) | 0;
    hi = hi + Math.imul(ah7, bh5) | 0;
    lo = lo + Math.imul(al6, bl6) | 0;
    mid = mid + Math.imul(al6, bh6) | 0;
    mid = mid + Math.imul(ah6, bl6) | 0;
    hi = hi + Math.imul(ah6, bh6) | 0;
    lo = lo + Math.imul(al5, bl7) | 0;
    mid = mid + Math.imul(al5, bh7) | 0;
    mid = mid + Math.imul(ah5, bl7) | 0;
    hi = hi + Math.imul(ah5, bh7) | 0;
    lo = lo + Math.imul(al4, bl8) | 0;
    mid = mid + Math.imul(al4, bh8) | 0;
    mid = mid + Math.imul(ah4, bl8) | 0;
    hi = hi + Math.imul(ah4, bh8) | 0;
    lo = lo + Math.imul(al3, bl9) | 0;
    mid = mid + Math.imul(al3, bh9) | 0;
    mid = mid + Math.imul(ah3, bl9) | 0;
    hi = hi + Math.imul(ah3, bh9) | 0;
    var w12 = (c23 + lo | 0) + ((mid & 8191) << 13) | 0;
    c23 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
    w12 &= 67108863;
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = mid + Math.imul(ah9, bl4) | 0;
    hi = Math.imul(ah9, bh4);
    lo = lo + Math.imul(al8, bl5) | 0;
    mid = mid + Math.imul(al8, bh5) | 0;
    mid = mid + Math.imul(ah8, bl5) | 0;
    hi = hi + Math.imul(ah8, bh5) | 0;
    lo = lo + Math.imul(al7, bl6) | 0;
    mid = mid + Math.imul(al7, bh6) | 0;
    mid = mid + Math.imul(ah7, bl6) | 0;
    hi = hi + Math.imul(ah7, bh6) | 0;
    lo = lo + Math.imul(al6, bl7) | 0;
    mid = mid + Math.imul(al6, bh7) | 0;
    mid = mid + Math.imul(ah6, bl7) | 0;
    hi = hi + Math.imul(ah6, bh7) | 0;
    lo = lo + Math.imul(al5, bl8) | 0;
    mid = mid + Math.imul(al5, bh8) | 0;
    mid = mid + Math.imul(ah5, bl8) | 0;
    hi = hi + Math.imul(ah5, bh8) | 0;
    lo = lo + Math.imul(al4, bl9) | 0;
    mid = mid + Math.imul(al4, bh9) | 0;
    mid = mid + Math.imul(ah4, bl9) | 0;
    hi = hi + Math.imul(ah4, bh9) | 0;
    var w13 = (c23 + lo | 0) + ((mid & 8191) << 13) | 0;
    c23 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
    w13 &= 67108863;
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = mid + Math.imul(ah9, bl5) | 0;
    hi = Math.imul(ah9, bh5);
    lo = lo + Math.imul(al8, bl6) | 0;
    mid = mid + Math.imul(al8, bh6) | 0;
    mid = mid + Math.imul(ah8, bl6) | 0;
    hi = hi + Math.imul(ah8, bh6) | 0;
    lo = lo + Math.imul(al7, bl7) | 0;
    mid = mid + Math.imul(al7, bh7) | 0;
    mid = mid + Math.imul(ah7, bl7) | 0;
    hi = hi + Math.imul(ah7, bh7) | 0;
    lo = lo + Math.imul(al6, bl8) | 0;
    mid = mid + Math.imul(al6, bh8) | 0;
    mid = mid + Math.imul(ah6, bl8) | 0;
    hi = hi + Math.imul(ah6, bh8) | 0;
    lo = lo + Math.imul(al5, bl9) | 0;
    mid = mid + Math.imul(al5, bh9) | 0;
    mid = mid + Math.imul(ah5, bl9) | 0;
    hi = hi + Math.imul(ah5, bh9) | 0;
    var w14 = (c23 + lo | 0) + ((mid & 8191) << 13) | 0;
    c23 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
    w14 &= 67108863;
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = mid + Math.imul(ah9, bl6) | 0;
    hi = Math.imul(ah9, bh6);
    lo = lo + Math.imul(al8, bl7) | 0;
    mid = mid + Math.imul(al8, bh7) | 0;
    mid = mid + Math.imul(ah8, bl7) | 0;
    hi = hi + Math.imul(ah8, bh7) | 0;
    lo = lo + Math.imul(al7, bl8) | 0;
    mid = mid + Math.imul(al7, bh8) | 0;
    mid = mid + Math.imul(ah7, bl8) | 0;
    hi = hi + Math.imul(ah7, bh8) | 0;
    lo = lo + Math.imul(al6, bl9) | 0;
    mid = mid + Math.imul(al6, bh9) | 0;
    mid = mid + Math.imul(ah6, bl9) | 0;
    hi = hi + Math.imul(ah6, bh9) | 0;
    var w15 = (c23 + lo | 0) + ((mid & 8191) << 13) | 0;
    c23 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
    w15 &= 67108863;
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = mid + Math.imul(ah9, bl7) | 0;
    hi = Math.imul(ah9, bh7);
    lo = lo + Math.imul(al8, bl8) | 0;
    mid = mid + Math.imul(al8, bh8) | 0;
    mid = mid + Math.imul(ah8, bl8) | 0;
    hi = hi + Math.imul(ah8, bh8) | 0;
    lo = lo + Math.imul(al7, bl9) | 0;
    mid = mid + Math.imul(al7, bh9) | 0;
    mid = mid + Math.imul(ah7, bl9) | 0;
    hi = hi + Math.imul(ah7, bh9) | 0;
    var w16 = (c23 + lo | 0) + ((mid & 8191) << 13) | 0;
    c23 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
    w16 &= 67108863;
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = mid + Math.imul(ah9, bl8) | 0;
    hi = Math.imul(ah9, bh8);
    lo = lo + Math.imul(al8, bl9) | 0;
    mid = mid + Math.imul(al8, bh9) | 0;
    mid = mid + Math.imul(ah8, bl9) | 0;
    hi = hi + Math.imul(ah8, bh9) | 0;
    var w17 = (c23 + lo | 0) + ((mid & 8191) << 13) | 0;
    c23 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
    w17 &= 67108863;
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = mid + Math.imul(ah9, bl9) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (c23 + lo | 0) + ((mid & 8191) << 13) | 0;
    c23 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
    w18 &= 67108863;
    o4[0] = w0;
    o4[1] = w1;
    o4[2] = w2;
    o4[3] = w3;
    o4[4] = w4;
    o4[5] = w5;
    o4[6] = w6;
    o4[7] = w7;
    o4[8] = w8;
    o4[9] = w9;
    o4[10] = w10;
    o4[11] = w11;
    o4[12] = w12;
    o4[13] = w13;
    o4[14] = w14;
    o4[15] = w15;
    o4[16] = w16;
    o4[17] = w17;
    o4[18] = w18;
    if (c23 !== 0) {
        o4[19] = c23;
        out.length++;
    }
    return out;
};
if (!Math.imul) {
    comb10MulTo = smallMulTo;
}
function bigMulTo(self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;
    var carry = 0;
    var hncarry = 0;
    for(var k16 = 0; k16 < out.length - 1; k16++){
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k16, num.length - 1);
        for(var j = Math.max(0, k16 - self.length + 1); j <= maxJ; j++){
            var i174 = k16 - j;
            var a23 = self.words[i174] | 0;
            var b29 = num.words[j] | 0;
            var r38 = a23 * b29;
            var lo = r38 & 67108863;
            ncarry = ncarry + (r38 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
        }
        out.words[k16] = rword;
        carry = ncarry;
        ncarry = hncarry;
    }
    if (carry !== 0) {
        out.words[k16] = carry;
    } else {
        out.length--;
    }
    return out._strip();
}
function jumboMulTo(self, num, out) {
    return bigMulTo(self, num, out);
}
BN.prototype.mulTo = function mulTo(num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
    } else if (len < 63) {
        res = smallMulTo(this, num, out);
    } else if (len < 1024) {
        res = bigMulTo(this, num, out);
    } else {
        res = jumboMulTo(this, num, out);
    }
    return res;
};
function FFTM(x31, y8) {
    this.x = x31;
    this.y = y8;
}
FFTM.prototype.makeRBT = function makeRBT(N) {
    var t8 = new Array(N);
    var l7 = BN.prototype._countBits(N) - 1;
    for(var i175 = 0; i175 < N; i175++){
        t8[i175] = this.revBin(i175, l7, N);
    }
    return t8;
};
FFTM.prototype.revBin = function revBin(x32, l8, N) {
    if (x32 === 0 || x32 === N - 1) return x32;
    var rb = 0;
    for(var i176 = 0; i176 < l8; i176++){
        rb |= (x32 & 1) << l8 - i176 - 1;
        x32 >>= 1;
    }
    return rb;
};
FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
    for(var i177 = 0; i177 < N; i177++){
        rtws[i177] = rws[rbt[i177]];
        itws[i177] = iws[rbt[i177]];
    }
};
FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);
    for(var s26 = 1; s26 < N; s26 <<= 1){
        var l9 = s26 << 1;
        var rtwdf = Math.cos(2 * Math.PI / l9);
        var itwdf = Math.sin(2 * Math.PI / l9);
        for(var p23 = 0; p23 < N; p23 += l9){
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for(var j = 0; j < s26; j++){
                var re = rtws[p23 + j];
                var ie = itws[p23 + j];
                var ro = rtws[p23 + j + s26];
                var io = itws[p23 + j + s26];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p23 + j] = re + ro;
                itws[p23 + j] = ie + io;
                rtws[p23 + j + s26] = re - ro;
                itws[p23 + j + s26] = ie - io;
                if (j !== l9) {
                    rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                    itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                    rtwdf_ = rx;
                }
            }
        }
    }
};
FFTM.prototype.guessLen13b = function guessLen13b(n37, m13) {
    var N = Math.max(m13, n37) | 1;
    var odd = N & 1;
    var i178 = 0;
    for(N = N / 2 | 0; N; N = N >>> 1){
        i178++;
    }
    return 1 << i178 + 1 + odd;
};
FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
    if (N <= 1) return;
    for(var i179 = 0; i179 < N / 2; i179++){
        var t9 = rws[i179];
        rws[i179] = rws[N - i179 - 1];
        rws[N - i179 - 1] = t9;
        t9 = iws[i179];
        iws[i179] = -iws[N - i179 - 1];
        iws[N - i179 - 1] = -t9;
    }
};
FFTM.prototype.normalize13b = function normalize13b(ws, N) {
    var carry = 0;
    for(var i180 = 0; i180 < N / 2; i180++){
        var w27 = Math.round(ws[2 * i180 + 1] / N) * 8192 + Math.round(ws[2 * i180] / N) + carry;
        ws[i180] = w27 & 67108863;
        if (w27 < 67108864) {
            carry = 0;
        } else {
            carry = w27 / 67108864 | 0;
        }
    }
    return ws;
};
FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
    var carry = 0;
    for(var i181 = 0; i181 < len; i181++){
        carry = carry + (ws[i181] | 0);
        rws[2 * i181] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i181 + 1] = carry & 8191;
        carry = carry >>> 13;
    }
    for(i181 = 2 * len; i181 < N; ++i181){
        rws[i181] = 0;
    }
    assert5(carry === 0);
    assert5((carry & ~8191) === 0);
};
FFTM.prototype.stub = function stub(N) {
    var ph = new Array(N);
    for(var i182 = 0; i182 < N; i182++){
        ph[i182] = 0;
    }
    return ph;
};
FFTM.prototype.mulp = function mulp(x33, y9, out) {
    var N = 2 * this.guessLen13b(x33.length, y9.length);
    var rbt = this.makeRBT(N);
    var _ = this.stub(N);
    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);
    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);
    var rmws = out.words;
    rmws.length = N;
    this.convert13b(x33.words, x33.length, rws, N);
    this.convert13b(y9.words, y9.length, nrws, N);
    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);
    for(var i183 = 0; i183 < N; i183++){
        var rx = rwst[i183] * nrwst[i183] - iwst[i183] * niwst[i183];
        iwst[i183] = rwst[i183] * niwst[i183] + iwst[i183] * nrwst[i183];
        rwst[i183] = rx;
    }
    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);
    out.negative = x33.negative ^ y9.negative;
    out.length = x33.length + y9.length;
    return out._strip();
};
BN.prototype.mul = function mul(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
};
BN.prototype.mulf = function mulf(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
};
BN.prototype.imul = function imul(num) {
    return this.clone().mulTo(num, this);
};
BN.prototype.imuln = function imuln(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert5(typeof num === "number");
    assert5(num < 67108864);
    var carry = 0;
    for(var i184 = 0; i184 < this.length; i184++){
        var w28 = (this.words[i184] | 0) * num;
        var lo = (w28 & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w28 / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i184] = lo & 67108863;
    }
    if (carry !== 0) {
        this.words[i184] = carry;
        this.length++;
    }
    return isNegNum ? this.ineg() : this;
};
BN.prototype.muln = function muln(num) {
    return this.clone().imuln(num);
};
BN.prototype.sqr = function sqr() {
    return this.mul(this);
};
BN.prototype.isqr = function isqr() {
    return this.imul(this.clone());
};
BN.prototype.pow = function pow(num) {
    var w29 = toBitArray(num);
    if (w29.length === 0) return new BN(1);
    var res = this;
    for(var i185 = 0; i185 < w29.length; i185++, res = res.sqr()){
        if (w29[i185] !== 0) break;
    }
    if (++i185 < w29.length) {
        for(var q2 = res.sqr(); i185 < w29.length; i185++, q2 = q2.sqr()){
            if (w29[i185] === 0) continue;
            res = res.mul(q2);
        }
    }
    return res;
};
BN.prototype.iushln = function iushln(bits) {
    assert5(typeof bits === "number" && bits >= 0);
    var r39 = bits % 26;
    var s27 = (bits - r39) / 26;
    var carryMask = 67108863 >>> 26 - r39 << 26 - r39;
    var i186;
    if (r39 !== 0) {
        var carry = 0;
        for(i186 = 0; i186 < this.length; i186++){
            var newCarry = this.words[i186] & carryMask;
            var c24 = (this.words[i186] | 0) - newCarry << r39;
            this.words[i186] = c24 | carry;
            carry = newCarry >>> 26 - r39;
        }
        if (carry) {
            this.words[i186] = carry;
            this.length++;
        }
    }
    if (s27 !== 0) {
        for(i186 = this.length - 1; i186 >= 0; i186--){
            this.words[i186 + s27] = this.words[i186];
        }
        for(i186 = 0; i186 < s27; i186++){
            this.words[i186] = 0;
        }
        this.length += s27;
    }
    return this._strip();
};
BN.prototype.ishln = function ishln(bits) {
    assert5(this.negative === 0);
    return this.iushln(bits);
};
BN.prototype.iushrn = function iushrn(bits, hint, extended) {
    assert5(typeof bits === "number" && bits >= 0);
    var h3;
    if (hint) {
        h3 = (hint - hint % 26) / 26;
    } else {
        h3 = 0;
    }
    var r40 = bits % 26;
    var s28 = Math.min((bits - r40) / 26, this.length);
    var mask = 67108863 ^ 67108863 >>> r40 << r40;
    var maskedWords = extended;
    h3 -= s28;
    h3 = Math.max(0, h3);
    if (maskedWords) {
        for(var i187 = 0; i187 < s28; i187++){
            maskedWords.words[i187] = this.words[i187];
        }
        maskedWords.length = s28;
    }
    if (s28 === 0) {} else if (this.length > s28) {
        this.length -= s28;
        for(i187 = 0; i187 < this.length; i187++){
            this.words[i187] = this.words[i187 + s28];
        }
    } else {
        this.words[0] = 0;
        this.length = 1;
    }
    var carry = 0;
    for(i187 = this.length - 1; i187 >= 0 && (carry !== 0 || i187 >= h3); i187--){
        var word = this.words[i187] | 0;
        this.words[i187] = carry << 26 - r40 | word >>> r40;
        carry = word & mask;
    }
    if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
    }
    if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
    }
    return this._strip();
};
BN.prototype.ishrn = function ishrn(bits, hint, extended) {
    assert5(this.negative === 0);
    return this.iushrn(bits, hint, extended);
};
BN.prototype.shln = function shln(bits) {
    return this.clone().ishln(bits);
};
BN.prototype.ushln = function ushln(bits) {
    return this.clone().iushln(bits);
};
BN.prototype.shrn = function shrn(bits) {
    return this.clone().ishrn(bits);
};
BN.prototype.ushrn = function ushrn(bits) {
    return this.clone().iushrn(bits);
};
BN.prototype.testn = function testn(bit) {
    assert5(typeof bit === "number" && bit >= 0);
    var r41 = bit % 26;
    var s29 = (bit - r41) / 26;
    var q3 = 1 << r41;
    if (this.length <= s29) return false;
    var w30 = this.words[s29];
    return !!(w30 & q3);
};
BN.prototype.imaskn = function imaskn(bits) {
    assert5(typeof bits === "number" && bits >= 0);
    var r42 = bits % 26;
    var s30 = (bits - r42) / 26;
    assert5(this.negative === 0, "imaskn works only with positive numbers");
    if (this.length <= s30) {
        return this;
    }
    if (r42 !== 0) {
        s30++;
    }
    this.length = Math.min(s30, this.length);
    if (r42 !== 0) {
        var mask = 67108863 ^ 67108863 >>> r42 << r42;
        this.words[this.length - 1] &= mask;
    }
    return this._strip();
};
BN.prototype.maskn = function maskn(bits) {
    return this.clone().imaskn(bits);
};
BN.prototype.iaddn = function iaddn(num) {
    assert5(typeof num === "number");
    assert5(num < 67108864);
    if (num < 0) return this.isubn(-num);
    if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
    }
    return this._iaddn(num);
};
BN.prototype._iaddn = function _iaddn(num) {
    this.words[0] += num;
    for(var i188 = 0; i188 < this.length && this.words[i188] >= 67108864; i188++){
        this.words[i188] -= 67108864;
        if (i188 === this.length - 1) {
            this.words[i188 + 1] = 1;
        } else {
            this.words[i188 + 1]++;
        }
    }
    this.length = Math.max(this.length, i188 + 1);
    return this;
};
BN.prototype.isubn = function isubn(num) {
    assert5(typeof num === "number");
    assert5(num < 67108864);
    if (num < 0) return this.iaddn(-num);
    if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
    }
    this.words[0] -= num;
    if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
    } else {
        for(var i189 = 0; i189 < this.length && this.words[i189] < 0; i189++){
            this.words[i189] += 67108864;
            this.words[i189 + 1] -= 1;
        }
    }
    return this._strip();
};
BN.prototype.addn = function addn(num) {
    return this.clone().iaddn(num);
};
BN.prototype.subn = function subn(num) {
    return this.clone().isubn(num);
};
BN.prototype.iabs = function iabs() {
    this.negative = 0;
    return this;
};
BN.prototype.abs = function abs() {
    return this.clone().iabs();
};
BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
    var len = num.length + shift;
    var i190;
    this._expand(len);
    var w31;
    var carry = 0;
    for(i190 = 0; i190 < num.length; i190++){
        w31 = (this.words[i190 + shift] | 0) + carry;
        var right = (num.words[i190] | 0) * mul;
        w31 -= right & 67108863;
        carry = (w31 >> 26) - (right / 67108864 | 0);
        this.words[i190 + shift] = w31 & 67108863;
    }
    for(; i190 < this.length - shift; i190++){
        w31 = (this.words[i190 + shift] | 0) + carry;
        carry = w31 >> 26;
        this.words[i190 + shift] = w31 & 67108863;
    }
    if (carry === 0) return this._strip();
    assert5(carry === -1);
    carry = 0;
    for(i190 = 0; i190 < this.length; i190++){
        w31 = -(this.words[i190] | 0) + carry;
        carry = w31 >> 26;
        this.words[i190] = w31 & 67108863;
    }
    this.negative = 1;
    return this._strip();
};
BN.prototype._wordDiv = function _wordDiv(num, mode19) {
    var shift = this.length - num.length;
    var a24 = this.clone();
    var b30 = num;
    var bhi = b30.words[b30.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
        b30 = b30.ushln(shift);
        a24.iushln(shift);
        bhi = b30.words[b30.length - 1] | 0;
    }
    var m14 = a24.length - b30.length;
    var q4;
    if (mode19 !== "mod") {
        q4 = new BN(null);
        q4.length = m14 + 1;
        q4.words = new Array(q4.length);
        for(var i191 = 0; i191 < q4.length; i191++){
            q4.words[i191] = 0;
        }
    }
    var diff2 = a24.clone()._ishlnsubmul(b30, 1, m14);
    if (diff2.negative === 0) {
        a24 = diff2;
        if (q4) {
            q4.words[m14] = 1;
        }
    }
    for(var j = m14 - 1; j >= 0; j--){
        var qj = (a24.words[b30.length + j] | 0) * 67108864 + (a24.words[b30.length + j - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a24._ishlnsubmul(b30, qj, j);
        while(a24.negative !== 0){
            qj--;
            a24.negative = 0;
            a24._ishlnsubmul(b30, 1, j);
            if (!a24.isZero()) {
                a24.negative ^= 1;
            }
        }
        if (q4) {
            q4.words[j] = qj;
        }
    }
    if (q4) {
        q4._strip();
    }
    a24._strip();
    if (mode19 !== "div" && shift !== 0) {
        a24.iushrn(shift);
    }
    return {
        div: q4 || null,
        mod: a24
    };
};
BN.prototype.divmod = function divmod(num, mode20, positive) {
    assert5(!num.isZero());
    if (this.isZero()) {
        return {
            div: new BN(0),
            mod: new BN(0)
        };
    }
    var div, mod65, res;
    if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode20);
        if (mode20 !== "mod") {
            div = res.div.neg();
        }
        if (mode20 !== "div") {
            mod65 = res.mod.neg();
            if (positive && mod65.negative !== 0) {
                mod65.iadd(num);
            }
        }
        return {
            div: div,
            mod: mod65
        };
    }
    if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode20);
        if (mode20 !== "mod") {
            div = res.div.neg();
        }
        return {
            div: div,
            mod: res.mod
        };
    }
    if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode20);
        if (mode20 !== "div") {
            mod65 = res.mod.neg();
            if (positive && mod65.negative !== 0) {
                mod65.isub(num);
            }
        }
        return {
            div: res.div,
            mod: mod65
        };
    }
    if (num.length > this.length || this.cmp(num) < 0) {
        return {
            div: new BN(0),
            mod: this
        };
    }
    if (num.length === 1) {
        if (mode20 === "div") {
            return {
                div: this.divn(num.words[0]),
                mod: null
            };
        }
        if (mode20 === "mod") {
            return {
                div: null,
                mod: new BN(this.modrn(num.words[0]))
            };
        }
        return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modrn(num.words[0]))
        };
    }
    return this._wordDiv(num, mode20);
};
BN.prototype.div = function div(num) {
    return this.divmod(num, "div", false).div;
};
BN.prototype.mod = function mod(num) {
    return this.divmod(num, "mod", false).mod;
};
BN.prototype.umod = function umod(num) {
    return this.divmod(num, "mod", true).mod;
};
BN.prototype.divRound = function divRound(num) {
    var dm = this.divmod(num);
    if (dm.mod.isZero()) return dm.div;
    var mod66 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod66.cmp(half);
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
};
BN.prototype.modrn = function modrn(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert5(num <= 67108863);
    var p24 = (1 << 26) % num;
    var acc = 0;
    for(var i192 = this.length - 1; i192 >= 0; i192--){
        acc = (p24 * acc + (this.words[i192] | 0)) % num;
    }
    return isNegNum ? -acc : acc;
};
BN.prototype.modn = function modn(num) {
    return this.modrn(num);
};
BN.prototype.idivn = function idivn(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert5(num <= 67108863);
    var carry = 0;
    for(var i193 = this.length - 1; i193 >= 0; i193--){
        var w32 = (this.words[i193] | 0) + carry * 67108864;
        this.words[i193] = w32 / num | 0;
        carry = w32 % num;
    }
    this._strip();
    return isNegNum ? this.ineg() : this;
};
BN.prototype.divn = function divn(num) {
    return this.clone().idivn(num);
};
BN.prototype.egcd = function egcd(p25) {
    assert5(p25.negative === 0);
    assert5(!p25.isZero());
    var x34 = this;
    var y10 = p25.clone();
    if (x34.negative !== 0) {
        x34 = x34.umod(p25);
    } else {
        x34 = x34.clone();
    }
    var A = new BN(1);
    var B = new BN(0);
    var C = new BN(0);
    var D = new BN(1);
    var g1 = 0;
    while(x34.isEven() && y10.isEven()){
        x34.iushrn(1);
        y10.iushrn(1);
        ++g1;
    }
    var yp = y10.clone();
    var xp = x34.clone();
    while(!x34.isZero()){
        for(var i194 = 0, im = 1; (x34.words[0] & im) === 0 && i194 < 26; ++i194, im <<= 1);
        if (i194 > 0) {
            x34.iushrn(i194);
            while(i194-- > 0){
                if (A.isOdd() || B.isOdd()) {
                    A.iadd(yp);
                    B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
            }
        }
        for(var j = 0, jm = 1; (y10.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
        if (j > 0) {
            y10.iushrn(j);
            while(j-- > 0){
                if (C.isOdd() || D.isOdd()) {
                    C.iadd(yp);
                    D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
            }
        }
        if (x34.cmp(y10) >= 0) {
            x34.isub(y10);
            A.isub(C);
            B.isub(D);
        } else {
            y10.isub(x34);
            C.isub(A);
            D.isub(B);
        }
    }
    return {
        a: C,
        b: D,
        gcd: y10.iushln(g1)
    };
};
BN.prototype._invmp = function _invmp(p26) {
    assert5(p26.negative === 0);
    assert5(!p26.isZero());
    var a25 = this;
    var b31 = p26.clone();
    if (a25.negative !== 0) {
        a25 = a25.umod(p26);
    } else {
        a25 = a25.clone();
    }
    var x1 = new BN(1);
    var x2 = new BN(0);
    var delta = b31.clone();
    while(a25.cmpn(1) > 0 && b31.cmpn(1) > 0){
        for(var i195 = 0, im = 1; (a25.words[0] & im) === 0 && i195 < 26; ++i195, im <<= 1);
        if (i195 > 0) {
            a25.iushrn(i195);
            while(i195-- > 0){
                if (x1.isOdd()) {
                    x1.iadd(delta);
                }
                x1.iushrn(1);
            }
        }
        for(var j = 0, jm = 1; (b31.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
        if (j > 0) {
            b31.iushrn(j);
            while(j-- > 0){
                if (x2.isOdd()) {
                    x2.iadd(delta);
                }
                x2.iushrn(1);
            }
        }
        if (a25.cmp(b31) >= 0) {
            a25.isub(b31);
            x1.isub(x2);
        } else {
            b31.isub(a25);
            x2.isub(x1);
        }
    }
    var res;
    if (a25.cmpn(1) === 0) {
        res = x1;
    } else {
        res = x2;
    }
    if (res.cmpn(0) < 0) {
        res.iadd(p26);
    }
    return res;
};
BN.prototype.gcd = function gcd(num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();
    var a26 = this.clone();
    var b32 = num.clone();
    a26.negative = 0;
    b32.negative = 0;
    for(var shift = 0; a26.isEven() && b32.isEven(); shift++){
        a26.iushrn(1);
        b32.iushrn(1);
    }
    do {
        while(a26.isEven()){
            a26.iushrn(1);
        }
        while(b32.isEven()){
            b32.iushrn(1);
        }
        var r43 = a26.cmp(b32);
        if (r43 < 0) {
            var t10 = a26;
            a26 = b32;
            b32 = t10;
        } else if (r43 === 0 || b32.cmpn(1) === 0) {
            break;
        }
        a26.isub(b32);
    }while (true)
    return b32.iushln(shift);
};
BN.prototype.invm = function invm(num) {
    return this.egcd(num).a.umod(num);
};
BN.prototype.isEven = function isEven() {
    return (this.words[0] & 1) === 0;
};
BN.prototype.isOdd = function isOdd() {
    return (this.words[0] & 1) === 1;
};
BN.prototype.andln = function andln(num) {
    return this.words[0] & num;
};
BN.prototype.bincn = function bincn(bit) {
    assert5(typeof bit === "number");
    var r44 = bit % 26;
    var s31 = (bit - r44) / 26;
    var q5 = 1 << r44;
    if (this.length <= s31) {
        this._expand(s31 + 1);
        this.words[s31] |= q5;
        return this;
    }
    var carry = q5;
    for(var i196 = s31; carry !== 0 && i196 < this.length; i196++){
        var w33 = this.words[i196] | 0;
        w33 += carry;
        carry = w33 >>> 26;
        w33 &= 67108863;
        this.words[i196] = w33;
    }
    if (carry !== 0) {
        this.words[i196] = carry;
        this.length++;
    }
    return this;
};
BN.prototype.isZero = function isZero() {
    return this.length === 1 && this.words[0] === 0;
};
BN.prototype.cmpn = function cmpn(num) {
    var negative = num < 0;
    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;
    this._strip();
    var res;
    if (this.length > 1) {
        res = 1;
    } else {
        if (negative) {
            num = -num;
        }
        assert5(num <= 67108863, "Number is too big");
        var w34 = this.words[0] | 0;
        res = w34 === num ? 0 : w34 < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
};
BN.prototype.cmp = function cmp(num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;
    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
};
BN.prototype.ucmp = function ucmp(num) {
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;
    var res = 0;
    for(var i197 = this.length - 1; i197 >= 0; i197--){
        var a27 = this.words[i197] | 0;
        var b33 = num.words[i197] | 0;
        if (a27 === b33) continue;
        if (a27 < b33) {
            res = -1;
        } else if (a27 > b33) {
            res = 1;
        }
        break;
    }
    return res;
};
BN.prototype.gtn = function gtn(num) {
    return this.cmpn(num) === 1;
};
BN.prototype.gt = function gt(num) {
    return this.cmp(num) === 1;
};
BN.prototype.gten = function gten(num) {
    return this.cmpn(num) >= 0;
};
BN.prototype.gte = function gte(num) {
    return this.cmp(num) >= 0;
};
BN.prototype.ltn = function ltn(num) {
    return this.cmpn(num) === -1;
};
BN.prototype.lt = function lt(num) {
    return this.cmp(num) === -1;
};
BN.prototype.lten = function lten(num) {
    return this.cmpn(num) <= 0;
};
BN.prototype.lte = function lte(num) {
    return this.cmp(num) <= 0;
};
BN.prototype.eqn = function eqn(num) {
    return this.cmpn(num) === 0;
};
BN.prototype.eq = function eq(num) {
    return this.cmp(num) === 0;
};
BN.red = function red(num) {
    return new Red(num);
};
BN.prototype.toRed = function toRed(ctx) {
    assert5(!this.red, "Already a number in reduction context");
    assert5(this.negative === 0, "red works only with positives");
    return ctx.convertTo(this)._forceRed(ctx);
};
BN.prototype.fromRed = function fromRed() {
    assert5(this.red, "fromRed works only with numbers in reduction context");
    return this.red.convertFrom(this);
};
BN.prototype._forceRed = function _forceRed(ctx) {
    this.red = ctx;
    return this;
};
BN.prototype.forceRed = function forceRed(ctx) {
    assert5(!this.red, "Already a number in reduction context");
    return this._forceRed(ctx);
};
BN.prototype.redAdd = function redAdd(num) {
    assert5(this.red, "redAdd works only with red numbers");
    return this.red.add(this, num);
};
BN.prototype.redIAdd = function redIAdd(num) {
    assert5(this.red, "redIAdd works only with red numbers");
    return this.red.iadd(this, num);
};
BN.prototype.redSub = function redSub(num) {
    assert5(this.red, "redSub works only with red numbers");
    return this.red.sub(this, num);
};
BN.prototype.redISub = function redISub(num) {
    assert5(this.red, "redISub works only with red numbers");
    return this.red.isub(this, num);
};
BN.prototype.redShl = function redShl(num) {
    assert5(this.red, "redShl works only with red numbers");
    return this.red.shl(this, num);
};
BN.prototype.redMul = function redMul(num) {
    assert5(this.red, "redMul works only with red numbers");
    this.red._verify2(this, num);
    return this.red.mul(this, num);
};
BN.prototype.redIMul = function redIMul(num) {
    assert5(this.red, "redMul works only with red numbers");
    this.red._verify2(this, num);
    return this.red.imul(this, num);
};
BN.prototype.redSqr = function redSqr() {
    assert5(this.red, "redSqr works only with red numbers");
    this.red._verify1(this);
    return this.red.sqr(this);
};
BN.prototype.redISqr = function redISqr() {
    assert5(this.red, "redISqr works only with red numbers");
    this.red._verify1(this);
    return this.red.isqr(this);
};
BN.prototype.redSqrt = function redSqrt() {
    assert5(this.red, "redSqrt works only with red numbers");
    this.red._verify1(this);
    return this.red.sqrt(this);
};
BN.prototype.redInvm = function redInvm() {
    assert5(this.red, "redInvm works only with red numbers");
    this.red._verify1(this);
    return this.red.invm(this);
};
BN.prototype.redNeg = function redNeg() {
    assert5(this.red, "redNeg works only with red numbers");
    this.red._verify1(this);
    return this.red.neg(this);
};
BN.prototype.redPow = function redPow(num) {
    assert5(this.red && !num.red, "redPow(normalNum)");
    this.red._verify1(this);
    return this.red.pow(this, num);
};
var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
};
function MPrime(name63, p27) {
    this.name = name63;
    this.p = new BN(p27, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);
    this.tmp = this._tmp();
}
MPrime.prototype._tmp = function _tmp() {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
};
MPrime.prototype.ireduce = function ireduce(num) {
    var r45 = num;
    var rlen;
    do {
        this.split(r45, this.tmp);
        r45 = this.imulK(r45);
        r45 = r45.iadd(this.tmp);
        rlen = r45.bitLength();
    }while (rlen > this.n)
    var cmp = rlen < this.n ? -1 : r45.ucmp(this.p);
    if (cmp === 0) {
        r45.words[0] = 0;
        r45.length = 1;
    } else if (cmp > 0) {
        r45.isub(this.p);
    } else {
        if (r45.strip !== undefined) {
            r45.strip();
        } else {
            r45._strip();
        }
    }
    return r45;
};
MPrime.prototype.split = function split(input, out) {
    input.iushrn(this.n, 0, out);
};
MPrime.prototype.imulK = function imulK(num) {
    return num.imul(this.k);
};
function K256() {
    MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
}
inherits1(K256, MPrime);
K256.prototype.split = function split(input, output) {
    var mask = 4194303;
    var outLen = Math.min(input.length, 9);
    for(var i198 = 0; i198 < outLen; i198++){
        output.words[i198] = input.words[i198];
    }
    output.length = outLen;
    if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
    }
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;
    for(i198 = 10; i198 < input.length; i198++){
        var next = input.words[i198] | 0;
        input.words[i198 - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
    }
    prev >>>= 22;
    input.words[i198 - 10] = prev;
    if (prev === 0 && input.length > 10) {
        input.length -= 10;
    } else {
        input.length -= 9;
    }
};
K256.prototype.imulK = function imulK(num) {
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;
    var lo = 0;
    for(var i199 = 0; i199 < num.length; i199++){
        var w35 = num.words[i199] | 0;
        lo += w35 * 977;
        num.words[i199] = lo & 67108863;
        lo = w35 * 64 + (lo / 67108864 | 0);
    }
    if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
            num.length--;
        }
    }
    return num;
};
function P224() {
    MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
}
inherits1(P224, MPrime);
function P192() {
    MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
}
inherits1(P192, MPrime);
function P25519() {
    MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
}
inherits1(P25519, MPrime);
P25519.prototype.imulK = function imulK(num) {
    var carry = 0;
    for(var i200 = 0; i200 < num.length; i200++){
        var hi = (num.words[i200] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i200] = lo;
        carry = hi;
    }
    if (carry !== 0) {
        num.words[num.length++] = carry;
    }
    return num;
};
BN._prime = function prime(name64) {
    if (primes[name64]) return primes[name64];
    var prime;
    if (name64 === "k256") {
        prime = new K256();
    } else if (name64 === "p224") {
        prime = new P224();
    } else if (name64 === "p192") {
        prime = new P192();
    } else if (name64 === "p25519") {
        prime = new P25519();
    } else {
        throw new Error("Unknown prime " + name64);
    }
    primes[name64] = prime;
    return prime;
};
function Red(m15) {
    if (typeof m15 === "string") {
        var prime = BN._prime(m15);
        this.m = prime.p;
        this.prime = prime;
    } else {
        assert5(m15.gtn(1), "modulus must be greater than 1");
        this.m = m15;
        this.prime = null;
    }
}
Red.prototype._verify1 = function _verify1(a28) {
    assert5(a28.negative === 0, "red works only with positives");
    assert5(a28.red, "red works only with red numbers");
};
Red.prototype._verify2 = function _verify2(a29, b34) {
    assert5((a29.negative | b34.negative) === 0, "red works only with positives");
    assert5(a29.red && a29.red === b34.red, "red works only with red numbers");
};
Red.prototype.imod = function imod(a30) {
    if (this.prime) return this.prime.ireduce(a30)._forceRed(this);
    move(a30, a30.umod(this.m)._forceRed(this));
    return a30;
};
Red.prototype.neg = function neg(a31) {
    if (a31.isZero()) {
        return a31.clone();
    }
    return this.m.sub(a31)._forceRed(this);
};
Red.prototype.add = function add(a32, b35) {
    this._verify2(a32, b35);
    var res = a32.add(b35);
    if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
    }
    return res._forceRed(this);
};
Red.prototype.iadd = function iadd(a33, b36) {
    this._verify2(a33, b36);
    var res = a33.iadd(b36);
    if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
    }
    return res;
};
Red.prototype.sub = function sub(a34, b37) {
    this._verify2(a34, b37);
    var res = a34.sub(b37);
    if (res.cmpn(0) < 0) {
        res.iadd(this.m);
    }
    return res._forceRed(this);
};
Red.prototype.isub = function isub(a35, b38) {
    this._verify2(a35, b38);
    var res = a35.isub(b38);
    if (res.cmpn(0) < 0) {
        res.iadd(this.m);
    }
    return res;
};
Red.prototype.shl = function shl(a36, num) {
    this._verify1(a36);
    return this.imod(a36.ushln(num));
};
Red.prototype.imul = function imul(a37, b39) {
    this._verify2(a37, b39);
    return this.imod(a37.imul(b39));
};
Red.prototype.mul = function mul(a38, b40) {
    this._verify2(a38, b40);
    return this.imod(a38.mul(b40));
};
Red.prototype.isqr = function isqr(a39) {
    return this.imul(a39, a39.clone());
};
Red.prototype.sqr = function sqr(a40) {
    return this.mul(a40, a40);
};
Red.prototype.sqrt = function sqrt(a41) {
    if (a41.isZero()) return a41.clone();
    var mod310 = this.m.andln(3);
    assert5(mod310 % 2 === 1);
    if (mod310 === 3) {
        var pow = this.m.add(new BN(1)).iushrn(2);
        return this.pow(a41, pow);
    }
    var q6 = this.m.subn(1);
    var s32 = 0;
    while(!q6.isZero() && q6.andln(1) === 0){
        s32++;
        q6.iushrn(1);
    }
    assert5(!q6.isZero());
    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);
    while(this.pow(z, lpow).cmp(nOne) !== 0){
        z.redIAdd(nOne);
    }
    var c25 = this.pow(z, q6);
    var r46 = this.pow(a41, q6.addn(1).iushrn(1));
    var t11 = this.pow(a41, q6);
    var m16 = s32;
    while(t11.cmp(one) !== 0){
        var tmp = t11;
        for(var i201 = 0; tmp.cmp(one) !== 0; i201++){
            tmp = tmp.redSqr();
        }
        assert5(i201 < m16);
        var b41 = this.pow(c25, new BN(1).iushln(m16 - i201 - 1));
        r46 = r46.redMul(b41);
        c25 = b41.redSqr();
        t11 = t11.redMul(c25);
        m16 = i201;
    }
    return r46;
};
Red.prototype.invm = function invm(a42) {
    var inv = a42._invmp(this.m);
    if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
    } else {
        return this.imod(inv);
    }
};
Red.prototype.pow = function pow(a43, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a43.clone();
    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a43;
    for(var i202 = 2; i202 < wnd.length; i202++){
        wnd[i202] = this.mul(wnd[i202 - 1], a43);
    }
    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start33 = num.bitLength() % 26;
    if (start33 === 0) {
        start33 = 26;
    }
    for(i202 = num.length - 1; i202 >= 0; i202--){
        var word = num.words[i202];
        for(var j = start33 - 1; j >= 0; j--){
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
                res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i202 !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
        }
        start33 = 26;
    }
    return res;
};
Red.prototype.convertTo = function convertTo(num) {
    var r47 = num.umod(this.m);
    return r47 === num ? r47.clone() : r47;
};
Red.prototype.convertFrom = function convertFrom(num) {
    var res = num.clone();
    res.red = null;
    return res;
};
BN.mont = function mont(num) {
    return new Mont(num);
};
function Mont(m17) {
    Red.call(this, m17);
    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
    }
    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);
    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
}
inherits1(Mont, Red);
Mont.prototype.convertTo = function convertTo(num) {
    return this.imod(num.ushln(this.shift));
};
Mont.prototype.convertFrom = function convertFrom(num) {
    var r48 = this.imod(num.mul(this.rinv));
    r48.red = null;
    return r48;
};
Mont.prototype.imul = function imul(a44, b42) {
    if (a44.isZero() || b42.isZero()) {
        a44.words[0] = 0;
        a44.length = 1;
        return a44;
    }
    var t12 = a44.imul(b42);
    var c26 = t12.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u1 = t12.isub(c26).iushrn(this.shift);
    var res = u1;
    if (u1.cmp(this.m) >= 0) {
        res = u1.isub(this.m);
    } else if (u1.cmpn(0) < 0) {
        res = u1.iadd(this.m);
    }
    return res._forceRed(this);
};
Mont.prototype.mul = function mul(a45, b43) {
    if (a45.isZero() || b43.isZero()) return new BN(0)._forceRed(this);
    var t13 = a45.mul(b43);
    var c27 = t13.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u2 = t13.isub(c27).iushrn(this.shift);
    var res = u2;
    if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
    } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
    }
    return res._forceRed(this);
};
Mont.prototype.invm = function invm(a46) {
    var res = this.imod(a46._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
};
function Reporter(options) {
    this._reporterState = {
        obj: null,
        path: [],
        options: options || {},
        errors: []
    };
}
Reporter.prototype.isError = function isError(obj) {
    return obj instanceof ReporterError;
};
Reporter.prototype.save = function save() {
    const state56 = this._reporterState;
    return {
        obj: state56.obj,
        pathLen: state56.path.length
    };
};
Reporter.prototype.restore = function restore(data43) {
    const state57 = this._reporterState;
    state57.obj = data43.obj;
    state57.path = state57.path.slice(0, data43.pathLen);
};
Reporter.prototype.enterKey = function enterKey(key) {
    return this._reporterState.path.push(key);
};
Reporter.prototype.exitKey = function exitKey(index16) {
    const state58 = this._reporterState;
    state58.path = state58.path.slice(0, index16 - 1);
};
Reporter.prototype.leaveKey = function leaveKey(index17, key, value) {
    const state59 = this._reporterState;
    this.exitKey(index17);
    if (state59.obj !== null) {
        state59.obj[key] = value;
    }
};
Reporter.prototype.path = function path() {
    return this._reporterState.path.join("/");
};
Reporter.prototype.enterObject = function enterObject() {
    const state60 = this._reporterState;
    const prev = state60.obj;
    state60.obj = {};
    return prev;
};
Reporter.prototype.leaveObject = function leaveObject(prev) {
    const state61 = this._reporterState;
    const now = state61.obj;
    state61.obj = prev;
    return now;
};
Reporter.prototype.error = function error(msg) {
    let err161;
    const state62 = this._reporterState;
    const inherited = msg instanceof ReporterError;
    if (inherited) {
        err161 = msg;
    } else {
        err161 = new ReporterError(state62.path.map(function(elem) {
            return "[" + JSON.stringify(elem) + "]";
        }).join(""), msg.message || msg, msg.stack);
    }
    if (!state62.options.partial) {
        throw err161;
    }
    if (!inherited) {
        state62.errors.push(err161);
    }
    return err161;
};
Reporter.prototype.wrapResult = function wrapResult(result) {
    const state63 = this._reporterState;
    if (!state63.options.partial) {
        return result;
    }
    return {
        result: this.isError(result) ? null : result,
        errors: state63.errors
    };
};
function ReporterError(path113, msg) {
    this.path = path113;
    this.rethrow(msg);
}
ReporterError.prototype = Object.create(Error.prototype, {
    constructor: {
        value: ReporterError,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
ReporterError.prototype.rethrow = function rethrow(msg) {
    this.message = msg + " at: " + (this.path || "(shallow)");
    if (Error.captureStackTrace) {
        Error.captureStackTrace(this, ReporterError);
    }
    if (!this.stack) {
        try {
            throw new Error(this.message);
        } catch (e45) {
            this.stack = e45.stack;
        }
    }
    return this;
};
function DecoderBuffer(base22, options) {
    Reporter.call(this, options);
    if (!Buffer1.isBuffer(base22)) {
        this.error("Input not Buffer");
        return;
    }
    this.base = base22;
    this.offset = 0;
    this.length = base22.length;
}
DecoderBuffer.prototype = Object.create(Reporter.prototype, {
    constructor: {
        value: DecoderBuffer,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data44) {
    if (data44 instanceof DecoderBuffer) {
        return true;
    }
    const isCompatible = typeof data44 === "object" && Buffer1.isBuffer(data44.base) && data44.constructor.name === "DecoderBuffer" && typeof data44.offset === "number" && typeof data44.length === "number" && typeof data44.save === "function" && typeof data44.restore === "function" && typeof data44.isEmpty === "function" && typeof data44.readUInt8 === "function" && typeof data44.skip === "function" && typeof data44.raw === "function";
    return isCompatible;
};
DecoderBuffer.prototype.save = function save() {
    return {
        offset: this.offset,
        reporter: Reporter.prototype.save.call(this)
    };
};
DecoderBuffer.prototype.restore = function restore(save) {
    const res = new DecoderBuffer(this.base);
    res.offset = save.offset;
    res.length = this.offset;
    this.offset = save.offset;
    Reporter.prototype.restore.call(this, save.reporter);
    return res;
};
DecoderBuffer.prototype.isEmpty = function isEmpty() {
    return this.offset === this.length;
};
DecoderBuffer.prototype.readUInt8 = function readUInt8(fail2) {
    if (this.offset + 1 <= this.length) {
        return this.base.readUInt8(this.offset++, true);
    } else {
        return this.error(fail2 || "DecoderBuffer overrun");
    }
};
DecoderBuffer.prototype.skip = function skip(bytes, fail3) {
    if (!(this.offset + bytes <= this.length)) {
        return this.error(fail3 || "DecoderBuffer overrun");
    }
    const res = new DecoderBuffer(this.base);
    res._reporterState = this._reporterState;
    res.offset = this.offset;
    res.length = this.offset + bytes;
    this.offset += bytes;
    return res;
};
DecoderBuffer.prototype.raw = function raw(save) {
    return this.base.slice(save ? save.offset : this.offset, this.length);
};
function EncoderBuffer(value, reporter) {
    if (Array.isArray(value)) {
        this.length = 0;
        this.value = value.map(function(item) {
            if (!EncoderBuffer.isEncoderBuffer(item)) {
                item = new EncoderBuffer(item, reporter);
            }
            this.length += item.length;
            return item;
        }, this);
    } else if (typeof value === "number") {
        if (!(0 <= value && value <= 255)) {
            return reporter.error("non-byte EncoderBuffer value");
        }
        this.value = value;
        this.length = 1;
    } else if (typeof value === "string") {
        this.value = value;
        this.length = Buffer1.byteLength(value);
    } else if (Buffer1.isBuffer(value)) {
        this.value = value;
        this.length = value.length;
    } else {
        return reporter.error("Unsupported type: " + typeof value);
    }
}
EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data45) {
    if (data45 instanceof EncoderBuffer) {
        return true;
    }
    const isCompatible = typeof data45 === "object" && data45.constructor.name === "EncoderBuffer" && typeof data45.length === "number" && typeof data45.join === "function";
    return isCompatible;
};
EncoderBuffer.prototype.join = function join(out, offset) {
    if (!out) {
        out = Buffer1.alloc(this.length);
    }
    if (!offset) {
        offset = 0;
    }
    if (this.length === 0) {
        return out;
    }
    if (Array.isArray(this.value)) {
        this.value.forEach(function(item) {
            item.join(out, offset);
            offset += item.length;
        });
    } else {
        if (typeof this.value === "number") {
            out[offset] = this.value;
        } else if (typeof this.value === "string") {
            out.write(this.value, offset);
        } else if (Buffer1.isBuffer(this.value)) {
            this.value.copy(out, offset);
        }
        offset += this.length;
    }
    return out;
};
const tags = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr", 
];
const methods = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains", 
].concat(tags);
const overrided = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool", 
];
function Node(enc, parent, name65) {
    const state64 = {};
    this._baseState = state64;
    state64.name = name65;
    state64.enc = enc;
    state64.parent = parent || null;
    state64.children = null;
    state64.tag = null;
    state64.args = null;
    state64.reverseArgs = null;
    state64.choice = null;
    state64.optional = false;
    state64.any = false;
    state64.obj = false;
    state64.use = null;
    state64.useDecoder = null;
    state64.key = null;
    state64["default"] = null;
    state64.explicit = null;
    state64.implicit = null;
    state64.contains = null;
    if (!state64.parent) {
        state64.children = [];
        this._wrap();
    }
}
const stateProps = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains", 
];
Node.prototype.clone = function clone() {
    const state65 = this._baseState;
    const cstate = {};
    stateProps.forEach(function(prop) {
        cstate[prop] = state65[prop];
    });
    const res = new this.constructor(cstate.parent);
    res._baseState = cstate;
    return res;
};
Node.prototype._wrap = function wrap() {
    const state66 = this._baseState;
    methods.forEach(function(method) {
        this[method] = function _wrappedMethod() {
            const clone = new this.constructor(this);
            state66.children.push(clone);
            return clone[method].apply(clone, arguments);
        };
    }, this);
};
Node.prototype._init = function init(body) {
    const state67 = this._baseState;
    assert(state67.parent === null);
    body.call(this);
    state67.children = state67.children.filter(function(child) {
        return child._baseState.parent === this;
    }, this);
    assertEquals(state67.children.length, 1, "Root node can have only one child");
};
Node.prototype._useArgs = function useArgs(args) {
    const state68 = this._baseState;
    const children = args.filter(function(arg) {
        return arg instanceof this.constructor;
    }, this);
    args = args.filter(function(arg) {
        return !(arg instanceof this.constructor);
    }, this);
    if (children.length !== 0) {
        assert(state68.children === null);
        state68.children = children;
        children.forEach(function(child) {
            child._baseState.parent = this;
        }, this);
    }
    if (args.length !== 0) {
        assert(state68.args === null);
        state68.args = args;
        state68.reverseArgs = args.map(function(arg) {
            if (typeof arg !== "object" || arg.constructor !== Object) {
                return arg;
            }
            const res = {};
            Object.keys(arg).forEach(function(key) {
                if (key == (key | 0)) {
                    key |= 0;
                }
                const value = arg[key];
                res[value] = key;
            });
            return res;
        });
    }
};
overrided.forEach(function(method) {
    Node.prototype[method] = function _overrided() {
        const state69 = this._baseState;
        throw new Error(method + " not implemented for encoding: " + state69.enc);
    };
});
tags.forEach(function(tag9) {
    Node.prototype[tag9] = function _tagMethod() {
        const state70 = this._baseState;
        const args = Array.prototype.slice.call(arguments);
        assert(state70.tag === null);
        state70.tag = tag9;
        this._useArgs(args);
        return this;
    };
});
Node.prototype.use = function use(item) {
    assert(item);
    const state71 = this._baseState;
    assert(state71.use === null);
    state71.use = item;
    return this;
};
Node.prototype.optional = function optional() {
    const state72 = this._baseState;
    state72.optional = true;
    return this;
};
Node.prototype.def = function def(val) {
    const state73 = this._baseState;
    assert(state73["default"] === null);
    state73["default"] = val;
    state73.optional = true;
    return this;
};
Node.prototype.explicit = function explicit(num) {
    const state74 = this._baseState;
    assert(state74.explicit === null && state74.implicit === null);
    state74.explicit = num;
    return this;
};
Node.prototype.implicit = function implicit(num) {
    const state75 = this._baseState;
    assert(state75.explicit === null && state75.implicit === null);
    state75.implicit = num;
    return this;
};
Node.prototype.obj = function obj() {
    const state76 = this._baseState;
    const args = Array.prototype.slice.call(arguments);
    state76.obj = true;
    if (args.length !== 0) {
        this._useArgs(args);
    }
    return this;
};
Node.prototype.key = function key(newKey) {
    const state77 = this._baseState;
    assert(state77.key === null);
    state77.key = newKey;
    return this;
};
Node.prototype.any = function any() {
    const state78 = this._baseState;
    state78.any = true;
    return this;
};
Node.prototype.choice = function choice(obj) {
    const state79 = this._baseState;
    assert(state79.choice === null);
    state79.choice = obj;
    this._useArgs(Object.keys(obj).map(function(key) {
        return obj[key];
    }));
    return this;
};
Node.prototype.contains = function contains(item) {
    const state80 = this._baseState;
    assert(state80.use === null);
    state80.contains = item;
    return this;
};
Node.prototype._decode = function decode(input, options) {
    const state81 = this._baseState;
    if (state81.parent === null) {
        return input.wrapResult(state81.children[0]._decode(input, options));
    }
    let result = state81["default"];
    let present = true;
    let prevKey = null;
    if (state81.key !== null) {
        prevKey = input.enterKey(state81.key);
    }
    if (state81.optional) {
        let tag10 = null;
        if (state81.explicit !== null) {
            tag10 = state81.explicit;
        } else if (state81.implicit !== null) {
            tag10 = state81.implicit;
        } else if (state81.tag !== null) {
            tag10 = state81.tag;
        }
        if (tag10 === null && !state81.any) {
            const save = input.save();
            try {
                if (state81.choice === null) {
                    this._decodeGeneric(state81.tag, input, options);
                } else {
                    this._decodeChoice(input, options);
                }
                present = true;
            } catch (_e) {
                present = false;
            }
            input.restore(save);
        } else {
            present = this._peekTag(input, tag10, state81.any);
            if (input.isError(present)) {
                return present;
            }
        }
    }
    let prevObj;
    if (state81.obj && present) {
        prevObj = input.enterObject();
    }
    if (present) {
        if (state81.explicit !== null) {
            const explicit = this._decodeTag(input, state81.explicit);
            if (input.isError(explicit)) {
                return explicit;
            }
            input = explicit;
        }
        const start34 = input.offset;
        if (state81.use === null && state81.choice === null) {
            let save;
            if (state81.any) {
                save = input.save();
            }
            const body = this._decodeTag(input, state81.implicit !== null ? state81.implicit : state81.tag, state81.any);
            if (input.isError(body)) {
                return body;
            }
            if (state81.any) {
                result = input.raw(save);
            } else {
                input = body;
            }
        }
        if (options && options.track && state81.tag !== null) {
            options.track(input.path(), start34, input.length, "tagged");
        }
        if (options && options.track && state81.tag !== null) {
            options.track(input.path(), input.offset, input.length, "content");
        }
        if (state81.any) {} else if (state81.choice === null) {
            result = this._decodeGeneric(state81.tag, input, options);
        } else {
            result = this._decodeChoice(input, options);
        }
        if (input.isError(result)) {
            return result;
        }
        if (!state81.any && state81.choice === null && state81.children !== null) {
            state81.children.forEach(function decodeChildren(child) {
                child._decode(input, options);
            });
        }
        if (state81.contains && (state81.tag === "octstr" || state81.tag === "bitstr")) {
            const data46 = new DecoderBuffer(result);
            result = this._getUse(state81.contains, input._reporterState.obj)._decode(data46, options);
        }
    }
    if (state81.obj && present) {
        result = input.leaveObject(prevObj);
    }
    if (state81.key !== null && (result !== null || present === true)) {
        input.leaveKey(prevKey, state81.key, result);
    } else if (prevKey !== null) {
        input.exitKey(prevKey);
    }
    return result;
};
Node.prototype._decodeGeneric = function decodeGeneric(tag11, input, options) {
    const state82 = this._baseState;
    if (tag11 === "seq" || tag11 === "set") {
        return null;
    }
    if (tag11 === "seqof" || tag11 === "setof") {
        return this._decodeList(input, tag11, state82.args[0], options);
    } else if (/str$/.test(tag11)) {
        return this._decodeStr(input, tag11, options);
    } else if (tag11 === "objid" && state82.args) {
        return this._decodeObjid(input, state82.args[0], state82.args[1], options);
    } else if (tag11 === "objid") {
        return this._decodeObjid(input, null, null, options);
    } else if (tag11 === "gentime" || tag11 === "utctime") {
        return this._decodeTime(input, tag11, options);
    } else if (tag11 === "null_") {
        return this._decodeNull(input, options);
    } else if (tag11 === "bool") {
        return this._decodeBool(input, options);
    } else if (tag11 === "objDesc") {
        return this._decodeStr(input, tag11, options);
    } else if (tag11 === "int" || tag11 === "enum") {
        return this._decodeInt(input, state82.args && state82.args[0], options);
    }
    if (state82.use !== null) {
        return this._getUse(state82.use, input._reporterState.obj)._decode(input, options);
    } else {
        return input.error("unknown tag: " + tag11);
    }
};
Node.prototype._getUse = function _getUse(entity, obj) {
    const state83 = this._baseState;
    state83.useDecoder = this._use(entity, obj);
    assert(state83.useDecoder._baseState.parent === null);
    state83.useDecoder = state83.useDecoder._baseState.children[0];
    if (state83.implicit !== state83.useDecoder._baseState.implicit) {
        state83.useDecoder = state83.useDecoder.clone();
        state83.useDecoder._baseState.implicit = state83.implicit;
    }
    return state83.useDecoder;
};
Node.prototype._decodeChoice = function decodeChoice(input, options) {
    const state84 = this._baseState;
    let result = null;
    let match3 = false;
    Object.keys(state84.choice).some(function(key) {
        const save = input.save();
        const node = state84.choice[key];
        try {
            const value = node._decode(input, options);
            if (input.isError(value)) {
                return false;
            }
            result = {
                type: key,
                value: value
            };
            match3 = true;
        } catch (_e) {
            input.restore(save);
            return false;
        }
        return true;
    }, this);
    if (!match3) {
        return input.error("Choice not matched");
    }
    return result;
};
Node.prototype._createEncoderBuffer = function createEncoderBuffer(data47) {
    return new EncoderBuffer(data47, this.reporter);
};
Node.prototype._encode = function encode(data48, reporter, parent) {
    const state85 = this._baseState;
    if (state85["default"] !== null && state85["default"] === data48) {
        return;
    }
    const result = this._encodeValue(data48, reporter, parent);
    if (result === undefined) {
        return;
    }
    if (this._skipDefault(result, reporter, parent)) {
        return;
    }
    return result;
};
Node.prototype._encodeValue = function encode(data49, reporter, parent) {
    const state1 = this._baseState;
    if (state1.parent === null) {
        return state1.children[0]._encode(data49, reporter || new Reporter());
    }
    let result = null;
    this.reporter = reporter;
    if (state1.optional && data49 === undefined) {
        if (state1["default"] !== null) {
            data49 = state1["default"];
        } else {
            return;
        }
    }
    let content = null;
    let primitive = false;
    if (state1.any) {
        result = this._createEncoderBuffer(data49);
    } else if (state1.choice) {
        result = this._encodeChoice(data49, reporter);
    } else if (state1.contains) {
        content = this._getUse(state1.contains, parent)._encode(data49, reporter);
        primitive = true;
    } else if (state1.children) {
        content = state1.children.map(function(child) {
            if (child._baseState.tag === "null_") {
                return child._encode(null, reporter, data49);
            }
            if (child._baseState.key === null) {
                return reporter.error("Child should have a key");
            }
            const prevKey = reporter.enterKey(child._baseState.key);
            if (typeof data49 !== "object") {
                return reporter.error("Child expected, but input is not object");
            }
            const res = child._encode(data49[child._baseState.key], reporter, data49);
            reporter.leaveKey(prevKey);
            return res;
        }, this).filter(function(child) {
            return child;
        });
        content = this._createEncoderBuffer(content);
    } else {
        if (state1.tag === "seqof" || state1.tag === "setof") {
            if (!(state1.args && state1.args.length === 1)) {
                return reporter.error("Too many args for : " + state1.tag);
            }
            if (!Array.isArray(data49)) {
                return reporter.error("seqof/setof, but data is not Array");
            }
            const child = this.clone();
            child._baseState.implicit = null;
            content = this._createEncoderBuffer(data49.map(function(item) {
                const state86 = this._baseState;
                return this._getUse(state86.args[0], data49)._encode(item, reporter);
            }, child));
        } else if (state1.use !== null) {
            result = this._getUse(state1.use, parent)._encode(data49, reporter);
        } else {
            content = this._encodePrimitive(state1.tag, data49);
            primitive = true;
        }
    }
    if (!state1.any && state1.choice === null) {
        const tag12 = state1.implicit !== null ? state1.implicit : state1.tag;
        const cls = state1.implicit === null ? "universal" : "context";
        if (tag12 === null) {
            if (state1.use === null) {
                reporter.error("Tag could be omitted only for .use()");
            }
        } else {
            if (state1.use === null) {
                result = this._encodeComposite(tag12, primitive, cls, content);
            }
        }
    }
    if (state1.explicit !== null) {
        result = this._encodeComposite(state1.explicit, false, "context", result);
    }
    return result;
};
Node.prototype._encodeChoice = function encodeChoice(data50, reporter) {
    const state87 = this._baseState;
    const node = state87.choice[data50.type];
    if (!node) {
        assert(false, data50.type + " not found in " + JSON.stringify(Object.keys(state87.choice)));
    }
    return node._encode(data50.value, reporter);
};
Node.prototype._encodePrimitive = function encodePrimitive(tag13, data51) {
    const state88 = this._baseState;
    if (/str$/.test(tag13)) {
        return this._encodeStr(data51, tag13);
    } else if (tag13 === "objid" && state88.args) {
        return this._encodeObjid(data51, state88.reverseArgs[0], state88.args[1]);
    } else if (tag13 === "objid") {
        return this._encodeObjid(data51, null, null);
    } else if (tag13 === "gentime" || tag13 === "utctime") {
        return this._encodeTime(data51, tag13);
    } else if (tag13 === "null_") {
        return this._encodeNull();
    } else if (tag13 === "int" || tag13 === "enum") {
        return this._encodeInt(data51, state88.args && state88.reverseArgs[0]);
    } else if (tag13 === "bool") {
        return this._encodeBool(data51);
    } else if (tag13 === "objDesc") {
        return this._encodeStr(data51, tag13);
    } else {
        throw new Error("Unsupported tag: " + tag13);
    }
};
Node.prototype._isNumstr = function isNumstr(str) {
    return /^[0-9 ]*$/.test(str);
};
Node.prototype._isPrintstr = function isPrintstr(str) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
};
function reverse(map) {
    const res = {};
    Object.keys(map).forEach(function(key) {
        if ((key | 0) == key) {
            key = key | 0;
        }
        const value = map[key];
        res[value] = key;
    });
    return res;
}
const tagClass = {
    0: "universal",
    1: "application",
    2: "context",
    3: "private"
};
const tagClassByName = reverse(tagClass);
const tag = {
    0: "end",
    1: "bool",
    2: "int",
    3: "bitstr",
    4: "octstr",
    5: "null_",
    6: "objid",
    7: "objDesc",
    8: "external",
    9: "real",
    10: "enum",
    11: "embed",
    12: "utf8str",
    13: "relativeOid",
    16: "seq",
    17: "set",
    18: "numstr",
    19: "printstr",
    20: "t61str",
    21: "videostr",
    22: "ia5str",
    23: "utctime",
    24: "gentime",
    25: "graphstr",
    26: "iso646str",
    27: "genstr",
    28: "unistr",
    29: "charstr",
    30: "bmpstr"
};
const tagByName = reverse(tag);
const mod55 = {
    tagClass: tagClass,
    tagClassByName: tagClassByName,
    tag: tag,
    tagByName: tagByName
};
function DEREncoder(entity) {
    this.enc = "der";
    this.name = entity.name;
    this.entity = entity;
    this.tree = new DERNode();
    this.tree._init(entity.body);
}
DEREncoder.prototype.encode = function encode(data52, reporter) {
    return this.tree._encode(data52, reporter).join();
};
function DERNode(parent) {
    Node.call(this, "der", parent);
}
DERNode.prototype = Object.create(Node.prototype, {
    constructor: {
        value: DERNode,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
DERNode.prototype._encodeComposite = function encodeComposite(tag14, primitive, cls, content) {
    const encodedTag = encodeTag(tag14, primitive, cls, this.reporter);
    if (content.length < 128) {
        const header = Buffer1.alloc(2);
        header[0] = encodedTag;
        header[1] = content.length;
        return this._createEncoderBuffer([
            header,
            content
        ]);
    }
    let lenOctets = 1;
    for(let i203 = content.length; i203 >= 256; i203 >>= 8){
        lenOctets++;
    }
    const header = Buffer1.alloc(1 + 1 + lenOctets);
    header[0] = encodedTag;
    header[1] = 128 | lenOctets;
    for(let i1100 = 1 + lenOctets, j = content.length; j > 0; i1100--, j >>= 8){
        header[i1100] = j & 255;
    }
    return this._createEncoderBuffer([
        header,
        content
    ]);
};
DERNode.prototype._encodeStr = function encodeStr(str, tag15) {
    if (tag15 === "bitstr") {
        return this._createEncoderBuffer([
            str.unused | 0,
            str.data
        ]);
    } else if (tag15 === "bmpstr") {
        const buf = Buffer1.alloc(str.length * 2);
        for(let i204 = 0; i204 < str.length; i204++){
            buf.writeUInt16BE(str.charCodeAt(i204), i204 * 2);
        }
        return this._createEncoderBuffer(buf);
    } else if (tag15 === "numstr") {
        if (!this._isNumstr(str)) {
            return this.reporter.error("Encoding of string type: numstr supports " + "only digits and space");
        }
        return this._createEncoderBuffer(str);
    } else if (tag15 === "printstr") {
        if (!this._isPrintstr(str)) {
            return this.reporter.error("Encoding of string type: printstr supports " + "only latin upper and lower case letters, " + "digits, space, apostrophe, left and rigth " + "parenthesis, plus sign, comma, hyphen, " + "dot, slash, colon, equal sign, " + "question mark");
        }
        return this._createEncoderBuffer(str);
    } else if (/str$/.test(tag15)) {
        return this._createEncoderBuffer(str);
    } else if (tag15 === "objDesc") {
        return this._createEncoderBuffer(str);
    } else {
        return this.reporter.error("Encoding of string type: " + tag15 + " unsupported");
    }
};
DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative9) {
    if (typeof id === "string") {
        if (!values) {
            return this.reporter.error("string objid given, but no values map found");
        }
        if (!values.hasOwnProperty(id)) {
            return this.reporter.error("objid not found in values map");
        }
        id = values[id].split(/[\s.]+/g);
        for(let i205 = 0; i205 < id.length; i205++){
            id[i205] |= 0;
        }
    } else if (Array.isArray(id)) {
        id = id.slice();
        for(let i206 = 0; i206 < id.length; i206++){
            id[i206] |= 0;
        }
    }
    if (!Array.isArray(id)) {
        return this.reporter.error("objid() should be either array or string, " + "got: " + JSON.stringify(id));
    }
    if (!relative9) {
        if (id[1] >= 40) {
            return this.reporter.error("Second objid identifier OOB");
        }
        id.splice(0, 2, id[0] * 40 + id[1]);
    }
    let size = 0;
    for(let i207 = 0; i207 < id.length; i207++){
        let ident = id[i207];
        for(size++; ident >= 128; ident >>= 7){
            size++;
        }
    }
    const objid = Buffer1.alloc(size);
    let offset = objid.length - 1;
    for(let i2 = id.length - 1; i2 >= 0; i2--){
        let ident = id[i2];
        objid[offset--] = ident & 127;
        while((ident >>= 7) > 0){
            objid[offset--] = 128 | ident & 127;
        }
    }
    return this._createEncoderBuffer(objid);
};
function two(num) {
    if (num < 10) {
        return "0" + num;
    } else {
        return num;
    }
}
DERNode.prototype._encodeTime = function encodeTime(time6, tag16) {
    let str;
    const date = new Date(time6);
    if (tag16 === "gentime") {
        str = [
            two(date.getUTCFullYear()),
            two(date.getUTCMonth() + 1),
            two(date.getUTCDate()),
            two(date.getUTCHours()),
            two(date.getUTCMinutes()),
            two(date.getUTCSeconds()),
            "Z", 
        ].join("");
    } else if (tag16 === "utctime") {
        str = [
            two(date.getUTCFullYear() % 100),
            two(date.getUTCMonth() + 1),
            two(date.getUTCDate()),
            two(date.getUTCHours()),
            two(date.getUTCMinutes()),
            two(date.getUTCSeconds()),
            "Z", 
        ].join("");
    } else {
        this.reporter.error("Encoding " + tag16 + " time is not supported yet");
    }
    return this._encodeStr(str, "octstr");
};
DERNode.prototype._encodeNull = function encodeNull() {
    return this._createEncoderBuffer("");
};
DERNode.prototype._encodeInt = function encodeInt(num, values) {
    if (typeof num === "string") {
        if (!values) {
            return this.reporter.error("String int or enum given, but no values map");
        }
        if (!values.hasOwnProperty(num)) {
            return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
        }
        num = values[num];
    }
    if (typeof num !== "number" && !Buffer1.isBuffer(num)) {
        const numArray = num.toArray();
        if (!num.sign && numArray[0] & 128) {
            numArray.unshift(0);
        }
        num = Buffer1.from(numArray);
    }
    if (Buffer1.isBuffer(num)) {
        let size = num.length;
        if (num.length === 0) {
            size++;
        }
        const out = Buffer1.alloc(size);
        num.copy(out);
        if (num.length === 0) {
            out[0] = 0;
        }
        return this._createEncoderBuffer(out);
    }
    if (num < 128) {
        return this._createEncoderBuffer(num);
    }
    if (num < 256) {
        return this._createEncoderBuffer([
            0,
            num
        ]);
    }
    let size = 1;
    for(let i208 = num; i208 >= 256; i208 >>= 8){
        size++;
    }
    const out = new Array(size);
    for(let i3 = out.length - 1; i3 >= 0; i3--){
        out[i3] = num & 255;
        num >>= 8;
    }
    if (out[0] & 128) {
        out.unshift(0);
    }
    return this._createEncoderBuffer(Buffer1.from(out));
};
DERNode.prototype._encodeBool = function encodeBool(value) {
    return this._createEncoderBuffer(value ? 255 : 0);
};
DERNode.prototype._use = function use(entity, obj) {
    if (typeof entity === "function") {
        entity = entity(obj);
    }
    return entity._getEncoder("der").tree;
};
DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
    const state89 = this._baseState;
    let i209;
    if (state89["default"] === null) {
        return false;
    }
    const data53 = dataBuffer.join();
    if (state89.defaultBuffer === undefined) {
        state89.defaultBuffer = this._encodeValue(state89["default"], reporter, parent).join();
    }
    if (data53.length !== state89.defaultBuffer.length) {
        return false;
    }
    for(i209 = 0; i209 < data53.length; i209++){
        if (data53[i209] !== state89.defaultBuffer[i209]) {
            return false;
        }
    }
    return true;
};
function encodeTag(tag17, primitive, cls, reporter) {
    let res;
    if (tag17 === "seqof") {
        tag17 = "seq";
    } else if (tag17 === "setof") {
        tag17 = "set";
    }
    if (tagByName.hasOwnProperty(tag17)) {
        res = tagByName[tag17];
    } else if (typeof tag17 === "number" && (tag17 | 0) === tag17) {
        res = tag17;
    } else {
        return reporter.error("Unknown tag: " + tag17);
    }
    if (res >= 31) {
        return reporter.error("Multi-octet tag encoding unsupported");
    }
    if (!primitive) {
        res |= 32;
    }
    res |= tagClassByName[cls || "universal"] << 6;
    return res;
}
function PEMEncoder(entity) {
    DEREncoder.call(this, entity);
    this.enc = "pem";
}
PEMEncoder.prototype = Object.create(DEREncoder.prototype, {
    constructor: {
        value: PEMEncoder,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
PEMEncoder.prototype.encode = function encode(data54, options) {
    const buf = DEREncoder.prototype.encode.call(this, data54);
    const p28 = buf.toString("base64");
    const out = [
        "-----BEGIN " + options.label + "-----"
    ];
    for(let i210 = 0; i210 < p28.length; i210 += 64){
        out.push(p28.slice(i210, i210 + 64));
    }
    out.push("-----END " + options.label + "-----");
    return out.join("\n");
};
function DERDecoder(entity) {
    this.enc = "der";
    this.name = entity.name;
    this.entity = entity;
    this.tree = new DERNode1();
    this.tree._init(entity.body);
}
DERDecoder.prototype.decode = function decode(data55, options) {
    if (!DecoderBuffer.isDecoderBuffer(data55)) {
        data55 = new DecoderBuffer(data55, options);
    }
    return this.tree._decode(data55, options);
};
function DERNode1(parent) {
    Node.call(this, "der", parent);
}
DERNode1.prototype = Object.create(Node.prototype, {
    constructor: {
        value: DERNode1,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
DERNode1.prototype._peekTag = function peekTag(buffer33, tag18, any) {
    if (buffer33.isEmpty()) {
        return false;
    }
    const state90 = buffer33.save();
    const decodedTag = derDecodeTag(buffer33, 'Failed to peek tag: "' + tag18 + '"');
    if (buffer33.isError(decodedTag)) {
        return decodedTag;
    }
    buffer33.restore(state90);
    return decodedTag.tag === tag18 || decodedTag.tagStr === tag18 || decodedTag.tagStr + "of" === tag18 || any;
};
DERNode1.prototype._decodeTag = function decodeTag(buffer34, tag19, any) {
    const decodedTag = derDecodeTag(buffer34, 'Failed to decode tag of "' + tag19 + '"');
    if (buffer34.isError(decodedTag)) {
        return decodedTag;
    }
    let len = derDecodeLen(buffer34, decodedTag.primitive, 'Failed to get length of "' + tag19 + '"');
    if (buffer34.isError(len)) {
        return len;
    }
    if (!any && decodedTag.tag !== tag19 && decodedTag.tagStr !== tag19 && decodedTag.tagStr + "of" !== tag19) {
        return buffer34.error('Failed to match tag: "' + tag19 + '"');
    }
    if (decodedTag.primitive || len !== null) {
        return buffer34.skip(len, 'Failed to match body of: "' + tag19 + '"');
    }
    const state91 = buffer34.save();
    const res = this._skipUntilEnd(buffer34, 'Failed to skip indefinite length body: "' + this.tag + '"');
    if (buffer34.isError(res)) {
        return res;
    }
    len = buffer34.offset - state91.offset;
    buffer34.restore(state91);
    return buffer34.skip(len, 'Failed to match body of: "' + tag19 + '"');
};
DERNode1.prototype._skipUntilEnd = function skipUntilEnd(buffer35, fail4) {
    for(;;){
        const tag20 = derDecodeTag(buffer35, fail4);
        if (buffer35.isError(tag20)) {
            return tag20;
        }
        const len = derDecodeLen(buffer35, tag20.primitive, fail4);
        if (buffer35.isError(len)) {
            return len;
        }
        let res;
        if (tag20.primitive || len !== null) {
            res = buffer35.skip(len);
        } else {
            res = this._skipUntilEnd(buffer35, fail4);
        }
        if (buffer35.isError(res)) {
            return res;
        }
        if (tag20.tagStr === "end") {
            break;
        }
    }
};
DERNode1.prototype._decodeList = function decodeList(buffer36, _tag, decoder, options) {
    const result = [];
    while(!buffer36.isEmpty()){
        const possibleEnd = this._peekTag(buffer36, "end");
        if (buffer36.isError(possibleEnd)) {
            return possibleEnd;
        }
        const res = decoder.decode(buffer36, "der", options);
        if (buffer36.isError(res) && possibleEnd) {
            break;
        }
        result.push(res);
    }
    return result;
};
DERNode1.prototype._decodeStr = function decodeStr(buffer37, tag21) {
    if (tag21 === "bitstr") {
        const unused = buffer37.readUInt8();
        if (buffer37.isError(unused)) {
            return unused;
        }
        return {
            unused: unused,
            data: buffer37.raw()
        };
    } else if (tag21 === "bmpstr") {
        const raw = buffer37.raw();
        if (raw.length % 2 === 1) {
            return buffer37.error("Decoding of string type: bmpstr length mismatch");
        }
        let str = "";
        for(let i211 = 0; i211 < raw.length / 2; i211++){
            str += String.fromCharCode(raw.readUInt16BE(i211 * 2));
        }
        return str;
    } else if (tag21 === "numstr") {
        const numstr = buffer37.raw().toString("ascii");
        if (!this._isNumstr(numstr)) {
            return buffer37.error("Decoding of string type: " + "numstr unsupported characters");
        }
        return numstr;
    } else if (tag21 === "octstr") {
        return buffer37.raw();
    } else if (tag21 === "objDesc") {
        return buffer37.raw();
    } else if (tag21 === "printstr") {
        const printstr = buffer37.raw().toString("ascii");
        if (!this._isPrintstr(printstr)) {
            return buffer37.error("Decoding of string type: " + "printstr unsupported characters");
        }
        return printstr;
    } else if (/str$/.test(tag21)) {
        return buffer37.raw().toString();
    } else {
        return buffer37.error("Decoding of string type: " + tag21 + " unsupported");
    }
};
DERNode1.prototype._decodeObjid = function decodeObjid(buffer38, values, relative10) {
    let result;
    const identifiers = [];
    let ident = 0;
    let subident = 0;
    while(!buffer38.isEmpty()){
        subident = buffer38.readUInt8();
        ident <<= 7;
        ident |= subident & 127;
        if ((subident & 128) === 0) {
            identifiers.push(ident);
            ident = 0;
        }
    }
    if (subident & 128) {
        identifiers.push(ident);
    }
    const first = identifiers[0] / 40 | 0;
    const second = identifiers[0] % 40;
    if (relative10) {
        result = identifiers;
    } else {
        result = [
            first,
            second
        ].concat(identifiers.slice(1));
    }
    if (values) {
        let tmp = values[result.join(" ")];
        if (tmp === undefined) {
            tmp = values[result.join(".")];
        }
        if (tmp !== undefined) {
            result = tmp;
        }
    }
    return result;
};
DERNode1.prototype._decodeTime = function decodeTime(buffer39, tag22) {
    const str = buffer39.raw().toString();
    let year;
    let mon;
    let day;
    let hour;
    let min25;
    let sec;
    if (tag22 === "gentime") {
        year = str.slice(0, 4) | 0;
        mon = str.slice(4, 6) | 0;
        day = str.slice(6, 8) | 0;
        hour = str.slice(8, 10) | 0;
        min25 = str.slice(10, 12) | 0;
        sec = str.slice(12, 14) | 0;
    } else if (tag22 === "utctime") {
        year = str.slice(0, 2) | 0;
        mon = str.slice(2, 4) | 0;
        day = str.slice(4, 6) | 0;
        hour = str.slice(6, 8) | 0;
        min25 = str.slice(8, 10) | 0;
        sec = str.slice(10, 12) | 0;
        if (year < 70) {
            year = 2000 + year;
        } else {
            year = 1900 + year;
        }
    } else {
        return buffer39.error("Decoding " + tag22 + " time is not supported yet");
    }
    return Date.UTC(year, mon - 1, day, hour, min25, sec, 0);
};
DERNode1.prototype._decodeNull = function decodeNull() {
    return null;
};
DERNode1.prototype._decodeBool = function decodeBool(buffer40) {
    const res = buffer40.readUInt8();
    if (buffer40.isError(res)) {
        return res;
    } else {
        return res !== 0;
    }
};
DERNode1.prototype._decodeInt = function decodeInt(buffer41, values) {
    const raw = buffer41.raw();
    let res = new BN(raw);
    if (values) {
        res = values[res.toString(10)] || res;
    }
    return res;
};
DERNode1.prototype._use = function use(entity, obj) {
    if (typeof entity === "function") {
        entity = entity(obj);
    }
    return entity._getDecoder("der").tree;
};
function derDecodeTag(buf, fail5) {
    let tag23 = buf.readUInt8(fail5);
    if (buf.isError(tag23)) {
        return tag23;
    }
    const cls = tagClass[tag23 >> 6];
    const primitive = (tag23 & 32) === 0;
    if ((tag23 & 31) === 31) {
        let oct = tag23;
        tag23 = 0;
        while((oct & 128) === 128){
            oct = buf.readUInt8(fail5);
            if (buf.isError(oct)) {
                return oct;
            }
            tag23 <<= 7;
            tag23 |= oct & 127;
        }
    } else {
        tag23 &= 31;
    }
    const tagStr = tag[tag23];
    return {
        cls: cls,
        primitive: primitive,
        tag: tag23,
        tagStr: tagStr
    };
}
function derDecodeLen(buf, primitive, fail6) {
    let len = buf.readUInt8(fail6);
    if (buf.isError(len)) {
        return len;
    }
    if (!primitive && len === 128) {
        return null;
    }
    if ((len & 128) === 0) {
        return len;
    }
    const num = len & 127;
    if (num > 4) {
        return buf.error("length octect is too long");
    }
    len = 0;
    for(let i212 = 0; i212 < num; i212++){
        len <<= 8;
        const j = buf.readUInt8(fail6);
        if (buf.isError(j)) {
            return j;
        }
        len |= j;
    }
    return len;
}
function PEMDecoder(entity) {
    DERDecoder.call(this, entity);
    this.enc = "pem";
}
PEMDecoder.prototype = Object.create(DERDecoder.prototype, {
    constructor: {
        value: PEMDecoder,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
PEMDecoder.prototype.decode = function decode(data56, options) {
    const lines = data56.toString().split(/[\r\n]+/g);
    const label = options.label.toUpperCase();
    const re = /^-----(BEGIN|END) ([^-]+)-----$/;
    let start35 = -1;
    let end = -1;
    for(let i213 = 0; i213 < lines.length; i213++){
        const match4 = lines[i213].match(re);
        if (match4 === null) {
            continue;
        }
        if (match4[2] !== label) {
            continue;
        }
        if (start35 === -1) {
            if (match4[1] !== "BEGIN") {
                break;
            }
            start35 = i213;
        } else {
            if (match4[1] !== "END") {
                break;
            }
            end = i213;
            break;
        }
    }
    if (start35 === -1 || end === -1) {
        throw new Error("PEM section not found for: " + label);
    }
    const base64 = lines.slice(start35 + 1, end).join("");
    base64.replace(/[^a-z0-9+/=]+/gi, "");
    const input = Buffer1.from(base64, "base64");
    return DERDecoder.prototype.decode.call(this, input, options);
};
const base1 = {
    DecoderBuffer,
    EncoderBuffer,
    Node,
    Reporter
};
const encoders = {
    der: DEREncoder,
    pem: PEMEncoder
};
const decoders = {
    der: DERDecoder,
    pem: PEMDecoder
};
const constants6 = {
    der: mod55
};
function define(name66, body) {
    return new Entity(name66, body);
}
function Entity(name67, body) {
    this.name = name67;
    this.body = body;
    this.decoders = {};
    this.encoders = {};
}
Entity.prototype._createNamed = function createNamed(Base) {
    const name1 = this.name;
    function Generated(entity) {
        this._initNamed(entity, name1);
    }
    Generated.prototype = Object.create(Base.prototype, {
        constructor: {
            value: Generated,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    Generated.prototype._initNamed = function _initNamed(entity, name68) {
        Base.call(this, entity, name68);
    };
    return new Generated(this);
};
Entity.prototype._getDecoder = function _getDecoder(enc) {
    enc = enc || "der";
    if (!this.decoders.hasOwnProperty(enc)) {
        this.decoders[enc] = this._createNamed(decoders[enc]);
    }
    return this.decoders[enc];
};
Entity.prototype.decode = function decode(data57, enc, options) {
    return this._getDecoder(enc).decode(data57, options);
};
Entity.prototype._getEncoder = function _getEncoder(enc) {
    enc = enc || "der";
    if (!this.encoders.hasOwnProperty(enc)) {
        this.encoders[enc] = this._createNamed(encoders[enc]);
    }
    return this.encoders[enc];
};
Entity.prototype.encode = function encode(data58, enc, reporter) {
    return this._getEncoder(enc).encode(data58, reporter);
};
const __default34 = {
    base: base1,
    bignum: BN,
    constants: constants6,
    decoders,
    define,
    encoders
};
const Time = define("Time", function() {
    this.choice({
        utcTime: this.utctime(),
        generalTime: this.gentime()
    });
});
const AttributeTypeValue = define("AttributeTypeValue", function() {
    this.seq().obj(this.key("type").objid(), this.key("value").any());
});
const AlgorithmIdentifier = define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
});
const SubjectPublicKeyInfo = define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
});
const RelativeDistinguishedName = define("RelativeDistinguishedName", function() {
    this.setof(AttributeTypeValue);
});
const RDNSequence = define("RDNSequence", function() {
    this.seqof(RelativeDistinguishedName);
});
const Name = define("Name", function() {
    this.choice({
        rdnSequence: this.use(RDNSequence)
    });
});
const Validity = define("Validity", function() {
    this.seq().obj(this.key("notBefore").use(Time), this.key("notAfter").use(Time));
});
const Extension = define("Extension", function() {
    this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
});
const TBSCertificate = define("TBSCertificate", function() {
    this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(AlgorithmIdentifier), this.key("issuer").use(Name), this.key("validity").use(Validity), this.key("subject").use(Name), this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(Extension).optional());
});
const X509Certificate = define("X509Certificate", function() {
    this.seq().obj(this.key("tbsCertificate").use(TBSCertificate), this.key("signatureAlgorithm").use(AlgorithmIdentifier), this.key("signatureValue").bitstr());
});
const RSAPrivateKey = __default34.define("RSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
});
const RSAPublicKey = __default34.define("RSAPublicKey", function() {
    this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
});
const PublicKey = __default34.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier1), this.key("subjectPublicKey").bitstr());
});
const AlgorithmIdentifier1 = __default34.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
});
const PrivateKey = __default34.define("PrivateKeyInfo", function() {
    this.seq().obj(this.key("version").int(), this.key("algorithm").use(AlgorithmIdentifier1), this.key("subjectPrivateKey").octstr());
});
const EncryptedPrivateKey = __default34.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
});
const DSAPrivateKey = __default34.define("DSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
});
const DSAparam = __default34.define("DSAparam", function() {
    this.int();
});
const ECPrivateKey = __default34.define("ECPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(ECParameters), this.key("publicKey").optional().explicit(1).bitstr());
});
const ECParameters = __default34.define("ECParameters", function() {
    this.choice({
        namedCurve: this.objid()
    });
});
const signature = __default34.define("signature", function() {
    this.seq().obj(this.key("r").int(), this.key("s").int());
});
function EVP_BytesToKey(password, salt, keyBits, ivLen) {
    if (!Buffer1.isBuffer(password)) password = Buffer1.from(password, "binary");
    if (salt) {
        if (!Buffer1.isBuffer(salt)) salt = Buffer1.from(salt, "binary");
        if (salt.length !== 8) {
            throw new RangeError("salt should be Buffer with 8 byte length");
        }
    }
    let keyLen = keyBits / 8;
    const key = Buffer1.alloc(keyLen);
    const iv = Buffer1.alloc(ivLen || 0);
    let tmp = Buffer1.alloc(0);
    while(keyLen > 0 || ivLen > 0){
        const hash = createHash("md5");
        hash.update(tmp);
        hash.update(password);
        if (salt) hash.update(salt);
        tmp = hash.digest();
        let used = 0;
        if (keyLen > 0) {
            const keyStart = key.length - keyLen;
            used = Math.min(keyLen, tmp.length);
            tmp.copy(key, keyStart, 0, used);
            keyLen -= used;
        }
        if (used < tmp.length && ivLen > 0) {
            const ivStart = iv.length - ivLen;
            const length = Math.min(ivLen, tmp.length - used);
            tmp.copy(iv, ivStart, used, used + length);
            ivLen -= length;
        }
    }
    tmp.fill(0);
    return {
        key,
        iv
    };
}
const encrypt = function(self, block) {
    return self._cipher.encryptBlock(block);
};
const decrypt = function(self, block) {
    return self._cipher.decryptBlock(block);
};
const mod56 = {
    encrypt: encrypt,
    decrypt: decrypt
};
function xor(a47, b44) {
    const length = Math.min(a47.length, b44.length);
    const buffer42 = Buffer1.allocUnsafe(length);
    for(let i214 = 0; i214 < length; ++i214){
        buffer42[i214] = a47[i214] ^ b44[i214];
    }
    return buffer42;
}
const encrypt1 = function(self, block) {
    const data59 = xor(block, self._prev);
    self._prev = self._cipher.encryptBlock(data59);
    return self._prev;
};
const decrypt1 = function(self, block) {
    const pad2 = self._prev;
    self._prev = block;
    const out = self._cipher.decryptBlock(block);
    return xor(out, pad2);
};
const mod57 = {
    encrypt: encrypt1,
    decrypt: decrypt1
};
function encryptStart(self, data60, decrypt3) {
    const len = data60.length;
    const out = xor(data60, self._cache);
    self._cache = self._cache.slice(len);
    self._prev = Buffer1.concat([
        self._prev,
        decrypt3 ? data60 : out
    ]);
    return out;
}
const encrypt2 = function(self, data61, decrypt4) {
    let out = Buffer1.allocUnsafe(0);
    let len;
    while(data61.length){
        if (self._cache.length === 0) {
            self._cache = self._cipher.encryptBlock(self._prev);
            self._prev = Buffer1.allocUnsafe(0);
        }
        if (self._cache.length <= data61.length) {
            len = self._cache.length;
            out = Buffer1.concat([
                out,
                encryptStart(self, data61.slice(0, len), decrypt4), 
            ]);
            data61 = data61.slice(len);
        } else {
            out = Buffer1.concat([
                out,
                encryptStart(self, data61, decrypt4)
            ]);
            break;
        }
    }
    return out;
};
const mod58 = {
    encrypt: encrypt2
};
function encryptByte(self, byteParam, decrypt5) {
    const pad3 = self._cipher.encryptBlock(self._prev);
    const out = pad3[0] ^ byteParam;
    self._prev = Buffer1.concat([
        self._prev.slice(1),
        Buffer1.from([
            decrypt5 ? byteParam : out
        ]), 
    ]);
    return out;
}
const encrypt3 = function(self, chunk, decrypt6) {
    const len = chunk.length;
    const out = Buffer1.allocUnsafe(len);
    let i215 = -1;
    while(++i215 < len){
        out[i215] = encryptByte(self, chunk[i215], decrypt6);
    }
    return out;
};
const mod59 = {
    encrypt: encrypt3
};
function encryptByte1(self, byteParam, decrypt7) {
    let pad4;
    let i216 = -1;
    let out = 0;
    let bit, value;
    while(++i216 < 8){
        pad4 = self._cipher.encryptBlock(self._prev);
        bit = byteParam & 1 << 7 - i216 ? 128 : 0;
        value = pad4[0] ^ bit;
        out += (value & 128) >> i216 % 8;
        self._prev = shiftIn(self._prev, decrypt7 ? bit : value);
    }
    return out;
}
function shiftIn(buffer43, value) {
    const len = buffer43.length;
    let i217 = -1;
    const out = Buffer1.allocUnsafe(buffer43.length);
    buffer43 = Buffer1.concat([
        buffer43,
        Buffer1.from([
            value
        ])
    ]);
    while(++i217 < len){
        out[i217] = buffer43[i217] << 1 | buffer43[i217 + 1] >> 7;
    }
    return out;
}
const encrypt4 = function(self, chunk, decrypt8) {
    const len = chunk.length;
    const out = Buffer1.allocUnsafe(len);
    let i218 = -1;
    while(++i218 < len){
        out[i218] = encryptByte1(self, chunk[i218], decrypt8);
    }
    return out;
};
const mod60 = {
    encrypt: encrypt4
};
function getBlock(self) {
    self._prev = self._cipher.encryptBlock(self._prev);
    return self._prev;
}
const encrypt5 = function(self, chunk) {
    while(self._cache.length < chunk.length){
        self._cache = Buffer1.concat([
            self._cache,
            getBlock(self)
        ]);
    }
    const pad5 = self._cache.slice(0, chunk.length);
    self._cache = self._cache.slice(chunk.length);
    return xor(chunk, pad5);
};
const mod61 = {
    encrypt: encrypt5
};
function incr32(iv) {
    let len = iv.length;
    let item;
    while(len--){
        item = iv.readUInt8(len);
        if (item === 255) {
            iv.writeUInt8(0, len);
        } else {
            item++;
            iv.writeUInt8(item, len);
            break;
        }
    }
}
function getBlock1(self) {
    const out = self._cipher.encryptBlockRaw(self._prev);
    incr32(self._prev);
    return out;
}
const blockSize = 16;
const encrypt6 = function(self, chunk) {
    const chunkNum = Math.ceil(chunk.length / 16);
    const start36 = self._cache.length;
    self._cache = Buffer1.concat([
        self._cache,
        Buffer1.allocUnsafe(chunkNum * blockSize), 
    ]);
    for(let i219 = 0; i219 < chunkNum; i219++){
        const out = getBlock1(self);
        const offset = start36 + i219 * 16;
        self._cache.writeUInt32BE(out[0], offset + 0);
        self._cache.writeUInt32BE(out[1], offset + 4);
        self._cache.writeUInt32BE(out[2], offset + 8);
        self._cache.writeUInt32BE(out[3], offset + 12);
    }
    const pad6 = self._cache.slice(0, chunk.length);
    self._cache = self._cache.slice(chunk.length);
    return xor(chunk, pad6);
};
const mod62 = {
    encrypt: encrypt6
};
const modeModules = {
    ECB: mod56,
    CBC: mod57,
    CFB: mod58,
    CFB8: mod59,
    CFB1: mod60,
    OFB: mod61,
    CTR: mod62,
    GCM: mod62
};
const MODES = {
    "aes-128-ecb": {
        "cipher": "AES",
        "key": 128,
        "iv": 0,
        "mode": "ECB",
        "type": "block"
    },
    "aes-192-ecb": {
        "cipher": "AES",
        "key": 192,
        "iv": 0,
        "mode": "ECB",
        "type": "block"
    },
    "aes-256-ecb": {
        "cipher": "AES",
        "key": 256,
        "iv": 0,
        "mode": "ECB",
        "type": "block"
    },
    "aes-128-cbc": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes-192-cbc": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes-256-cbc": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes128": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes192": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes256": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes-128-cfb": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CFB",
        "type": "stream"
    },
    "aes-192-cfb": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CFB",
        "type": "stream"
    },
    "aes-256-cfb": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CFB",
        "type": "stream"
    },
    "aes-128-cfb8": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CFB8",
        "type": "stream"
    },
    "aes-192-cfb8": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CFB8",
        "type": "stream"
    },
    "aes-256-cfb8": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CFB8",
        "type": "stream"
    },
    "aes-128-cfb1": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CFB1",
        "type": "stream"
    },
    "aes-192-cfb1": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CFB1",
        "type": "stream"
    },
    "aes-256-cfb1": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CFB1",
        "type": "stream"
    },
    "aes-128-ofb": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "OFB",
        "type": "stream"
    },
    "aes-192-ofb": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "OFB",
        "type": "stream"
    },
    "aes-256-ofb": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "OFB",
        "type": "stream"
    },
    "aes-128-ctr": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CTR",
        "type": "stream"
    },
    "aes-192-ctr": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CTR",
        "type": "stream"
    },
    "aes-256-ctr": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CTR",
        "type": "stream"
    },
    "aes-128-gcm": {
        "cipher": "AES",
        "key": 128,
        "iv": 12,
        "mode": "GCM",
        "type": "auth"
    },
    "aes-192-gcm": {
        "cipher": "AES",
        "key": 192,
        "iv": 12,
        "mode": "GCM",
        "type": "auth"
    },
    "aes-256-gcm": {
        "cipher": "AES",
        "key": 256,
        "iv": 12,
        "mode": "GCM",
        "type": "auth"
    }
};
for (const mode of Object.values(MODES)){
    mode.module = modeModules[mode.mode];
}
function asUInt32Array(buf) {
    if (!Buffer1.isBuffer(buf)) buf = Buffer1.from(buf);
    var len = buf.length / 4 | 0;
    var out = new Array(len);
    for(var i220 = 0; i220 < len; i220++){
        out[i220] = buf.readUInt32BE(i220 * 4);
    }
    return out;
}
function scrubVec(v17) {
    for(var i221 = 0; i221 < v17.length; v17++){
        v17[i221] = 0;
    }
}
function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
    var SUB_MIX0 = SUB_MIX[0];
    var SUB_MIX1 = SUB_MIX[1];
    var SUB_MIX2 = SUB_MIX[2];
    var SUB_MIX3 = SUB_MIX[3];
    var s0 = M[0] ^ keySchedule[0];
    var s1 = M[1] ^ keySchedule[1];
    var s2 = M[2] ^ keySchedule[2];
    var s3 = M[3] ^ keySchedule[3];
    var t0, t1, t2, t3;
    var ksRow = 4;
    for(var round = 1; round < nRounds; round++){
        t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 255] ^ SUB_MIX2[s2 >>> 8 & 255] ^ SUB_MIX3[s3 & 255] ^ keySchedule[ksRow++];
        t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 255] ^ SUB_MIX2[s3 >>> 8 & 255] ^ SUB_MIX3[s0 & 255] ^ keySchedule[ksRow++];
        t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 255] ^ SUB_MIX2[s0 >>> 8 & 255] ^ SUB_MIX3[s1 & 255] ^ keySchedule[ksRow++];
        t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 255] ^ SUB_MIX2[s1 >>> 8 & 255] ^ SUB_MIX3[s2 & 255] ^ keySchedule[ksRow++];
        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;
    }
    t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++];
    t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++];
    t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++];
    t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++];
    t0 = t0 >>> 0;
    t1 = t1 >>> 0;
    t2 = t2 >>> 0;
    t3 = t3 >>> 0;
    return [
        t0,
        t1,
        t2,
        t3
    ];
}
var RCON = [
    0,
    1,
    2,
    4,
    8,
    16,
    32,
    64,
    128,
    27,
    54
];
var G = function() {
    var d8 = new Array(256);
    for(var j = 0; j < 256; j++){
        if (j < 128) {
            d8[j] = j << 1;
        } else {
            d8[j] = j << 1 ^ 283;
        }
    }
    var SBOX = [];
    var INV_SBOX = [];
    var SUB_MIX = [
        [],
        [],
        [],
        []
    ];
    var INV_SUB_MIX = [
        [],
        [],
        [],
        []
    ];
    var x35 = 0;
    var xi = 0;
    for(var i222 = 0; i222 < 256; ++i222){
        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 255 ^ 99;
        SBOX[x35] = sx;
        INV_SBOX[sx] = x35;
        var x2 = d8[x35];
        var x4 = d8[x2];
        var x8 = d8[x4];
        var t14 = d8[sx] * 257 ^ sx * 16843008;
        SUB_MIX[0][x35] = t14 << 24 | t14 >>> 8;
        SUB_MIX[1][x35] = t14 << 16 | t14 >>> 16;
        SUB_MIX[2][x35] = t14 << 8 | t14 >>> 24;
        SUB_MIX[3][x35] = t14;
        t14 = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x35 * 16843008;
        INV_SUB_MIX[0][sx] = t14 << 24 | t14 >>> 8;
        INV_SUB_MIX[1][sx] = t14 << 16 | t14 >>> 16;
        INV_SUB_MIX[2][sx] = t14 << 8 | t14 >>> 24;
        INV_SUB_MIX[3][sx] = t14;
        if (x35 === 0) {
            x35 = xi = 1;
        } else {
            x35 = x2 ^ d8[d8[d8[x8 ^ x2]]];
            xi ^= d8[d8[xi]];
        }
    }
    return {
        SBOX: SBOX,
        INV_SBOX: INV_SBOX,
        SUB_MIX: SUB_MIX,
        INV_SUB_MIX: INV_SUB_MIX
    };
}();
function AES(key) {
    this._key = asUInt32Array(key);
    this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
    var keyWords = this._key;
    var keySize = keyWords.length;
    var nRounds = keySize + 6;
    var ksRows = (nRounds + 1) * 4;
    var keySchedule = [];
    for(var k17 = 0; k17 < keySize; k17++){
        keySchedule[k17] = keyWords[k17];
    }
    for(k17 = keySize; k17 < ksRows; k17++){
        var t15 = keySchedule[k17 - 1];
        if (k17 % keySize === 0) {
            t15 = t15 << 8 | t15 >>> 24;
            t15 = G.SBOX[t15 >>> 24] << 24 | G.SBOX[t15 >>> 16 & 255] << 16 | G.SBOX[t15 >>> 8 & 255] << 8 | G.SBOX[t15 & 255];
            t15 ^= RCON[k17 / keySize | 0] << 24;
        } else if (keySize > 6 && k17 % keySize === 4) {
            t15 = G.SBOX[t15 >>> 24] << 24 | G.SBOX[t15 >>> 16 & 255] << 16 | G.SBOX[t15 >>> 8 & 255] << 8 | G.SBOX[t15 & 255];
        }
        keySchedule[k17] = keySchedule[k17 - keySize] ^ t15;
    }
    var invKeySchedule = [];
    for(var ik = 0; ik < ksRows; ik++){
        var ksR = ksRows - ik;
        var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];
        if (ik < 4 || ksR <= 4) {
            invKeySchedule[ik] = tt;
        } else {
            invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 255]];
        }
    }
    this._nRounds = nRounds;
    this._keySchedule = keySchedule;
    this._invKeySchedule = invKeySchedule;
};
AES.prototype.encryptBlockRaw = function(M) {
    M = asUInt32Array(M);
    return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(M) {
    var out = this.encryptBlockRaw(M);
    var buf = Buffer1.allocUnsafe(16);
    buf.writeUInt32BE(out[0], 0);
    buf.writeUInt32BE(out[1], 4);
    buf.writeUInt32BE(out[2], 8);
    buf.writeUInt32BE(out[3], 12);
    return buf;
};
AES.prototype.decryptBlock = function(M) {
    M = asUInt32Array(M);
    var m1 = M[1];
    M[1] = M[3];
    M[3] = m1;
    var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
    var buf = Buffer1.allocUnsafe(16);
    buf.writeUInt32BE(out[0], 0);
    buf.writeUInt32BE(out[3], 4);
    buf.writeUInt32BE(out[2], 8);
    buf.writeUInt32BE(out[1], 12);
    return buf;
};
AES.prototype.scrub = function() {
    scrubVec(this._keySchedule);
    scrubVec(this._invKeySchedule);
    scrubVec(this._key);
};
function CipherBase(hashMode) {
    Transform.call(this);
    this.hashMode = typeof hashMode === "string";
    if (this.hashMode) {
        this[hashMode] = this._finalOrDigest;
    } else {
        this.final = this._finalOrDigest;
    }
    if (this._final) {
        this.__final = this._final;
        this._final = null;
    }
    this._decoder = null;
    this._encoding = null;
}
CipherBase.prototype = Object.create(Transform.prototype, {
    constructor: {
        value: CipherBase,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
CipherBase.prototype.update = function(data62, inputEnc, outputEnc) {
    if (typeof data62 === "string") {
        data62 = Buffer1.from(data62, inputEnc);
    }
    var outData = this._update(data62);
    if (this.hashMode) return this;
    if (outputEnc) {
        outData = this._toString(outData, outputEnc);
    }
    return outData;
};
CipherBase.prototype.setAutoPadding = function() {};
CipherBase.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
};
CipherBase.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
};
CipherBase.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
};
CipherBase.prototype._transform = function(data63, _, next) {
    var err162;
    try {
        if (this.hashMode) {
            this._update(data63);
        } else {
            this.push(this._update(data63));
        }
    } catch (e46) {
        err162 = e46;
    } finally{
        next(err162);
    }
};
CipherBase.prototype._flush = function(done) {
    var err163;
    try {
        this.push(this.__final());
    } catch (e47) {
        err163 = e47;
    }
    done(err163);
};
CipherBase.prototype._finalOrDigest = function(outputEnc) {
    var outData = this.__final() || Buffer1.alloc(0);
    if (outputEnc) {
        outData = this._toString(outData, outputEnc, true);
    }
    return outData;
};
CipherBase.prototype._toString = function(value, enc, fin) {
    if (!this._decoder) {
        this._decoder = new StringDecoder(enc);
        this._encoding = enc;
    }
    if (this._encoding !== enc) throw new Error("can't switch encodings");
    var out = this._decoder.write(value);
    if (fin) {
        out += this._decoder.end();
    }
    return out;
};
var ZEROES = Buffer1.alloc(16, 0);
function toArray(buf) {
    return [
        buf.readUInt32BE(0),
        buf.readUInt32BE(4),
        buf.readUInt32BE(8),
        buf.readUInt32BE(12), 
    ];
}
function fromArray(out) {
    var buf = Buffer1.allocUnsafe(16);
    buf.writeUInt32BE(out[0] >>> 0, 0);
    buf.writeUInt32BE(out[1] >>> 0, 4);
    buf.writeUInt32BE(out[2] >>> 0, 8);
    buf.writeUInt32BE(out[3] >>> 0, 12);
    return buf;
}
function GHASH(key) {
    this.h = key;
    this.state = Buffer1.alloc(16, 0);
    this.cache = Buffer1.allocUnsafe(0);
}
GHASH.prototype.ghash = function(block) {
    var i223 = -1;
    while(++i223 < block.length){
        this.state[i223] ^= block[i223];
    }
    this._multiply();
};
GHASH.prototype._multiply = function() {
    var Vi = toArray(this.h);
    var Zi = [
        0,
        0,
        0,
        0
    ];
    var j, xi, lsbVi;
    var i224 = -1;
    while(++i224 < 128){
        xi = (this.state[~~(i224 / 8)] & 1 << 7 - i224 % 8) !== 0;
        if (xi) {
            Zi[0] ^= Vi[0];
            Zi[1] ^= Vi[1];
            Zi[2] ^= Vi[2];
            Zi[3] ^= Vi[3];
        }
        lsbVi = (Vi[3] & 1) !== 0;
        for(j = 3; j > 0; j--){
            Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
        }
        Vi[0] = Vi[0] >>> 1;
        if (lsbVi) {
            Vi[0] = Vi[0] ^ 225 << 24;
        }
    }
    this.state = fromArray(Zi);
};
GHASH.prototype.update = function(buf) {
    this.cache = Buffer1.concat([
        this.cache,
        buf
    ]);
    var chunk;
    while(this.cache.length >= 16){
        chunk = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        this.ghash(chunk);
    }
};
GHASH.prototype.final = function(abl, bl) {
    if (this.cache.length) {
        this.ghash(Buffer1.concat([
            this.cache,
            ZEROES
        ], 16));
    }
    this.ghash(fromArray([
        0,
        abl,
        0,
        bl
    ]));
    return this.state;
};
function xorTest(a48, b45) {
    var out = 0;
    if (a48.length !== b45.length) out++;
    var len = Math.min(a48.length, b45.length);
    for(var i225 = 0; i225 < len; ++i225){
        out += a48[i225] ^ b45[i225];
    }
    return out;
}
function calcIv(self, iv, ck) {
    if (iv.length === 12) {
        self._finID = Buffer1.concat([
            iv,
            Buffer1.from([
                0,
                0,
                0,
                1
            ])
        ]);
        return Buffer1.concat([
            iv,
            Buffer1.from([
                0,
                0,
                0,
                2
            ])
        ]);
    }
    var ghash = new GHASH(ck);
    var len = iv.length;
    var toPad = len % 16;
    ghash.update(iv);
    if (toPad) {
        toPad = 16 - toPad;
        ghash.update(Buffer1.alloc(toPad, 0));
    }
    ghash.update(Buffer1.alloc(8, 0));
    var ivBits = len * 8;
    var tail = Buffer1.alloc(8);
    tail.writeUIntBE(ivBits, 2, 6);
    ghash.update(tail);
    self._finID = ghash.state;
    var out = Buffer1.from(self._finID);
    incr32(out);
    return out;
}
function StreamCipher(mode21, key, iv, decrypt9) {
    CipherBase.call(this);
    var h4 = Buffer1.alloc(4, 0);
    this._cipher = new AES(key);
    var ck = this._cipher.encryptBlock(h4);
    this._ghash = new GHASH(ck);
    iv = calcIv(this, iv, ck);
    this._prev = Buffer1.from(iv);
    this._cache = Buffer1.allocUnsafe(0);
    this._secCache = Buffer1.allocUnsafe(0);
    this._decrypt = decrypt9;
    this._alen = 0;
    this._len = 0;
    this._mode = mode21;
    this._authTag = null;
    this._called = false;
}
StreamCipher.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: StreamCipher,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
StreamCipher.prototype._update = function(chunk) {
    if (!this._called && this._alen) {
        var rump = 16 - this._alen % 16;
        if (rump < 16) {
            rump = Buffer1.alloc(rump, 0);
            this._ghash.update(rump);
        }
    }
    this._called = true;
    var out = this._mode.encrypt(this, chunk);
    if (this._decrypt) {
        this._ghash.update(chunk);
    } else {
        this._ghash.update(out);
    }
    this._len += chunk.length;
    return out;
};
StreamCipher.prototype._final = function() {
    if (this._decrypt && !this._authTag) {
        throw new Error("Unsupported state or unable to authenticate data");
    }
    var tag24 = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && xorTest(tag24, this._authTag)) {
        throw new Error("Unsupported state or unable to authenticate data");
    }
    this._authTag = tag24;
    this._cipher.scrub();
};
StreamCipher.prototype.getAuthTag = function getAuthTag() {
    if (this._decrypt || !Buffer1.isBuffer(this._authTag)) {
        throw new Error("Attempting to get auth tag in unsupported state");
    }
    return this._authTag;
};
StreamCipher.prototype.setAuthTag = function setAuthTag(tag25) {
    if (!this._decrypt) {
        throw new Error("Attempting to set auth tag in unsupported state");
    }
    this._authTag = tag25;
};
StreamCipher.prototype.setAAD = function setAAD(buf) {
    if (this._called) {
        throw new Error("Attempting to set AAD in unsupported state");
    }
    this._ghash.update(buf);
    this._alen += buf.length;
};
function StreamCipher1(mode22, key, iv, decrypt10) {
    CipherBase.call(this);
    this._cipher = new AES(key);
    this._prev = Buffer1.from(iv);
    this._cache = Buffer1.allocUnsafe(0);
    this._secCache = Buffer1.allocUnsafe(0);
    this._decrypt = decrypt10;
    this._mode = mode22;
}
StreamCipher1.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: StreamCipher1,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
StreamCipher1.prototype._update = function(chunk) {
    return this._mode.encrypt(this, chunk, this._decrypt);
};
StreamCipher1.prototype._final = function() {
    this._cipher.scrub();
};
function Cipher(mode23, key, iv) {
    CipherBase.call(this);
    this._cache = new Splitter();
    this._cipher = new AES(key);
    this._prev = Buffer1.from(iv);
    this._mode = mode23;
    this._autopadding = true;
}
Cipher.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: Cipher,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
Cipher.prototype._update = function(data64) {
    this._cache.add(data64);
    var chunk;
    var thing;
    var out = [];
    while(chunk = this._cache.get()){
        thing = this._mode.encrypt(this, chunk);
        out.push(thing);
    }
    return Buffer1.concat(out);
};
var PADDING = Buffer1.alloc(16, 16);
Cipher.prototype._final = function() {
    var chunk = this._cache.flush();
    if (this._autopadding) {
        chunk = this._mode.encrypt(this, chunk);
        this._cipher.scrub();
        return chunk;
    }
    if (!chunk.equals(PADDING)) {
        this._cipher.scrub();
        throw new Error("data not multiple of block length");
    }
};
Cipher.prototype.setAutoPadding = function(setTo) {
    this._autopadding = !!setTo;
    return this;
};
function Splitter() {
    this.cache = Buffer1.allocUnsafe(0);
}
Splitter.prototype.add = function(data65) {
    this.cache = Buffer1.concat([
        this.cache,
        data65
    ]);
};
Splitter.prototype.get = function() {
    if (this.cache.length > 15) {
        const out = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        return out;
    }
    return null;
};
Splitter.prototype.flush = function() {
    var len = 16 - this.cache.length;
    var padBuff = Buffer1.allocUnsafe(len);
    var i226 = -1;
    while(++i226 < len){
        padBuff.writeUInt8(len, i226);
    }
    return Buffer1.concat([
        this.cache,
        padBuff
    ]);
};
function Decipher(mode24, key, iv) {
    CipherBase.call(this);
    this._cache = new Splitter1();
    this._last = void 0;
    this._cipher = new AES(key);
    this._prev = Buffer1.from(iv);
    this._mode = mode24;
    this._autopadding = true;
}
Decipher.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: Decipher,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
Decipher.prototype._update = function(data66) {
    this._cache.add(data66);
    var chunk;
    var thing;
    var out = [];
    while(chunk = this._cache.get(this._autopadding)){
        thing = this._mode.decrypt(this, chunk);
        out.push(thing);
    }
    return Buffer1.concat(out);
};
Decipher.prototype._final = function() {
    var chunk = this._cache.flush();
    if (this._autopadding) {
        return unpad(this._mode.decrypt(this, chunk));
    } else if (chunk) {
        throw new Error("data not multiple of block length");
    }
};
Decipher.prototype.setAutoPadding = function(setTo) {
    this._autopadding = !!setTo;
    return this;
};
function Splitter1() {
    this.cache = Buffer1.allocUnsafe(0);
}
Splitter1.prototype.add = function(data67) {
    this.cache = Buffer1.concat([
        this.cache,
        data67
    ]);
};
Splitter1.prototype.get = function(autoPadding) {
    var out;
    if (autoPadding) {
        if (this.cache.length > 16) {
            out = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            return out;
        }
    } else {
        if (this.cache.length >= 16) {
            out = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            return out;
        }
    }
    return null;
};
Splitter1.prototype.flush = function() {
    if (this.cache.length) return this.cache;
};
function unpad(last) {
    var padded = last[15];
    if (padded < 1 || padded > 16) {
        throw new Error("unable to decrypt data");
    }
    var i227 = -1;
    while(++i227 < padded){
        if (last[i227 + (16 - padded)] !== padded) {
            throw new Error("unable to decrypt data");
        }
    }
    if (padded === 16) return;
    return last.slice(0, 16 - padded);
}
function createDecipheriv(suite, password, iv) {
    var config = MODES[suite.toLowerCase()];
    if (!config) throw new TypeError("invalid suite type");
    if (typeof iv === "string") iv = Buffer1.from(iv);
    if (config.mode !== "GCM" && iv.length !== config.iv) {
        throw new TypeError("invalid iv length " + iv.length);
    }
    if (typeof password === "string") password = Buffer1.from(password);
    if (password.length !== config.key / 8) {
        throw new TypeError("invalid key length " + password.length);
    }
    if (config.type === "stream") {
        return new StreamCipher1(config.module, password, iv, true);
    } else if (config.type === "auth") {
        return new StreamCipher(config.module, password, iv, true);
    }
    return new Decipher(config.module, password, iv);
}
const findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
const startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
const fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
function __default35(okey, password) {
    const key = okey.toString();
    const match5 = key.match(findProc);
    let decrypted;
    if (!match5) {
        const match2 = key.match(fullRegex);
        decrypted = Buffer1.from(match2[2].replace(/[\r\n]/g, ""), "base64");
    } else {
        const suite = "aes" + match5[1];
        const iv = Buffer1.from(match5[2], "hex");
        const cipherText = Buffer1.from(match5[3].replace(/[\r\n]/g, ""), "base64");
        const cipherKey = EVP_BytesToKey(password, iv.slice(0, 8), parseInt(match5[1], 10)).key;
        const out = [];
        const cipher = createDecipheriv(suite, cipherKey, iv);
        out.push(cipher.update(cipherText));
        out.push(cipher.final());
        decrypted = Buffer1.concat(out);
    }
    const tag26 = key.match(startRegex)[1];
    return {
        tag: tag26,
        data: decrypted
    };
}
const aesid = {
    "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
    "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
    "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
    "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
    "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
    "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
    "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
    "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
    "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
    "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
    "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
    "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
function parseKeys(buffer44) {
    let password;
    if (typeof buffer44 === "object" && !Buffer1.isBuffer(buffer44)) {
        password = buffer44.passphrase;
        buffer44 = buffer44.key;
    }
    if (typeof buffer44 === "string") {
        buffer44 = Buffer1.from(buffer44);
    }
    const stripped = __default35(buffer44, password);
    const type51 = stripped.tag;
    let data68 = stripped.data;
    let subtype, ndata;
    switch(type51){
        case "CERTIFICATE":
            ndata = X509Certificate.decode(data68, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
            if (!ndata) {
                ndata = PublicKey.decode(data68, "der");
            }
            subtype = ndata.algorithm.algorithm.join(".");
            switch(subtype){
                case "1.2.840.113549.1.1.1":
                    return RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
                case "1.2.840.10045.2.1":
                    ndata.subjectPrivateKey = ndata.subjectPublicKey;
                    return {
                        type: "ec",
                        data: ndata
                    };
                case "1.2.840.10040.4.1":
                    ndata.algorithm.params.pub_key = DSAparam.decode(ndata.subjectPublicKey.data, "der");
                    return {
                        type: "dsa",
                        data: ndata.algorithm.params
                    };
                default:
                    throw new Error("unknown key id " + subtype);
            }
        case "ENCRYPTED PRIVATE KEY":
            data68 = EncryptedPrivateKey.decode(data68, "der");
            data68 = decrypt2(data68, password);
        case "PRIVATE KEY":
            ndata = PrivateKey.decode(data68, "der");
            subtype = ndata.algorithm.algorithm.join(".");
            switch(subtype){
                case "1.2.840.113549.1.1.1":
                    return RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
                case "1.2.840.10045.2.1":
                    return {
                        curve: ndata.algorithm.curve,
                        privateKey: ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey
                    };
                case "1.2.840.10040.4.1":
                    ndata.algorithm.params.priv_key = DSAparam.decode(ndata.subjectPrivateKey, "der");
                    return {
                        type: "dsa",
                        params: ndata.algorithm.params
                    };
                default:
                    throw new Error("unknown key id " + subtype);
            }
        case "RSA PUBLIC KEY":
            return RSAPublicKey.decode(data68, "der");
        case "RSA PRIVATE KEY":
            return RSAPrivateKey.decode(data68, "der");
        case "DSA PRIVATE KEY":
            return {
                type: "dsa",
                params: DSAPrivateKey.decode(data68, "der")
            };
        case "EC PRIVATE KEY":
            data68 = ECPrivateKey.decode(data68, "der");
            return {
                curve: data68.parameters.value,
                privateKey: data68.privateKey
            };
        default:
            throw new Error("unknown key type " + type51);
    }
}
parseKeys.signature = signature;
function decrypt2(data69, password) {
    const salt = data69.algorithm.decrypt.kde.kdeparams.salt;
    const iters = parseInt(data69.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
    const algo = aesid[data69.algorithm.decrypt.cipher.algo.join(".")];
    const iv = data69.algorithm.decrypt.cipher.iv;
    const cipherText = data69.subjectPrivateKey;
    const keylen = parseInt(algo.split("-")[1], 10) / 8;
    const key = pbkdf2Sync(password, salt, iters, keylen, "sha1");
    const cipher = createDecipheriv(algo, key, iv);
    const out = [];
    out.push(cipher.update(cipherText));
    out.push(cipher.final());
    return Buffer1.concat(out);
}
const MAX_BYTES = 65536;
function randomBytes1(size, cb) {
    if (size > 4294967295) {
        throw new RangeError("requested too many random bytes");
    }
    const bytes = Buffer1.allocUnsafe(size);
    if (size > 0) {
        if (size > 65536) {
            for(let generated = 0; generated < size; generated += MAX_BYTES){
                crypto.getRandomValues(bytes.slice(generated, generated + 65536));
            }
        } else {
            crypto.getRandomValues(bytes);
        }
    }
    if (typeof cb === "function") {
        return nextTick2(function() {
            cb(null, bytes);
        });
    }
    return bytes;
}
function __default36(seed, len) {
    let t16 = Buffer1.alloc(0);
    let i228 = 0;
    let c28;
    while(t16.length < len){
        c28 = i2ops(i228++);
        t16 = Buffer1.concat([
            t16,
            createHash("sha1").update(seed).update(c28).digest()
        ]);
    }
    return t16.slice(0, len);
}
function i2ops(c29) {
    const out = Buffer1.allocUnsafe(4);
    out.writeUInt32BE(c29, 0);
    return out;
}
function xor1(a49, b46) {
    const len = a49.length;
    let i229 = -1;
    while(++i229 < len){
        a49[i229] ^= b46[i229];
    }
    return a49;
}
function withPublic(paddedMsg, key) {
    return Buffer1.from(paddedMsg.toRed(BN.mont(key.modulus)).redPow(new BN(key.publicExponent)).fromRed().toArray());
}
function blind(priv) {
    const r49 = getr(priv);
    const blinder = r49.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
    return {
        blinder: blinder,
        unblinder: r49.invm(priv.modulus)
    };
}
function getr(priv) {
    const len = priv.modulus.byteLength();
    let r50;
    do {
        r50 = new BN(randomBytes1(len));
    }while (r50.cmp(priv.modulus) >= 0 || !r50.umod(priv.prime1) || !r50.umod(priv.prime2))
    return r50;
}
function crt(msg, priv) {
    const blinds = blind(priv);
    const len = priv.modulus.byteLength();
    const blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus);
    const c1 = blinded.toRed(BN.mont(priv.prime1));
    const c2 = blinded.toRed(BN.mont(priv.prime2));
    const qinv = priv.coefficient;
    const p29 = priv.prime1;
    const q7 = priv.prime2;
    const m1 = c1.redPow(priv.exponent1).fromRed();
    const m2 = c2.redPow(priv.exponent2).fromRed();
    const h5 = m1.isub(m2).imul(qinv).umod(p29).imul(q7);
    return m2.iadd(h5).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer1, "be", len);
}
crt.getr = getr;
function publicEncrypt(publicKey, msg, reverse2) {
    let padding;
    if (publicKey.padding) {
        padding = publicKey.padding;
    } else if (reverse2) {
        padding = 1;
    } else {
        padding = 4;
    }
    const key = parseKeys(publicKey);
    let paddedMsg;
    if (padding === 4) {
        paddedMsg = oaep(key, msg);
    } else if (padding === 1) {
        paddedMsg = pkcs1(key, msg, reverse2);
    } else if (padding === 3) {
        paddedMsg = new BN(msg);
        if (paddedMsg.cmp(key.modulus) >= 0) {
            throw new Error("data too long for modulus");
        }
    } else {
        throw new Error("unknown padding");
    }
    if (reverse2) {
        return crt(paddedMsg, key);
    } else {
        return withPublic(paddedMsg, key);
    }
}
function oaep(key, msg) {
    const k18 = key.modulus.byteLength();
    const mLen = msg.length;
    const iHash = createHash("sha1").update(Buffer1.alloc(0)).digest();
    const hLen = iHash.length;
    const hLen2 = 2 * hLen;
    if (mLen > k18 - hLen2 - 2) {
        throw new Error("message too long");
    }
    const ps = Buffer1.alloc(k18 - mLen - hLen2 - 2);
    const dblen = k18 - hLen - 1;
    const seed = randomBytes1(hLen);
    const maskedDb = xor1(Buffer1.concat([
        iHash,
        ps,
        Buffer1.alloc(1, 1),
        msg
    ], dblen), __default36(seed, dblen));
    const maskedSeed = xor1(seed, __default36(maskedDb, hLen));
    return new BN(Buffer1.concat([
        Buffer1.alloc(1),
        maskedSeed,
        maskedDb
    ], k18));
}
function pkcs1(key, msg, reverse3) {
    const mLen = msg.length;
    const k19 = key.modulus.byteLength();
    if (mLen > k19 - 11) {
        throw new Error("message too long");
    }
    let ps;
    if (reverse3) {
        ps = Buffer1.alloc(k19 - mLen - 3, 255);
    } else {
        ps = nonZero(k19 - mLen - 3);
    }
    return new BN(Buffer1.concat([
        Buffer1.from([
            0,
            reverse3 ? 1 : 2, 
        ]),
        ps,
        Buffer1.alloc(1),
        msg, 
    ], k19));
}
function nonZero(len) {
    const out = Buffer1.allocUnsafe(len);
    let i230 = 0;
    let cache1 = randomBytes1(len * 2);
    let cur = 0;
    let num;
    while(i230 < len){
        if (cur === cache1.length) {
            cache1 = randomBytes1(len * 2);
            cur = 0;
        }
        num = cache1[cur++];
        if (num) {
            out[i230++] = num;
        }
    }
    return out;
}
function privateDecrypt(privateKey, enc, reverse4) {
    let padding;
    if (privateKey.padding) {
        padding = privateKey.padding;
    } else if (reverse4) {
        padding = 1;
    } else {
        padding = 4;
    }
    const key = parseKeys(privateKey);
    const k20 = key.modulus.byteLength();
    if (enc.length > k20 || new BN(enc).cmp(key.modulus) >= 0) {
        throw new Error("decryption error");
    }
    let msg;
    if (reverse4) {
        msg = withPublic(new BN(enc), key);
    } else {
        msg = crt(enc, key);
    }
    const zBuffer = Buffer1.alloc(k20 - msg.length);
    msg = Buffer1.concat([
        zBuffer,
        msg
    ], k20);
    if (padding === 4) {
        return oaep1(key, msg);
    } else if (padding === 1) {
        return pkcs11(key, msg, reverse4);
    } else if (padding === 3) {
        return msg;
    } else {
        throw new Error("unknown padding");
    }
}
function oaep1(key, msg) {
    const k21 = key.modulus.byteLength();
    const iHash = createHash("sha1").update(Buffer1.alloc(0)).digest();
    const hLen = iHash.length;
    if (msg[0] !== 0) {
        throw new Error("decryption error");
    }
    const maskedSeed = msg.slice(1, hLen + 1);
    const maskedDb = msg.slice(hLen + 1);
    const seed = xor1(maskedSeed, __default36(maskedDb, hLen));
    const db = xor1(maskedDb, __default36(seed, k21 - hLen - 1));
    if (compare(iHash, db.slice(0, hLen))) {
        throw new Error("decryption error");
    }
    let i231 = hLen;
    while(db[i231] === 0){
        i231++;
    }
    if (db[i231++] !== 1) {
        throw new Error("decryption error");
    }
    return db.slice(i231);
}
function pkcs11(_key, msg, reverse5) {
    const p1 = msg.slice(0, 2);
    let i232 = 2;
    let status = 0;
    while(msg[i232++] !== 0){
        if (i232 >= msg.length) {
            status++;
            break;
        }
    }
    const ps = msg.slice(2, i232 - 1);
    if (p1.toString("hex") !== "0002" && !reverse5 || p1.toString("hex") !== "0001" && reverse5) {
        status++;
    }
    if (ps.length < 8) {
        status++;
    }
    if (status) {
        throw new Error("decryption error");
    }
    return msg.slice(i232);
}
function compare(a50, b47) {
    a50 = Buffer1.from(a50);
    b47 = Buffer1.from(b47);
    let dif = 0;
    let len = a50.length;
    if (a50.length !== b47.length) {
        dif++;
        len = Math.min(a50.length, b47.length);
    }
    let i233 = -1;
    while(++i233 < len){
        dif += a50[i233] ^ b47[i233];
    }
    return dif;
}
function privateEncrypt(key, buf) {
    return publicEncrypt(key, buf, true);
}
function publicDecrypt(key, buf) {
    return privateDecrypt(key, buf, true);
}
const randomUUID = ()=>crypto.randomUUID()
;
const webcrypto = crypto;
const __default37 = {
    Hash,
    createHash,
    getHashes,
    randomFill,
    randomInt,
    randomFillSync,
    pbkdf2,
    pbkdf2Sync,
    privateDecrypt,
    privateEncrypt,
    publicDecrypt,
    publicEncrypt,
    randomBytes,
    randomUUID,
    scrypt,
    scryptSync,
    timingSafeEqual,
    webcrypto
};
class Socket1 extends EventEmitter {
    constructor(_type, _listener){
        super();
    }
    addMembership(_multicastAddress, _interfaceAddress) {
        notImplemented();
    }
    addSourceSpecificMembership(_sourceAddress, _groupAddress, _interfaceAddress) {
        notImplemented();
    }
    address() {
        notImplemented();
    }
    bind(..._args) {
        notImplemented();
    }
    close(_callback) {
        notImplemented();
    }
    connect(_port, _arg1, _arg2) {
        notImplemented();
    }
    disconnect() {
        notImplemented();
    }
    dropMembership(_multicastAddress, _interfaceAddress) {
        notImplemented();
    }
    dropSourceSpecificMembership(_sourceAddress, _groupAddress, _interfaceAddress) {
        notImplemented();
    }
    getRecvBufferSize() {
        notImplemented();
    }
    getSendBufferSize() {
        notImplemented();
    }
    ref() {
        notImplemented();
    }
    send(_msg, ..._args) {
        notImplemented();
    }
    remoteAddress() {
        notImplemented();
    }
    setBroadcast(_arg) {
        notImplemented();
    }
    setMulticastInterface(_interfaceAddress) {
        notImplemented();
    }
    setMulticastLoopback(_arg) {
        notImplemented();
    }
    setMulticastTTL(_ttl) {
        notImplemented();
    }
    setRecvBufferSize(_size) {
        notImplemented();
    }
    setSendBufferSize(_size) {
        notImplemented();
    }
    setTTL(_ttl) {
        notImplemented();
    }
    unref() {
        notImplemented();
    }
    addListener(event, listener) {
        return super.addListener(event, listener);
    }
    emit(event, ...args) {
        return super.emit(event, ...args);
    }
    on(event, listener) {
        return super.on(event, listener);
    }
    once(event, listener) {
        return super.on(event, listener);
    }
    prependListener(event, listener) {
        return super.prependListener(event, listener);
    }
    prependOnceListener(event, listener) {
        return super.prependOnceListener(event, listener);
    }
}
function createSocket(type52, listener) {
    return new Socket1(type52, listener);
}
const __default38 = {
    createSocket,
    Socket: Socket1
};
function create() {
    notImplemented();
}
class Domain {
    constructor(){
        notImplemented();
    }
}
const __default39 = {
    create,
    Domain
};
promises.access;
promises.copyFile;
promises.open;
promises.rename;
promises.truncate;
promises.rm;
promises.rmdir;
promises.mkdir;
promises.readdir;
promises.readlink;
promises.symlink;
promises.lstat;
promises.stat;
promises.link;
promises.unlink;
promises.chmod;
promises.chown;
promises.utimes;
promises.realpath;
promises.mkdtemp;
promises.writeFile;
promises.appendFile;
promises.readFile;
promises.watch;
var Status;
(function(Status1) {
    Status1[Status1["Continue"] = 100] = "Continue";
    Status1[Status1["SwitchingProtocols"] = 101] = "SwitchingProtocols";
    Status1[Status1["Processing"] = 102] = "Processing";
    Status1[Status1["EarlyHints"] = 103] = "EarlyHints";
    Status1[Status1["OK"] = 200] = "OK";
    Status1[Status1["Created"] = 201] = "Created";
    Status1[Status1["Accepted"] = 202] = "Accepted";
    Status1[Status1["NonAuthoritativeInfo"] = 203] = "NonAuthoritativeInfo";
    Status1[Status1["NoContent"] = 204] = "NoContent";
    Status1[Status1["ResetContent"] = 205] = "ResetContent";
    Status1[Status1["PartialContent"] = 206] = "PartialContent";
    Status1[Status1["MultiStatus"] = 207] = "MultiStatus";
    Status1[Status1["AlreadyReported"] = 208] = "AlreadyReported";
    Status1[Status1["IMUsed"] = 226] = "IMUsed";
    Status1[Status1["MultipleChoices"] = 300] = "MultipleChoices";
    Status1[Status1["MovedPermanently"] = 301] = "MovedPermanently";
    Status1[Status1["Found"] = 302] = "Found";
    Status1[Status1["SeeOther"] = 303] = "SeeOther";
    Status1[Status1["NotModified"] = 304] = "NotModified";
    Status1[Status1["UseProxy"] = 305] = "UseProxy";
    Status1[Status1["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    Status1[Status1["PermanentRedirect"] = 308] = "PermanentRedirect";
    Status1[Status1["BadRequest"] = 400] = "BadRequest";
    Status1[Status1["Unauthorized"] = 401] = "Unauthorized";
    Status1[Status1["PaymentRequired"] = 402] = "PaymentRequired";
    Status1[Status1["Forbidden"] = 403] = "Forbidden";
    Status1[Status1["NotFound"] = 404] = "NotFound";
    Status1[Status1["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    Status1[Status1["NotAcceptable"] = 406] = "NotAcceptable";
    Status1[Status1["ProxyAuthRequired"] = 407] = "ProxyAuthRequired";
    Status1[Status1["RequestTimeout"] = 408] = "RequestTimeout";
    Status1[Status1["Conflict"] = 409] = "Conflict";
    Status1[Status1["Gone"] = 410] = "Gone";
    Status1[Status1["LengthRequired"] = 411] = "LengthRequired";
    Status1[Status1["PreconditionFailed"] = 412] = "PreconditionFailed";
    Status1[Status1["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
    Status1[Status1["RequestURITooLong"] = 414] = "RequestURITooLong";
    Status1[Status1["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
    Status1[Status1["RequestedRangeNotSatisfiable"] = 416] = "RequestedRangeNotSatisfiable";
    Status1[Status1["ExpectationFailed"] = 417] = "ExpectationFailed";
    Status1[Status1["Teapot"] = 418] = "Teapot";
    Status1[Status1["MisdirectedRequest"] = 421] = "MisdirectedRequest";
    Status1[Status1["UnprocessableEntity"] = 422] = "UnprocessableEntity";
    Status1[Status1["Locked"] = 423] = "Locked";
    Status1[Status1["FailedDependency"] = 424] = "FailedDependency";
    Status1[Status1["TooEarly"] = 425] = "TooEarly";
    Status1[Status1["UpgradeRequired"] = 426] = "UpgradeRequired";
    Status1[Status1["PreconditionRequired"] = 428] = "PreconditionRequired";
    Status1[Status1["TooManyRequests"] = 429] = "TooManyRequests";
    Status1[Status1["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
    Status1[Status1["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
    Status1[Status1["InternalServerError"] = 500] = "InternalServerError";
    Status1[Status1["NotImplemented"] = 501] = "NotImplemented";
    Status1[Status1["BadGateway"] = 502] = "BadGateway";
    Status1[Status1["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    Status1[Status1["GatewayTimeout"] = 504] = "GatewayTimeout";
    Status1[Status1["HTTPVersionNotSupported"] = 505] = "HTTPVersionNotSupported";
    Status1[Status1["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
    Status1[Status1["InsufficientStorage"] = 507] = "InsufficientStorage";
    Status1[Status1["LoopDetected"] = 508] = "LoopDetected";
    Status1[Status1["NotExtended"] = 510] = "NotExtended";
    Status1[Status1["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
})(Status || (Status = {}));
new Map([
    [
        Status.Continue,
        "Continue"
    ],
    [
        Status.SwitchingProtocols,
        "Switching Protocols"
    ],
    [
        Status.Processing,
        "Processing"
    ],
    [
        Status.EarlyHints,
        "Early Hints"
    ],
    [
        Status.OK,
        "OK"
    ],
    [
        Status.Created,
        "Created"
    ],
    [
        Status.Accepted,
        "Accepted"
    ],
    [
        Status.NonAuthoritativeInfo,
        "Non-Authoritative Information"
    ],
    [
        Status.NoContent,
        "No Content"
    ],
    [
        Status.ResetContent,
        "Reset Content"
    ],
    [
        Status.PartialContent,
        "Partial Content"
    ],
    [
        Status.MultiStatus,
        "Multi-Status"
    ],
    [
        Status.AlreadyReported,
        "Already Reported"
    ],
    [
        Status.IMUsed,
        "IM Used"
    ],
    [
        Status.MultipleChoices,
        "Multiple Choices"
    ],
    [
        Status.MovedPermanently,
        "Moved Permanently"
    ],
    [
        Status.Found,
        "Found"
    ],
    [
        Status.SeeOther,
        "See Other"
    ],
    [
        Status.NotModified,
        "Not Modified"
    ],
    [
        Status.UseProxy,
        "Use Proxy"
    ],
    [
        Status.TemporaryRedirect,
        "Temporary Redirect"
    ],
    [
        Status.PermanentRedirect,
        "Permanent Redirect"
    ],
    [
        Status.BadRequest,
        "Bad Request"
    ],
    [
        Status.Unauthorized,
        "Unauthorized"
    ],
    [
        Status.PaymentRequired,
        "Payment Required"
    ],
    [
        Status.Forbidden,
        "Forbidden"
    ],
    [
        Status.NotFound,
        "Not Found"
    ],
    [
        Status.MethodNotAllowed,
        "Method Not Allowed"
    ],
    [
        Status.NotAcceptable,
        "Not Acceptable"
    ],
    [
        Status.ProxyAuthRequired,
        "Proxy Authentication Required"
    ],
    [
        Status.RequestTimeout,
        "Request Timeout"
    ],
    [
        Status.Conflict,
        "Conflict"
    ],
    [
        Status.Gone,
        "Gone"
    ],
    [
        Status.LengthRequired,
        "Length Required"
    ],
    [
        Status.PreconditionFailed,
        "Precondition Failed"
    ],
    [
        Status.RequestEntityTooLarge,
        "Request Entity Too Large"
    ],
    [
        Status.RequestURITooLong,
        "Request URI Too Long"
    ],
    [
        Status.UnsupportedMediaType,
        "Unsupported Media Type"
    ],
    [
        Status.RequestedRangeNotSatisfiable,
        "Requested Range Not Satisfiable"
    ],
    [
        Status.ExpectationFailed,
        "Expectation Failed"
    ],
    [
        Status.Teapot,
        "I'm a teapot"
    ],
    [
        Status.MisdirectedRequest,
        "Misdirected Request"
    ],
    [
        Status.UnprocessableEntity,
        "Unprocessable Entity"
    ],
    [
        Status.Locked,
        "Locked"
    ],
    [
        Status.FailedDependency,
        "Failed Dependency"
    ],
    [
        Status.TooEarly,
        "Too Early"
    ],
    [
        Status.UpgradeRequired,
        "Upgrade Required"
    ],
    [
        Status.PreconditionRequired,
        "Precondition Required"
    ],
    [
        Status.TooManyRequests,
        "Too Many Requests"
    ],
    [
        Status.RequestHeaderFieldsTooLarge,
        "Request Header Fields Too Large"
    ],
    [
        Status.UnavailableForLegalReasons,
        "Unavailable For Legal Reasons"
    ],
    [
        Status.InternalServerError,
        "Internal Server Error"
    ],
    [
        Status.NotImplemented,
        "Not Implemented"
    ],
    [
        Status.BadGateway,
        "Bad Gateway"
    ],
    [
        Status.ServiceUnavailable,
        "Service Unavailable"
    ],
    [
        Status.GatewayTimeout,
        "Gateway Timeout"
    ],
    [
        Status.HTTPVersionNotSupported,
        "HTTP Version Not Supported"
    ],
    [
        Status.VariantAlsoNegotiates,
        "Variant Also Negotiates"
    ],
    [
        Status.InsufficientStorage,
        "Insufficient Storage"
    ],
    [
        Status.LoopDetected,
        "Loop Detected"
    ],
    [
        Status.NotExtended,
        "Not Extended"
    ],
    [
        Status.NetworkAuthenticationRequired,
        "Network Authentication Required"
    ], 
]);
const METHODS = [
    "ACL",
    "BIND",
    "CHECKOUT",
    "CONNECT",
    "COPY",
    "DELETE",
    "GET",
    "HEAD",
    "LINK",
    "LOCK",
    "M-SEARCH",
    "MERGE",
    "MKACTIVITY",
    "MKCALENDAR",
    "MKCOL",
    "MOVE",
    "NOTIFY",
    "OPTIONS",
    "PATCH",
    "POST",
    "PROPFIND",
    "PROPPATCH",
    "PURGE",
    "PUT",
    "REBIND",
    "REPORT",
    "SEARCH",
    "SOURCE",
    "SUBSCRIBE",
    "TRACE",
    "UNBIND",
    "UNLINK",
    "UNLOCK",
    "UNSUBSCRIBE", 
];
function chunkToU8(chunk) {
    if (typeof chunk === "string") {
        return core.encode(chunk);
    }
    return chunk;
}
class ClientRequest extends Writable {
    opts;
    cb;
    body = null;
    controller = null;
    constructor(opts, cb){
        super();
        this.opts = opts;
        this.cb = cb;
    }
    _write(chunk, _enc, cb) {
        if (this.controller) {
            this.controller.enqueue(chunk);
            cb();
            return;
        }
        this.body = new ReadableStream({
            start: (controller)=>{
                this.controller = controller;
                controller.enqueue(chunk);
                cb();
            }
        });
    }
    async _final() {
        if (this.controller) {
            this.controller.close();
        }
        const client = await this._createCustomClient();
        const opts = {
            body: this.body,
            method: this.opts.method,
            client
        };
        const mayResponse = fetch(this._createUrlStrFromOptions(this.opts), opts).catch((e48)=>{
            if (e48.message.includes("connection closed before message completed")) {} else {
                this.emit("error", e48);
            }
            return undefined;
        });
        const res = new IncomingMessageForClient(await mayResponse, this._createSocket());
        this.emit("response", res);
        if (client) {
            res.on("end", ()=>{
                client.close();
            });
        }
        this.cb?.(res);
    }
    abort() {
        this.destroy();
    }
    _createCustomClient() {
        return Promise.resolve(undefined);
    }
    _createSocket() {
        return new Socket({});
    }
    _createUrlStrFromOptions(opts) {
        if (opts.href) {
            return opts.href;
        } else {
            const { auth , protocol , host , hostname: hostname13 , path: path114 , port: port11 ,  } = opts;
            return `${protocol}//${auth ? `${auth}@` : ""}${host ?? hostname13}${port11 ? `:${port11}` : ""}${path114}`;
        }
    }
}
class IncomingMessageForClient extends Readable {
    response;
    socket;
    reader;
    constructor(response, socket){
        super();
        this.response = response;
        this.socket = socket;
        this.reader = response?.body?.getReader();
    }
    async _read(_size) {
        if (this.reader === undefined) {
            this.push(null);
            return;
        }
        try {
            const res = await this.reader.read();
            if (res.done) {
                this.push(null);
                return;
            }
            this.push(res.value);
        } catch (e49) {
            this.destroy(e49);
        }
    }
    get headers() {
        if (this.response) {
            return Object.fromEntries(this.response.headers.entries());
        }
        return {};
    }
    get trailers() {
        return {};
    }
    get statusCode() {
        return this.response?.status || 0;
    }
    get statusMessage() {
        return this.response?.statusText || "";
    }
}
class ServerResponse extends Writable {
    statusCode = undefined;
    statusMessage = undefined;
    #headers = new Headers({});
    readable;
    headersSent = false;
    #reqEvent;
    #firstChunk = null;
    constructor(reqEvent){
        let controller;
        const readable = new ReadableStream({
            start (c30) {
                controller = c30;
            }
        });
        super({
            autoDestroy: true,
            defaultEncoding: "utf-8",
            emitClose: true,
            write: (chunk, _encoding, cb)=>{
                if (!this.headersSent) {
                    if (this.#firstChunk === null) {
                        this.#firstChunk = chunk;
                        return cb();
                    } else {
                        controller.enqueue(chunkToU8(this.#firstChunk));
                        this.#firstChunk = null;
                        this.respond(false);
                    }
                }
                controller.enqueue(chunkToU8(chunk));
                return cb();
            },
            final: (cb)=>{
                if (this.#firstChunk) {
                    this.respond(true, this.#firstChunk);
                } else if (!this.headersSent) {
                    this.respond(true);
                }
                controller.close();
                return cb();
            },
            destroy: (err164, cb)=>{
                if (err164) {
                    controller.error(err164);
                }
                return cb(null);
            }
        });
        this.readable = readable;
        this.#reqEvent = reqEvent;
    }
    setHeader(name69, value) {
        this.#headers.set(name69, value);
        return this;
    }
    getHeader(name70) {
        return this.#headers.get(name70);
    }
    removeHeader(name71) {
        return this.#headers.delete(name71);
    }
    getHeaderNames() {
        return Array.from(this.#headers.keys());
    }
    hasHeader(name72) {
        return this.#headers.has(name72);
    }
    writeHead(status, headers) {
        this.statusCode = status;
        for(const k22 in headers){
            this.#headers.set(k22, headers[k22]);
        }
        return this;
    }
     #ensureHeaders(singleChunk) {
        if (this.statusCode === undefined) {
            this.statusCode = 200;
            this.statusMessage = "OK";
        }
        if (typeof singleChunk === "string" && !this.hasHeader("content-type")) {
            this.setHeader("content-type", "text/plain;charset=UTF-8");
        }
    }
    respond(__final3, singleChunk1) {
        this.headersSent = true;
        this.#ensureHeaders(singleChunk1);
        const body = singleChunk1 ?? (__final3 ? null : this.readable);
        this.#reqEvent.respondWith(new Response(body, {
            headers: this.#headers,
            status: this.statusCode,
            statusText: this.statusMessage
        }));
    }
    end(chunk, encoding, cb) {
        if (!chunk && this.#headers.has("transfer-encoding")) {
            this.#headers.set("content-length", "0");
            this.#headers.delete("transfer-encoding");
        }
        return super.end(chunk, encoding, cb);
    }
}
class IncomingMessageForServer extends Readable {
    req;
    url;
    constructor(req25){
        const reader = req25.body?.getReader();
        super({
            autoDestroy: true,
            emitClose: true,
            objectMode: false,
            read: async function(_size) {
                if (!reader) {
                    return this.push(null);
                }
                try {
                    const { value  } = await reader.read();
                    this.push(value !== undefined ? Buffer1.from(value) : null);
                } catch (err165) {
                    this.destroy(err165);
                }
            },
            destroy: (err166, cb)=>{
                reader?.cancel().finally(()=>cb(err166)
                );
            }
        });
        this.req = req25;
        this.url = req25.url.slice(this.req.url.indexOf("/", 8));
    }
    get aborted() {
        return false;
    }
    get httpVersion() {
        return "1.1";
    }
    get headers() {
        return Object.fromEntries(this.req.headers.entries());
    }
    get method() {
        return this.req.method;
    }
}
function Server1(handler) {
    return new ServerImpl(handler);
}
class ServerImpl extends EventEmitter {
    #httpConnections = new Set();
    #listener;
    constructor(handler){
        super();
        if (handler !== undefined) {
            this.on("request", handler);
        }
    }
    listen(...args) {
        const normalized = _normalizeArgs(args);
        const options = normalized[0];
        const cb = normalized[1];
        if (cb !== null) {
            this.once("listening", cb);
        }
        let port12 = 0;
        if (typeof options.port === "number" || typeof options.port === "string") {
            validatePort(options.port, "options.port");
            port12 = options.port | 0;
        }
        const hostname14 = options.host ?? "";
        this.#listener = Deno.listen({
            port: port12,
            hostname: hostname14
        });
        nextTick2(()=>this.#listenLoop()
        );
        return this;
    }
    async #listenLoop() {
        const go = async (httpConn)=>{
            try {
                for(;;){
                    let reqEvent = null;
                    try {
                        reqEvent = await httpConn.nextRequest();
                    } catch  {}
                    if (reqEvent === null) {
                        break;
                    }
                    const req26 = new IncomingMessageForServer(reqEvent.request);
                    const res = new ServerResponse(reqEvent);
                    this.emit("request", req26, res);
                }
            } finally{
                this.#httpConnections.delete(httpConn);
            }
        };
        const listener = this.#listener;
        if (listener !== undefined) {
            this.emit("listening");
            for await (const conn of listener){
                let httpConn;
                try {
                    httpConn = Deno.serveHttp(conn);
                } catch  {
                    continue;
                }
                this.#httpConnections.add(httpConn);
                go(httpConn);
            }
        }
    }
    get listening() {
        return this.#listener !== undefined;
    }
    close(cb) {
        const listening = this.listening;
        if (typeof cb === "function") {
            if (listening) {
                this.once("close", cb);
            } else {
                this.once("close", function close() {
                    cb(new ERR_SERVER_NOT_RUNNING());
                });
            }
        }
        nextTick2(()=>this.emit("close")
        );
        if (listening) {
            this.#listener.close();
            this.#listener = undefined;
            for (const httpConn of this.#httpConnections){
                try {
                    httpConn.close();
                } catch  {}
            }
            this.#httpConnections.clear();
        }
        return this;
    }
    address() {
        const addr = this.#listener.addr;
        return {
            port: addr.port,
            address: addr.hostname
        };
    }
}
Server1.prototype = ServerImpl.prototype;
function createServer1(handler) {
    return Server1(handler);
}
function request(...args) {
    let options = {};
    if (typeof args[0] === "string") {
        options = urlToHttpOptions1(new URL(args.shift()));
    } else if (args[0] instanceof URL) {
        options = urlToHttpOptions1(args.shift());
    }
    if (args[0] && typeof args[0] !== "function") {
        Object.assign(options, args.shift());
    }
    args.unshift(options);
    return new ClientRequest(args[0], args[1]);
}
function get1(...args) {
    const req27 = request(args[0], args[1], args[2]);
    req27.end();
    return req27;
}
const __default40 = {
    Agent,
    ClientRequest,
    STATUS_CODES: Status,
    METHODS,
    createServer: createServer1,
    Server: Server1,
    IncomingMessage: IncomingMessageForServer,
    OutgoingMessage,
    ServerResponse,
    request,
    get: get1
};
class Http2Session {
    constructor(){
        notImplemented();
    }
}
class ServerHttp2Session {
    constructor(){
        notImplemented();
    }
}
class ClientHttp2Session {
    constructor(){
        notImplemented();
    }
}
class Http2Stream {
    constructor(){
        notImplemented();
    }
}
class ClientHttp2Stream {
    constructor(){
        notImplemented();
    }
}
class ServerHttp2Stream {
    constructor(){
        notImplemented();
    }
}
class Http2Server {
    constructor(){
        notImplemented();
    }
}
class Http2SecureServer {
    constructor(){
        notImplemented();
    }
}
function createServer2() {}
function createSecureServer() {}
function connect1() {}
const constants7 = {};
function getDefaultSettings() {}
function getPackedSettings() {}
function getUnpackedSettings() {}
const sensitiveHeaders = Symbol("nodejs.http2.sensitiveHeaders");
class Http2ServerRequest {
    constructor(){
        notImplemented();
    }
}
class Http2ServerResponse {
    constructor(){
        notImplemented();
    }
}
const __default41 = {
    Http2Session,
    ServerHttp2Session,
    ClientHttp2Session,
    Http2Stream,
    ClientHttp2Stream,
    ServerHttp2Stream,
    Http2Server,
    Http2SecureServer,
    createServer: createServer2,
    createSecureServer,
    connect: connect1,
    constants: constants7,
    getDefaultSettings,
    getPackedSettings,
    getUnpackedSettings,
    sensitiveHeaders,
    Http2ServerRequest,
    Http2ServerResponse
};
class Agent1 extends Agent {
}
class Server2 {
    constructor(){
        notImplemented();
    }
}
function createServer3() {
    notImplemented();
}
let caCerts;
function get2(...args) {
    const req28 = request1(args[0], args[1], args[2]);
    req28.end();
    return req28;
}
const globalAgent1 = undefined;
class HttpsClientRequest extends ClientRequest {
    async _createCustomClient() {
        if (caCerts === null) {
            return undefined;
        }
        if (caCerts !== undefined) {
            return createHttpClient({
                caCerts
            });
        }
        const status = await Deno.permissions.query({
            name: "env",
            variable: "NODE_EXTRA_CA_CERTS"
        });
        if (status.state !== "granted") {
            caCerts = null;
            return undefined;
        }
        const certFilename = Deno.env.get("NODE_EXTRA_CA_CERTS");
        if (!certFilename) {
            caCerts = null;
            return undefined;
        }
        const caCert = await Deno.readTextFile(certFilename);
        caCerts = [
            caCert
        ];
        return createHttpClient({
            caCerts
        });
    }
    _createSocket() {
        return {
            authorized: true
        };
    }
}
function request1(...args) {
    let options = {};
    if (typeof args[0] === "string") {
        options = urlToHttpOptions1(new URL(args.shift()));
    } else if (args[0] instanceof URL) {
        options = urlToHttpOptions1(args.shift());
    }
    if (args[0] && typeof args[0] !== "function") {
        Object.assign(options, args.shift());
    }
    args.unshift(options);
    return new HttpsClientRequest(args[0], args[1]);
}
const __default42 = {
    Agent: Agent1,
    Server: Server2,
    createServer: createServer3,
    get: get2,
    globalAgent: globalAgent1,
    request: request1
};
const connectionSymbol = Symbol("connectionProperty");
const messageCallbacksSymbol = Symbol("messageCallbacks");
const nextIdSymbol = Symbol("nextId");
const onMessageSymbol = Symbol("onMessage");
class Session extends EventEmitter {
    [connectionSymbol];
    [nextIdSymbol];
    [messageCallbacksSymbol];
    constructor(){
        super();
        notImplemented();
    }
    connect() {
        notImplemented();
    }
    connectToMainThread() {
        notImplemented();
    }
    [onMessageSymbol](_message) {
        notImplemented();
    }
    post(_method, _params, _callback) {
        notImplemented();
    }
    disconnect() {
        notImplemented();
    }
}
function open1(_port, _host, _wait) {
    notImplemented();
}
function close1() {
    notImplemented();
}
function url() {
    return undefined;
}
function waitForDebugger() {
    notImplemented();
}
const console1 = globalThis.console;
const __default43 = {
    close: close1,
    console: console1,
    open: open1,
    Session,
    url,
    waitForDebugger
};
"use strict";
const kEscape = "\x1b";
const kSubstringSearch = Symbol("kSubstringSearch");
function CSI(strings1, ...args) {
    let ret = `${kEscape}[`;
    for(let n38 = 0; n38 < strings1.length; n38++){
        ret += strings1[n38];
        if (n38 < args.length) {
            ret += args[n38];
        }
    }
    return ret;
}
CSI.kEscape = kEscape;
CSI.kClearToLineBeginning = CSI`1K`;
CSI.kClearToLineEnd = CSI`0K`;
CSI.kClearLine = CSI`2K`;
CSI.kClearScreenDown = CSI`0J`;
function charLengthLeft(str, i234) {
    if (i234 <= 0) {
        return 0;
    }
    if (i234 > 1 && str.codePointAt(i234 - 2) >= 65536 || str.codePointAt(i234 - 1) >= 65536) {
        return 2;
    }
    return 1;
}
function charLengthAt(str, i235) {
    if (str.length <= i235) {
        return 1;
    }
    return str.codePointAt(i235) >= 65536 ? 2 : 1;
}
function* emitKeys(stream5) {
    while(true){
        let ch = yield;
        let s33 = ch;
        let escaped = false;
        const key = {
            sequence: null,
            name: undefined,
            ctrl: false,
            meta: false,
            shift: false
        };
        if (ch === kEscape) {
            escaped = true;
            s33 += ch = yield;
            if (ch === kEscape) {
                s33 += ch = yield;
            }
        }
        if (escaped && (ch === "O" || ch === "[")) {
            let code62 = ch;
            let modifier = 0;
            if (ch === "O") {
                s33 += ch = yield;
                if (ch >= "0" && ch <= "9") {
                    modifier = (ch >> 0) - 1;
                    s33 += ch = yield;
                }
                code62 += ch;
            } else if (ch === "[") {
                s33 += ch = yield;
                if (ch === "[") {
                    code62 += ch;
                    s33 += ch = yield;
                }
                const cmdStart = s33.length - 1;
                if (ch >= "0" && ch <= "9") {
                    s33 += ch = yield;
                    if (ch >= "0" && ch <= "9") {
                        s33 += ch = yield;
                    }
                }
                if (ch === ";") {
                    s33 += ch = yield;
                    if (ch >= "0" && ch <= "9") {
                        s33 += yield;
                    }
                }
                const cmd = s33.slice(cmdStart);
                let match6;
                if (match6 = cmd.match(/^(\d\d?)(;(\d))?([~^$])$/)) {
                    code62 += match6[1] + match6[4];
                    modifier = (match6[3] || 1) - 1;
                } else if (match6 = cmd.match(/^((\d;)?(\d))?([A-Za-z])$/)) {
                    code62 += match6[4];
                    modifier = (match6[3] || 1) - 1;
                } else {
                    code62 += cmd;
                }
            }
            key.ctrl = !!(modifier & 4);
            key.meta = !!(modifier & 10);
            key.shift = !!(modifier & 1);
            key.code = code62;
            switch(code62){
                case "[P":
                    key.name = "f1";
                    break;
                case "[Q":
                    key.name = "f2";
                    break;
                case "[R":
                    key.name = "f3";
                    break;
                case "[S":
                    key.name = "f4";
                    break;
                case "OP":
                    key.name = "f1";
                    break;
                case "OQ":
                    key.name = "f2";
                    break;
                case "OR":
                    key.name = "f3";
                    break;
                case "OS":
                    key.name = "f4";
                    break;
                case "[11~":
                    key.name = "f1";
                    break;
                case "[12~":
                    key.name = "f2";
                    break;
                case "[13~":
                    key.name = "f3";
                    break;
                case "[14~":
                    key.name = "f4";
                    break;
                case "[[A":
                    key.name = "f1";
                    break;
                case "[[B":
                    key.name = "f2";
                    break;
                case "[[C":
                    key.name = "f3";
                    break;
                case "[[D":
                    key.name = "f4";
                    break;
                case "[[E":
                    key.name = "f5";
                    break;
                case "[15~":
                    key.name = "f5";
                    break;
                case "[17~":
                    key.name = "f6";
                    break;
                case "[18~":
                    key.name = "f7";
                    break;
                case "[19~":
                    key.name = "f8";
                    break;
                case "[20~":
                    key.name = "f9";
                    break;
                case "[21~":
                    key.name = "f10";
                    break;
                case "[23~":
                    key.name = "f11";
                    break;
                case "[24~":
                    key.name = "f12";
                    break;
                case "[A":
                    key.name = "up";
                    break;
                case "[B":
                    key.name = "down";
                    break;
                case "[C":
                    key.name = "right";
                    break;
                case "[D":
                    key.name = "left";
                    break;
                case "[E":
                    key.name = "clear";
                    break;
                case "[F":
                    key.name = "end";
                    break;
                case "[H":
                    key.name = "home";
                    break;
                case "OA":
                    key.name = "up";
                    break;
                case "OB":
                    key.name = "down";
                    break;
                case "OC":
                    key.name = "right";
                    break;
                case "OD":
                    key.name = "left";
                    break;
                case "OE":
                    key.name = "clear";
                    break;
                case "OF":
                    key.name = "end";
                    break;
                case "OH":
                    key.name = "home";
                    break;
                case "[1~":
                    key.name = "home";
                    break;
                case "[2~":
                    key.name = "insert";
                    break;
                case "[3~":
                    key.name = "delete";
                    break;
                case "[4~":
                    key.name = "end";
                    break;
                case "[5~":
                    key.name = "pageup";
                    break;
                case "[6~":
                    key.name = "pagedown";
                    break;
                case "[[5~":
                    key.name = "pageup";
                    break;
                case "[[6~":
                    key.name = "pagedown";
                    break;
                case "[7~":
                    key.name = "home";
                    break;
                case "[8~":
                    key.name = "end";
                    break;
                case "[a":
                    key.name = "up";
                    key.shift = true;
                    break;
                case "[b":
                    key.name = "down";
                    key.shift = true;
                    break;
                case "[c":
                    key.name = "right";
                    key.shift = true;
                    break;
                case "[d":
                    key.name = "left";
                    key.shift = true;
                    break;
                case "[e":
                    key.name = "clear";
                    key.shift = true;
                    break;
                case "[2$":
                    key.name = "insert";
                    key.shift = true;
                    break;
                case "[3$":
                    key.name = "delete";
                    key.shift = true;
                    break;
                case "[5$":
                    key.name = "pageup";
                    key.shift = true;
                    break;
                case "[6$":
                    key.name = "pagedown";
                    key.shift = true;
                    break;
                case "[7$":
                    key.name = "home";
                    key.shift = true;
                    break;
                case "[8$":
                    key.name = "end";
                    key.shift = true;
                    break;
                case "Oa":
                    key.name = "up";
                    key.ctrl = true;
                    break;
                case "Ob":
                    key.name = "down";
                    key.ctrl = true;
                    break;
                case "Oc":
                    key.name = "right";
                    key.ctrl = true;
                    break;
                case "Od":
                    key.name = "left";
                    key.ctrl = true;
                    break;
                case "Oe":
                    key.name = "clear";
                    key.ctrl = true;
                    break;
                case "[2^":
                    key.name = "insert";
                    key.ctrl = true;
                    break;
                case "[3^":
                    key.name = "delete";
                    key.ctrl = true;
                    break;
                case "[5^":
                    key.name = "pageup";
                    key.ctrl = true;
                    break;
                case "[6^":
                    key.name = "pagedown";
                    key.ctrl = true;
                    break;
                case "[7^":
                    key.name = "home";
                    key.ctrl = true;
                    break;
                case "[8^":
                    key.name = "end";
                    key.ctrl = true;
                    break;
                case "[Z":
                    key.name = "tab";
                    key.shift = true;
                    break;
                default:
                    key.name = "undefined";
                    break;
            }
        } else if (ch === "\r") {
            key.name = "return";
            key.meta = escaped;
        } else if (ch === "\n") {
            key.name = "enter";
            key.meta = escaped;
        } else if (ch === "\t") {
            key.name = "tab";
            key.meta = escaped;
        } else if (ch === "\b" || ch === "\x7f") {
            key.name = "backspace";
            key.meta = escaped;
        } else if (ch === kEscape) {
            key.name = "escape";
            key.meta = escaped;
        } else if (ch === " ") {
            key.name = "space";
            key.meta = escaped;
        } else if (!escaped && ch <= "\x1a") {
            key.name = String.fromCharCode(ch.charCodeAt() + "a".charCodeAt() - 1);
            key.ctrl = true;
        } else if (/^[0-9A-Za-z]$/.test(ch)) {
            key.name = ch.toLowerCase();
            key.shift = /^[A-Z]$/.test(ch);
            key.meta = escaped;
        } else if (escaped) {
            key.name = ch.length ? undefined : "escape";
            key.meta = true;
        }
        key.sequence = s33;
        if (s33.length !== 0 && (key.name !== undefined || escaped)) {
            stream5.emit("keypress", escaped ? undefined : s33, key);
        } else if (charLengthAt(s33, 0) === s33.length) {
            stream5.emit("keypress", s33, key);
        }
    }
}
function commonPrefix(strings2) {
    if (strings2.length === 1) {
        return strings2[0];
    }
    const sorted = strings2.slice().sort();
    const min26 = sorted[0];
    const max = sorted[sorted.length - 1];
    for(let i236 = 0; i236 < min26.length; i236++){
        if (min26[i236] !== max[i236]) {
            return min26.slice(0, i236);
        }
    }
    return min26;
}
const __default44 = {
    CSI,
    charLengthAt,
    charLengthLeft,
    emitKeys,
    commonPrefix
};
function internalBinding(name73) {
    return getBinding(name73);
}
const primordials = {};
const __default45 = {
    internalBinding,
    primordials
};
const { PerformanceObserver , PerformanceEntry , performance: shimPerformance  } = globalThis;
const constants8 = {};
const performance1 = {
    clearMarks: (markName)=>shimPerformance.clearMarks(markName)
    ,
    eventLoopUtilization: ()=>notImplemented("eventLoopUtilization from performance")
    ,
    mark: (markName)=>shimPerformance.mark(markName)
    ,
    measure: (measureName, startMark, endMark)=>{
        if (endMark) {
            return shimPerformance.measure(measureName, startMark, endMark);
        } else {
            return shimPerformance.measure(measureName, startMark);
        }
    },
    nodeTiming: {},
    now: ()=>shimPerformance.now()
    ,
    timerify: ()=>notImplemented("timerify from performance")
    ,
    timeOrigin: shimPerformance.timeOrigin
};
const monitorEventLoopDelay = ()=>notImplemented("monitorEventLoopDelay from performance")
;
const __default46 = {
    performance: performance1,
    PerformanceObserver,
    PerformanceEntry,
    monitorEventLoopDelay,
    constants: constants8
};
const __default47 = {
    decode: decode2,
    encode: encode2,
    toASCII,
    toUnicode,
    ucs2
};
"use strict";
const { kClearLine , kClearScreenDown , kClearToLineBeginning , kClearToLineEnd ,  } = CSI;
function cursorTo(stream6, x36, y11, callback) {
    if (callback !== undefined) {
        validateCallback(callback);
    }
    if (typeof y11 === "function") {
        callback = y11;
        y11 = undefined;
    }
    if (Number.isNaN(x36)) throw new ERR_INVALID_ARG_VALUE("x", x36);
    if (Number.isNaN(y11)) throw new ERR_INVALID_ARG_VALUE("y", y11);
    if (stream6 == null || typeof x36 !== "number" && typeof y11 !== "number") {
        if (typeof callback === "function") process.nextTick(callback, null);
        return true;
    }
    if (typeof x36 !== "number") throw new ERR_INVALID_CURSOR_POS();
    const data70 = typeof y11 !== "number" ? CSI`${x36 + 1}G` : CSI`${y11 + 1};${x36 + 1}H`;
    return stream6.write(data70, callback);
}
function moveCursor(stream7, dx, dy, callback) {
    if (callback !== undefined) {
        validateCallback(callback);
    }
    if (stream7 == null || !(dx || dy)) {
        if (typeof callback === "function") process.nextTick(callback, null);
        return true;
    }
    let data71 = "";
    if (dx < 0) {
        data71 += CSI`${-dx}D`;
    } else if (dx > 0) {
        data71 += CSI`${dx}C`;
    }
    if (dy < 0) {
        data71 += CSI`${-dy}A`;
    } else if (dy > 0) {
        data71 += CSI`${dy}B`;
    }
    return stream7.write(data71, callback);
}
function clearLine(stream8, dir12, callback) {
    if (callback !== undefined) {
        validateCallback(callback);
    }
    if (stream8 === null || stream8 === undefined) {
        if (typeof callback === "function") process.nextTick(callback, null);
        return true;
    }
    const type53 = dir12 < 0 ? kClearToLineBeginning : dir12 > 0 ? kClearToLineEnd : kClearLine;
    return stream8.write(type53, callback);
}
function clearScreenDown(stream9, callback) {
    if (callback !== undefined) {
        validateCallback(callback);
    }
    if (stream9 === null || stream9 === undefined) {
        if (typeof callback === "function") process.nextTick(callback, null);
        return true;
    }
    return stream9.write(kClearScreenDown, callback);
}
const kAddHistory = Symbol("_addHistory");
const kDecoder = Symbol("_decoder");
const kDeleteLeft = Symbol("_deleteLeft");
const kDeleteLineLeft = Symbol("_deleteLineLeft");
const kDeleteLineRight = Symbol("_deleteLineRight");
const kDeleteRight = Symbol("_deleteRight");
const kDeleteWordLeft = Symbol("_deleteWordLeft");
const kDeleteWordRight = Symbol("_deleteWordRight");
const kGetDisplayPos = Symbol("_getDisplayPos");
const kHistoryNext = Symbol("_historyNext");
const kHistoryPrev = Symbol("_historyPrev");
const kInsertString = Symbol("_insertString");
const kLine = Symbol("_line");
const kLine_buffer = Symbol("_line_buffer");
const kMoveCursor = Symbol("_moveCursor");
const kNormalWrite = Symbol("_normalWrite");
const kOldPrompt = Symbol("_oldPrompt");
const kOnLine = Symbol("_onLine");
const kPreviousKey = Symbol("_previousKey");
const kPrompt = Symbol("_prompt");
const kQuestionCallback = Symbol("_questionCallback");
const kRefreshLine = Symbol("_refreshLine");
const kSawKeyPress = Symbol("_sawKeyPress");
const kSawReturnAt = Symbol("_sawReturnAt");
const kSetRawMode = Symbol("_setRawMode");
const kTabComplete = Symbol("_tabComplete");
const kTabCompleter = Symbol("_tabCompleter");
const kTtyWrite = Symbol("_ttyWrite");
const kWordLeft = Symbol("_wordLeft");
const kWordRight = Symbol("_wordRight");
const kWriteToOutput = Symbol("_writeToOutput");
const { kEscape: kEscape1 ,  } = CSI;
const KEYPRESS_DECODER = Symbol("keypress-decoder");
const ESCAPE_DECODER = Symbol("escape-decoder");
function emitKeypressEvents(stream10, iface = {}) {
    if (stream10[KEYPRESS_DECODER]) return;
    stream10[KEYPRESS_DECODER] = new StringDecoder("utf8");
    stream10[ESCAPE_DECODER] = emitKeys(stream10);
    stream10[ESCAPE_DECODER].next();
    const triggerEscape = ()=>stream10[ESCAPE_DECODER].next("")
    ;
    const { escapeCodeTimeout =500  } = iface;
    let timeoutId;
    function onData(input) {
        if (stream10.listenerCount("keypress") > 0) {
            const string = stream10[KEYPRESS_DECODER].write(input);
            if (string) {
                clearTimeout1(timeoutId);
                iface[kSawKeyPress] = charLengthAt(string, 0) === string.length;
                iface.isCompletionEnabled = false;
                let length = 0;
                for (const character of string[Symbol.iterator]()){
                    length += character.length;
                    if (length === string.length) {
                        iface.isCompletionEnabled = true;
                    }
                    try {
                        stream10[ESCAPE_DECODER].next(character);
                        if (length === string.length && character === kEscape1) {
                            timeoutId = setTimeout2(triggerEscape, escapeCodeTimeout);
                        }
                    } catch (err167) {
                        stream10[ESCAPE_DECODER] = emitKeys(stream10);
                        stream10[ESCAPE_DECODER].next();
                        throw err167;
                    }
                }
            }
        } else {
            stream10.removeListener("data", onData);
            stream10.on("newListener", onNewListener);
        }
    }
    function onNewListener(event) {
        if (event === "keypress") {
            stream10.on("data", onData);
            stream10.removeListener("newListener", onNewListener);
        }
    }
    if (stream10.listenerCount("keypress") > 0) {
        stream10.on("data", onData);
    } else {
        stream10.on("newListener", onNewListener);
    }
}
let Readable1;
const kHistorySize = 30;
const kMincrlfDelay = 100;
const lineEnding = /\r?\n|\r(?!\n)/;
const kLineObjectStream = Symbol("line object stream");
const kQuestionCancel = Symbol("kQuestionCancel");
const ESCAPE_CODE_TIMEOUT = 500;
function InterfaceConstructor(input, output, completer, terminal) {
    this[kSawReturnAt] = 0;
    this.isCompletionEnabled = true;
    this[kSawKeyPress] = false;
    this[kPreviousKey] = null;
    this.escapeCodeTimeout = ESCAPE_CODE_TIMEOUT;
    this.tabSize = 8;
    Function.prototype.call(EventEmitter, this);
    let history;
    let historySize;
    let removeHistoryDuplicates = false;
    let crlfDelay;
    let prompt = "> ";
    let signal;
    if (input?.input) {
        output = input.output;
        completer = input.completer;
        terminal = input.terminal;
        history = input.history;
        historySize = input.historySize;
        signal = input.signal;
        if (input.tabSize !== undefined) {
            validateUint32(input.tabSize, "tabSize", true);
            this.tabSize = input.tabSize;
        }
        removeHistoryDuplicates = input.removeHistoryDuplicates;
        if (input.prompt !== undefined) {
            prompt = input.prompt;
        }
        if (input.escapeCodeTimeout !== undefined) {
            if (Number.isFinite(input.escapeCodeTimeout)) {
                this.escapeCodeTimeout = input.escapeCodeTimeout;
            } else {
                throw new ERR_INVALID_ARG_VALUE("input.escapeCodeTimeout", this.escapeCodeTimeout);
            }
        }
        if (signal) {
            validateAbortSignal(signal, "options.signal");
        }
        crlfDelay = input.crlfDelay;
        input = input.input;
    }
    if (completer !== undefined && typeof completer !== "function") {
        throw new ERR_INVALID_ARG_VALUE("completer", completer);
    }
    if (history === undefined) {
        history = [];
    } else {
        validateArray(history, "history");
    }
    if (historySize === undefined) {
        historySize = kHistorySize;
    }
    if (typeof historySize !== "number" || Number.isNaN(historySize) || historySize < 0) {
        throw new ERR_INVALID_ARG_VALUE.RangeError("historySize", historySize);
    }
    if (terminal === undefined && !(output === null || output === undefined)) {
        terminal = !!output.isTTY;
    }
    const self = this;
    this.line = "";
    this[kSubstringSearch] = null;
    this.output = output;
    this.input = input;
    this.history = history;
    this.historySize = historySize;
    this.removeHistoryDuplicates = !!removeHistoryDuplicates;
    this.crlfDelay = crlfDelay ? Math.max(kMincrlfDelay, crlfDelay) : kMincrlfDelay;
    this.completer = completer;
    this.setPrompt(prompt);
    this.terminal = !!terminal;
    function onerror(err168) {
        self.emit("error", err168);
    }
    function ondata(data72) {
        self[kNormalWrite](data72);
    }
    function onend() {
        if (typeof self[kLine_buffer] === "string" && self[kLine_buffer].length > 0) {
            self.emit("line", self[kLine_buffer]);
        }
        self.close();
    }
    function ontermend() {
        if (typeof self.line === "string" && self.line.length > 0) {
            self.emit("line", self.line);
        }
        self.close();
    }
    function onkeypress(s34, key) {
        self[kTtyWrite](s34, key);
        if (key && key.sequence) {
            const ch = key.sequence.codePointAt(0);
            if (ch >= 55296 && ch <= 57343) self[kRefreshLine]();
        }
    }
    function onresize() {
        self[kRefreshLine]();
    }
    this[kLineObjectStream] = undefined;
    input.on("error", onerror);
    if (!this.terminal) {
        function onSelfCloseWithoutTerminal() {
            input.removeListener("data", ondata);
            input.removeListener("error", onerror);
            input.removeListener("end", onend);
        }
        input.on("data", ondata);
        input.on("end", onend);
        self.once("close", onSelfCloseWithoutTerminal);
        this[kDecoder] = new StringDecoder("utf8");
    } else {
        function onSelfCloseWithTerminal() {
            input.removeListener("keypress", onkeypress);
            input.removeListener("error", onerror);
            input.removeListener("end", ontermend);
            if (output !== null && output !== undefined) {
                output.removeListener("resize", onresize);
            }
        }
        emitKeypressEvents(input, this);
        input.on("keypress", onkeypress);
        input.on("end", ontermend);
        this[kSetRawMode](true);
        this.terminal = true;
        this.cursor = 0;
        this.historyIndex = -1;
        if (output !== null && output !== undefined) {
            output.on("resize", onresize);
        }
        self.once("close", onSelfCloseWithTerminal);
    }
    if (signal) {
        const onAborted = ()=>self.close()
        ;
        if (signal.aborted) {
            process.nextTick(onAborted);
        } else {
            signal.addEventListener("abort", onAborted, {
                once: true
            });
            self.once("close", ()=>signal.removeEventListener("abort", onAborted)
            );
        }
    }
    this.line = "";
    input.resume();
}
Object.setPrototypeOf(InterfaceConstructor.prototype, EventEmitter.prototype);
Object.setPrototypeOf(InterfaceConstructor, EventEmitter);
class Interface extends InterfaceConstructor {
    constructor(input, output, completer, terminal){
        super(input, output, completer, terminal);
    }
    get columns() {
        if (this.output && this.output.columns) return this.output.columns;
        return Infinity;
    }
    setPrompt(prompt) {
        this[kPrompt] = prompt;
    }
    getPrompt() {
        return this[kPrompt];
    }
    [kSetRawMode](mode25) {
        const wasInRawMode = this.input.isRaw;
        if (typeof this.input.setRawMode === "function") {
            this.input.setRawMode(mode25);
        }
        return wasInRawMode;
    }
    prompt(preserveCursor) {
        if (this.paused) this.resume();
        if (this.terminal && process.env.TERM !== "dumb") {
            if (!preserveCursor) this.cursor = 0;
            this[kRefreshLine]();
        } else {
            this[kWriteToOutput](this[kPrompt]);
        }
    }
    question(query, cb) {
        if (this[kQuestionCallback]) {
            this.prompt();
        } else {
            this[kOldPrompt] = this[kPrompt];
            this.setPrompt(query);
            this[kQuestionCallback] = cb;
            this.prompt();
        }
    }
    [kOnLine](line) {
        if (this[kQuestionCallback]) {
            const cb = this[kQuestionCallback];
            this[kQuestionCallback] = null;
            this.setPrompt(this[kOldPrompt]);
            cb(line);
        } else {
            this.emit("line", line);
        }
    }
    [kQuestionCancel]() {
        if (this[kQuestionCallback]) {
            this[kQuestionCallback] = null;
            this.setPrompt(this[kOldPrompt]);
            this.clearLine();
        }
    }
    [kWriteToOutput](stringToWrite) {
        validateString(stringToWrite, "stringToWrite");
        if (this.output !== null && this.output !== undefined) {
            this.output.write(stringToWrite);
        }
    }
    [kAddHistory]() {
        if (this.line.length === 0) return "";
        if (this.historySize === 0) return this.line;
        if (this.line.trim().length === 0) return this.line;
        if (this.history.length === 0 || this.history[0] !== this.line) {
            if (this.removeHistoryDuplicates) {
                const dupIndex = this.history.indexOf(this.line);
                if (dupIndex !== -1) this.history.splice(dupIndex, 1);
            }
            this.history.unshift(this.line);
            if (this.history.length > this.historySize) {
                this.history.pop();
            }
        }
        this.historyIndex = -1;
        const line = this.history[0];
        this.emit("history", this.history);
        return line;
    }
    [kRefreshLine]() {
        const line = this[kPrompt] + this.line;
        const dispPos = this[kGetDisplayPos](line);
        const lineCols = dispPos.cols;
        const lineRows = dispPos.rows;
        const cursorPos = this.getCursorPos();
        const prevRows = this.prevRows || 0;
        if (prevRows > 0) {
            moveCursor(this.output, 0, -prevRows);
        }
        cursorTo(this.output, 0);
        clearScreenDown(this.output);
        this[kWriteToOutput](line);
        if (lineCols === 0) {
            this[kWriteToOutput](" ");
        }
        cursorTo(this.output, cursorPos.cols);
        const diff3 = lineRows - cursorPos.rows;
        if (diff3 > 0) {
            moveCursor(this.output, 0, -diff3);
        }
        this.prevRows = cursorPos.rows;
    }
    close() {
        if (this.closed) return;
        this.pause();
        if (this.terminal) {
            this[kSetRawMode](false);
        }
        this.closed = true;
        this.emit("close");
    }
    pause() {
        if (this.paused) return;
        this.input.pause();
        this.paused = true;
        this.emit("pause");
        return this;
    }
    resume() {
        if (!this.paused) return;
        this.input.resume();
        this.paused = false;
        this.emit("resume");
        return this;
    }
    write(d9, key) {
        if (this.paused) this.resume();
        if (this.terminal) {
            this[kTtyWrite](d9, key);
        } else {
            this[kNormalWrite](d9);
        }
    }
    [kNormalWrite](b48) {
        if (b48 === undefined) {
            return;
        }
        let string = this[kDecoder].write(b48);
        if (this[kSawReturnAt] && Date.now() - this[kSawReturnAt] <= this.crlfDelay) {
            string = string.replace(/^\n/, "");
            this[kSawReturnAt] = 0;
        }
        const newPartContainsEnding = lineEnding.test(string);
        if (this[kLine_buffer]) {
            string = this[kLine_buffer] + string;
            this[kLine_buffer] = null;
        }
        if (newPartContainsEnding) {
            this[kSawReturnAt] = string.endsWith("\r") ? Date.now() : 0;
            const lines = string.split(lineEnding);
            string = lines.pop();
            this[kLine_buffer] = string;
            for(let n39 = 0; n39 < lines.length; n39++)this[kOnLine](lines[n39]);
        } else if (string) {
            this[kLine_buffer] = string;
        }
    }
    [kInsertString](c31) {
        if (this.cursor < this.line.length) {
            const beg = this.line.slice(0, this.cursor);
            const end = this.line.slice(this.cursor, this.line.length);
            this.line = beg + c31 + end;
            this.cursor += c31.length;
            this[kRefreshLine]();
        } else {
            this.line += c31;
            this.cursor += c31.length;
            if (this.getCursorPos().cols === 0) {
                this[kRefreshLine]();
            } else {
                this[kWriteToOutput](c31);
            }
        }
    }
    async [kTabComplete](lastKeypressWasTab) {
        this.pause();
        const string = this.line.slice(0, this.cursor);
        let value;
        try {
            value = await this.completer(string);
        } catch (err169) {
            this[kWriteToOutput](`Tab completion error: ${err169}`);
            return;
        } finally{
            this.resume();
        }
        this[kTabCompleter](lastKeypressWasTab, value);
    }
    [kTabCompleter](lastKeypressWasTab, { 0: completions , 1: completeOn  }) {
        if (!completions || completions.length === 0) {
            return;
        }
        const prefix = commonPrefix(completions.filter((e50)=>e50 !== ""
        ));
        if (prefix.startsWith(completeOn) && prefix.length > completeOn.length) {
            this[kInsertString](prefix.slice(completeOn.length));
            return;
        } else if (!completeOn.startsWith(prefix)) {
            this.line = this.line.slice(0, this.cursor - completeOn.length) + prefix + this.line.slice(this.cursor, this.line.length);
            this.cursor = this.cursor - completeOn.length + prefix.length;
            this._refreshLine();
            return;
        }
        if (!lastKeypressWasTab) {
            return;
        }
        const completionsWidth = completions.map((e51)=>getStringWidth(e51)
        );
        const width = Math.max.apply(completionsWidth) + 2;
        let maxColumns = Math.floor(this.columns / width) || 1;
        if (maxColumns === Infinity) {
            maxColumns = 1;
        }
        let output = "\r\n";
        let lineIndex = 0;
        let whitespace = 0;
        for(let i237 = 0; i237 < completions.length; i237++){
            const completion = completions[i237];
            if (completion === "" || lineIndex === maxColumns) {
                output += "\r\n";
                lineIndex = 0;
                whitespace = 0;
            } else {
                output += " ".repeat(whitespace);
            }
            if (completion !== "") {
                output += completion;
                whitespace = width - completionsWidth[i237];
                lineIndex++;
            } else {
                output += "\r\n";
            }
        }
        if (lineIndex !== 0) {
            output += "\r\n\r\n";
        }
        this[kWriteToOutput](output);
        this[kRefreshLine]();
    }
    [kWordLeft]() {
        if (this.cursor > 0) {
            const leading = this.line.slice(0, this.cursor);
            const reversed = Array.from(leading).reverse().join("");
            const match7 = reversed.match(/^\s*(?:[^\w\s]+|\w+)?/);
            this[kMoveCursor](-match7[0].length);
        }
    }
    [kWordRight]() {
        if (this.cursor < this.line.length) {
            const trailing = this.line.slice(this.cursor);
            const match8 = trailing.match(/^(?:\s+|[^\w\s]+|\w+)\s*/);
            this[kMoveCursor](match8[0].length);
        }
    }
    [kDeleteLeft]() {
        if (this.cursor > 0 && this.line.length > 0) {
            const charSize = charLengthLeft(this.line, this.cursor);
            this.line = this.line.slice(0, this.cursor - charSize) + this.line.slice(this.cursor, this.line.length);
            this.cursor -= charSize;
            this[kRefreshLine]();
        }
    }
    [kDeleteRight]() {
        if (this.cursor < this.line.length) {
            const charSize = charLengthAt(this.line, this.cursor);
            this.line = this.line.slice(0, this.cursor) + this.line.slice(this.cursor + charSize, this.line.length);
            this[kRefreshLine]();
        }
    }
    [kDeleteWordLeft]() {
        if (this.cursor > 0) {
            let leading = this.line.slice(0, this.cursor);
            const reversed = Array.from(leading).reverse().join("");
            const match9 = reversed.match(/^\s*(?:[^\w\s]+|\w+)?/);
            leading = leading.slice(0, leading.length - match9[0].length);
            this.line = leading + this.line.slice(this.cursor, this.line.length);
            this.cursor = leading.length;
            this[kRefreshLine]();
        }
    }
    [kDeleteWordRight]() {
        if (this.cursor < this.line.length) {
            const trailing = this.line.slice(this.cursor);
            const match10 = trailing.match(/^(?:\s+|\W+|\w+)\s*/);
            this.line = this.line.slice(0, this.cursor) + trailing.slice(match10[0].length);
            this[kRefreshLine]();
        }
    }
    [kDeleteLineLeft]() {
        this.line = this.line.slice(this.cursor);
        this.cursor = 0;
        this[kRefreshLine]();
    }
    [kDeleteLineRight]() {
        this.line = this.line.slice(0, this.cursor);
        this[kRefreshLine]();
    }
    clearLine() {
        this[kMoveCursor](+Infinity);
        this[kWriteToOutput]("\r\n");
        this.line = "";
        this.cursor = 0;
        this.prevRows = 0;
    }
    [kLine]() {
        const line = this[kAddHistory]();
        this.clearLine();
        this[kOnLine](line);
    }
    [kHistoryNext]() {
        if (this.historyIndex >= 0) {
            const search = this[kSubstringSearch] || "";
            let index18 = this.historyIndex - 1;
            while(index18 >= 0 && (!this.history[index18].startsWith(search) || this.line === this.history[index18])){
                index18--;
            }
            if (index18 === -1) {
                this.line = search;
            } else {
                this.line = this.history[index18];
            }
            this.historyIndex = index18;
            this.cursor = this.line.length;
            this[kRefreshLine]();
        }
    }
    [kHistoryPrev]() {
        if (this.historyIndex < this.history.length && this.history.length) {
            const search = this[kSubstringSearch] || "";
            let index19 = this.historyIndex + 1;
            while(index19 < this.history.length && (!this.history[index19].startsWith(search) || this.line === this.history[index19])){
                index19++;
            }
            if (index19 === this.history.length) {
                this.line = search;
            } else {
                this.line = this.history[index19];
            }
            this.historyIndex = index19;
            this.cursor = this.line.length;
            this[kRefreshLine]();
        }
    }
    [kGetDisplayPos](str) {
        let offset = 0;
        const col = this.columns;
        let rows = 0;
        str = stripVTControlCharacters(str);
        for (const __char of str[Symbol.iterator]()){
            if (__char === "\n") {
                rows += Math.ceil(offset / col) || 1;
                offset = 0;
                continue;
            }
            if (__char === "\t") {
                offset += this.tabSize - offset % this.tabSize;
                continue;
            }
            const width = getStringWidth(__char);
            if (width === 0 || width === 1) {
                offset += width;
            } else {
                if ((offset + 1) % col === 0) {
                    offset++;
                }
                offset += 2;
            }
        }
        const cols = offset % col;
        rows += (offset - cols) / col;
        return {
            cols,
            rows
        };
    }
    getCursorPos() {
        const strBeforeCursor = this[kPrompt] + this.line.slice(0, this.cursor);
        return this[kGetDisplayPos](strBeforeCursor);
    }
    [kMoveCursor](dx) {
        if (dx === 0) {
            return;
        }
        const oldPos = this.getCursorPos();
        this.cursor += dx;
        if (this.cursor < 0) {
            this.cursor = 0;
        } else if (this.cursor > this.line.length) {
            this.cursor = this.line.length;
        }
        const newPos = this.getCursorPos();
        if (oldPos.rows === newPos.rows) {
            const diffWidth = newPos.cols - oldPos.cols;
            moveCursor(this.output, diffWidth, 0);
        } else {
            this[kRefreshLine]();
        }
    }
    [kTtyWrite](s35, key) {
        const previousKey = this[kPreviousKey];
        key = key || {};
        this[kPreviousKey] = key;
        if ((key.name === "up" || key.name === "down") && !key.ctrl && !key.meta && !key.shift) {
            if (this[kSubstringSearch] === null) {
                this[kSubstringSearch] = this.line.slice(0, this.cursor);
            }
        } else if (this[kSubstringSearch] !== null) {
            this[kSubstringSearch] = null;
            if (this.history.length === this.historyIndex) {
                this.historyIndex = -1;
            }
        }
        if (key.name === "escape") return;
        if (key.ctrl && key.shift) {
            switch(key.name){
                case "backspace":
                    this[kDeleteLineLeft]();
                    break;
                case "delete":
                    this[kDeleteLineRight]();
                    break;
            }
        } else if (key.ctrl) {
            switch(key.name){
                case "c":
                    if (this.listenerCount("SIGINT") > 0) {
                        this.emit("SIGINT");
                    } else {
                        this.close();
                    }
                    break;
                case "h":
                    this[kDeleteLeft]();
                    break;
                case "d":
                    if (this.cursor === 0 && this.line.length === 0) {
                        this.close();
                    } else if (this.cursor < this.line.length) {
                        this[kDeleteRight]();
                    }
                    break;
                case "u":
                    this[kDeleteLineLeft]();
                    break;
                case "k":
                    this[kDeleteLineRight]();
                    break;
                case "a":
                    this[kMoveCursor](-Infinity);
                    break;
                case "e":
                    this[kMoveCursor](+Infinity);
                    break;
                case "b":
                    this[kMoveCursor](-charLengthLeft(this.line, this.cursor));
                    break;
                case "f":
                    this[kMoveCursor](+charLengthAt(this.line, this.cursor));
                    break;
                case "l":
                    cursorTo(this.output, 0, 0);
                    clearScreenDown(this.output);
                    this[kRefreshLine]();
                    break;
                case "n":
                    this[kHistoryNext]();
                    break;
                case "p":
                    this[kHistoryPrev]();
                    break;
                case "z":
                    if (process.platform === "win32") break;
                    if (this.listenerCount("SIGTSTP") > 0) {
                        this.emit("SIGTSTP");
                    } else {
                        process.once("SIGCONT", ()=>{
                            if (!this.paused) {
                                this.pause();
                                this.emit("SIGCONT");
                            }
                            this[kSetRawMode](true);
                            this[kRefreshLine]();
                        });
                        this[kSetRawMode](false);
                        process.kill(process.pid, "SIGTSTP");
                    }
                    break;
                case "w":
                case "backspace":
                    this[kDeleteWordLeft]();
                    break;
                case "delete":
                    this[kDeleteWordRight]();
                    break;
                case "left":
                    this[kWordLeft]();
                    break;
                case "right":
                    this[kWordRight]();
                    break;
            }
        } else if (key.meta) {
            switch(key.name){
                case "b":
                    this[kWordLeft]();
                    break;
                case "f":
                    this[kWordRight]();
                    break;
                case "d":
                case "delete":
                    this[kDeleteWordRight]();
                    break;
                case "backspace":
                    this[kDeleteWordLeft]();
                    break;
            }
        } else {
            if (this[kSawReturnAt] && key.name !== "enter") this[kSawReturnAt] = 0;
            switch(key.name){
                case "return":
                    this[kSawReturnAt] = Date.now();
                    this[kLine]();
                    break;
                case "enter":
                    if (this[kSawReturnAt] === 0 || Date.now() - this[kSawReturnAt] > this.crlfDelay) {
                        this[kLine]();
                    }
                    this[kSawReturnAt] = 0;
                    break;
                case "backspace":
                    this[kDeleteLeft]();
                    break;
                case "delete":
                    this[kDeleteRight]();
                    break;
                case "left":
                    this[kMoveCursor](-charLengthLeft(this.line, this.cursor));
                    break;
                case "right":
                    this[kMoveCursor](+charLengthAt(this.line, this.cursor));
                    break;
                case "home":
                    this[kMoveCursor](-Infinity);
                    break;
                case "end":
                    this[kMoveCursor](+Infinity);
                    break;
                case "up":
                    this[kHistoryPrev]();
                    break;
                case "down":
                    this[kHistoryNext]();
                    break;
                case "tab":
                    if (typeof this.completer === "function" && this.isCompletionEnabled) {
                        const lastKeypressWasTab = previousKey && previousKey.name === "tab";
                        this[kTabComplete](lastKeypressWasTab);
                        break;
                    }
                default:
                    if (typeof s35 === "string" && s35) {
                        const lines = s35.split(/\r\n|\n|\r/);
                        for(let i238 = 0, len = lines.length; i238 < len; i238++){
                            if (i238 > 0) {
                                this[kLine]();
                            }
                            this[kInsertString](lines[i238]);
                        }
                    }
            }
        }
    }
    [Symbol.asyncIterator]() {
        if (this[kLineObjectStream] === undefined) {
            if (Readable1 === undefined) {
                Readable1 = require("stream").Readable;
            }
            const readable = new Readable1({
                objectMode: true,
                read: ()=>{
                    this.resume();
                },
                destroy: (err170, cb)=>{
                    this.off("line", lineListener);
                    this.off("close", closeListener);
                    this.close();
                    cb(err170);
                }
            });
            const lineListener = (input)=>{
                if (!readable.push(input)) {
                    this.pause();
                }
            };
            const closeListener = ()=>{
                readable.push(null);
            };
            const errorListener = (err171)=>{
                readable.destroy(err171);
            };
            this.on("error", errorListener);
            this.on("line", lineListener);
            this.on("close", closeListener);
            this[kLineObjectStream] = readable;
        }
        return this[kLineObjectStream][Symbol.asyncIterator]();
    }
}
function Interface1(input, output, completer, terminal) {
    if (!(this instanceof Interface1)) {
        return new Interface1(input, output, completer, terminal);
    }
    if (input?.input && typeof input.completer === "function" && input.completer.length !== 2) {
        const { completer  } = input;
        input.completer = (v18, cb)=>cb(null, completer(v18))
        ;
    } else if (typeof completer === "function" && completer.length !== 2) {
        const realCompleter = completer;
        completer = (v19, cb)=>cb(null, realCompleter(v19))
        ;
    }
    InterfaceConstructor.bind(this)(input, output, completer, terminal);
    if (process.env.TERM === "dumb") {
        this._ttyWrite = _ttyWriteDumb.bind(this);
    }
}
Object.setPrototypeOf(Interface1.prototype, Interface.prototype);
Object.setPrototypeOf(Interface1, Interface);
const superQuestion = Interface.prototype.question;
Interface1.prototype.question = function(query, options, cb) {
    cb = typeof options === "function" ? options : cb;
    options = typeof options === "object" && options !== null ? options : {};
    if (options.signal) {
        validateAbortSignal(options.signal, "options.signal");
        if (options.signal.aborted) {
            return;
        }
        const onAbort = ()=>{
            this[kQuestionCancel]();
        };
        options.signal.addEventListener("abort", onAbort, {
            once: true
        });
        const cleanup = ()=>{
            options.signal.removeEventListener(onAbort);
        };
        cb = typeof cb === "function" ? (answer)=>{
            cleanup();
            return cb(answer);
        } : cleanup;
    }
    if (typeof cb === "function") {
        superQuestion.call(this, query, cb);
    }
};
Interface1.prototype.question[promisify.custom] = function(query, options) {
    options = typeof options === "object" && options !== null ? options : {};
    if (options.signal && options.signal.aborted) {
        return Promise.reject(new AbortError());
    }
    return new Promise((resolve20, reject)=>{
        let cb = resolve20;
        if (options.signal) {
            const onAbort = ()=>{
                reject(new AbortError());
            };
            options.signal.addEventListener("abort", onAbort, {
                once: true
            });
            cb = (answer)=>{
                options.signal.removeEventListener("abort", onAbort);
                resolve20(answer);
            };
        }
        this.question(query, options, cb);
    });
};
function createInterface(input, output, completer, terminal) {
    return new Interface1(input, output, completer, terminal);
}
Object.defineProperties(Interface1.prototype, {
    [kSetRawMode]: {
        get () {
            return this._setRawMode;
        }
    },
    [kOnLine]: {
        get () {
            return this._onLine;
        }
    },
    [kWriteToOutput]: {
        get () {
            return this._writeToOutput;
        }
    },
    [kAddHistory]: {
        get () {
            return this._addHistory;
        }
    },
    [kRefreshLine]: {
        get () {
            return this._refreshLine;
        }
    },
    [kNormalWrite]: {
        get () {
            return this._normalWrite;
        }
    },
    [kInsertString]: {
        get () {
            return this._insertString;
        }
    },
    [kTabComplete]: {
        get () {
            return this._tabComplete;
        }
    },
    [kWordLeft]: {
        get () {
            return this._wordLeft;
        }
    },
    [kWordRight]: {
        get () {
            return this._wordRight;
        }
    },
    [kDeleteLeft]: {
        get () {
            return this._deleteLeft;
        }
    },
    [kDeleteRight]: {
        get () {
            return this._deleteRight;
        }
    },
    [kDeleteWordLeft]: {
        get () {
            return this._deleteWordLeft;
        }
    },
    [kDeleteWordRight]: {
        get () {
            return this._deleteWordRight;
        }
    },
    [kDeleteLineLeft]: {
        get () {
            return this._deleteLineLeft;
        }
    },
    [kDeleteLineRight]: {
        get () {
            return this._deleteLineRight;
        }
    },
    [kLine]: {
        get () {
            return this._line;
        }
    },
    [kHistoryNext]: {
        get () {
            return this._historyNext;
        }
    },
    [kHistoryPrev]: {
        get () {
            return this._historyPrev;
        }
    },
    [kGetDisplayPos]: {
        get () {
            return this._getDisplayPos;
        }
    },
    [kMoveCursor]: {
        get () {
            return this._moveCursor;
        }
    },
    [kTtyWrite]: {
        get () {
            return this._ttyWrite;
        }
    },
    _decoder: {
        get () {
            return this[kDecoder];
        },
        set (value) {
            this[kDecoder] = value;
        }
    },
    _line_buffer: {
        get () {
            return this[kLine_buffer];
        },
        set (value) {
            this[kLine_buffer] = value;
        }
    },
    _oldPrompt: {
        get () {
            return this[kOldPrompt];
        },
        set (value) {
            this[kOldPrompt] = value;
        }
    },
    _previousKey: {
        get () {
            return this[kPreviousKey];
        },
        set (value) {
            this[kPreviousKey] = value;
        }
    },
    _prompt: {
        get () {
            return this[kPrompt];
        },
        set (value) {
            this[kPrompt] = value;
        }
    },
    _questionCallback: {
        get () {
            return this[kQuestionCallback];
        },
        set (value) {
            this[kQuestionCallback] = value;
        }
    },
    _sawKeyPress: {
        get () {
            return this[kSawKeyPress];
        },
        set (value) {
            this[kSawKeyPress] = value;
        }
    },
    _sawReturnAt: {
        get () {
            return this[kSawReturnAt];
        },
        set (value) {
            this[kSawReturnAt] = value;
        }
    }
});
Interface1.prototype._setRawMode = Interface.prototype[kSetRawMode];
Interface1.prototype._onLine = Interface.prototype[kOnLine];
Interface1.prototype._writeToOutput = Interface.prototype[kWriteToOutput];
Interface1.prototype._addHistory = Interface.prototype[kAddHistory];
Interface1.prototype._refreshLine = Interface.prototype[kRefreshLine];
Interface1.prototype._normalWrite = Interface.prototype[kNormalWrite];
Interface1.prototype._insertString = Interface.prototype[kInsertString];
Interface1.prototype._tabComplete = function(lastKeypressWasTab) {
    this.pause();
    const string = this.line.slice(0, this.cursor);
    this.completer(string, (err172, value)=>{
        this.resume();
        if (err172) {
            this._writeToOutput(`Tab completion error: ${err172}`);
            return;
        }
        this[kTabCompleter](lastKeypressWasTab, value);
    });
};
Interface1.prototype._wordLeft = Interface.prototype[kWordLeft];
Interface1.prototype._wordRight = Interface.prototype[kWordRight];
Interface1.prototype._deleteLeft = Interface.prototype[kDeleteLeft];
Interface1.prototype._deleteRight = Interface.prototype[kDeleteRight];
Interface1.prototype._deleteWordLeft = Interface.prototype[kDeleteWordLeft];
Interface1.prototype._deleteWordRight = Interface.prototype[kDeleteWordRight];
Interface1.prototype._deleteLineLeft = Interface.prototype[kDeleteLineLeft];
Interface1.prototype._deleteLineRight = Interface.prototype[kDeleteLineRight];
Interface1.prototype._line = Interface.prototype[kLine];
Interface1.prototype._historyNext = Interface.prototype[kHistoryNext];
Interface1.prototype._historyPrev = Interface.prototype[kHistoryPrev];
Interface1.prototype._getDisplayPos = Interface.prototype[kGetDisplayPos];
Interface1.prototype._getCursorPos = Interface.prototype.getCursorPos;
Interface1.prototype._moveCursor = Interface.prototype[kMoveCursor];
Interface1.prototype._ttyWrite = Interface.prototype[kTtyWrite];
function _ttyWriteDumb(s36, key) {
    key = key || {};
    if (key.name === "escape") return;
    if (this[kSawReturnAt] && key.name !== "enter") {
        this[kSawReturnAt] = 0;
    }
    if (key.ctrl) {
        if (key.name === "c") {
            if (this.listenerCount("SIGINT") > 0) {
                this.emit("SIGINT");
            } else {
                this.close();
            }
            return;
        } else if (key.name === "d") {
            this.close();
            return;
        }
    }
    switch(key.name){
        case "return":
            this[kSawReturnAt] = Date.now();
            this._line();
            break;
        case "enter":
            if (this[kSawReturnAt] === 0 || Date.now() - this[kSawReturnAt] > this.crlfDelay) {
                this._line();
            }
            this[kSawReturnAt] = 0;
            break;
        default:
            if (typeof s36 === "string" && s36) {
                this.line += s36;
                this.cursor += s36.length;
                this._writeToOutput(s36);
            }
    }
}
const __default48 = {
    Interface: Interface1,
    clearLine,
    clearScreenDown,
    createInterface,
    cursorTo,
    emitKeypressEvents,
    moveCursor
};
class REPLServer {
    constructor(){
        notImplemented();
    }
}
const builtinModules = [
    "assert",
    "async_hooks",
    "buffer",
    "child_process",
    "cluster",
    "console",
    "constants",
    "crypto",
    "dgram",
    "diagnostics_channel",
    "dns",
    "domain",
    "events",
    "fs",
    "http",
    "http2",
    "https",
    "inspector",
    "module",
    "net",
    "os",
    "path",
    "perf_hooks",
    "process",
    "punycode",
    "querystring",
    "readline",
    "repl",
    "stream",
    "string_decoder",
    "sys",
    "timers",
    "tls",
    "trace_events",
    "tty",
    "url",
    "util",
    "v8",
    "vm",
    "wasi",
    "worker_threads",
    "zlib", 
];
function start() {
    notImplemented();
}
const __default49 = {
    REPLServer,
    builtinModules,
    start
};
async function blob(stream11) {
    const chunks = [];
    for await (const chunk of stream11){
        chunks.push(chunk);
    }
    return new Blob(chunks);
}
async function arrayBuffer(stream12) {
    const ret = await blob(stream12);
    return ret.arrayBuffer();
}
async function buffer(stream13) {
    return Buffer1.from(await arrayBuffer(stream13));
}
async function text(stream14) {
    const dec = new TextDecoder();
    let str = "";
    for await (const chunk of stream14){
        if (typeof chunk === "string") {
            str += chunk;
        } else {
            str += dec.decode(chunk, {
                stream: true
            });
        }
    }
    str += dec.decode(undefined, {
        stream: false
    });
    return str;
}
async function json(stream15) {
    const str = await text(stream15);
    return JSON.parse(str);
}
const __default50 = {
    arrayBuffer,
    blob,
    buffer,
    json,
    text
};
const __default51 = {
    ReadableStream,
    ReadableStreamDefaultReader,
    ReadableByteStreamController,
    ReadableStreamDefaultController,
    TransformStream,
    TransformStreamDefaultController,
    WritableStream,
    WritableStreamDefaultWriter,
    WritableStreamDefaultController,
    ByteLengthQueuingStrategy,
    CountQueuingStrategy,
    TextEncoderStream,
    TextDecoderStream
};
const setTimeout1 = promisify(__default15.setTimeout), setImmediate1 = promisify(__default15.setImmediate), setInterval1 = promisify(__default15.setInterval);
const __default52 = {
    setTimeout: setTimeout1,
    setImmediate: setImmediate1,
    setInterval: setInterval1
};
function createSecureContext(options) {
    return {
        ca: options?.ca,
        cert: options?.cert,
        key: options?.key
    };
}
const __default53 = {
    createSecureContext
};
Array.isArray;
const ObjectAssign = Object.assign;
String.fromCharCode;
const StringPrototypeReplace = (that, ...args)=>that.replace(...args)
;
const kConnectOptions = Symbol("connect-options");
const kIsVerified = Symbol("verified");
const kPendingSession = Symbol("pendingSession");
const kRes = Symbol("res");
debuglog("tls", (fn)=>{});
function onConnectEnd() {
    if (!this._hadError) {
        const options = this[kConnectOptions];
        this._hadError = true;
        const error24 = connResetException("Client network socket disconnected " + "before secure TLS connection was " + "established");
        error24.path = options.path;
        error24.host = options.host;
        error24.port = options.port;
        error24.localAddress = options.localAddress;
        this.destroy(error24);
    }
}
class TLSSocket extends Socket {
    _tlsOptions;
    _secureEstablished;
    _securePending;
    _newSessionPending;
    _controlReleased;
    secureConnecting;
    _SNICallback;
    servername;
    alpnProtocol;
    authorized;
    authorizationError;
    [kRes];
    [kIsVerified];
    [kPendingSession];
    [kConnectOptions];
    ssl;
    _start;
    constructor(socket, opts){
        const tlsOptions1 = {
            ...opts
        };
        let hostname15 = tlsOptions1?.secureContext?.servername;
        hostname15 = opts.host;
        tlsOptions1.hostname = hostname15;
        tlsOptions1?.secureContext?.cert;
        tlsOptions1?.secureContext?.key;
        let caCerts1 = tlsOptions1?.secureContext?.ca;
        if (typeof caCerts1 === "string") caCerts1 = [
            caCerts1
        ];
        tlsOptions1.caCerts = caCerts1;
        super({
            handle: _wrapHandle(tlsOptions1, socket),
            ...opts,
            manualStart: true
        });
        if (socket) {
            this._parent = socket;
        }
        this._tlsOptions = tlsOptions1;
        this._secureEstablished = false;
        this._securePending = false;
        this._newSessionPending = false;
        this._controlReleased = false;
        this.secureConnecting = true;
        this._SNICallback = null;
        this.servername = null;
        this.alpnProtocol = null;
        this.authorized = false;
        this.authorizationError = null;
        this[kRes] = null;
        this[kIsVerified] = false;
        this[kPendingSession] = null;
        this.ssl = new class {
            verifyError() {
                return null;
            }
        }();
        const tlssock = this;
        function _wrapHandle(tlsOptions, wrap2) {
            let handle;
            if (wrap2) {
                handle = wrap2._handle;
            }
            const options = tlsOptions;
            if (!handle) {
                handle = options.pipe ? new Pipe(constants2.SOCKET) : new TCP(constants3.SOCKET);
            }
            const afterConnect = handle.afterConnect;
            handle.afterConnect = async (req29, status)=>{
                try {
                    const conn = await Deno.startTls(handle[kStreamBaseField], options);
                    tlssock.emit("secure");
                    tlssock.removeListener("end", onConnectEnd);
                    handle[kStreamBaseField] = conn;
                } catch  {}
                return afterConnect.call(handle, req29, status);
            };
            handle.verifyError = function() {
                return null;
            };
            return handle;
        }
    }
    _tlsError(err173) {
        this.emit("_tlsError", err173);
        if (this._controlReleased) {
            return err173;
        }
        return null;
    }
    _releaseControl() {
        if (this._controlReleased) {
            return false;
        }
        this._controlReleased = true;
        this.removeListener("error", this._tlsError);
        return true;
    }
    getEphemeralKeyInfo() {
        return {};
    }
    isSessionReused() {
        return false;
    }
    setSession(_session) {}
    setServername(_servername) {}
    getPeerCertificate(_detailed) {
        return {
            subject: "localhost",
            subjectaltname: "IP Address:127.0.0.1, IP Address:::1"
        };
    }
}
function normalizeConnectArgs(listArgs) {
    const args = _normalizeArgs(listArgs);
    const options = args[0];
    const cb = args[1];
    if (listArgs[1] !== null && typeof listArgs[1] === "object") {
        ObjectAssign(options, listArgs[1]);
    } else if (listArgs[2] !== null && typeof listArgs[2] === "object") {
        ObjectAssign(options, listArgs[2]);
    }
    return cb ? [
        options,
        cb
    ] : [
        options
    ];
}
let ipServernameWarned = false;
function Server3(options, listener) {
    return new ServerImpl1(options, listener);
}
class ServerImpl1 extends EventEmitter {
    options;
    listener;
    #closed = false;
    constructor(options, listener){
        super();
        this.options = options;
        if (listener) {
            this.on("secureConnection", listener);
        }
    }
    listen(port13, callback) {
        const { key , cert  } = this.options;
        const tmpdir1 = Deno.makeTempDirSync();
        const certFile = join8(tmpdir1, "cert");
        const keyFile = join8(tmpdir1, "key");
        Deno.writeTextFileSync(certFile, cert);
        Deno.writeTextFileSync(keyFile, key);
        const hostname16 = "localhost";
        this.listener = Deno.listenTls({
            port: port13,
            hostname: hostname16,
            certFile,
            keyFile
        });
        Deno.remove(tmpdir1, {
            recursive: true
        });
        callback?.();
        this.#listen(this.listener);
        return this;
    }
    async #listen(listener) {
        while(!this.#closed){
            try {
                const handle = new TCP(constants3.SOCKET, await listener.accept());
                const socket = new Socket({
                    handle
                });
                this.emit("secureConnection", socket);
            } catch (e) {
                if (e instanceof Deno.errors.BadResource) {
                    this.#closed = true;
                }
            }
        }
    }
    close(cb) {
        if (this.listener) {
            this.listener.close();
        }
        cb?.();
        return this;
    }
}
Server3.prototype = ServerImpl1.prototype;
function createServer4(options, listener1) {
    return new ServerImpl1(options, listener1);
}
function connect2(...args) {
    args = normalizeConnectArgs(args);
    let options = args[0];
    const cb = args[1];
    const allowUnauthorized = getAllowUnauthorized();
    options = {
        rejectUnauthorized: !allowUnauthorized,
        ciphers: DEFAULT_CIPHERS,
        checkServerIdentity,
        minDHSize: 1024,
        ...options
    };
    if (!options.keepAlive) {
        options.singleUse = true;
    }
    assert2(typeof options.checkServerIdentity === "function");
    assert2(typeof options.minDHSize === "number", "options.minDHSize is not a number: " + options.minDHSize);
    assert2(options.minDHSize > 0, "options.minDHSize is not a positive number: " + options.minDHSize);
    const context = options.secureContext || createSecureContext(options);
    const tlssock = new TLSSocket(options.socket, {
        allowHalfOpen: options.allowHalfOpen,
        pipe: !!options.path,
        secureContext: context,
        isServer: false,
        requestCert: true,
        rejectUnauthorized: options.rejectUnauthorized !== false,
        session: options.session,
        ALPNProtocols: options.ALPNProtocols,
        requestOCSP: options.requestOCSP,
        enableTrace: options.enableTrace,
        pskCallback: options.pskCallback,
        highWaterMark: options.highWaterMark,
        onread: options.onread,
        signal: options.signal,
        ...options
    });
    options.rejectUnauthorized = options.rejectUnauthorized !== false;
    tlssock[kConnectOptions] = options;
    if (cb) {
        tlssock.once("secureConnect", cb);
    }
    if (!options.socket) {
        if (options.timeout) {
            tlssock.setTimeout(options.timeout);
        }
        tlssock.connect(options, tlssock._start);
    }
    tlssock._releaseControl();
    if (options.session) {
        tlssock.setSession(options.session);
    }
    if (options.servername) {
        if (!ipServernameWarned && isIP(options.servername)) {
            emitWarning("Setting the TLS ServerName to an IP address is not permitted by " + "RFC 6066. This will be ignored in a future version.", "DeprecationWarning", "DEP0123");
            ipServernameWarned = true;
        }
        tlssock.setServername(options.servername);
    }
    if (options.socket) {
        tlssock._start();
    }
    tlssock.prependListener("end", onConnectEnd);
    return tlssock;
}
function getAllowUnauthorized() {
    return false;
}
function checkServerIdentity(_hostname, _cert) {}
function unfqdn(host) {
    return StringPrototypeReplace(host, /[.]$/, "");
}
const DEFAULT_CIPHERS = [
    "AES256-GCM-SHA384",
    "AES128-GCM-SHA256",
    "TLS_CHACHA20_POLY1305_SHA256",
    "ECDHE-ECDSA-AES256-GCM-SHA384",
    "ECDHE-ECDSA-AES128-GCM-SHA256",
    "ECDHE-ECDSA-CHACHA20-POLY1305",
    "ECDHE-RSA-AES256-GCM-SHA384",
    "ECDHE-RSA-AES128-GCM-SHA256",
    "ECDHE-RSA-CHACHA20-POLY1305", 
].join(":");
const __default54 = {
    TLSSocket,
    connect: connect2,
    createServer: createServer4,
    checkServerIdentity,
    DEFAULT_CIPHERS,
    unfqdn
};
const cipherMap = {
    "__proto__": null,
    "AES128-GCM-SHA256": "TLS13_AES_128_GCM_SHA256",
    "AES256-GCM-SHA384": "TLS13_AES_256_GCM_SHA384",
    "ECDHE-ECDSA-AES128-GCM-SHA256": "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
    "ECDHE-ECDSA-AES256-GCM-SHA384": "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
    "ECDHE-ECDSA-CHACHA20-POLY1305": "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",
    "ECDHE-RSA-AES128-GCM-SHA256": "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
    "ECDHE-RSA-AES256-GCM-SHA384": "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
    "ECDHE-RSA-CHACHA20-POLY1305": "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
    "TLS_AES_128_GCM_SHA256": "TLS13_AES_128_GCM_SHA256",
    "TLS_AES_256_GCM_SHA384": "TLS13_AES_256_GCM_SHA384",
    "TLS_CHACHA20_POLY1305_SHA256": "TLS13_CHACHA20_POLY1305_SHA256"
};
function getCiphers() {
    return Object.keys(cipherMap).map((name74)=>name74.toLowerCase()
    );
}
const rootCertificates = undefined;
const DEFAULT_ECDH_CURVE = "auto";
const DEFAULT_MAX_VERSION = "TLSv1.3";
const DEFAULT_MIN_VERSION = "TLSv1.2";
class CryptoStream {
}
class SecurePair {
}
class Server4 {
}
function createSecurePair() {
    notImplemented();
}
__default53.createSecureContext;
__default54.TLSSocket;
__default54.createServer;
__default54.connect;
const __default55 = {
    CryptoStream,
    SecurePair,
    Server: Server4,
    TLSSocket: __default54.TLSSocket,
    checkServerIdentity: __default54.checkServerIdentity,
    connect: __default54.connect,
    createSecureContext: __default53.createSecureContext,
    createSecurePair,
    createServer: __default54.createServer,
    getCiphers,
    rootCertificates,
    DEFAULT_CIPHERS: __default54.DEFAULT_CIPHERS,
    DEFAULT_ECDH_CURVE,
    DEFAULT_MAX_VERSION,
    DEFAULT_MIN_VERSION
};
function isatty(fd) {
    if (typeof fd !== "number") {
        return false;
    }
    try {
        return Deno.isatty(fd);
    } catch (_) {
        return false;
    }
}
class ReadStream extends Socket {
}
class WriteStream1 extends Socket {
}
const __default56 = {
    isatty,
    WriteStream: WriteStream1,
    ReadStream
};
function cachedDataVersionTag() {
    notImplemented();
}
function getHeapCodeStatistics() {
    notImplemented();
}
function getHeapSnapshot() {
    notImplemented();
}
function getHeapSpaceStatistics() {
    notImplemented();
}
function getHeapStatistics() {
    notImplemented();
}
function setFlagsFromString() {
    notImplemented();
}
function stopCoverage() {
    notImplemented();
}
function takeCoverage() {
    notImplemented();
}
function writeHeapSnapshot() {
    notImplemented();
}
function serialize() {
    notImplemented();
}
function deserialize() {
    notImplemented();
}
class Serializer {
    constructor(){
        notImplemented();
    }
}
class Deserializer {
    constructor(){
        notImplemented();
    }
}
class DefaultSerializer {
    constructor(){
        notImplemented();
    }
}
class DefaultDeserializer {
    constructor(){
        notImplemented();
    }
}
const promiseHooks = {
    onInit () {
        notImplemented();
    },
    onSettled () {
        notImplemented();
    },
    onBefore () {
        notImplemented();
    },
    createHook () {
        notImplemented();
    }
};
const __default57 = {
    cachedDataVersionTag,
    getHeapCodeStatistics,
    getHeapSnapshot,
    getHeapSpaceStatistics,
    getHeapStatistics,
    setFlagsFromString,
    stopCoverage,
    takeCoverage,
    writeHeapSnapshot,
    serialize,
    deserialize,
    Serializer,
    Deserializer,
    DefaultSerializer,
    DefaultDeserializer,
    promiseHooks
};
class Script {
    code;
    constructor(code63, _options = {}){
        this.code = `${code63}`;
    }
    runInThisContext(_options) {
        return eval.call(globalThis, this.code);
    }
    runInContext(_contextifiedObject, _options) {
        notImplemented();
    }
    runInNewContext(_contextObject, _options) {
        notImplemented();
    }
    createCachedData() {
        notImplemented();
    }
}
function createContext(_contextObject, _options) {
    notImplemented();
}
function createScript(code64, options) {
    return new Script(code64, options);
}
function runInContext(_code, _contextifiedObject, _options) {
    notImplemented();
}
function runInNewContext(_code, _contextObject, _options) {
    notImplemented();
}
function runInThisContext(code65, options) {
    return createScript(code65, options).runInThisContext(options);
}
function isContext(_maybeContext) {
    notImplemented();
}
function compileFunction(_code, _params, _options) {
    notImplemented();
}
function measureMemory(_options) {
    notImplemented();
}
const __default58 = {
    Script,
    createContext,
    createScript,
    runInContext,
    runInNewContext,
    runInThisContext,
    isContext,
    compileFunction,
    measureMemory
};
function getEnvironmentData() {
    notImplemented();
}
const isMainThread = undefined;
function markAsUntransferable() {
    notImplemented();
}
function moveMessagePortToContext() {
    notImplemented();
}
const parentPort = undefined;
function receiveMessageOnPort() {
    notImplemented();
}
const resourceLimits = undefined;
const SHARE_ENV = undefined;
function setEnvironmentData() {
    notImplemented();
}
const threadId = undefined;
const workerData = undefined;
class BroadcastChannel {
    constructor(){
        notImplemented();
    }
}
class MessageChannel {
    constructor(){
        notImplemented();
    }
}
class MessagePort {
    constructor(){
        notImplemented();
    }
}
class Worker1 {
    constructor(){
        notImplemented();
    }
}
const __default59 = {
    getEnvironmentData,
    isMainThread,
    markAsUntransferable,
    moveMessagePortToContext,
    parentPort,
    receiveMessageOnPort,
    resourceLimits,
    SHARE_ENV,
    setEnvironmentData,
    threadId,
    workerData,
    BroadcastChannel,
    MessageChannel,
    MessagePort,
    Worker: Worker1
};
const CLOCKID_REALTIME = 0;
const CLOCKID_MONOTONIC = 1;
const CLOCKID_PROCESS_CPUTIME_ID = 2;
const CLOCKID_THREAD_CPUTIME_ID = 3;
const ERRNO_SUCCESS = 0;
const ERRNO_BADF = 8;
const ERRNO_INVAL = 28;
const ERRNO_NOSYS = 52;
const ERRNO_NOTDIR = 54;
const ERRNO_NOTCAPABLE = 76;
const RIGHTS_FD_DATASYNC = 1n;
const RIGHTS_FD_READ = 2n;
const RIGHTS_FD_WRITE = 64n;
const RIGHTS_FD_ALLOCATE = 256n;
const RIGHTS_FD_READDIR = 16384n;
const RIGHTS_FD_FILESTAT_SET_SIZE = 4194304n;
const FILETYPE_UNKNOWN = 0;
const FILETYPE_CHARACTER_DEVICE = 2;
const FILETYPE_DIRECTORY = 3;
const FILETYPE_REGULAR_FILE = 4;
const FILETYPE_SYMBOLIC_LINK = 7;
const FDFLAGS_APPEND = 1;
const FSTFLAGS_ATIM_NOW = 2;
const FSTFLAGS_MTIM_NOW = 8;
const LOOKUPFLAGS_SYMLINK_FOLLOW = 1;
const OFLAGS_CREAT = 1;
const OFLAGS_DIRECTORY = 2;
const OFLAGS_EXCL = 4;
const OFLAGS_TRUNC = 8;
const PREOPENTYPE_DIR = 0;
function syscall(target) {
    return function(...args) {
        try {
            return target(...args);
        } catch (err174) {
            if (err174 instanceof ExitStatus) {
                throw err174;
            }
            if (!(err174 instanceof Error)) {
                return 28;
            }
            switch(err174.name){
                case "NotFound":
                    return 44;
                case "PermissionDenied":
                    return 2;
                case "ConnectionRefused":
                    return 14;
                case "ConnectionReset":
                    return 15;
                case "ConnectionAborted":
                    return 13;
                case "NotConnected":
                    return 53;
                case "AddrInUse":
                    return 3;
                case "AddrNotAvailable":
                    return 4;
                case "BrokenPipe":
                    return 64;
                case "InvalidData":
                    return 28;
                case "TimedOut":
                    return 73;
                case "Interrupted":
                    return 27;
                case "BadResource":
                    return 8;
                case "Busy":
                    return 10;
                default:
                    return 28;
            }
        }
    };
}
class ExitStatus {
    code;
    constructor(code66){
        this.code = code66;
    }
}
class Context {
    #args;
    #env;
    #exitOnReturn;
    #memory;
    #fds;
    #started;
    exports;
    constructor(options1){
        this.#args = options1.args ?? [];
        this.#env = options1.env ?? {};
        this.#exitOnReturn = options1.exitOnReturn ?? true;
        this.#memory = null;
        this.#fds = [
            {
                rid: options1.stdin ?? Deno.stdin.rid,
                type: FILETYPE_CHARACTER_DEVICE,
                flags: FDFLAGS_APPEND
            },
            {
                rid: options1.stdout ?? Deno.stdout.rid,
                type: FILETYPE_CHARACTER_DEVICE,
                flags: FDFLAGS_APPEND
            },
            {
                rid: options1.stderr ?? Deno.stderr.rid,
                type: FILETYPE_CHARACTER_DEVICE,
                flags: FDFLAGS_APPEND
            }, 
        ];
        if (options1.preopens) {
            for (const [vpath, path115] of Object.entries(options1.preopens)){
                const entries = Array.from(Deno.readDirSync(path115));
                const entry = {
                    type: 3,
                    entries,
                    path: path115,
                    vpath
                };
                this.#fds.push(entry);
            }
        }
        this.exports = {
            "args_get": syscall((argvOffset, argvBufferOffset)=>{
                const args = this.#args;
                const textEncoder = new TextEncoder();
                const memoryData = new Uint8Array(this.#memory.buffer);
                const memoryView = new DataView(this.#memory.buffer);
                for (const arg of args){
                    memoryView.setUint32(argvOffset, argvBufferOffset, true);
                    argvOffset += 4;
                    const data73 = textEncoder.encode(`${arg}\0`);
                    memoryData.set(data73, argvBufferOffset);
                    argvBufferOffset += data73.length;
                }
                return ERRNO_SUCCESS;
            }),
            "args_sizes_get": syscall((argcOffset, argvBufferSizeOffset)=>{
                const args = this.#args;
                const textEncoder = new TextEncoder();
                const memoryView = new DataView(this.#memory.buffer);
                memoryView.setUint32(argcOffset, args.length, true);
                memoryView.setUint32(argvBufferSizeOffset, args.reduce(function(acc, arg) {
                    return acc + textEncoder.encode(`${arg}\0`).length;
                }, 0), true);
                return ERRNO_SUCCESS;
            }),
            "environ_get": syscall((environOffset, environBufferOffset)=>{
                const entries = Object.entries(this.#env);
                const textEncoder = new TextEncoder();
                const memoryData = new Uint8Array(this.#memory.buffer);
                const memoryView = new DataView(this.#memory.buffer);
                for (const [key, value] of entries){
                    memoryView.setUint32(environOffset, environBufferOffset, true);
                    environOffset += 4;
                    const data74 = textEncoder.encode(`${key}=${value}\0`);
                    memoryData.set(data74, environBufferOffset);
                    environBufferOffset += data74.length;
                }
                return ERRNO_SUCCESS;
            }),
            "environ_sizes_get": syscall((environcOffset, environBufferSizeOffset)=>{
                const entries = Object.entries(this.#env);
                const textEncoder = new TextEncoder();
                const memoryView = new DataView(this.#memory.buffer);
                memoryView.setUint32(environcOffset, entries.length, true);
                memoryView.setUint32(environBufferSizeOffset, entries.reduce(function(acc, [key, value]) {
                    return acc + textEncoder.encode(`${key}=${value}\0`).length;
                }, 0), true);
                return ERRNO_SUCCESS;
            }),
            "clock_res_get": syscall((id, resolutionOffset)=>{
                const memoryView = new DataView(this.#memory.buffer);
                switch(id){
                    case CLOCKID_REALTIME:
                        {
                            const resolution = BigInt(1000000);
                            memoryView.setBigUint64(resolutionOffset, resolution, true);
                            break;
                        }
                    case CLOCKID_MONOTONIC:
                    case CLOCKID_PROCESS_CPUTIME_ID:
                    case CLOCKID_THREAD_CPUTIME_ID:
                        {
                            const resolution = BigInt(1000);
                            memoryView.setBigUint64(resolutionOffset, resolution, true);
                            break;
                        }
                    default:
                        return ERRNO_INVAL;
                }
                return ERRNO_SUCCESS;
            }),
            "clock_time_get": syscall((id, precision, timeOffset)=>{
                const memoryView = new DataView(this.#memory.buffer);
                switch(id){
                    case CLOCKID_REALTIME:
                        {
                            const time7 = BigInt(Date.now()) * BigInt(1000000);
                            memoryView.setBigUint64(timeOffset, time7, true);
                            break;
                        }
                    case CLOCKID_MONOTONIC:
                    case CLOCKID_PROCESS_CPUTIME_ID:
                    case CLOCKID_THREAD_CPUTIME_ID:
                        {
                            const t17 = performance.now();
                            const s37 = Math.trunc(t17);
                            const ms = Math.floor((t17 - s37) * 1000);
                            const time8 = BigInt(s37) * BigInt(1000000000) + BigInt(ms) * BigInt(1000000);
                            memoryView.setBigUint64(timeOffset, time8, true);
                            break;
                        }
                    default:
                        return ERRNO_INVAL;
                }
                return ERRNO_SUCCESS;
            }),
            "fd_advise": syscall((_fd, _offset, _length, _advice)=>{
                return ERRNO_NOSYS;
            }),
            "fd_allocate": syscall((_fd, _offset, _length)=>{
                return ERRNO_NOSYS;
            }),
            "fd_close": syscall((fd)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (entry.rid) {
                    Deno.close(entry.rid);
                }
                delete this.#fds[fd];
                return ERRNO_SUCCESS;
            }),
            "fd_datasync": syscall((fd)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                Deno.fdatasyncSync(entry.rid);
                return ERRNO_SUCCESS;
            }),
            "fd_fdstat_get": syscall((fd, offset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                const memoryView = new DataView(this.#memory.buffer);
                memoryView.setUint8(offset, entry.type);
                memoryView.setUint16(offset + 2, entry.flags, true);
                memoryView.setBigUint64(offset + 8, 0n, true);
                memoryView.setBigUint64(offset + 16, 0n, true);
                return ERRNO_SUCCESS;
            }),
            "fd_fdstat_set_flags": syscall((_fd, _flags)=>{
                return ERRNO_NOSYS;
            }),
            "fd_fdstat_set_rights": syscall((_fd, _rightsBase, _rightsInheriting)=>{
                return ERRNO_NOSYS;
            }),
            "fd_filestat_get": syscall((fd, offset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                const memoryView = new DataView(this.#memory.buffer);
                const info3 = Deno.fstatSync(entry.rid);
                if (entry.type === undefined) {
                    switch(true){
                        case info3.isFile:
                            entry.type = FILETYPE_REGULAR_FILE;
                            break;
                        case info3.isDirectory:
                            entry.type = FILETYPE_DIRECTORY;
                            break;
                        case info3.isSymlink:
                            entry.type = FILETYPE_SYMBOLIC_LINK;
                            break;
                        default:
                            entry.type = FILETYPE_UNKNOWN;
                            break;
                    }
                }
                memoryView.setBigUint64(offset, BigInt(info3.dev ? info3.dev : 0), true);
                offset += 8;
                memoryView.setBigUint64(offset, BigInt(info3.ino ? info3.ino : 0), true);
                offset += 8;
                memoryView.setUint8(offset, entry.type);
                offset += 8;
                memoryView.setUint32(offset, Number(info3.nlink), true);
                offset += 8;
                memoryView.setBigUint64(offset, BigInt(info3.size), true);
                offset += 8;
                memoryView.setBigUint64(offset, BigInt(info3.atime ? info3.atime.getTime() * 1000000 : 0), true);
                offset += 8;
                memoryView.setBigUint64(offset, BigInt(info3.mtime ? info3.mtime.getTime() * 1000000 : 0), true);
                offset += 8;
                memoryView.setBigUint64(offset, BigInt(info3.birthtime ? info3.birthtime.getTime() * 1000000 : 0), true);
                offset += 8;
                return ERRNO_SUCCESS;
            }),
            "fd_filestat_set_size": syscall((fd, size)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                Deno.ftruncateSync(entry.rid, Number(size));
                return ERRNO_SUCCESS;
            }),
            "fd_filestat_set_times": syscall((fd, atim, mtim, flags)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (!entry.path) {
                    return ERRNO_INVAL;
                }
                if ((flags & FSTFLAGS_ATIM_NOW) == FSTFLAGS_ATIM_NOW) {
                    atim = BigInt(Date.now() * 1000000);
                }
                if ((flags & FSTFLAGS_MTIM_NOW) == FSTFLAGS_MTIM_NOW) {
                    mtim = BigInt(Date.now() * 1000000);
                }
                utimeSync(entry.path, Number(atim), Number(mtim));
                return ERRNO_SUCCESS;
            }),
            "fd_pread": syscall((fd, iovsOffset, iovsLength, offset, nreadOffset)=>{
                const entry = this.#fds[fd];
                if (entry == null) {
                    return ERRNO_BADF;
                }
                const seek = Deno.seekSync(entry.rid, 0, Deno.SeekMode.Current);
                const memoryView = new DataView(this.#memory.buffer);
                let nread = 0;
                for(let i239 = 0; i239 < iovsLength; i239++){
                    const dataOffset = memoryView.getUint32(iovsOffset, true);
                    iovsOffset += 4;
                    const dataLength = memoryView.getUint32(iovsOffset, true);
                    iovsOffset += 4;
                    const data75 = new Uint8Array(this.#memory.buffer, dataOffset, dataLength);
                    nread += Deno.readSync(entry.rid, data75);
                }
                Deno.seekSync(entry.rid, seek, Deno.SeekMode.Start);
                memoryView.setUint32(nreadOffset, nread, true);
                return ERRNO_SUCCESS;
            }),
            "fd_prestat_get": syscall((fd, prestatOffset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (!entry.vpath) {
                    return ERRNO_BADF;
                }
                const memoryView = new DataView(this.#memory.buffer);
                memoryView.setUint8(prestatOffset, PREOPENTYPE_DIR);
                memoryView.setUint32(prestatOffset + 4, new TextEncoder().encode(entry.vpath).byteLength, true);
                return ERRNO_SUCCESS;
            }),
            "fd_prestat_dir_name": syscall((fd, pathOffset, pathLength)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (!entry.vpath) {
                    return ERRNO_BADF;
                }
                const data76 = new Uint8Array(this.#memory.buffer, pathOffset, pathLength);
                data76.set(new TextEncoder().encode(entry.vpath));
                return ERRNO_SUCCESS;
            }),
            "fd_pwrite": syscall((fd, iovsOffset, iovsLength, offset, nwrittenOffset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                const seek = Deno.seekSync(entry.rid, 0, Deno.SeekMode.Current);
                const memoryView = new DataView(this.#memory.buffer);
                let nwritten = 0;
                for(let i240 = 0; i240 < iovsLength; i240++){
                    const dataOffset = memoryView.getUint32(iovsOffset, true);
                    iovsOffset += 4;
                    const dataLength = memoryView.getUint32(iovsOffset, true);
                    iovsOffset += 4;
                    const data77 = new Uint8Array(this.#memory.buffer, dataOffset, dataLength);
                    nwritten += Deno.writeSync(entry.rid, data77);
                }
                Deno.seekSync(entry.rid, seek, Deno.SeekMode.Start);
                memoryView.setUint32(nwrittenOffset, nwritten, true);
                return ERRNO_SUCCESS;
            }),
            "fd_read": syscall((fd, iovsOffset, iovsLength, nreadOffset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                const memoryView = new DataView(this.#memory.buffer);
                let nread = 0;
                for(let i241 = 0; i241 < iovsLength; i241++){
                    const dataOffset = memoryView.getUint32(iovsOffset, true);
                    iovsOffset += 4;
                    const dataLength = memoryView.getUint32(iovsOffset, true);
                    iovsOffset += 4;
                    const data78 = new Uint8Array(this.#memory.buffer, dataOffset, dataLength);
                    nread += Deno.readSync(entry.rid, data78);
                }
                memoryView.setUint32(nreadOffset, nread, true);
                return ERRNO_SUCCESS;
            }),
            "fd_readdir": syscall((fd, bufferOffset, bufferLength, cookie, bufferUsedOffset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                const memoryData = new Uint8Array(this.#memory.buffer);
                const memoryView = new DataView(this.#memory.buffer);
                let bufferUsed = 0;
                const entries = Array.from(Deno.readDirSync(entry.path));
                for(let i242 = Number(cookie); i242 < entries.length; i242++){
                    const nameData = new TextEncoder().encode(entries[i242].name);
                    const entryInfo = Deno.statSync(resolve2(entry.path, entries[i242].name));
                    const entryData = new Uint8Array(24 + nameData.byteLength);
                    const entryView = new DataView(entryData.buffer);
                    entryView.setBigUint64(0, BigInt(i242 + 1), true);
                    entryView.setBigUint64(8, BigInt(entryInfo.ino ? entryInfo.ino : 0), true);
                    entryView.setUint32(16, nameData.byteLength, true);
                    let type54;
                    switch(true){
                        case entries[i242].isFile:
                            type54 = FILETYPE_REGULAR_FILE;
                            break;
                        case entries[i242].isDirectory:
                            type54 = FILETYPE_REGULAR_FILE;
                            break;
                        case entries[i242].isSymlink:
                            type54 = FILETYPE_SYMBOLIC_LINK;
                            break;
                        default:
                            type54 = FILETYPE_REGULAR_FILE;
                            break;
                    }
                    entryView.setUint8(20, type54);
                    entryData.set(nameData, 24);
                    const data79 = entryData.slice(0, Math.min(entryData.length, bufferLength - bufferUsed));
                    memoryData.set(data79, bufferOffset + bufferUsed);
                    bufferUsed += data79.byteLength;
                }
                memoryView.setUint32(bufferUsedOffset, bufferUsed, true);
                return ERRNO_SUCCESS;
            }),
            "fd_renumber": syscall((fd, to)=>{
                if (!this.#fds[fd]) {
                    return ERRNO_BADF;
                }
                if (!this.#fds[to]) {
                    return ERRNO_BADF;
                }
                if (this.#fds[to].rid) {
                    Deno.close(this.#fds[to].rid);
                }
                this.#fds[to] = this.#fds[fd];
                delete this.#fds[fd];
                return ERRNO_SUCCESS;
            }),
            "fd_seek": syscall((fd, offset, whence, newOffsetOffset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                const memoryView = new DataView(this.#memory.buffer);
                const newOffset = Deno.seekSync(entry.rid, Number(offset), whence);
                memoryView.setBigUint64(newOffsetOffset, BigInt(newOffset), true);
                return ERRNO_SUCCESS;
            }),
            "fd_sync": syscall((fd)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                Deno.fsyncSync(entry.rid);
                return ERRNO_SUCCESS;
            }),
            "fd_tell": syscall((fd, offsetOffset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                const memoryView = new DataView(this.#memory.buffer);
                const offset = Deno.seekSync(entry.rid, 0, Deno.SeekMode.Current);
                memoryView.setBigUint64(offsetOffset, BigInt(offset), true);
                return ERRNO_SUCCESS;
            }),
            "fd_write": syscall((fd, iovsOffset, iovsLength, nwrittenOffset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                const memoryView = new DataView(this.#memory.buffer);
                let nwritten = 0;
                for(let i243 = 0; i243 < iovsLength; i243++){
                    const dataOffset = memoryView.getUint32(iovsOffset, true);
                    iovsOffset += 4;
                    const dataLength = memoryView.getUint32(iovsOffset, true);
                    iovsOffset += 4;
                    const data80 = new Uint8Array(this.#memory.buffer, dataOffset, dataLength);
                    nwritten += Deno.writeSync(entry.rid, data80);
                }
                memoryView.setUint32(nwrittenOffset, nwritten, true);
                return ERRNO_SUCCESS;
            }),
            "path_create_directory": syscall((fd, pathOffset, pathLength)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (!entry.path) {
                    return ERRNO_INVAL;
                }
                const textDecoder = new TextDecoder();
                const data81 = new Uint8Array(this.#memory.buffer, pathOffset, pathLength);
                const path116 = resolve2(entry.path, textDecoder.decode(data81));
                Deno.mkdirSync(path116);
                return ERRNO_SUCCESS;
            }),
            "path_filestat_get": syscall((fd, flags, pathOffset, pathLength, bufferOffset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (!entry.path) {
                    return ERRNO_INVAL;
                }
                const textDecoder = new TextDecoder();
                const data82 = new Uint8Array(this.#memory.buffer, pathOffset, pathLength);
                const path117 = resolve2(entry.path, textDecoder.decode(data82));
                const memoryView = new DataView(this.#memory.buffer);
                const info4 = (flags & LOOKUPFLAGS_SYMLINK_FOLLOW) != 0 ? Deno.statSync(path117) : Deno.lstatSync(path117);
                memoryView.setBigUint64(bufferOffset, BigInt(info4.dev ? info4.dev : 0), true);
                bufferOffset += 8;
                memoryView.setBigUint64(bufferOffset, BigInt(info4.ino ? info4.ino : 0), true);
                bufferOffset += 8;
                switch(true){
                    case info4.isFile:
                        memoryView.setUint8(bufferOffset, FILETYPE_REGULAR_FILE);
                        bufferOffset += 8;
                        break;
                    case info4.isDirectory:
                        memoryView.setUint8(bufferOffset, FILETYPE_DIRECTORY);
                        bufferOffset += 8;
                        break;
                    case info4.isSymlink:
                        memoryView.setUint8(bufferOffset, FILETYPE_SYMBOLIC_LINK);
                        bufferOffset += 8;
                        break;
                    default:
                        memoryView.setUint8(bufferOffset, FILETYPE_UNKNOWN);
                        bufferOffset += 8;
                        break;
                }
                memoryView.setUint32(bufferOffset, Number(info4.nlink), true);
                bufferOffset += 8;
                memoryView.setBigUint64(bufferOffset, BigInt(info4.size), true);
                bufferOffset += 8;
                memoryView.setBigUint64(bufferOffset, BigInt(info4.atime ? info4.atime.getTime() * 1000000 : 0), true);
                bufferOffset += 8;
                memoryView.setBigUint64(bufferOffset, BigInt(info4.mtime ? info4.mtime.getTime() * 1000000 : 0), true);
                bufferOffset += 8;
                memoryView.setBigUint64(bufferOffset, BigInt(info4.birthtime ? info4.birthtime.getTime() * 1000000 : 0), true);
                bufferOffset += 8;
                return ERRNO_SUCCESS;
            }),
            "path_filestat_set_times": syscall((fd, flags, pathOffset, pathLength, atim, mtim, fstflags)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (!entry.path) {
                    return ERRNO_INVAL;
                }
                const textDecoder = new TextDecoder();
                const data83 = new Uint8Array(this.#memory.buffer, pathOffset, pathLength);
                const path118 = resolve2(entry.path, textDecoder.decode(data83));
                if ((fstflags & FSTFLAGS_ATIM_NOW) == FSTFLAGS_ATIM_NOW) {
                    atim = BigInt(Date.now()) * BigInt(1000000);
                }
                if ((fstflags & FSTFLAGS_MTIM_NOW) == FSTFLAGS_MTIM_NOW) {
                    mtim = BigInt(Date.now()) * BigInt(1000000);
                }
                utimeSync(path118, Number(atim), Number(mtim));
                return ERRNO_SUCCESS;
            }),
            "path_link": syscall((oldFd, oldFlags, oldPathOffset, oldPathLength, newFd, newPathOffset, newPathLength)=>{
                const oldEntry = this.#fds[oldFd];
                const newEntry = this.#fds[newFd];
                if (!oldEntry || !newEntry) {
                    return ERRNO_BADF;
                }
                if (!oldEntry.path || !newEntry.path) {
                    return ERRNO_INVAL;
                }
                const textDecoder = new TextDecoder();
                const oldData = new Uint8Array(this.#memory.buffer, oldPathOffset, oldPathLength);
                const oldPath = resolve2(oldEntry.path, textDecoder.decode(oldData));
                const newData = new Uint8Array(this.#memory.buffer, newPathOffset, newPathLength);
                const newPath = resolve2(newEntry.path, textDecoder.decode(newData));
                Deno.linkSync(oldPath, newPath);
                return ERRNO_SUCCESS;
            }),
            "path_open": syscall((fd, dirflags, pathOffset, pathLength, oflags, rightsBase, rightsInheriting, fdflags, openedFdOffset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (!entry.path) {
                    return ERRNO_INVAL;
                }
                const textDecoder = new TextDecoder();
                const pathData = new Uint8Array(this.#memory.buffer, pathOffset, pathLength);
                const resolvedPath = resolve2(entry.path, textDecoder.decode(pathData));
                if (relative2(entry.path, resolvedPath).startsWith("..")) {
                    return ERRNO_NOTCAPABLE;
                }
                let path119;
                if ((dirflags & LOOKUPFLAGS_SYMLINK_FOLLOW) == LOOKUPFLAGS_SYMLINK_FOLLOW) {
                    try {
                        path119 = Deno.realPathSync(resolvedPath);
                        if (relative2(entry.path, path119).startsWith("..")) {
                            return ERRNO_NOTCAPABLE;
                        }
                    } catch (_err) {
                        path119 = resolvedPath;
                    }
                } else {
                    path119 = resolvedPath;
                }
                if ((oflags & OFLAGS_DIRECTORY) !== 0) {
                    const entries = Array.from(Deno.readDirSync(path119));
                    const openedFd = this.#fds.push({
                        flags: fdflags,
                        path: path119,
                        entries
                    }) - 1;
                    const memoryView = new DataView(this.#memory.buffer);
                    memoryView.setUint32(openedFdOffset, openedFd, true);
                    return ERRNO_SUCCESS;
                }
                const options = {
                    read: false,
                    write: false,
                    append: false,
                    truncate: false,
                    create: false,
                    createNew: false
                };
                if ((oflags & OFLAGS_CREAT) !== 0) {
                    options.create = true;
                    options.write = true;
                }
                if ((oflags & OFLAGS_EXCL) !== 0) {
                    options.createNew = true;
                }
                if ((oflags & OFLAGS_TRUNC) !== 0) {
                    options.truncate = true;
                    options.write = true;
                }
                const read1 = RIGHTS_FD_READ | RIGHTS_FD_READDIR;
                if ((rightsBase & read1) != 0n) {
                    options.read = true;
                }
                const write2 = RIGHTS_FD_DATASYNC | RIGHTS_FD_WRITE | RIGHTS_FD_ALLOCATE | RIGHTS_FD_FILESTAT_SET_SIZE;
                if ((rightsBase & write2) != 0n) {
                    options.write = true;
                }
                if ((fdflags & FDFLAGS_APPEND) != 0) {
                    options.append = true;
                }
                if (!options.read && !options.write && !options.truncate) {
                    options.read = true;
                }
                const { rid  } = Deno.openSync(path119, options);
                const openedFd = this.#fds.push({
                    rid,
                    flags: fdflags,
                    path: path119
                }) - 1;
                const memoryView = new DataView(this.#memory.buffer);
                memoryView.setUint32(openedFdOffset, openedFd, true);
                return ERRNO_SUCCESS;
            }),
            "path_readlink": syscall((fd, pathOffset, pathLength, bufferOffset, bufferLength, bufferUsedOffset)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (!entry.path) {
                    return ERRNO_INVAL;
                }
                const memoryData = new Uint8Array(this.#memory.buffer);
                const memoryView = new DataView(this.#memory.buffer);
                const pathData = new Uint8Array(this.#memory.buffer, pathOffset, pathLength);
                const path120 = resolve2(entry.path, new TextDecoder().decode(pathData));
                const link1 = Deno.readLinkSync(path120);
                const linkData = new TextEncoder().encode(link1);
                memoryData.set(new Uint8Array(linkData, 0, bufferLength), bufferOffset);
                const bufferUsed = Math.min(linkData.byteLength, bufferLength);
                memoryView.setUint32(bufferUsedOffset, bufferUsed, true);
                return ERRNO_SUCCESS;
            }),
            "path_remove_directory": syscall((fd, pathOffset, pathLength)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (!entry.path) {
                    return ERRNO_INVAL;
                }
                const textDecoder = new TextDecoder();
                const data84 = new Uint8Array(this.#memory.buffer, pathOffset, pathLength);
                const path121 = resolve2(entry.path, textDecoder.decode(data84));
                if (!Deno.statSync(path121).isDirectory) {
                    return ERRNO_NOTDIR;
                }
                Deno.removeSync(path121);
                return ERRNO_SUCCESS;
            }),
            "path_rename": syscall((fd, oldPathOffset, oldPathLength, newFd, newPathOffset, newPathLength)=>{
                const oldEntry = this.#fds[fd];
                const newEntry = this.#fds[newFd];
                if (!oldEntry || !newEntry) {
                    return ERRNO_BADF;
                }
                if (!oldEntry.path || !newEntry.path) {
                    return ERRNO_INVAL;
                }
                const textDecoder = new TextDecoder();
                const oldData = new Uint8Array(this.#memory.buffer, oldPathOffset, oldPathLength);
                const oldPath = resolve2(oldEntry.path, textDecoder.decode(oldData));
                const newData = new Uint8Array(this.#memory.buffer, newPathOffset, newPathLength);
                const newPath = resolve2(newEntry.path, textDecoder.decode(newData));
                Deno.renameSync(oldPath, newPath);
                return ERRNO_SUCCESS;
            }),
            "path_symlink": syscall((oldPathOffset, oldPathLength, fd, newPathOffset, newPathLength)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (!entry.path) {
                    return ERRNO_INVAL;
                }
                const textDecoder = new TextDecoder();
                const oldData = new Uint8Array(this.#memory.buffer, oldPathOffset, oldPathLength);
                const oldPath = textDecoder.decode(oldData);
                const newData = new Uint8Array(this.#memory.buffer, newPathOffset, newPathLength);
                const newPath = resolve2(entry.path, textDecoder.decode(newData));
                Deno.symlinkSync(oldPath, newPath);
                return ERRNO_SUCCESS;
            }),
            "path_unlink_file": syscall((fd, pathOffset, pathLength)=>{
                const entry = this.#fds[fd];
                if (!entry) {
                    return ERRNO_BADF;
                }
                if (!entry.path) {
                    return ERRNO_INVAL;
                }
                const textDecoder = new TextDecoder();
                const data85 = new Uint8Array(this.#memory.buffer, pathOffset, pathLength);
                const path122 = resolve2(entry.path, textDecoder.decode(data85));
                Deno.removeSync(path122);
                return ERRNO_SUCCESS;
            }),
            "poll_oneoff": syscall((_inOffset, _outOffset, _nsubscriptions, _neventsOffset)=>{
                return ERRNO_NOSYS;
            }),
            "proc_exit": syscall((rval)=>{
                if (this.#exitOnReturn) {
                    Deno.exit(rval);
                }
                throw new ExitStatus(rval);
            }),
            "proc_raise": syscall((_sig)=>{
                return ERRNO_NOSYS;
            }),
            "sched_yield": syscall(()=>{
                return ERRNO_SUCCESS;
            }),
            "random_get": syscall((bufferOffset, bufferLength)=>{
                const buffer45 = new Uint8Array(this.#memory.buffer, bufferOffset, bufferLength);
                crypto.getRandomValues(buffer45);
                return ERRNO_SUCCESS;
            }),
            "sock_recv": syscall((_fd, _riDataOffset, _riDataLength, _riFlags, _roDataLengthOffset, _roFlagsOffset)=>{
                return ERRNO_NOSYS;
            }),
            "sock_send": syscall((_fd, _siDataOffset, _siDataLength, _siFlags, _soDataLengthOffset)=>{
                return ERRNO_NOSYS;
            }),
            "sock_shutdown": syscall((_fd, _how)=>{
                return ERRNO_NOSYS;
            })
        };
        this.#started = false;
    }
    start(instance) {
        if (this.#started) {
            throw new Error("WebAssembly.Instance has already started");
        }
        this.#started = true;
        const { _start , _initialize , memory  } = instance.exports;
        if (!(memory instanceof WebAssembly.Memory)) {
            throw new TypeError("WebAsembly.instance must provide a memory export");
        }
        this.#memory = memory;
        if (typeof _initialize == "function") {
            throw new TypeError("WebAsembly.instance export _initialize must not be a function");
        }
        if (typeof _start != "function") {
            throw new TypeError("WebAssembly.Instance export _start must be a function");
        }
        try {
            _start();
        } catch (err175) {
            if (err175 instanceof ExitStatus) {
                return err175.code;
            }
            throw err175;
        }
        return null;
    }
    initialize(instance) {
        if (this.#started) {
            throw new Error("WebAssembly.Instance has already started");
        }
        this.#started = true;
        const { _start , _initialize , memory  } = instance.exports;
        if (!(memory instanceof WebAssembly.Memory)) {
            throw new TypeError("WebAsembly.instance must provide a memory export");
        }
        this.#memory = memory;
        if (typeof _start == "function") {
            throw new TypeError("WebAssembly.Instance export _start must not be a function");
        }
        if (typeof _initialize != "function") {
            throw new TypeError("WebAsembly.instance export _initialize must be a function");
        }
        _initialize();
    }
}
const __default60 = {
    WASI: Context
};
function zero$1(buf) {
    let len = buf.length;
    while(--len >= 0)buf[len] = 0;
}
const LITERALS$1 = 256;
const L_CODES$1 = 256 + 1 + 29;
const D_CODES$1 = 30;
const BL_CODES$1 = 19;
const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
const MAX_BITS$1 = 15;
const Buf_size = 16;
const MAX_BL_BITS = 7;
const END_BLOCK = 256;
const extra_lbits = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0, 
]);
const extra_dbits = new Uint8Array([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13, 
]);
const extra_blbits = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    3,
    7
]);
const bl_order = new Uint8Array([
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15, 
]);
const static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
const static_dtree = new Array(30 * 2);
zero$1(static_dtree);
const _dist_code = new Array(512);
zero$1(_dist_code);
const _length_code = new Array(258 - 3 + 1);
zero$1(_length_code);
const base_length = new Array(29);
zero$1(base_length);
const base_dist = new Array(30);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
}
let static_l_desc;
let static_d_desc;
let static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
}
const d_code = (dist)=>{
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
const put_short = (s38, w36)=>{
    s38.pending_buf[s38.pending++] = w36 & 255;
    s38.pending_buf[s38.pending++] = w36 >>> 8 & 255;
};
const send_bits = (s39, value, length)=>{
    if (s39.bi_valid > 16 - length) {
        s39.bi_buf |= value << s39.bi_valid & 65535;
        put_short(s39, s39.bi_buf);
        s39.bi_buf = value >> Buf_size - s39.bi_valid;
        s39.bi_valid += length - Buf_size;
    } else {
        s39.bi_buf |= value << s39.bi_valid & 65535;
        s39.bi_valid += length;
    }
};
const send_code = (s40, c32, tree)=>{
    send_bits(s40, tree[c32 * 2], tree[c32 * 2 + 1]);
};
const bi_reverse = (code67, len)=>{
    let res = 0;
    do {
        res |= code67 & 1;
        code67 >>>= 1;
        res <<= 1;
    }while (--len > 0)
    return res >>> 1;
};
const bi_flush = (s41)=>{
    if (s41.bi_valid === 16) {
        put_short(s41, s41.bi_buf);
        s41.bi_buf = 0;
        s41.bi_valid = 0;
    } else if (s41.bi_valid >= 8) {
        s41.pending_buf[s41.pending++] = s41.bi_buf & 255;
        s41.bi_buf >>= 8;
        s41.bi_valid -= 8;
    }
};
const gen_bitlen = (s42, desc)=>{
    const tree = desc.dyn_tree;
    const max_code = desc.max_code;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const extra = desc.stat_desc.extra_bits;
    const base23 = desc.stat_desc.extra_base;
    const max_length = desc.stat_desc.max_length;
    let h6;
    let n40, m18;
    let bits;
    let xbits;
    let f1;
    let overflow = 0;
    for(bits = 0; bits <= 15; bits++){
        s42.bl_count[bits] = 0;
    }
    tree[s42.heap[s42.heap_max] * 2 + 1] = 0;
    for(h6 = s42.heap_max + 1; h6 < HEAP_SIZE$1; h6++){
        n40 = s42.heap[h6];
        bits = tree[tree[n40 * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
            bits = max_length;
            overflow++;
        }
        tree[n40 * 2 + 1] = bits;
        if (n40 > max_code) continue;
        s42.bl_count[bits]++;
        xbits = 0;
        if (n40 >= base23) {
            xbits = extra[n40 - base23];
        }
        f1 = tree[n40 * 2];
        s42.opt_len += f1 * (bits + xbits);
        if (has_stree) {
            s42.static_len += f1 * (stree[n40 * 2 + 1] + xbits);
        }
    }
    if (overflow === 0) return;
    do {
        bits = max_length - 1;
        while(s42.bl_count[bits] === 0)bits--;
        s42.bl_count[bits]--;
        s42.bl_count[bits + 1] += 2;
        s42.bl_count[max_length]--;
        overflow -= 2;
    }while (overflow > 0)
    for(bits = max_length; bits !== 0; bits--){
        n40 = s42.bl_count[bits];
        while(n40 !== 0){
            m18 = s42.heap[--h6];
            if (m18 > max_code) continue;
            if (tree[m18 * 2 + 1] !== bits) {
                s42.opt_len += (bits - tree[m18 * 2 + 1]) * tree[m18 * 2];
                tree[m18 * 2 + 1] = bits;
            }
            n40--;
        }
    }
};
const gen_codes = (tree, max_code, bl_count)=>{
    const next_code = new Array(15 + 1);
    let code68 = 0;
    let bits;
    let n41;
    for(bits = 1; bits <= 15; bits++){
        next_code[bits] = code68 = code68 + bl_count[bits - 1] << 1;
    }
    for(n41 = 0; n41 <= max_code; n41++){
        let len = tree[n41 * 2 + 1];
        if (len === 0) continue;
        tree[n41 * 2] = bi_reverse(next_code[len]++, len);
    }
};
const tr_static_init = ()=>{
    let n42;
    let bits;
    let length;
    let code69;
    let dist;
    const bl_count = new Array(15 + 1);
    length = 0;
    for(code69 = 0; code69 < 29 - 1; code69++){
        base_length[code69] = length;
        for(n42 = 0; n42 < 1 << extra_lbits[code69]; n42++){
            _length_code[length++] = code69;
        }
    }
    _length_code[length - 1] = code69;
    dist = 0;
    for(code69 = 0; code69 < 16; code69++){
        base_dist[code69] = dist;
        for(n42 = 0; n42 < 1 << extra_dbits[code69]; n42++){
            _dist_code[dist++] = code69;
        }
    }
    dist >>= 7;
    for(; code69 < 30; code69++){
        base_dist[code69] = dist << 7;
        for(n42 = 0; n42 < 1 << extra_dbits[code69] - 7; n42++){
            _dist_code[256 + dist++] = code69;
        }
    }
    for(bits = 0; bits <= 15; bits++){
        bl_count[bits] = 0;
    }
    n42 = 0;
    while(n42 <= 143){
        static_ltree[n42 * 2 + 1] = 8;
        n42++;
        bl_count[8]++;
    }
    while(n42 <= 255){
        static_ltree[n42 * 2 + 1] = 9;
        n42++;
        bl_count[9]++;
    }
    while(n42 <= 279){
        static_ltree[n42 * 2 + 1] = 7;
        n42++;
        bl_count[7]++;
    }
    while(n42 <= 287){
        static_ltree[n42 * 2 + 1] = 8;
        n42++;
        bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
    for(n42 = 0; n42 < 30; n42++){
        static_dtree[n42 * 2 + 1] = 5;
        static_dtree[n42 * 2] = bi_reverse(n42, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
const init_block = (s43)=>{
    let n43;
    for(n43 = 0; n43 < L_CODES$1; n43++)s43.dyn_ltree[n43 * 2] = 0;
    for(n43 = 0; n43 < 30; n43++)s43.dyn_dtree[n43 * 2] = 0;
    for(n43 = 0; n43 < 19; n43++)s43.bl_tree[n43 * 2] = 0;
    s43.dyn_ltree[END_BLOCK * 2] = 1;
    s43.opt_len = s43.static_len = 0;
    s43.last_lit = s43.matches = 0;
};
const bi_windup = (s44)=>{
    if (s44.bi_valid > 8) {
        put_short(s44, s44.bi_buf);
    } else if (s44.bi_valid > 0) {
        s44.pending_buf[s44.pending++] = s44.bi_buf;
    }
    s44.bi_buf = 0;
    s44.bi_valid = 0;
};
const copy_block = (s45, buf, len, header)=>{
    bi_windup(s45);
    if (header) {
        put_short(s45, len);
        put_short(s45, ~len);
    }
    s45.pending_buf.set(s45.window.subarray(buf, buf + len), s45.pending);
    s45.pending += len;
};
const smaller = (tree, n44, m19, depth)=>{
    const _n2 = n44 * 2;
    const _m2 = m19 * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n44] <= depth[m19];
};
const pqdownheap = (s46, tree, k23)=>{
    const v20 = s46.heap[k23];
    let j = k23 << 1;
    while(j <= s46.heap_len){
        if (j < s46.heap_len && smaller(tree, s46.heap[j + 1], s46.heap[j], s46.depth)) {
            j++;
        }
        if (smaller(tree, v20, s46.heap[j], s46.depth)) break;
        s46.heap[k23] = s46.heap[j];
        k23 = j;
        j <<= 1;
    }
    s46.heap[k23] = v20;
};
const compress_block = (s47, ltree, dtree)=>{
    let dist;
    let lc;
    let lx = 0;
    let code70;
    let extra;
    if (s47.last_lit !== 0) {
        do {
            dist = s47.pending_buf[s47.d_buf + lx * 2] << 8 | s47.pending_buf[s47.d_buf + lx * 2 + 1];
            lc = s47.pending_buf[s47.l_buf + lx];
            lx++;
            if (dist === 0) {
                send_code(s47, lc, ltree);
            } else {
                code70 = _length_code[lc];
                send_code(s47, code70 + 256 + 1, ltree);
                extra = extra_lbits[code70];
                if (extra !== 0) {
                    lc -= base_length[code70];
                    send_bits(s47, lc, extra);
                }
                dist--;
                code70 = d_code(dist);
                send_code(s47, code70, dtree);
                extra = extra_dbits[code70];
                if (extra !== 0) {
                    dist -= base_dist[code70];
                    send_bits(s47, dist, extra);
                }
            }
        }while (lx < s47.last_lit)
    }
    send_code(s47, 256, ltree);
};
const build_tree = (s48, desc)=>{
    const tree = desc.dyn_tree;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems = desc.stat_desc.elems;
    let n45, m20;
    let max_code = -1;
    let node;
    s48.heap_len = 0;
    s48.heap_max = HEAP_SIZE$1;
    for(n45 = 0; n45 < elems; n45++){
        if (tree[n45 * 2] !== 0) {
            s48.heap[++s48.heap_len] = max_code = n45;
            s48.depth[n45] = 0;
        } else {
            tree[n45 * 2 + 1] = 0;
        }
    }
    while(s48.heap_len < 2){
        node = s48.heap[++s48.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s48.depth[node] = 0;
        s48.opt_len--;
        if (has_stree) {
            s48.static_len -= stree[node * 2 + 1];
        }
    }
    desc.max_code = max_code;
    for(n45 = s48.heap_len >> 1; n45 >= 1; n45--)pqdownheap(s48, tree, n45);
    node = elems;
    do {
        n45 = s48.heap[1];
        s48.heap[1] = s48.heap[s48.heap_len--];
        pqdownheap(s48, tree, 1);
        m20 = s48.heap[1];
        s48.heap[--s48.heap_max] = n45;
        s48.heap[--s48.heap_max] = m20;
        tree[node * 2] = tree[n45 * 2] + tree[m20 * 2];
        s48.depth[node] = (s48.depth[n45] >= s48.depth[m20] ? s48.depth[n45] : s48.depth[m20]) + 1;
        tree[n45 * 2 + 1] = tree[m20 * 2 + 1] = node;
        s48.heap[1] = node++;
        pqdownheap(s48, tree, 1);
    }while (s48.heap_len >= 2)
    s48.heap[--s48.heap_max] = s48.heap[1];
    gen_bitlen(s48, desc);
    gen_codes(tree, max_code, s48.bl_count);
};
const scan_tree = (s49, tree, max_code)=>{
    let n46;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count6 = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for(n46 = 0; n46 <= max_code; n46++){
        curlen = nextlen;
        nextlen = tree[(n46 + 1) * 2 + 1];
        if (++count6 < max_count && curlen === nextlen) {
            continue;
        } else if (count6 < min_count) {
            s49.bl_tree[curlen * 2] += count6;
        } else if (curlen !== 0) {
            if (curlen !== prevlen) s49.bl_tree[curlen * 2]++;
            s49.bl_tree[16 * 2]++;
        } else if (count6 <= 10) {
            s49.bl_tree[17 * 2]++;
        } else {
            s49.bl_tree[18 * 2]++;
        }
        count6 = 0;
        prevlen = curlen;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
        } else {
            max_count = 7;
            min_count = 4;
        }
    }
};
const send_tree = (s50, tree, max_code)=>{
    let n47;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count7 = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
    }
    for(n47 = 0; n47 <= max_code; n47++){
        curlen = nextlen;
        nextlen = tree[(n47 + 1) * 2 + 1];
        if (++count7 < max_count && curlen === nextlen) {
            continue;
        } else if (count7 < min_count) {
            do {
                send_code(s50, curlen, s50.bl_tree);
            }while (--count7 !== 0)
        } else if (curlen !== 0) {
            if (curlen !== prevlen) {
                send_code(s50, curlen, s50.bl_tree);
                count7--;
            }
            send_code(s50, 16, s50.bl_tree);
            send_bits(s50, count7 - 3, 2);
        } else if (count7 <= 10) {
            send_code(s50, 17, s50.bl_tree);
            send_bits(s50, count7 - 3, 3);
        } else {
            send_code(s50, 18, s50.bl_tree);
            send_bits(s50, count7 - 11, 7);
        }
        count7 = 0;
        prevlen = curlen;
        if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
        } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
        } else {
            max_count = 7;
            min_count = 4;
        }
    }
};
const build_bl_tree = (s51)=>{
    let max_blindex;
    scan_tree(s51, s51.dyn_ltree, s51.l_desc.max_code);
    scan_tree(s51, s51.dyn_dtree, s51.d_desc.max_code);
    build_tree(s51, s51.bl_desc);
    for(max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--){
        if (s51.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
            break;
        }
    }
    s51.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
};
const send_all_trees = (s52, lcodes, dcodes, blcodes)=>{
    let rank1;
    send_bits(s52, lcodes - 257, 5);
    send_bits(s52, dcodes - 1, 5);
    send_bits(s52, blcodes - 4, 4);
    for(rank1 = 0; rank1 < blcodes; rank1++){
        send_bits(s52, s52.bl_tree[bl_order[rank1] * 2 + 1], 3);
    }
    send_tree(s52, s52.dyn_ltree, lcodes - 1);
    send_tree(s52, s52.dyn_dtree, dcodes - 1);
};
const detect_data_type = (s53)=>{
    let black_mask = 4093624447;
    let n48;
    for(n48 = 0; n48 <= 31; n48++, black_mask >>>= 1){
        if (black_mask & 1 && s53.dyn_ltree[n48 * 2] !== 0) {
            return 0;
        }
    }
    if (s53.dyn_ltree[9 * 2] !== 0 || s53.dyn_ltree[10 * 2] !== 0 || s53.dyn_ltree[13 * 2] !== 0) {
        return 1;
    }
    for(n48 = 32; n48 < 256; n48++){
        if (s53.dyn_ltree[n48 * 2] !== 0) {
            return 1;
        }
    }
    return 0;
};
let static_init_done = false;
const _tr_init$1 = (s54)=>{
    if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
    }
    s54.l_desc = new TreeDesc(s54.dyn_ltree, static_l_desc);
    s54.d_desc = new TreeDesc(s54.dyn_dtree, static_d_desc);
    s54.bl_desc = new TreeDesc(s54.bl_tree, static_bl_desc);
    s54.bi_buf = 0;
    s54.bi_valid = 0;
    init_block(s54);
};
const _tr_stored_block$1 = (s55, buf, stored_len, last)=>{
    send_bits(s55, (0 << 1) + (last ? 1 : 0), 3);
    copy_block(s55, buf, stored_len, true);
};
const _tr_align$1 = (s56)=>{
    send_bits(s56, 1 << 1, 3);
    send_code(s56, 256, static_ltree);
    bi_flush(s56);
};
const _tr_flush_block$1 = (s57, buf, stored_len, last)=>{
    let opt_lenb, static_lenb;
    let max_blindex = 0;
    if (s57.level > 0) {
        if (s57.strm.data_type === 2) {
            s57.strm.data_type = detect_data_type(s57);
        }
        build_tree(s57, s57.l_desc);
        build_tree(s57, s57.d_desc);
        max_blindex = build_bl_tree(s57);
        opt_lenb = s57.opt_len + 3 + 7 >>> 3;
        static_lenb = s57.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
    } else {
        opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block$1(s57, buf, stored_len, last);
    } else if (s57.strategy === 4 || static_lenb === opt_lenb) {
        send_bits(s57, (1 << 1) + (last ? 1 : 0), 3);
        compress_block(s57, static_ltree, static_dtree);
    } else {
        send_bits(s57, (2 << 1) + (last ? 1 : 0), 3);
        send_all_trees(s57, s57.l_desc.max_code + 1, s57.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s57, s57.dyn_ltree, s57.dyn_dtree);
    }
    init_block(s57);
    if (last) {
        bi_windup(s57);
    }
};
const _tr_tally$1 = (s58, dist, lc)=>{
    s58.pending_buf[s58.d_buf + s58.last_lit * 2] = dist >>> 8 & 255;
    s58.pending_buf[s58.d_buf + s58.last_lit * 2 + 1] = dist & 255;
    s58.pending_buf[s58.l_buf + s58.last_lit] = lc & 255;
    s58.last_lit++;
    if (dist === 0) {
        s58.dyn_ltree[lc * 2]++;
    } else {
        s58.matches++;
        dist--;
        s58.dyn_ltree[(_length_code[lc] + 256 + 1) * 2]++;
        s58.dyn_dtree[d_code(dist) * 2]++;
    }
    return s58.last_lit === s58.lit_bufsize - 1;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
    _tr_init: _tr_init_1,
    _tr_stored_block: _tr_stored_block_1,
    _tr_flush_block: _tr_flush_block_1,
    _tr_tally: _tr_tally_1,
    _tr_align: _tr_align_1
};
const adler32 = (adler, buf, len, pos)=>{
    let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n49 = 0;
    while(len !== 0){
        n49 = len > 2000 ? 2000 : len;
        len -= n49;
        do {
            s1 = s1 + buf[pos++] | 0;
            s2 = s2 + s1 | 0;
        }while (--n49)
        s1 %= 65521;
        s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
const makeTable = ()=>{
    let c33, table2 = [];
    for(var n50 = 0; n50 < 256; n50++){
        c33 = n50;
        for(var k24 = 0; k24 < 8; k24++){
            c33 = c33 & 1 ? 3988292384 ^ c33 >>> 1 : c33 >>> 1;
        }
        table2[n50] = c33;
    }
    return table2;
};
const crcTable = new Uint32Array(makeTable());
const crc32 = (crc, buf, len, pos)=>{
    const t18 = crcTable;
    const end = pos + len;
    crc ^= -1;
    for(let i244 = pos; i244 < end; i244++){
        crc = crc >>> 8 ^ t18[(crc ^ buf[i244]) & 255];
    }
    return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
    2: "need dictionary",
    1: "stream end",
    0: "",
    "-1": "file error",
    "-2": "stream error",
    "-3": "data error",
    "-4": "insufficient memory",
    "-5": "buffer error",
    "-6": "incompatible version"
};
var constants$2 = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
};
const { _tr_init , _tr_stored_block , _tr_flush_block , _tr_tally , _tr_align  } = trees;
const { Z_NO_FLUSH: Z_NO_FLUSH$2 , Z_PARTIAL_FLUSH , Z_FULL_FLUSH: Z_FULL_FLUSH$1 , Z_FINISH: Z_FINISH$3 , Z_BLOCK: Z_BLOCK$1 , Z_OK: Z_OK$3 , Z_STREAM_END: Z_STREAM_END$3 , Z_STREAM_ERROR: Z_STREAM_ERROR$2 , Z_DATA_ERROR: Z_DATA_ERROR$2 , Z_BUF_ERROR: Z_BUF_ERROR$1 , Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1 , Z_FILTERED , Z_HUFFMAN_ONLY , Z_RLE , Z_FIXED , Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1 , Z_UNKNOWN , Z_DEFLATED: Z_DEFLATED$2 ,  } = constants$2;
const L_CODES = 256 + 1 + 29;
const D_CODES = 30;
const BL_CODES = 19;
const HEAP_SIZE = 2 * L_CODES + 1;
const MAX_BITS = 15;
const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = 258 + 3 + 1;
const PRESET_DICT = 32;
const INIT_STATE = 42;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;
const err = (strm, errorCode)=>{
    strm.msg = messages[errorCode];
    return errorCode;
};
const rank = (f2)=>{
    return (f2 << 1) - (f2 > 4 ? 9 : 0);
};
const zero = (buf)=>{
    let len = buf.length;
    while(--len >= 0)buf[len] = 0;
};
let HASH_ZLIB = (s59, prev, data86)=>(prev << s59.hash_shift ^ data86) & s59.hash_mask
;
let HASH = HASH_ZLIB;
const flush_pending = (strm)=>{
    const s60 = strm.state;
    let len = s60.pending;
    if (len > strm.avail_out) {
        len = strm.avail_out;
    }
    if (len === 0) return;
    strm.output.set(s60.pending_buf.subarray(s60.pending_out, s60.pending_out + len), strm.next_out);
    strm.next_out += len;
    s60.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s60.pending -= len;
    if (s60.pending === 0) {
        s60.pending_out = 0;
    }
};
const flush_block_only = (s61, last)=>{
    _tr_flush_block(s61, s61.block_start >= 0 ? s61.block_start : -1, s61.strstart - s61.block_start, last);
    s61.block_start = s61.strstart;
    flush_pending(s61.strm);
};
const put_byte = (s62, b49)=>{
    s62.pending_buf[s62.pending++] = b49;
};
const putShortMSB = (s63, b50)=>{
    s63.pending_buf[s63.pending++] = b50 >>> 8 & 255;
    s63.pending_buf[s63.pending++] = b50 & 255;
};
const read_buf = (strm, buf, start37, size)=>{
    let len = strm.avail_in;
    if (len > size) len = size;
    if (len === 0) return 0;
    strm.avail_in -= len;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start37);
    if (strm.state.wrap === 1) {
        strm.adler = adler32_1(strm.adler, buf, len, start37);
    } else if (strm.state.wrap === 2) {
        strm.adler = crc32_1(strm.adler, buf, len, start37);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
};
const longest_match = (s64, cur_match)=>{
    let chain_length = s64.max_chain_length;
    let scan = s64.strstart;
    let match11;
    let len;
    let best_len = s64.prev_length;
    let nice_match = s64.nice_match;
    const limit = s64.strstart > s64.w_size - MIN_LOOKAHEAD ? s64.strstart - (s64.w_size - MIN_LOOKAHEAD) : 0;
    const _win = s64.window;
    const wmask = s64.w_mask;
    const prev = s64.prev;
    const strend = s64.strstart + 258;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s64.prev_length >= s64.good_match) {
        chain_length >>= 2;
    }
    if (nice_match > s64.lookahead) nice_match = s64.lookahead;
    do {
        match11 = cur_match;
        if (_win[match11 + best_len] !== scan_end || _win[match11 + best_len - 1] !== scan_end1 || _win[match11] !== _win[scan] || _win[++match11] !== _win[scan + 1]) {
            continue;
        }
        scan += 2;
        match11++;
        do {}while (_win[++scan] === _win[++match11] && _win[++scan] === _win[++match11] && _win[++scan] === _win[++match11] && _win[++scan] === _win[++match11] && _win[++scan] === _win[++match11] && _win[++scan] === _win[++match11] && _win[++scan] === _win[++match11] && _win[++scan] === _win[++match11] && scan < strend)
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
            s64.match_start = cur_match;
            best_len = len;
            if (len >= nice_match) {
                break;
            }
            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len];
        }
    }while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0)
    if (best_len <= s64.lookahead) {
        return best_len;
    }
    return s64.lookahead;
};
const fill_window = (s65)=>{
    const _w_size = s65.w_size;
    let p30, n51, m21, more, str;
    do {
        more = s65.window_size - s65.lookahead - s65.strstart;
        if (s65.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
            s65.window.set(s65.window.subarray(_w_size, _w_size + _w_size), 0);
            s65.match_start -= _w_size;
            s65.strstart -= _w_size;
            s65.block_start -= _w_size;
            n51 = s65.hash_size;
            p30 = n51;
            do {
                m21 = s65.head[--p30];
                s65.head[p30] = m21 >= _w_size ? m21 - _w_size : 0;
            }while (--n51)
            n51 = _w_size;
            p30 = n51;
            do {
                m21 = s65.prev[--p30];
                s65.prev[p30] = m21 >= _w_size ? m21 - _w_size : 0;
            }while (--n51)
            more += _w_size;
        }
        if (s65.strm.avail_in === 0) {
            break;
        }
        n51 = read_buf(s65.strm, s65.window, s65.strstart + s65.lookahead, more);
        s65.lookahead += n51;
        if (s65.lookahead + s65.insert >= 3) {
            str = s65.strstart - s65.insert;
            s65.ins_h = s65.window[str];
            s65.ins_h = HASH(s65, s65.ins_h, s65.window[str + 1]);
            while(s65.insert){
                s65.ins_h = HASH(s65, s65.ins_h, s65.window[str + MIN_MATCH - 1]);
                s65.prev[str & s65.w_mask] = s65.head[s65.ins_h];
                s65.head[s65.ins_h] = str;
                str++;
                s65.insert--;
                if (s65.lookahead + s65.insert < 3) {
                    break;
                }
            }
        }
    }while (s65.lookahead < MIN_LOOKAHEAD && s65.strm.avail_in !== 0)
};
const deflate_stored = (s66, flush)=>{
    let max_block_size = 65535;
    if (max_block_size > s66.pending_buf_size - 5) {
        max_block_size = s66.pending_buf_size - 5;
    }
    for(;;){
        if (s66.lookahead <= 1) {
            fill_window(s66);
            if (s66.lookahead === 0 && flush === Z_NO_FLUSH$2) {
                return 1;
            }
            if (s66.lookahead === 0) {
                break;
            }
        }
        s66.strstart += s66.lookahead;
        s66.lookahead = 0;
        const max_start = s66.block_start + max_block_size;
        if (s66.strstart === 0 || s66.strstart >= max_start) {
            s66.lookahead = s66.strstart - max_start;
            s66.strstart = max_start;
            flush_block_only(s66, false);
            if (s66.strm.avail_out === 0) {
                return 1;
            }
        }
        if (s66.strstart - s66.block_start >= s66.w_size - MIN_LOOKAHEAD) {
            flush_block_only(s66, false);
            if (s66.strm.avail_out === 0) {
                return 1;
            }
        }
    }
    s66.insert = 0;
    if (flush === Z_FINISH$3) {
        flush_block_only(s66, true);
        if (s66.strm.avail_out === 0) {
            return 3;
        }
        return 4;
    }
    if (s66.strstart > s66.block_start) {
        flush_block_only(s66, false);
        if (s66.strm.avail_out === 0) {
            return 1;
        }
    }
    return 1;
};
const deflate_fast = (s67, flush)=>{
    let hash_head;
    let bflush;
    for(;;){
        if (s67.lookahead < MIN_LOOKAHEAD) {
            fill_window(s67);
            if (s67.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
                return 1;
            }
            if (s67.lookahead === 0) {
                break;
            }
        }
        hash_head = 0;
        if (s67.lookahead >= 3) {
            s67.ins_h = HASH(s67, s67.ins_h, s67.window[s67.strstart + MIN_MATCH - 1]);
            hash_head = s67.prev[s67.strstart & s67.w_mask] = s67.head[s67.ins_h];
            s67.head[s67.ins_h] = s67.strstart;
        }
        if (hash_head !== 0 && s67.strstart - hash_head <= s67.w_size - MIN_LOOKAHEAD) {
            s67.match_length = longest_match(s67, hash_head);
        }
        if (s67.match_length >= 3) {
            bflush = _tr_tally(s67, s67.strstart - s67.match_start, s67.match_length - MIN_MATCH);
            s67.lookahead -= s67.match_length;
            if (s67.match_length <= s67.max_lazy_match && s67.lookahead >= 3) {
                s67.match_length--;
                do {
                    s67.strstart++;
                    s67.ins_h = HASH(s67, s67.ins_h, s67.window[s67.strstart + MIN_MATCH - 1]);
                    hash_head = s67.prev[s67.strstart & s67.w_mask] = s67.head[s67.ins_h];
                    s67.head[s67.ins_h] = s67.strstart;
                }while (--s67.match_length !== 0)
                s67.strstart++;
            } else {
                s67.strstart += s67.match_length;
                s67.match_length = 0;
                s67.ins_h = s67.window[s67.strstart];
                s67.ins_h = HASH(s67, s67.ins_h, s67.window[s67.strstart + 1]);
            }
        } else {
            bflush = _tr_tally(s67, 0, s67.window[s67.strstart]);
            s67.lookahead--;
            s67.strstart++;
        }
        if (bflush) {
            flush_block_only(s67, false);
            if (s67.strm.avail_out === 0) {
                return 1;
            }
        }
    }
    s67.insert = s67.strstart < MIN_MATCH - 1 ? s67.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH$3) {
        flush_block_only(s67, true);
        if (s67.strm.avail_out === 0) {
            return 3;
        }
        return 4;
    }
    if (s67.last_lit) {
        flush_block_only(s67, false);
        if (s67.strm.avail_out === 0) {
            return 1;
        }
    }
    return 2;
};
const deflate_slow = (s68, flush)=>{
    let hash_head;
    let bflush;
    let max_insert;
    for(;;){
        if (s68.lookahead < MIN_LOOKAHEAD) {
            fill_window(s68);
            if (s68.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
                return 1;
            }
            if (s68.lookahead === 0) break;
        }
        hash_head = 0;
        if (s68.lookahead >= 3) {
            s68.ins_h = HASH(s68, s68.ins_h, s68.window[s68.strstart + MIN_MATCH - 1]);
            hash_head = s68.prev[s68.strstart & s68.w_mask] = s68.head[s68.ins_h];
            s68.head[s68.ins_h] = s68.strstart;
        }
        s68.prev_length = s68.match_length;
        s68.prev_match = s68.match_start;
        s68.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s68.prev_length < s68.max_lazy_match && s68.strstart - hash_head <= s68.w_size - MIN_LOOKAHEAD) {
            s68.match_length = longest_match(s68, hash_head);
            if (s68.match_length <= 5 && (s68.strategy === Z_FILTERED || s68.match_length === 3 && s68.strstart - s68.match_start > 4096)) {
                s68.match_length = MIN_MATCH - 1;
            }
        }
        if (s68.prev_length >= 3 && s68.match_length <= s68.prev_length) {
            max_insert = s68.strstart + s68.lookahead - MIN_MATCH;
            bflush = _tr_tally(s68, s68.strstart - 1 - s68.prev_match, s68.prev_length - MIN_MATCH);
            s68.lookahead -= s68.prev_length - 1;
            s68.prev_length -= 2;
            do {
                if (++s68.strstart <= max_insert) {
                    s68.ins_h = HASH(s68, s68.ins_h, s68.window[s68.strstart + MIN_MATCH - 1]);
                    hash_head = s68.prev[s68.strstart & s68.w_mask] = s68.head[s68.ins_h];
                    s68.head[s68.ins_h] = s68.strstart;
                }
            }while (--s68.prev_length !== 0)
            s68.match_available = 0;
            s68.match_length = MIN_MATCH - 1;
            s68.strstart++;
            if (bflush) {
                flush_block_only(s68, false);
                if (s68.strm.avail_out === 0) {
                    return 1;
                }
            }
        } else if (s68.match_available) {
            bflush = _tr_tally(s68, 0, s68.window[s68.strstart - 1]);
            if (bflush) {
                flush_block_only(s68, false);
            }
            s68.strstart++;
            s68.lookahead--;
            if (s68.strm.avail_out === 0) {
                return 1;
            }
        } else {
            s68.match_available = 1;
            s68.strstart++;
            s68.lookahead--;
        }
    }
    if (s68.match_available) {
        bflush = _tr_tally(s68, 0, s68.window[s68.strstart - 1]);
        s68.match_available = 0;
    }
    s68.insert = s68.strstart < MIN_MATCH - 1 ? s68.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH$3) {
        flush_block_only(s68, true);
        if (s68.strm.avail_out === 0) {
            return 3;
        }
        return 4;
    }
    if (s68.last_lit) {
        flush_block_only(s68, false);
        if (s68.strm.avail_out === 0) {
            return 1;
        }
    }
    return 2;
};
const deflate_rle = (s69, flush)=>{
    let bflush;
    let prev;
    let scan, strend;
    const _win = s69.window;
    for(;;){
        if (s69.lookahead <= 258) {
            fill_window(s69);
            if (s69.lookahead <= 258 && flush === Z_NO_FLUSH$2) {
                return 1;
            }
            if (s69.lookahead === 0) break;
        }
        s69.match_length = 0;
        if (s69.lookahead >= 3 && s69.strstart > 0) {
            scan = s69.strstart - 1;
            prev = _win[scan];
            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                strend = s69.strstart + MAX_MATCH;
                do {}while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend)
                s69.match_length = MAX_MATCH - (strend - scan);
                if (s69.match_length > s69.lookahead) {
                    s69.match_length = s69.lookahead;
                }
            }
        }
        if (s69.match_length >= 3) {
            bflush = _tr_tally(s69, 1, s69.match_length - MIN_MATCH);
            s69.lookahead -= s69.match_length;
            s69.strstart += s69.match_length;
            s69.match_length = 0;
        } else {
            bflush = _tr_tally(s69, 0, s69.window[s69.strstart]);
            s69.lookahead--;
            s69.strstart++;
        }
        if (bflush) {
            flush_block_only(s69, false);
            if (s69.strm.avail_out === 0) {
                return 1;
            }
        }
    }
    s69.insert = 0;
    if (flush === Z_FINISH$3) {
        flush_block_only(s69, true);
        if (s69.strm.avail_out === 0) {
            return 3;
        }
        return 4;
    }
    if (s69.last_lit) {
        flush_block_only(s69, false);
        if (s69.strm.avail_out === 0) {
            return 1;
        }
    }
    return 2;
};
const deflate_huff = (s70, flush)=>{
    let bflush;
    for(;;){
        if (s70.lookahead === 0) {
            fill_window(s70);
            if (s70.lookahead === 0) {
                if (flush === Z_NO_FLUSH$2) {
                    return 1;
                }
                break;
            }
        }
        s70.match_length = 0;
        bflush = _tr_tally(s70, 0, s70.window[s70.strstart]);
        s70.lookahead--;
        s70.strstart++;
        if (bflush) {
            flush_block_only(s70, false);
            if (s70.strm.avail_out === 0) {
                return 1;
            }
        }
    }
    s70.insert = 0;
    if (flush === Z_FINISH$3) {
        flush_block_only(s70, true);
        if (s70.strm.avail_out === 0) {
            return 3;
        }
        return 4;
    }
    if (s70.last_lit) {
        flush_block_only(s70, false);
        if (s70.strm.avail_out === 0) {
            return 1;
        }
    }
    return 2;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
}
const configuration_table = [
    new Config(0, 0, 0, 0, deflate_stored),
    new Config(4, 4, 8, 4, deflate_fast),
    new Config(4, 5, 16, 8, deflate_fast),
    new Config(4, 6, 32, 32, deflate_fast),
    new Config(4, 4, 16, 16, deflate_slow),
    new Config(8, 16, 32, 32, deflate_slow),
    new Config(8, 16, 128, 128, deflate_slow),
    new Config(8, 32, 128, 256, deflate_slow),
    new Config(32, 128, 258, 1024, deflate_slow),
    new Config(32, 258, 258, 4096, deflate_slow)
];
const lm_init = (s71)=>{
    s71.window_size = 2 * s71.w_size;
    zero(s71.head);
    s71.max_lazy_match = configuration_table[s71.level].max_lazy;
    s71.good_match = configuration_table[s71.level].good_length;
    s71.nice_match = configuration_table[s71.level].nice_length;
    s71.max_chain_length = configuration_table[s71.level].max_chain;
    s71.strstart = 0;
    s71.block_start = 0;
    s71.lookahead = 0;
    s71.insert = 0;
    s71.match_length = s71.prev_length = MIN_MATCH - 1;
    s71.match_available = 0;
    s71.ins_h = 0;
};
function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED$2;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(MAX_BITS + 1);
    this.heap = new Uint16Array(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * L_CODES + 1);
    zero(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
}
const deflateResetKeep = (strm)=>{
    if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR$2);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    const s72 = strm.state;
    s72.pending = 0;
    s72.pending_out = 0;
    if (s72.wrap < 0) {
        s72.wrap = -s72.wrap;
    }
    s72.status = s72.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s72.wrap === 2 ? 0 : 1;
    s72.last_flush = Z_NO_FLUSH$2;
    _tr_init(s72);
    return Z_OK$3;
};
const deflateReset = (strm)=>{
    const ret = deflateResetKeep(strm);
    if (ret === Z_OK$3) {
        lm_init(strm.state);
    }
    return ret;
};
const deflateSetHeader = (strm, head)=>{
    if (!strm || !strm.state) return Z_STREAM_ERROR$2;
    if (strm.state.wrap !== 2) return Z_STREAM_ERROR$2;
    strm.state.gzhead = head;
    return Z_OK$3;
};
const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy)=>{
    if (!strm) {
        return Z_STREAM_ERROR$2;
    }
    let wrap3 = 1;
    if (level === Z_DEFAULT_COMPRESSION$1) {
        level = 6;
    }
    if (windowBits < 0) {
        wrap3 = 0;
        windowBits = -windowBits;
    } else if (windowBits > 15) {
        wrap3 = 2;
        windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > 9 || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR$2);
    }
    if (windowBits === 8) {
        windowBits = 9;
    }
    const s73 = new DeflateState();
    strm.state = s73;
    s73.strm = strm;
    s73.wrap = wrap3;
    s73.gzhead = null;
    s73.w_bits = windowBits;
    s73.w_size = 1 << s73.w_bits;
    s73.w_mask = s73.w_size - 1;
    s73.hash_bits = memLevel + 7;
    s73.hash_size = 1 << s73.hash_bits;
    s73.hash_mask = s73.hash_size - 1;
    s73.hash_shift = ~~((s73.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s73.window = new Uint8Array(s73.w_size * 2);
    s73.head = new Uint16Array(s73.hash_size);
    s73.prev = new Uint16Array(s73.w_size);
    s73.lit_bufsize = 1 << memLevel + 6;
    s73.pending_buf_size = s73.lit_bufsize * 4;
    s73.pending_buf = new Uint8Array(s73.pending_buf_size);
    s73.d_buf = 1 * s73.lit_bufsize;
    s73.l_buf = (1 + 2) * s73.lit_bufsize;
    s73.level = level;
    s73.strategy = strategy;
    s73.method = method;
    return deflateReset(strm);
};
const deflateInit = (strm, level)=>{
    return deflateInit2(strm, level, Z_DEFLATED$2, 15, 8, Z_DEFAULT_STRATEGY$1);
};
const deflate$2 = (strm, flush)=>{
    let beg, val;
    if (!strm || !strm.state || flush > Z_BLOCK$1 || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
    }
    const s74 = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s74.status === 666 && flush !== Z_FINISH$3) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
    }
    s74.strm = strm;
    const old_flush = s74.last_flush;
    s74.last_flush = flush;
    if (s74.status === 42) {
        if (s74.wrap === 2) {
            strm.adler = 0;
            put_byte(s74, 31);
            put_byte(s74, 139);
            put_byte(s74, 8);
            if (!s74.gzhead) {
                put_byte(s74, 0);
                put_byte(s74, 0);
                put_byte(s74, 0);
                put_byte(s74, 0);
                put_byte(s74, 0);
                put_byte(s74, s74.level === 9 ? 2 : s74.strategy >= Z_HUFFMAN_ONLY || s74.level < 2 ? 4 : 0);
                put_byte(s74, 3);
                s74.status = BUSY_STATE;
            } else {
                put_byte(s74, (s74.gzhead.text ? 1 : 0) + (s74.gzhead.hcrc ? 2 : 0) + (!s74.gzhead.extra ? 0 : 4) + (!s74.gzhead.name ? 0 : 8) + (!s74.gzhead.comment ? 0 : 16));
                put_byte(s74, s74.gzhead.time & 255);
                put_byte(s74, s74.gzhead.time >> 8 & 255);
                put_byte(s74, s74.gzhead.time >> 16 & 255);
                put_byte(s74, s74.gzhead.time >> 24 & 255);
                put_byte(s74, s74.level === 9 ? 2 : s74.strategy >= Z_HUFFMAN_ONLY || s74.level < 2 ? 4 : 0);
                put_byte(s74, s74.gzhead.os & 255);
                if (s74.gzhead.extra && s74.gzhead.extra.length) {
                    put_byte(s74, s74.gzhead.extra.length & 255);
                    put_byte(s74, s74.gzhead.extra.length >> 8 & 255);
                }
                if (s74.gzhead.hcrc) {
                    strm.adler = crc32_1(strm.adler, s74.pending_buf, s74.pending, 0);
                }
                s74.gzindex = 0;
                s74.status = EXTRA_STATE;
            }
        } else {
            let header = Z_DEFLATED$2 + (s74.w_bits - 8 << 4) << 8;
            let level_flags = -1;
            if (s74.strategy >= Z_HUFFMAN_ONLY || s74.level < 2) {
                level_flags = 0;
            } else if (s74.level < 6) {
                level_flags = 1;
            } else if (s74.level === 6) {
                level_flags = 2;
            } else {
                level_flags = 3;
            }
            header |= level_flags << 6;
            if (s74.strstart !== 0) header |= PRESET_DICT;
            header += 31 - header % 31;
            s74.status = BUSY_STATE;
            putShortMSB(s74, header);
            if (s74.strstart !== 0) {
                putShortMSB(s74, strm.adler >>> 16);
                putShortMSB(s74, strm.adler & 65535);
            }
            strm.adler = 1;
        }
    }
    if (s74.status === 69) {
        if (s74.gzhead.extra) {
            beg = s74.pending;
            while(s74.gzindex < (s74.gzhead.extra.length & 65535)){
                if (s74.pending === s74.pending_buf_size) {
                    if (s74.gzhead.hcrc && s74.pending > beg) {
                        strm.adler = crc32_1(strm.adler, s74.pending_buf, s74.pending - beg, beg);
                    }
                    flush_pending(strm);
                    beg = s74.pending;
                    if (s74.pending === s74.pending_buf_size) {
                        break;
                    }
                }
                put_byte(s74, s74.gzhead.extra[s74.gzindex] & 255);
                s74.gzindex++;
            }
            if (s74.gzhead.hcrc && s74.pending > beg) {
                strm.adler = crc32_1(strm.adler, s74.pending_buf, s74.pending - beg, beg);
            }
            if (s74.gzindex === s74.gzhead.extra.length) {
                s74.gzindex = 0;
                s74.status = NAME_STATE;
            }
        } else {
            s74.status = NAME_STATE;
        }
    }
    if (s74.status === 73) {
        if (s74.gzhead.name) {
            beg = s74.pending;
            do {
                if (s74.pending === s74.pending_buf_size) {
                    if (s74.gzhead.hcrc && s74.pending > beg) {
                        strm.adler = crc32_1(strm.adler, s74.pending_buf, s74.pending - beg, beg);
                    }
                    flush_pending(strm);
                    beg = s74.pending;
                    if (s74.pending === s74.pending_buf_size) {
                        val = 1;
                        break;
                    }
                }
                if (s74.gzindex < s74.gzhead.name.length) {
                    val = s74.gzhead.name.charCodeAt(s74.gzindex++) & 255;
                } else {
                    val = 0;
                }
                put_byte(s74, val);
            }while (val !== 0)
            if (s74.gzhead.hcrc && s74.pending > beg) {
                strm.adler = crc32_1(strm.adler, s74.pending_buf, s74.pending - beg, beg);
            }
            if (val === 0) {
                s74.gzindex = 0;
                s74.status = COMMENT_STATE;
            }
        } else {
            s74.status = COMMENT_STATE;
        }
    }
    if (s74.status === 91) {
        if (s74.gzhead.comment) {
            beg = s74.pending;
            do {
                if (s74.pending === s74.pending_buf_size) {
                    if (s74.gzhead.hcrc && s74.pending > beg) {
                        strm.adler = crc32_1(strm.adler, s74.pending_buf, s74.pending - beg, beg);
                    }
                    flush_pending(strm);
                    beg = s74.pending;
                    if (s74.pending === s74.pending_buf_size) {
                        val = 1;
                        break;
                    }
                }
                if (s74.gzindex < s74.gzhead.comment.length) {
                    val = s74.gzhead.comment.charCodeAt(s74.gzindex++) & 255;
                } else {
                    val = 0;
                }
                put_byte(s74, val);
            }while (val !== 0)
            if (s74.gzhead.hcrc && s74.pending > beg) {
                strm.adler = crc32_1(strm.adler, s74.pending_buf, s74.pending - beg, beg);
            }
            if (val === 0) {
                s74.status = HCRC_STATE;
            }
        } else {
            s74.status = HCRC_STATE;
        }
    }
    if (s74.status === 103) {
        if (s74.gzhead.hcrc) {
            if (s74.pending + 2 > s74.pending_buf_size) {
                flush_pending(strm);
            }
            if (s74.pending + 2 <= s74.pending_buf_size) {
                put_byte(s74, strm.adler & 255);
                put_byte(s74, strm.adler >> 8 & 255);
                strm.adler = 0;
                s74.status = BUSY_STATE;
            }
        } else {
            s74.status = BUSY_STATE;
        }
    }
    if (s74.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
            s74.last_flush = -1;
            return Z_OK$3;
        }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
        return err(strm, Z_BUF_ERROR$1);
    }
    if (s74.status === 666 && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR$1);
    }
    if (strm.avail_in !== 0 || s74.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s74.status !== 666) {
        let bstate = s74.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s74, flush) : s74.strategy === Z_RLE ? deflate_rle(s74, flush) : configuration_table[s74.level].func(s74, flush);
        if (bstate === 3 || bstate === 4) {
            s74.status = FINISH_STATE;
        }
        if (bstate === 1 || bstate === 3) {
            if (strm.avail_out === 0) {
                s74.last_flush = -1;
            }
            return Z_OK$3;
        }
        if (bstate === 2) {
            if (flush === Z_PARTIAL_FLUSH) {
                _tr_align(s74);
            } else if (flush !== Z_BLOCK$1) {
                _tr_stored_block(s74, 0, 0, false);
                if (flush === Z_FULL_FLUSH$1) {
                    zero(s74.head);
                    if (s74.lookahead === 0) {
                        s74.strstart = 0;
                        s74.block_start = 0;
                        s74.insert = 0;
                    }
                }
            }
            flush_pending(strm);
            if (strm.avail_out === 0) {
                s74.last_flush = -1;
                return Z_OK$3;
            }
        }
    }
    if (flush !== Z_FINISH$3) return Z_OK$3;
    if (s74.wrap <= 0) return Z_STREAM_END$3;
    if (s74.wrap === 2) {
        put_byte(s74, strm.adler & 255);
        put_byte(s74, strm.adler >> 8 & 255);
        put_byte(s74, strm.adler >> 16 & 255);
        put_byte(s74, strm.adler >> 24 & 255);
        put_byte(s74, strm.total_in & 255);
        put_byte(s74, strm.total_in >> 8 & 255);
        put_byte(s74, strm.total_in >> 16 & 255);
        put_byte(s74, strm.total_in >> 24 & 255);
    } else {
        putShortMSB(s74, strm.adler >>> 16);
        putShortMSB(s74, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s74.wrap > 0) s74.wrap = -s74.wrap;
    return s74.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
const deflateEnd = (strm)=>{
    if (!strm || !strm.state) {
        return Z_STREAM_ERROR$2;
    }
    const status = strm.state.status;
    if (status !== 42 && status !== 69 && status !== 73 && status !== 91 && status !== 103 && status !== 113 && status !== 666) {
        return err(strm, Z_STREAM_ERROR$2);
    }
    strm.state = null;
    return status === 113 ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
const deflateSetDictionary = (strm, dictionary)=>{
    let dictLength = dictionary.length;
    if (!strm || !strm.state) {
        return Z_STREAM_ERROR$2;
    }
    const s75 = strm.state;
    const wrap4 = s75.wrap;
    if (wrap4 === 2 || wrap4 === 1 && s75.status !== 42 || s75.lookahead) {
        return Z_STREAM_ERROR$2;
    }
    if (wrap4 === 1) {
        strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
    }
    s75.wrap = 0;
    if (dictLength >= s75.w_size) {
        if (wrap4 === 0) {
            zero(s75.head);
            s75.strstart = 0;
            s75.block_start = 0;
            s75.insert = 0;
        }
        let tmpDict = new Uint8Array(s75.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s75.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s75.w_size;
    }
    const avail = strm.avail_in;
    const next = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s75);
    while(s75.lookahead >= 3){
        let str = s75.strstart;
        let n52 = s75.lookahead - (3 - 1);
        do {
            s75.ins_h = HASH(s75, s75.ins_h, s75.window[str + MIN_MATCH - 1]);
            s75.prev[str & s75.w_mask] = s75.head[s75.ins_h];
            s75.head[s75.ins_h] = str;
            str++;
        }while (--n52)
        s75.strstart = str;
        s75.lookahead = MIN_MATCH - 1;
        fill_window(s75);
    }
    s75.strstart += s75.lookahead;
    s75.block_start = s75.strstart;
    s75.insert = s75.lookahead;
    s75.lookahead = 0;
    s75.match_length = s75.prev_length = MIN_MATCH - 1;
    s75.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s75.wrap = wrap4;
    return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
    deflateInit: deflateInit_1,
    deflateInit2: deflateInit2_1,
    deflateReset: deflateReset_1,
    deflateResetKeep: deflateResetKeep_1,
    deflateSetHeader: deflateSetHeader_1,
    deflate: deflate_2$1,
    deflateEnd: deflateEnd_1,
    deflateSetDictionary: deflateSetDictionary_1,
    deflateInfo: deflateInfo
};
const _has = (obj, key)=>{
    return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
    const sources = Array.prototype.slice.call(arguments, 1);
    while(sources.length){
        const source = sources.shift();
        if (!source) continue;
        if (typeof source !== "object") {
            throw new TypeError(source + "must be non-object");
        }
        for(const p31 in source){
            if (_has(source, p31)) {
                obj[p31] = source[p31];
            }
        }
    }
    return obj;
};
var flattenChunks = (chunks)=>{
    let len = 0;
    for(let i245 = 0, l10 = chunks.length; i245 < l10; i245++){
        len += chunks[i245].length;
    }
    const result = new Uint8Array(len);
    for(let i1101 = 0, pos = 0, l1 = chunks.length; i1101 < l1; i1101++){
        let chunk = chunks[i1101];
        result.set(chunk, pos);
        pos += chunk.length;
    }
    return result;
};
var common1 = {
    assign: assign,
    flattenChunks: flattenChunks
};
let STR_APPLY_UIA_OK = true;
try {
    String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
    STR_APPLY_UIA_OK = false;
}
const _utf8len = new Uint8Array(256);
for(let q = 0; q < 256; q++){
    _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str)=>{
    if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
        return new TextEncoder().encode(str);
    }
    let buf, c34, c2, m_pos, i246, str_len = str.length, buf_len = 0;
    for(m_pos = 0; m_pos < str_len; m_pos++){
        c34 = str.charCodeAt(m_pos);
        if ((c34 & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
                c34 = 65536 + (c34 - 55296 << 10) + (c2 - 56320);
                m_pos++;
            }
        }
        buf_len += c34 < 128 ? 1 : c34 < 2048 ? 2 : c34 < 65536 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for(i246 = 0, m_pos = 0; i246 < buf_len; m_pos++){
        c34 = str.charCodeAt(m_pos);
        if ((c34 & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
                c34 = 65536 + (c34 - 55296 << 10) + (c2 - 56320);
                m_pos++;
            }
        }
        if (c34 < 128) {
            buf[i246++] = c34;
        } else if (c34 < 2048) {
            buf[i246++] = 192 | c34 >>> 6;
            buf[i246++] = 128 | c34 & 63;
        } else if (c34 < 65536) {
            buf[i246++] = 224 | c34 >>> 12;
            buf[i246++] = 128 | c34 >>> 6 & 63;
            buf[i246++] = 128 | c34 & 63;
        } else {
            buf[i246++] = 240 | c34 >>> 18;
            buf[i246++] = 128 | c34 >>> 12 & 63;
            buf[i246++] = 128 | c34 >>> 6 & 63;
            buf[i246++] = 128 | c34 & 63;
        }
    }
    return buf;
};
const buf2binstring = (buf, len)=>{
    if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK) {
            return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
        }
    }
    let result = "";
    for(let i247 = 0; i247 < len; i247++){
        result += String.fromCharCode(buf[i247]);
    }
    return result;
};
var buf2string = (buf, max)=>{
    const len = max || buf.length;
    if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
        return new TextDecoder().decode(buf.subarray(0, max));
    }
    let i248, out;
    const utf16buf = new Array(len * 2);
    for(out = 0, i248 = 0; i248 < len;){
        let c35 = buf[i248++];
        if (c35 < 128) {
            utf16buf[out++] = c35;
            continue;
        }
        let c_len = _utf8len[c35];
        if (c_len > 4) {
            utf16buf[out++] = 65533;
            i248 += c_len - 1;
            continue;
        }
        c35 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while(c_len > 1 && i248 < len){
            c35 = c35 << 6 | buf[i248++] & 63;
            c_len--;
        }
        if (c_len > 1) {
            utf16buf[out++] = 65533;
            continue;
        }
        if (c35 < 65536) {
            utf16buf[out++] = c35;
        } else {
            c35 -= 65536;
            utf16buf[out++] = 55296 | c35 >> 10 & 1023;
            utf16buf[out++] = 56320 | c35 & 1023;
        }
    }
    return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max)=>{
    max = max || buf.length;
    if (max > buf.length) max = buf.length;
    let pos = max - 1;
    while(pos >= 0 && (buf[pos] & 192) === 128)pos--;
    if (pos < 0) return max;
    if (pos === 0) return max;
    return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
    string2buf: string2buf,
    buf2string: buf2string,
    utf8border: utf8border
};
function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
}
var zstream = ZStream;
const toString$1 = Object.prototype.toString;
const { Z_NO_FLUSH: Z_NO_FLUSH$1 , Z_SYNC_FLUSH , Z_FULL_FLUSH , Z_FINISH: Z_FINISH$2 , Z_OK: Z_OK$2 , Z_STREAM_END: Z_STREAM_END$2 , Z_DEFAULT_COMPRESSION , Z_DEFAULT_STRATEGY , Z_DEFLATED: Z_DEFLATED$1 ,  } = constants$2;
function Deflate$1(options) {
    this.options = common1.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED$1,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY
    }, options || {});
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zstream();
    this.strm.avail_out = 0;
    let status = deflate_1$2.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
    if (status !== Z_OK$2) {
        throw new Error(messages[status]);
    }
    if (opt.header) {
        deflate_1$2.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
        let dict;
        if (typeof opt.dictionary === "string") {
            dict = strings.string2buf(opt.dictionary);
        } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
            dict = new Uint8Array(opt.dictionary);
        } else {
            dict = opt.dictionary;
        }
        status = deflate_1$2.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK$2) {
            throw new Error(messages[status]);
        }
        this._dict_set = true;
    }
}
Deflate$1.prototype.push = function(data87, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status, _flush_mode;
    if (this.ended) return false;
    if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
    else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
    if (typeof data87 === "string") {
        strm.input = strings.string2buf(data87);
    } else if (toString$1.call(data87) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data87);
    } else {
        strm.input = data87;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for(;;){
        if (strm.avail_out === 0) {
            strm.output = new Uint8Array(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
        }
        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
            this.onData(strm.output.subarray(0, strm.next_out));
            strm.avail_out = 0;
            continue;
        }
        status = deflate_1$2.deflate(strm, _flush_mode);
        if (status === Z_STREAM_END$2) {
            if (strm.next_out > 0) {
                this.onData(strm.output.subarray(0, strm.next_out));
            }
            status = deflate_1$2.deflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === Z_OK$2;
        }
        if (strm.avail_out === 0) {
            this.onData(strm.output);
            continue;
        }
        if (_flush_mode > 0 && strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
            strm.avail_out = 0;
            continue;
        }
        if (strm.avail_in === 0) break;
    }
    return true;
};
Deflate$1.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
    if (status === Z_OK$2) {
        this.result = common1.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
};
function deflate$1(input, options) {
    const deflator = new Deflate$1(options);
    deflator.push(input, true);
    if (deflator.err) throw deflator.msg || messages[deflator.err];
    return deflator.result;
}
function deflateRaw$1(input, options) {
    options = options || {};
    options.raw = true;
    return deflate$1(input, options);
}
function gzip$1(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
    Deflate: Deflate_1$1,
    deflate: deflate_2,
    deflateRaw: deflateRaw_1$1,
    gzip: gzip_1$1,
    constants: constants$1
};
const BAD$1 = 30;
const TYPE$1 = 12;
var inffast = function inflate_fast(strm, start38) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let dmax;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist;
    let from;
    let from_source;
    let input, output;
    const state92 = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start38 - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state92.dmax;
    wsize = state92.wsize;
    whave = state92.whave;
    wnext = state92.wnext;
    s_window = state92.window;
    hold = state92.hold;
    bits = state92.bits;
    lcode = state92.lencode;
    dcode = state92.distcode;
    lmask = (1 << state92.lenbits) - 1;
    dmask = (1 << state92.distbits) - 1;
    top: do {
        if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
        }
        here = lcode[hold & lmask];
        dolen: for(;;){
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
                output[_out++] = here & 65535;
            } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                    if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                    }
                    len += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                }
                if (bits < 15) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    hold += input[_in++] << bits;
                    bits += 8;
                }
                here = dcode[hold & dmask];
                dodist: for(;;){
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                        dist = here & 65535;
                        op &= 15;
                        if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                            if (bits < op) {
                                hold += input[_in++] << bits;
                                bits += 8;
                            }
                        }
                        dist += hold & (1 << op) - 1;
                        if (dist > dmax) {
                            strm.msg = "invalid distance too far back";
                            state92.mode = BAD$1;
                            break top;
                        }
                        hold >>>= op;
                        bits -= op;
                        op = _out - beg;
                        if (dist > op) {
                            op = dist - op;
                            if (op > whave) {
                                if (state92.sane) {
                                    strm.msg = "invalid distance too far back";
                                    state92.mode = BAD$1;
                                    break top;
                                }
                            }
                            from = 0;
                            from_source = s_window;
                            if (wnext === 0) {
                                from += wsize - op;
                                if (op < len) {
                                    len -= op;
                                    do {
                                        output[_out++] = s_window[from++];
                                    }while (--op)
                                    from = _out - dist;
                                    from_source = output;
                                }
                            } else if (wnext < op) {
                                from += wsize + wnext - op;
                                op -= wnext;
                                if (op < len) {
                                    len -= op;
                                    do {
                                        output[_out++] = s_window[from++];
                                    }while (--op)
                                    from = 0;
                                    if (wnext < len) {
                                        op = wnext;
                                        len -= op;
                                        do {
                                            output[_out++] = s_window[from++];
                                        }while (--op)
                                        from = _out - dist;
                                        from_source = output;
                                    }
                                }
                            } else {
                                from += wnext - op;
                                if (op < len) {
                                    len -= op;
                                    do {
                                        output[_out++] = s_window[from++];
                                    }while (--op)
                                    from = _out - dist;
                                    from_source = output;
                                }
                            }
                            while(len > 2){
                                output[_out++] = from_source[from++];
                                output[_out++] = from_source[from++];
                                output[_out++] = from_source[from++];
                                len -= 3;
                            }
                            if (len) {
                                output[_out++] = from_source[from++];
                                if (len > 1) {
                                    output[_out++] = from_source[from++];
                                }
                            }
                        } else {
                            from = _out - dist;
                            do {
                                output[_out++] = output[from++];
                                output[_out++] = output[from++];
                                output[_out++] = output[from++];
                                len -= 3;
                            }while (len > 2)
                            if (len) {
                                output[_out++] = output[from++];
                                if (len > 1) {
                                    output[_out++] = output[from++];
                                }
                            }
                        }
                    } else if ((op & 64) === 0) {
                        here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                        continue dodist;
                    } else {
                        strm.msg = "invalid distance code";
                        state92.mode = BAD$1;
                        break top;
                    }
                    break;
                }
            } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
            } else if (op & 32) {
                state92.mode = TYPE$1;
                break top;
            } else {
                strm.msg = "invalid literal/length code";
                state92.mode = BAD$1;
                break top;
            }
            break;
        }
    }while (_in < last && _out < end)
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state92.hold = hold;
    state92.bits = bits;
    return;
};
const MAXBITS = 15;
const lbase = new Uint16Array([
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0, 
]);
const lext = new Uint8Array([
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78, 
]);
const dbase = new Uint16Array([
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0, 
]);
const dext = new Uint8Array([
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64, 
]);
const inflate_table = (type55, lens, lens_index, codes2, table3, table_index, work, opts)=>{
    const bits = opts.bits;
    let len = 0;
    let sym = 0;
    let min27 = 0, max = 0;
    let root = 0;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask;
    let next;
    let base24 = null;
    let base_index = 0;
    let end;
    const count8 = new Uint16Array(15 + 1);
    const offs = new Uint16Array(15 + 1);
    let extra = null;
    let extra_index = 0;
    let here_bits, here_op, here_val;
    for(len = 0; len <= 15; len++){
        count8[len] = 0;
    }
    for(sym = 0; sym < codes2; sym++){
        count8[lens[lens_index + sym]]++;
    }
    root = bits;
    for(max = MAXBITS; max >= 1; max--){
        if (count8[max] !== 0) break;
    }
    if (root > max) {
        root = max;
    }
    if (max === 0) {
        table3[table_index++] = 1 << 24 | 64 << 16 | 0;
        table3[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
    }
    for(min27 = 1; min27 < max; min27++){
        if (count8[min27] !== 0) break;
    }
    if (root < min27) {
        root = min27;
    }
    left = 1;
    for(len = 1; len <= 15; len++){
        left <<= 1;
        left -= count8[len];
        if (left < 0) {
            return -1;
        }
    }
    if (left > 0 && (type55 === 0 || max !== 1)) {
        return -1;
    }
    offs[1] = 0;
    for(len = 1; len < 15; len++){
        offs[len + 1] = offs[len] + count8[len];
    }
    for(sym = 0; sym < codes2; sym++){
        if (lens[lens_index + sym] !== 0) {
            work[offs[lens[lens_index + sym]]++] = sym;
        }
    }
    if (type55 === 0) {
        base24 = extra = work;
        end = 19;
    } else if (type55 === 1) {
        base24 = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
    } else {
        base24 = dbase;
        extra = dext;
        end = -1;
    }
    huff = 0;
    sym = 0;
    len = min27;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type55 === 1 && used > 852 || type55 === 2 && used > 592) {
        return 1;
    }
    for(;;){
        here_bits = len - drop;
        if (work[sym] < end) {
            here_op = 0;
            here_val = work[sym];
        } else if (work[sym] > end) {
            here_op = extra[extra_index + work[sym]];
            here_val = base24[base_index + work[sym]];
        } else {
            here_op = 32 + 64;
            here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min27 = fill;
        do {
            fill -= incr;
            table3[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        }while (fill !== 0)
        incr = 1 << len - 1;
        while(huff & incr){
            incr >>= 1;
        }
        if (incr !== 0) {
            huff &= incr - 1;
            huff += incr;
        } else {
            huff = 0;
        }
        sym++;
        if (--count8[len] === 0) {
            if (len === max) break;
            len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
            if (drop === 0) {
                drop = root;
            }
            next += min27;
            curr = len - drop;
            left = 1 << curr;
            while(curr + drop < max){
                left -= count8[curr + drop];
                if (left <= 0) break;
                curr++;
                left <<= 1;
            }
            used += 1 << curr;
            if (type55 === 1 && used > 852 || type55 === 2 && used > 592) {
                return 1;
            }
            low = huff & mask;
            table3[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
    }
    if (huff !== 0) {
        table3[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
};
var inftrees = inflate_table;
const CODES = 0;
const LENS = 1;
const DISTS = 2;
const { Z_FINISH: Z_FINISH$1 , Z_BLOCK , Z_TREES , Z_OK: Z_OK$1 , Z_STREAM_END: Z_STREAM_END$1 , Z_NEED_DICT: Z_NEED_DICT$1 , Z_STREAM_ERROR: Z_STREAM_ERROR$1 , Z_DATA_ERROR: Z_DATA_ERROR$1 , Z_MEM_ERROR: Z_MEM_ERROR$1 , Z_BUF_ERROR , Z_DEFLATED ,  } = constants$2;
const HEAD = 1;
const FLAGS = 2;
const TIME = 3;
const OS = 4;
const EXLEN = 5;
const EXTRA = 6;
const NAME = 7;
const COMMENT = 8;
const HCRC = 9;
const DICTID = 10;
const DICT = 11;
const TYPE = 12;
const TYPEDO = 13;
const STORED = 14;
const COPY_ = 15;
const COPY = 16;
const TABLE = 17;
const LENLENS = 18;
const CODELENS = 19;
const LEN_ = 20;
const LEN = 21;
const LENEXT = 22;
const DIST = 23;
const DISTEXT = 24;
const MATCH = 25;
const LIT = 26;
const CHECK = 27;
const LENGTH = 28;
const DONE = 29;
const BAD = 30;
const MEM = 31;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
const zswap32 = (q1)=>{
    return (q1 >>> 24 & 255) + (q1 >>> 8 & 65280) + ((q1 & 65280) << 8) + ((q1 & 255) << 24);
};
function InflateState() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
}
const inflateResetKeep = (strm)=>{
    if (!strm || !strm.state) return Z_STREAM_ERROR$1;
    const state93 = strm.state;
    strm.total_in = strm.total_out = state93.total = 0;
    strm.msg = "";
    if (state93.wrap) {
        strm.adler = state93.wrap & 1;
    }
    state93.mode = HEAD;
    state93.last = 0;
    state93.havedict = 0;
    state93.dmax = 32768;
    state93.head = null;
    state93.hold = 0;
    state93.bits = 0;
    state93.lencode = state93.lendyn = new Int32Array(ENOUGH_LENS);
    state93.distcode = state93.distdyn = new Int32Array(ENOUGH_DISTS);
    state93.sane = 1;
    state93.back = -1;
    return Z_OK$1;
};
const inflateReset = (strm)=>{
    if (!strm || !strm.state) return Z_STREAM_ERROR$1;
    const state94 = strm.state;
    state94.wsize = 0;
    state94.whave = 0;
    state94.wnext = 0;
    return inflateResetKeep(strm);
};
const inflateReset2 = (strm, windowBits)=>{
    let wrap5;
    if (!strm || !strm.state) return Z_STREAM_ERROR$1;
    const state95 = strm.state;
    if (windowBits < 0) {
        wrap5 = 0;
        windowBits = -windowBits;
    } else {
        wrap5 = (windowBits >> 4) + 1;
        if (windowBits < 48) {
            windowBits &= 15;
        }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR$1;
    }
    if (state95.window !== null && state95.wbits !== windowBits) {
        state95.window = null;
    }
    state95.wrap = wrap5;
    state95.wbits = windowBits;
    return inflateReset(strm);
};
const inflateInit2 = (strm, windowBits)=>{
    if (!strm) return Z_STREAM_ERROR$1;
    const state96 = new InflateState();
    strm.state = state96;
    state96.window = null;
    const ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK$1) {
        strm.state = null;
    }
    return ret;
};
const inflateInit = (strm)=>{
    return inflateInit2(strm, 15);
};
let virgin = true;
let lenfix, distfix;
const fixedtables = (state97)=>{
    if (virgin) {
        lenfix = new Int32Array(512);
        distfix = new Int32Array(32);
        let sym = 0;
        while(sym < 144)state97.lens[sym++] = 8;
        while(sym < 256)state97.lens[sym++] = 9;
        while(sym < 280)state97.lens[sym++] = 7;
        while(sym < 288)state97.lens[sym++] = 8;
        inftrees(1, state97.lens, 0, 288, lenfix, 0, state97.work, {
            bits: 9
        });
        sym = 0;
        while(sym < 32)state97.lens[sym++] = 5;
        inftrees(2, state97.lens, 0, 32, distfix, 0, state97.work, {
            bits: 5
        });
        virgin = false;
    }
    state97.lencode = lenfix;
    state97.lenbits = 9;
    state97.distcode = distfix;
    state97.distbits = 5;
};
const updatewindow = (strm, src, end, copy1)=>{
    let dist;
    const state98 = strm.state;
    if (state98.window === null) {
        state98.wsize = 1 << state98.wbits;
        state98.wnext = 0;
        state98.whave = 0;
        state98.window = new Uint8Array(state98.wsize);
    }
    if (copy1 >= state98.wsize) {
        state98.window.set(src.subarray(end - state98.wsize, end), 0);
        state98.wnext = 0;
        state98.whave = state98.wsize;
    } else {
        dist = state98.wsize - state98.wnext;
        if (dist > copy1) {
            dist = copy1;
        }
        state98.window.set(src.subarray(end - copy1, end - copy1 + dist), state98.wnext);
        copy1 -= dist;
        if (copy1) {
            state98.window.set(src.subarray(end - copy1, end), 0);
            state98.wnext = copy1;
            state98.whave = state98.wsize;
        } else {
            state98.wnext += dist;
            if (state98.wnext === state98.wsize) state98.wnext = 0;
            if (state98.whave < state98.wsize) state98.whave += dist;
        }
    }
    return 0;
};
const inflate$2 = (strm, flush)=>{
    let state99;
    let input, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in, _out;
    let copy2;
    let from;
    let from_source;
    let here = 0;
    let here_bits, here_op, here_val;
    let last_bits, last_op, last_val;
    let len;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n53;
    const order = new Uint8Array([
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15, 
    ]);
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR$1;
    }
    state99 = strm.state;
    if (state99.mode === 12) state99.mode = TYPEDO;
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state99.hold;
    bits = state99.bits;
    _in = have;
    _out = left;
    ret = Z_OK$1;
    inf_leave: for(;;){
        switch(state99.mode){
            case 1:
                if (state99.wrap === 0) {
                    state99.mode = TYPEDO;
                    break;
                }
                while(bits < 16){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (state99.wrap & 2 && hold === 35615) {
                    state99.check = 0;
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state99.check = crc32_1(state99.check, hbuf, 2, 0);
                    hold = 0;
                    bits = 0;
                    state99.mode = FLAGS;
                    break;
                }
                state99.flags = 0;
                if (state99.head) {
                    state99.head.done = false;
                }
                if (!(state99.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                    strm.msg = "incorrect header check";
                    state99.mode = BAD;
                    break;
                }
                if ((hold & 15) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state99.mode = BAD;
                    break;
                }
                hold >>>= 4;
                bits -= 4;
                len = (hold & 15) + 8;
                if (state99.wbits === 0) {
                    state99.wbits = len;
                } else if (len > state99.wbits) {
                    strm.msg = "invalid window size";
                    state99.mode = BAD;
                    break;
                }
                state99.dmax = 1 << state99.wbits;
                strm.adler = state99.check = 1;
                state99.mode = hold & 512 ? DICTID : TYPE;
                hold = 0;
                bits = 0;
                break;
            case 2:
                while(bits < 16){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                state99.flags = hold;
                if ((state99.flags & 255) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state99.mode = BAD;
                    break;
                }
                if (state99.flags & 57344) {
                    strm.msg = "unknown header flags set";
                    state99.mode = BAD;
                    break;
                }
                if (state99.head) {
                    state99.head.text = hold >> 8 & 1;
                }
                if (state99.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state99.check = crc32_1(state99.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state99.mode = TIME;
            case 3:
                while(bits < 32){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (state99.head) {
                    state99.head.time = hold;
                }
                if (state99.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    hbuf[2] = hold >>> 16 & 255;
                    hbuf[3] = hold >>> 24 & 255;
                    state99.check = crc32_1(state99.check, hbuf, 4, 0);
                }
                hold = 0;
                bits = 0;
                state99.mode = OS;
            case 4:
                while(bits < 16){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (state99.head) {
                    state99.head.xflags = hold & 255;
                    state99.head.os = hold >> 8;
                }
                if (state99.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state99.check = crc32_1(state99.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state99.mode = EXLEN;
            case 5:
                if (state99.flags & 1024) {
                    while(bits < 16){
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state99.length = hold;
                    if (state99.head) {
                        state99.head.extra_len = hold;
                    }
                    if (state99.flags & 512) {
                        hbuf[0] = hold & 255;
                        hbuf[1] = hold >>> 8 & 255;
                        state99.check = crc32_1(state99.check, hbuf, 2, 0);
                    }
                    hold = 0;
                    bits = 0;
                } else if (state99.head) {
                    state99.head.extra = null;
                }
                state99.mode = EXTRA;
            case 6:
                if (state99.flags & 1024) {
                    copy2 = state99.length;
                    if (copy2 > have) copy2 = have;
                    if (copy2) {
                        if (state99.head) {
                            len = state99.head.extra_len - state99.length;
                            if (!state99.head.extra) {
                                state99.head.extra = new Uint8Array(state99.head.extra_len);
                            }
                            state99.head.extra.set(input.subarray(next, next + copy2), len);
                        }
                        if (state99.flags & 512) {
                            state99.check = crc32_1(state99.check, input, copy2, next);
                        }
                        have -= copy2;
                        next += copy2;
                        state99.length -= copy2;
                    }
                    if (state99.length) break inf_leave;
                }
                state99.length = 0;
                state99.mode = NAME;
            case 7:
                if (state99.flags & 2048) {
                    if (have === 0) break inf_leave;
                    copy2 = 0;
                    do {
                        len = input[next + copy2++];
                        if (state99.head && len && state99.length < 65536) {
                            state99.head.name += String.fromCharCode(len);
                        }
                    }while (len && copy2 < have)
                    if (state99.flags & 512) {
                        state99.check = crc32_1(state99.check, input, copy2, next);
                    }
                    have -= copy2;
                    next += copy2;
                    if (len) break inf_leave;
                } else if (state99.head) {
                    state99.head.name = null;
                }
                state99.length = 0;
                state99.mode = COMMENT;
            case 8:
                if (state99.flags & 4096) {
                    if (have === 0) break inf_leave;
                    copy2 = 0;
                    do {
                        len = input[next + copy2++];
                        if (state99.head && len && state99.length < 65536) {
                            state99.head.comment += String.fromCharCode(len);
                        }
                    }while (len && copy2 < have)
                    if (state99.flags & 512) {
                        state99.check = crc32_1(state99.check, input, copy2, next);
                    }
                    have -= copy2;
                    next += copy2;
                    if (len) break inf_leave;
                } else if (state99.head) {
                    state99.head.comment = null;
                }
                state99.mode = HCRC;
            case 9:
                if (state99.flags & 512) {
                    while(bits < 16){
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (hold !== (state99.check & 65535)) {
                        strm.msg = "header crc mismatch";
                        state99.mode = BAD;
                        break;
                    }
                    hold = 0;
                    bits = 0;
                }
                if (state99.head) {
                    state99.head.hcrc = state99.flags >> 9 & 1;
                    state99.head.done = true;
                }
                strm.adler = state99.check = 0;
                state99.mode = TYPE;
                break;
            case 10:
                while(bits < 32){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                strm.adler = state99.check = zswap32(hold);
                hold = 0;
                bits = 0;
                state99.mode = DICT;
            case 11:
                if (state99.havedict === 0) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state99.hold = hold;
                    state99.bits = bits;
                    return Z_NEED_DICT$1;
                }
                strm.adler = state99.check = 1;
                state99.mode = TYPE;
            case 12:
                if (flush === Z_BLOCK || flush === Z_TREES) break inf_leave;
            case 13:
                if (state99.last) {
                    hold >>>= bits & 7;
                    bits -= bits & 7;
                    state99.mode = CHECK;
                    break;
                }
                while(bits < 3){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                state99.last = hold & 1;
                hold >>>= 1;
                bits -= 1;
                switch(hold & 3){
                    case 0:
                        state99.mode = STORED;
                        break;
                    case 1:
                        fixedtables(state99);
                        state99.mode = LEN_;
                        if (flush === Z_TREES) {
                            hold >>>= 2;
                            bits -= 2;
                            break inf_leave;
                        }
                        break;
                    case 2:
                        state99.mode = TABLE;
                        break;
                    case 3:
                        strm.msg = "invalid block type";
                        state99.mode = BAD;
                }
                hold >>>= 2;
                bits -= 2;
                break;
            case 14:
                hold >>>= bits & 7;
                bits -= bits & 7;
                while(bits < 32){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                    strm.msg = "invalid stored block lengths";
                    state99.mode = BAD;
                    break;
                }
                state99.length = hold & 65535;
                hold = 0;
                bits = 0;
                state99.mode = COPY_;
                if (flush === Z_TREES) break inf_leave;
            case 15:
                state99.mode = COPY;
            case 16:
                copy2 = state99.length;
                if (copy2) {
                    if (copy2 > have) copy2 = have;
                    if (copy2 > left) copy2 = left;
                    if (copy2 === 0) break inf_leave;
                    output.set(input.subarray(next, next + copy2), put);
                    have -= copy2;
                    next += copy2;
                    left -= copy2;
                    put += copy2;
                    state99.length -= copy2;
                    break;
                }
                state99.mode = TYPE;
                break;
            case 17:
                while(bits < 14){
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                state99.nlen = (hold & 31) + 257;
                hold >>>= 5;
                bits -= 5;
                state99.ndist = (hold & 31) + 1;
                hold >>>= 5;
                bits -= 5;
                state99.ncode = (hold & 15) + 4;
                hold >>>= 4;
                bits -= 4;
                if (state99.nlen > 286 || state99.ndist > 30) {
                    strm.msg = "too many length or distance symbols";
                    state99.mode = BAD;
                    break;
                }
                state99.have = 0;
                state99.mode = LENLENS;
            case 18:
                while(state99.have < state99.ncode){
                    while(bits < 3){
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state99.lens[order[state99.have++]] = hold & 7;
                    hold >>>= 3;
                    bits -= 3;
                }
                while(state99.have < 19){
                    state99.lens[order[state99.have++]] = 0;
                }
                state99.lencode = state99.lendyn;
                state99.lenbits = 7;
                opts = {
                    bits: state99.lenbits
                };
                ret = inftrees(CODES, state99.lens, 0, 19, state99.lencode, 0, state99.work, opts);
                state99.lenbits = opts.bits;
                if (ret) {
                    strm.msg = "invalid code lengths set";
                    state99.mode = BAD;
                    break;
                }
                state99.have = 0;
                state99.mode = CODELENS;
            case 19:
                while(state99.have < state99.nlen + state99.ndist){
                    for(;;){
                        here = state99.lencode[hold & (1 << state99.lenbits) - 1];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 255;
                        here_val = here & 65535;
                        if (here_bits <= bits) break;
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (here_val < 16) {
                        hold >>>= here_bits;
                        bits -= here_bits;
                        state99.lens[state99.have++] = here_val;
                    } else {
                        if (here_val === 16) {
                            n53 = here_bits + 2;
                            while(bits < n53){
                                if (have === 0) break inf_leave;
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= here_bits;
                            bits -= here_bits;
                            if (state99.have === 0) {
                                strm.msg = "invalid bit length repeat";
                                state99.mode = BAD;
                                break;
                            }
                            len = state99.lens[state99.have - 1];
                            copy2 = 3 + (hold & 3);
                            hold >>>= 2;
                            bits -= 2;
                        } else if (here_val === 17) {
                            n53 = here_bits + 3;
                            while(bits < n53){
                                if (have === 0) break inf_leave;
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= here_bits;
                            bits -= here_bits;
                            len = 0;
                            copy2 = 3 + (hold & 7);
                            hold >>>= 3;
                            bits -= 3;
                        } else {
                            n53 = here_bits + 7;
                            while(bits < n53){
                                if (have === 0) break inf_leave;
                                have--;
                                hold += input[next++] << bits;
                                bits += 8;
                            }
                            hold >>>= here_bits;
                            bits -= here_bits;
                            len = 0;
                            copy2 = 11 + (hold & 127);
                            hold >>>= 7;
                            bits -= 7;
                        }
                        if (state99.have + copy2 > state99.nlen + state99.ndist) {
                            strm.msg = "invalid bit length repeat";
                            state99.mode = BAD;
                            break;
                        }
                        while(copy2--){
                            state99.lens[state99.have++] = len;
                        }
                    }
                }
                if (state99.mode === 30) break;
                if (state99.lens[256] === 0) {
                    strm.msg = "invalid code -- missing end-of-block";
                    state99.mode = BAD;
                    break;
                }
                state99.lenbits = 9;
                opts = {
                    bits: state99.lenbits
                };
                ret = inftrees(LENS, state99.lens, 0, state99.nlen, state99.lencode, 0, state99.work, opts);
                state99.lenbits = opts.bits;
                if (ret) {
                    strm.msg = "invalid literal/lengths set";
                    state99.mode = BAD;
                    break;
                }
                state99.distbits = 6;
                state99.distcode = state99.distdyn;
                opts = {
                    bits: state99.distbits
                };
                ret = inftrees(DISTS, state99.lens, state99.nlen, state99.ndist, state99.distcode, 0, state99.work, opts);
                state99.distbits = opts.bits;
                if (ret) {
                    strm.msg = "invalid distances set";
                    state99.mode = BAD;
                    break;
                }
                state99.mode = LEN_;
                if (flush === Z_TREES) break inf_leave;
            case 20:
                state99.mode = LEN;
            case 21:
                if (have >= 6 && left >= 258) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state99.hold = hold;
                    state99.bits = bits;
                    inffast(strm, _out);
                    put = strm.next_out;
                    output = strm.output;
                    left = strm.avail_out;
                    next = strm.next_in;
                    input = strm.input;
                    have = strm.avail_in;
                    hold = state99.hold;
                    bits = state99.bits;
                    if (state99.mode === 12) {
                        state99.back = -1;
                    }
                    break;
                }
                state99.back = 0;
                for(;;){
                    here = state99.lencode[hold & (1 << state99.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) break;
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if (here_op && (here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for(;;){
                        here = state99.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 255;
                        here_val = here & 65535;
                        if (last_bits + here_bits <= bits) break;
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state99.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state99.back += here_bits;
                state99.length = here_val;
                if (here_op === 0) {
                    state99.mode = LIT;
                    break;
                }
                if (here_op & 32) {
                    state99.back = -1;
                    state99.mode = TYPE;
                    break;
                }
                if (here_op & 64) {
                    strm.msg = "invalid literal/length code";
                    state99.mode = BAD;
                    break;
                }
                state99.extra = here_op & 15;
                state99.mode = LENEXT;
            case 22:
                if (state99.extra) {
                    n53 = state99.extra;
                    while(bits < n53){
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state99.length += hold & (1 << state99.extra) - 1;
                    hold >>>= state99.extra;
                    bits -= state99.extra;
                    state99.back += state99.extra;
                }
                state99.was = state99.length;
                state99.mode = DIST;
            case 23:
                for(;;){
                    here = state99.distcode[hold & (1 << state99.distbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) break;
                    if (have === 0) break inf_leave;
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                }
                if ((here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for(;;){
                        here = state99.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                        here_bits = here >>> 24;
                        here_op = here >>> 16 & 255;
                        here_val = here & 65535;
                        if (last_bits + here_bits <= bits) break;
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state99.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state99.back += here_bits;
                if (here_op & 64) {
                    strm.msg = "invalid distance code";
                    state99.mode = BAD;
                    break;
                }
                state99.offset = here_val;
                state99.extra = here_op & 15;
                state99.mode = DISTEXT;
            case 24:
                if (state99.extra) {
                    n53 = state99.extra;
                    while(bits < n53){
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    state99.offset += hold & (1 << state99.extra) - 1;
                    hold >>>= state99.extra;
                    bits -= state99.extra;
                    state99.back += state99.extra;
                }
                if (state99.offset > state99.dmax) {
                    strm.msg = "invalid distance too far back";
                    state99.mode = BAD;
                    break;
                }
                state99.mode = MATCH;
            case 25:
                if (left === 0) break inf_leave;
                copy2 = _out - left;
                if (state99.offset > copy2) {
                    copy2 = state99.offset - copy2;
                    if (copy2 > state99.whave) {
                        if (state99.sane) {
                            strm.msg = "invalid distance too far back";
                            state99.mode = BAD;
                            break;
                        }
                    }
                    if (copy2 > state99.wnext) {
                        copy2 -= state99.wnext;
                        from = state99.wsize - copy2;
                    } else {
                        from = state99.wnext - copy2;
                    }
                    if (copy2 > state99.length) copy2 = state99.length;
                    from_source = state99.window;
                } else {
                    from_source = output;
                    from = put - state99.offset;
                    copy2 = state99.length;
                }
                if (copy2 > left) copy2 = left;
                left -= copy2;
                state99.length -= copy2;
                do {
                    output[put++] = from_source[from++];
                }while (--copy2)
                if (state99.length === 0) state99.mode = LEN;
                break;
            case 26:
                if (left === 0) break inf_leave;
                output[put++] = state99.length;
                left--;
                state99.mode = LEN;
                break;
            case 27:
                if (state99.wrap) {
                    while(bits < 32){
                        if (have === 0) break inf_leave;
                        have--;
                        hold |= input[next++] << bits;
                        bits += 8;
                    }
                    _out -= left;
                    strm.total_out += _out;
                    state99.total += _out;
                    if (_out) {
                        strm.adler = state99.check = state99.flags ? crc32_1(state99.check, output, _out, put - _out) : adler32_1(state99.check, output, _out, put - _out);
                    }
                    _out = left;
                    if ((state99.flags ? hold : zswap32(hold)) !== state99.check) {
                        strm.msg = "incorrect data check";
                        state99.mode = BAD;
                        break;
                    }
                    hold = 0;
                    bits = 0;
                }
                state99.mode = LENGTH;
            case 28:
                if (state99.wrap && state99.flags) {
                    while(bits < 32){
                        if (have === 0) break inf_leave;
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                    }
                    if (hold !== (state99.total & 4294967295)) {
                        strm.msg = "incorrect length check";
                        state99.mode = BAD;
                        break;
                    }
                    hold = 0;
                    bits = 0;
                }
                state99.mode = DONE;
            case 29:
                ret = Z_STREAM_END$1;
                break inf_leave;
            case 30:
                ret = Z_DATA_ERROR$1;
                break inf_leave;
            case 31:
                return Z_MEM_ERROR$1;
            case 32:
            default:
                return Z_STREAM_ERROR$1;
        }
    }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state99.hold = hold;
    state99.bits = bits;
    if (state99.wsize || _out !== strm.avail_out && state99.mode < 30 && (state99.mode < 27 || flush !== Z_FINISH$1)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state99.total += _out;
    if (state99.wrap && _out) {
        strm.adler = state99.check = state99.flags ? crc32_1(state99.check, output, _out, strm.next_out - _out) : adler32_1(state99.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state99.bits + (state99.last ? 64 : 0) + (state99.mode === TYPE ? 128 : 0) + (state99.mode === LEN_ || state99.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
        ret = Z_BUF_ERROR;
    }
    return ret;
};
const inflateEnd = (strm)=>{
    if (!strm || !strm.state) {
        return Z_STREAM_ERROR$1;
    }
    let state100 = strm.state;
    if (state100.window) {
        state100.window = null;
    }
    strm.state = null;
    return Z_OK$1;
};
const inflateGetHeader = (strm, head)=>{
    if (!strm || !strm.state) return Z_STREAM_ERROR$1;
    const state101 = strm.state;
    if ((state101.wrap & 2) === 0) return Z_STREAM_ERROR$1;
    state101.head = head;
    head.done = false;
    return Z_OK$1;
};
const inflateSetDictionary = (strm, dictionary)=>{
    const dictLength = dictionary.length;
    let state102;
    let dictid;
    let ret;
    if (!strm || !strm.state) {
        return Z_STREAM_ERROR$1;
    }
    state102 = strm.state;
    if (state102.wrap !== 0 && state102.mode !== 11) {
        return Z_STREAM_ERROR$1;
    }
    if (state102.mode === 11) {
        dictid = 1;
        dictid = adler32_1(dictid, dictionary, dictLength, 0);
        if (dictid !== state102.check) {
            return Z_DATA_ERROR$1;
        }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
        state102.mode = MEM;
        return Z_MEM_ERROR$1;
    }
    state102.havedict = 1;
    return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
    inflateReset: inflateReset_1,
    inflateReset2: inflateReset2_1,
    inflateResetKeep: inflateResetKeep_1,
    inflateInit: inflateInit_1,
    inflateInit2: inflateInit2_1,
    inflate: inflate_2$1,
    inflateEnd: inflateEnd_1,
    inflateGetHeader: inflateGetHeader_1,
    inflateSetDictionary: inflateSetDictionary_1,
    inflateInfo: inflateInfo
};
function GZheader() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
}
var gzheader = GZheader;
const toString = Object.prototype.toString;
const { Z_NO_FLUSH , Z_FINISH , Z_OK , Z_STREAM_END , Z_NEED_DICT , Z_STREAM_ERROR , Z_DATA_ERROR , Z_MEM_ERROR ,  } = constants$2;
function Inflate$1(options) {
    this.options = common1.assign({
        chunkSize: 1024 * 64,
        windowBits: 15,
        to: ""
    }, options || {});
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) opt.windowBits = -15;
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
            opt.windowBits |= 15;
        }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zstream();
    this.strm.avail_out = 0;
    let status = inflate_1$2.inflateInit2(this.strm, opt.windowBits);
    if (status !== Z_OK) {
        throw new Error(messages[status]);
    }
    this.header = new gzheader();
    inflate_1$2.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
            opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
            opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
            status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
            if (status !== Z_OK) {
                throw new Error(messages[status]);
            }
        }
    }
}
Inflate$1.prototype.push = function(data88, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status, _flush_mode, last_avail_out;
    if (this.ended) return false;
    if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
    else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
    if (toString.call(data88) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data88);
    } else {
        strm.input = data88;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for(;;){
        if (strm.avail_out === 0) {
            strm.output = new Uint8Array(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
        }
        status = inflate_1$2.inflate(strm, _flush_mode);
        if (status === Z_NEED_DICT && dictionary) {
            status = inflate_1$2.inflateSetDictionary(strm, dictionary);
            if (status === Z_OK) {
                status = inflate_1$2.inflate(strm, _flush_mode);
            } else if (status === Z_DATA_ERROR) {
                status = Z_NEED_DICT;
            }
        }
        while(strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data88[strm.next_in] !== 0){
            inflate_1$2.inflateReset(strm);
            status = inflate_1$2.inflate(strm, _flush_mode);
        }
        switch(status){
            case Z_STREAM_ERROR:
            case Z_DATA_ERROR:
            case Z_NEED_DICT:
            case Z_MEM_ERROR:
                this.onEnd(status);
                this.ended = true;
                return false;
        }
        last_avail_out = strm.avail_out;
        if (strm.next_out) {
            if (strm.avail_out === 0 || status === Z_STREAM_END) {
                if (this.options.to === "string") {
                    let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                    let tail = strm.next_out - next_out_utf8;
                    let utf8str = strings.buf2string(strm.output, next_out_utf8);
                    strm.next_out = tail;
                    strm.avail_out = chunkSize - tail;
                    if (tail) {
                        strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
                    }
                    this.onData(utf8str);
                } else {
                    this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
                }
            }
        }
        if (status === Z_OK && last_avail_out === 0) continue;
        if (status === Z_STREAM_END) {
            status = inflate_1$2.inflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return true;
        }
        if (strm.avail_in === 0) break;
    }
    return true;
};
Inflate$1.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
    if (status === Z_OK) {
        if (this.options.to === "string") {
            this.result = this.chunks.join("");
        } else {
            this.result = common1.flattenChunks(this.chunks);
        }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
};
function inflate$1(input, options) {
    const inflator = new Inflate$1(options);
    inflator.push(input);
    if (inflator.err) throw inflator.msg || messages[inflator.err];
    return inflator.result;
}
function inflateRaw$1(input, options) {
    options = options || {};
    options.raw = true;
    return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants9 = constants$2;
var inflate_1$1 = {
    Inflate: Inflate_1$1,
    inflate: inflate_2,
    inflateRaw: inflateRaw_1$1,
    ungzip: ungzip$1,
    constants: constants9
};
const { Deflate , deflate , deflateRaw , gzip  } = deflate_1$1;
const { Inflate , inflate , inflateRaw , ungzip  } = inflate_1$1;
var constants_1 = constants$2;
const Z_NO_FLUSH1 = constants_1.Z_NO_FLUSH;
const Z_PARTIAL_FLUSH1 = constants_1.Z_PARTIAL_FLUSH;
const Z_SYNC_FLUSH1 = constants_1.Z_SYNC_FLUSH;
const Z_FULL_FLUSH1 = constants_1.Z_FULL_FLUSH;
const Z_FINISH1 = constants_1.Z_FINISH;
const Z_BLOCK1 = constants_1.Z_BLOCK;
constants_1.Z_TREES;
const Z_OK1 = constants_1.Z_OK;
const Z_STREAM_END1 = constants_1.Z_STREAM_END;
const Z_NEED_DICT1 = constants_1.Z_NEED_DICT;
const Z_ERRNO = constants_1.Z_ERRNO;
const Z_STREAM_ERROR1 = constants_1.Z_STREAM_ERROR;
const Z_DATA_ERROR1 = constants_1.Z_DATA_ERROR;
const Z_MEM_ERROR1 = constants_1.Z_MEM_ERROR;
const Z_BUF_ERROR1 = constants_1.Z_BUF_ERROR;
constants_1.Z_NO_COMPRESSION;
constants_1.Z_BEST_SPEED;
constants_1.Z_BEST_COMPRESSION;
constants_1.Z_DEFAULT_COMPRESSION;
const Z_FILTERED1 = constants_1.Z_FILTERED;
const Z_HUFFMAN_ONLY1 = constants_1.Z_HUFFMAN_ONLYZ_FILTERED;
const Z_RLE1 = constants_1.Z_RLE;
const Z_FIXED1 = constants_1.Z_FIXED;
const Z_DEFAULT_STRATEGY1 = constants_1.Z_DEFAULT_STRATEGY;
constants_1.Z_BINARY;
constants_1.Z_TEXT;
constants_1.Z_UNKNOWN;
const Z_DEFLATED1 = constants_1.Z_DEFLATED;
const NONE = 0;
const DEFLATE = 1;
const INFLATE = 2;
const GZIP = 3;
const GUNZIP = 4;
const DEFLATERAW = 5;
const INFLATERAW = 6;
const UNZIP = 7;
var GZIP_HEADER_ID1 = 31;
var GZIP_HEADER_ID2 = 139;
function Zlib(mode26) {
    if (typeof mode26 !== "number" || mode26 < 1 || mode26 > 7) {
        throw new TypeError("Bad argument");
    }
    this.dictionary = null;
    this.err = 0;
    this.flush = 0;
    this.init_done = false;
    this.level = 0;
    this.memLevel = 0;
    this.mode = mode26;
    this.strategy = 0;
    this.windowBits = 0;
    this.write_in_progress = false;
    this.pending_close = false;
    this.gzip_id_bytes_read = 0;
}
Zlib.prototype.close = function() {
    if (this.write_in_progress) {
        this.pending_close = true;
        return;
    }
    this.pending_close = false;
    __default22(this.init_done, "close before init");
    __default22(this.mode <= UNZIP);
    if (this.mode === DEFLATE || this.mode === GZIP || this.mode === DEFLATERAW) {
        deflate_1$2.deflateEnd(this.strm);
    } else if (this.mode === INFLATE || this.mode === GUNZIP || this.mode === INFLATERAW || this.mode === UNZIP) {
        inflate_1$2.inflateEnd(this.strm);
    }
    this.mode = NONE;
    this.dictionary = null;
};
Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
};
Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
};
Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
    __default22.equal(arguments.length, 8);
    __default22(this.init_done, "write before init");
    __default22(this.mode !== NONE, "already finalized");
    __default22.equal(false, this.write_in_progress, "write already in progress");
    __default22.equal(false, this.pending_close, "close is pending");
    this.write_in_progress = true;
    __default22.equal(false, flush === undefined, "must provide flush value");
    this.write_in_progress = true;
    if (flush !== Z_NO_FLUSH1 && flush !== Z_PARTIAL_FLUSH1 && flush !== Z_SYNC_FLUSH1 && flush !== Z_FULL_FLUSH1 && flush !== Z_FINISH1 && flush !== Z_BLOCK1) {
        throw new Error("Invalid flush value");
    }
    if (input == null) {
        input = Buffer.alloc(0);
        in_len = 0;
        in_off = 0;
    }
    this.strm.avail_in = in_len;
    this.strm.input = input;
    this.strm.next_in = in_off;
    this.strm.avail_out = out_len;
    this.strm.output = out;
    this.strm.next_out = out_off;
    this.flush = flush;
    if (!async) {
        this._process();
        if (this._checkError()) {
            return this._afterSync();
        }
        return;
    }
    var self = this;
    process.nextTick(function() {
        self._process();
        self._after();
    });
    return this;
};
Zlib.prototype._afterSync = function() {
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    return [
        avail_in,
        avail_out
    ];
};
Zlib.prototype._process = function() {
    var next_expected_header_byte = null;
    switch(this.mode){
        case DEFLATE:
        case GZIP:
        case DEFLATERAW:
            this.err = deflate_1$2.deflate(this.strm, this.flush);
            break;
        case UNZIP:
            if (this.strm.avail_in > 0) {
                next_expected_header_byte = this.strm.next_in;
            }
            switch(this.gzip_id_bytes_read){
                case 0:
                    if (next_expected_header_byte === null) {
                        break;
                    }
                    if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
                        this.gzip_id_bytes_read = 1;
                        next_expected_header_byte++;
                        if (this.strm.avail_in === 1) {
                            break;
                        }
                    } else {
                        this.mode = INFLATE;
                        break;
                    }
                case 1:
                    if (next_expected_header_byte === null) {
                        break;
                    }
                    if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
                        this.gzip_id_bytes_read = 2;
                        this.mode = GUNZIP;
                    } else {
                        this.mode = INFLATE;
                    }
                    break;
                default:
                    throw new Error("invalid number of gzip magic number bytes read");
            }
        case INFLATE:
        case GUNZIP:
        case INFLATERAW:
            this.err = inflate_1$2.inflate(this.strm, this.flush);
            if (this.err === Z_NEED_DICT1 && this.dictionary) {
                this.err = inflate_1$2.inflateSetDictionary(this.strm, this.dictionary);
                if (this.err === Z_OK1) {
                    this.err = inflate_1$2.inflate(this.strm, this.flush);
                } else if (this.err === Z_DATA_ERROR1) {
                    this.err = Z_NEED_DICT1;
                }
            }
            while(this.strm.avail_in > 0 && this.mode === GUNZIP && this.err === Z_STREAM_END1 && this.strm.next_in[0] !== 0){
                this.reset();
                this.err = inflate_1$2.inflate(this.strm, this.flush);
            }
            break;
        default:
            throw new Error("Unknown mode " + this.mode);
    }
};
Zlib.prototype._checkError = function() {
    switch(this.err){
        case Z_OK1:
        case Z_BUF_ERROR1:
            if (this.strm.avail_out !== 0 && this.flush === Z_FINISH1) {
                this._error("unexpected end of file");
                return false;
            }
            break;
        case Z_STREAM_END1:
            break;
        case Z_NEED_DICT1:
            if (this.dictionary == null) {
                this._error("Missing dictionary");
            } else {
                this._error("Bad dictionary");
            }
            return false;
        default:
            this._error("Zlib error");
            return false;
    }
    return true;
};
Zlib.prototype._after = function() {
    if (!this._checkError()) {
        return;
    }
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    this.callback(avail_in, avail_out);
    if (this.pending_close) {
        this.close();
    }
};
Zlib.prototype._error = function(message) {
    if (this.strm.msg) {
        message = this.strm.msg;
    }
    this.onerror(message, this.err);
    this.write_in_progress = false;
    if (this.pending_close) {
        this.close();
    }
};
Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
    __default22(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
    __default22(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
    __default22(level >= -1 && level <= 9, "invalid compression level");
    __default22(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
    __default22(strategy === Z_FILTERED1 || strategy === Z_HUFFMAN_ONLY1 || strategy === Z_RLE1 || strategy === Z_FIXED1 || strategy === Z_DEFAULT_STRATEGY1, "invalid strategy");
    this._init(level, windowBits, memLevel, strategy, dictionary);
    this._setDictionary();
};
Zlib.prototype.params = function() {
    throw new Error("deflateParams Not supported");
};
Zlib.prototype.reset = function() {
    this._reset();
    this._setDictionary();
};
Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
    this.level = level;
    this.windowBits = windowBits;
    this.memLevel = memLevel;
    this.strategy = strategy;
    this.flush = Z_NO_FLUSH1;
    this.err = Z_OK1;
    if (this.mode === GZIP || this.mode === GUNZIP) {
        this.windowBits += 16;
    }
    if (this.mode === UNZIP) {
        this.windowBits += 32;
    }
    if (this.mode === DEFLATERAW || this.mode === INFLATERAW) {
        this.windowBits = -1 * this.windowBits;
    }
    this.strm = new ZStream();
    switch(this.mode){
        case DEFLATE:
        case GZIP:
        case DEFLATERAW:
            this.err = deflate_1$2.deflateInit2(this.strm, this.level, Z_DEFLATED1, this.windowBits, this.memLevel, this.strategy);
            break;
        case INFLATE:
        case GUNZIP:
        case INFLATERAW:
        case UNZIP:
            this.err = inflate_1$2.inflateInit2(this.strm, this.windowBits);
            break;
        default:
            throw new Error("Unknown mode " + this.mode);
    }
    if (this.err !== Z_OK1) {
        this._error("Init error");
    }
    this.dictionary = dictionary;
    this.write_in_progress = false;
    this.init_done = true;
};
Zlib.prototype._setDictionary = function() {
    if (this.dictionary == null) {
        return;
    }
    this.err = Z_OK1;
    switch(this.mode){
        case DEFLATE:
        case DEFLATERAW:
            this.err = deflate_1$2.deflateSetDictionary(this.strm, this.dictionary);
            break;
        default:
            break;
    }
    if (this.err !== Z_OK1) {
        this._error("Failed to set dictionary");
    }
};
Zlib.prototype._reset = function() {
    this.err = Z_OK1;
    switch(this.mode){
        case DEFLATE:
        case DEFLATERAW:
        case GZIP:
            this.err = deflate_1$2.deflateReset(this.strm);
            break;
        case INFLATE:
        case INFLATERAW:
        case GUNZIP:
            this.err = inflate_1$2.inflateReset(this.strm);
            break;
        default:
            break;
    }
    if (this.err !== Z_OK1) {
        this._error("Failed to reset stream");
    }
};
var kRangeErrorMessage = "Cannot create final Buffer. It would be larger " + "than 0x" + 2147483647..toString(16) + " bytes";
const codes1 = Object.freeze({
    Z_OK: Z_OK1,
    Z_STREAM_END: Z_STREAM_END1,
    Z_NEED_DICT: Z_NEED_DICT1,
    Z_ERRNO: Z_ERRNO,
    Z_STREAM_ERROR: Z_STREAM_ERROR1,
    Z_DATA_ERROR: Z_DATA_ERROR1,
    Z_MEM_ERROR: Z_MEM_ERROR1,
    Z_BUF_ERROR: Z_BUF_ERROR1,
    Z_VERSION_ERROR: zlib.Z_VERSION_ERROR,
    [Z_OK1]: "Z_OK",
    [Z_STREAM_END1]: "Z_STREAM_END",
    [Z_NEED_DICT1]: "Z_NEED_DICT",
    [Z_ERRNO]: "Z_ERRNO",
    [Z_STREAM_ERROR1]: "Z_STREAM_ERROR",
    [Z_DATA_ERROR1]: "Z_DATA_ERROR",
    [Z_MEM_ERROR1]: "Z_MEM_ERROR",
    [Z_BUF_ERROR1]: "Z_BUF_ERROR",
    [zlib.Z_VERSION_ERROR]: "Z_VERSION_ERROR"
});
const createDeflate = function(o5) {
    return new Deflate1(o5);
};
const createInflate = function(o6) {
    return new Inflate1(o6);
};
const createDeflateRaw = function(o7) {
    return new DeflateRaw(o7);
};
const createInflateRaw = function(o8) {
    return new InflateRaw(o8);
};
const createGzip = function(o9) {
    return new Gzip(o9);
};
const createGunzip = function(o10) {
    return new Gunzip(o10);
};
const createUnzip = function(o11) {
    return new Unzip(o11);
};
const deflate1 = function(buffer46, opts, callback) {
    if (typeof opts === "function") {
        callback = opts;
        opts = {};
    }
    return zlibBuffer(new Deflate1(opts), buffer46, callback);
};
const deflateSync = function(buffer47, opts) {
    return zlibBufferSync(new Deflate1(opts), buffer47);
};
const gzip1 = function(buffer48, opts, callback) {
    if (typeof opts === "function") {
        callback = opts;
        opts = {};
    }
    return zlibBuffer(new Gzip(opts), buffer48, callback);
};
const gzipSync = function(buffer49, opts) {
    return zlibBufferSync(new Gzip(opts), buffer49);
};
const deflateRaw1 = function(buffer50, opts, callback) {
    if (typeof opts === "function") {
        callback = opts;
        opts = {};
    }
    return zlibBuffer(new DeflateRaw(opts), buffer50, callback);
};
const deflateRawSync = function(buffer51, opts) {
    return zlibBufferSync(new DeflateRaw(opts), buffer51);
};
const unzip = function(buffer52, opts, callback) {
    if (typeof opts === "function") {
        callback = opts;
        opts = {};
    }
    return zlibBuffer(new Unzip(opts), buffer52, callback);
};
const unzipSync = function(buffer53, opts) {
    return zlibBufferSync(new Unzip(opts), buffer53);
};
const inflate1 = function(buffer54, opts, callback) {
    if (typeof opts === "function") {
        callback = opts;
        opts = {};
    }
    return zlibBuffer(new Inflate1(opts), buffer54, callback);
};
const inflateSync = function(buffer55, opts) {
    return zlibBufferSync(new Inflate1(opts), buffer55);
};
const gunzip = function(buffer56, opts, callback) {
    if (typeof opts === "function") {
        callback = opts;
        opts = {};
    }
    return zlibBuffer(new Gunzip(opts), buffer56, callback);
};
const gunzipSync = function(buffer57, opts) {
    return zlibBufferSync(new Gunzip(opts), buffer57);
};
const inflateRaw1 = function(buffer58, opts, callback) {
    if (typeof opts === "function") {
        callback = opts;
        opts = {};
    }
    return zlibBuffer(new InflateRaw(opts), buffer58, callback);
};
const inflateRawSync = function(buffer59, opts) {
    return zlibBufferSync(new InflateRaw(opts), buffer59);
};
function zlibBuffer(engine, buffer60, callback) {
    var buffers = [];
    var nread = 0;
    engine.on("error", onError2);
    engine.on("end", onEnd);
    engine.end(buffer60);
    flow1();
    function flow1() {
        var chunk;
        while(null !== (chunk = engine.read())){
            buffers.push(chunk);
            nread += chunk.length;
        }
        engine.once("readable", flow1);
    }
    function onError2(err176) {
        engine.removeListener("end", onEnd);
        engine.removeListener("readable", flow1);
        callback(err176);
    }
    function onEnd() {
        var buf;
        var err177 = null;
        if (nread >= 2147483647) {
            err177 = new RangeError(kRangeErrorMessage);
        } else {
            buf = Buffer1.concat(buffers, nread);
        }
        buffers = [];
        engine.close();
        callback(err177, buf);
    }
}
function zlibBufferSync(engine, buffer61) {
    if (typeof buffer61 === "string") buffer61 = Buffer1.from(buffer61);
    if (!Buffer1.isBuffer(buffer61)) throw new TypeError("Not a string or buffer");
    var flushFlag = engine._finishFlushFlag;
    return engine._processChunk(buffer61, flushFlag);
}
function Deflate1(opts) {
    if (!(this instanceof Deflate1)) return new Deflate1(opts);
    Zlib1.call(this, opts, 1);
}
function Inflate1(opts) {
    if (!(this instanceof Inflate1)) return new Inflate1(opts);
    Zlib1.call(this, opts, 2);
}
function Gzip(opts) {
    if (!(this instanceof Gzip)) return new Gzip(opts);
    Zlib1.call(this, opts, 3);
}
function Gunzip(opts) {
    if (!(this instanceof Gunzip)) return new Gunzip(opts);
    Zlib1.call(this, opts, 4);
}
function DeflateRaw(opts) {
    if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
    Zlib1.call(this, opts, 5);
}
function InflateRaw(opts) {
    if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
    Zlib1.call(this, opts, 6);
}
function Unzip(opts) {
    if (!(this instanceof Unzip)) return new Unzip(opts);
    Zlib1.call(this, opts, 7);
}
function isValidFlushFlag(flag) {
    return flag === Z_NO_FLUSH1 || flag === Z_PARTIAL_FLUSH1 || flag === Z_SYNC_FLUSH1 || flag === Z_FULL_FLUSH1 || flag === Z_FINISH1 || flag === Z_BLOCK1;
}
function Zlib1(opts, mode27) {
    var _this = this;
    this._opts = opts = opts || {};
    this._chunkSize = opts.chunkSize || zlib.Z_DEFAULT_CHUNK;
    Transform.call(this, opts);
    if (opts.flush && !isValidFlushFlag(opts.flush)) {
        throw new Error("Invalid flush flag: " + opts.flush);
    }
    if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
        throw new Error("Invalid flush flag: " + opts.finishFlush);
    }
    this._flushFlag = opts.flush || Z_NO_FLUSH1;
    this._finishFlushFlag = typeof opts.finishFlush !== "undefined" ? opts.finishFlush : Z_FINISH1;
    if (opts.chunkSize) {
        if (opts.chunkSize < zlib.Z_MIN_CHUNK || opts.chunkSize > zlib.Z_MAX_CHUNK) {
            throw new Error("Invalid chunk size: " + opts.chunkSize);
        }
    }
    if (opts.windowBits) {
        if (opts.windowBits < zlib.Z_MIN_WINDOWBITS || opts.windowBits > zlib.Z_MAX_WINDOWBITS) {
            throw new Error("Invalid windowBits: " + opts.windowBits);
        }
    }
    if (opts.level) {
        if (opts.level < zlib.Z_MIN_LEVEL || opts.level > zlib.Z_MAX_LEVEL) {
            throw new Error("Invalid compression level: " + opts.level);
        }
    }
    if (opts.memLevel) {
        if (opts.memLevel < zlib.Z_MIN_MEMLEVEL || opts.memLevel > zlib.Z_MAX_MEMLEVEL) {
            throw new Error("Invalid memLevel: " + opts.memLevel);
        }
    }
    if (opts.strategy) {
        if (opts.strategy != zlib.Z_FILTERED && opts.strategy != zlib.Z_HUFFMAN_ONLY && opts.strategy != zlib.Z_RLE && opts.strategy != zlib.Z_FIXED && opts.strategy != zlib.Z_DEFAULT_STRATEGY) {
            throw new Error("Invalid strategy: " + opts.strategy);
        }
    }
    if (opts.dictionary) {
        if (!Buffer1.isBuffer(opts.dictionary)) {
            throw new Error("Invalid dictionary: it should be a Buffer instance");
        }
    }
    this._handle = new Zlib(mode27);
    var self = this;
    this._hadError = false;
    this._handle.onerror = function(message, errno) {
        _close(self);
        self._hadError = true;
        var error25 = new Error(message);
        error25.errno = errno;
        error25.code = codes1[errno];
        self.emit("error", error25);
    };
    var level = zlib.Z_DEFAULT_COMPRESSION;
    if (typeof opts.level === "number") level = opts.level;
    var strategy = zlib.Z_DEFAULT_STRATEGY;
    if (typeof opts.strategy === "number") strategy = opts.strategy;
    this._handle.init(opts.windowBits || zlib.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || zlib.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);
    this._buffer = Buffer1.allocUnsafe(this._chunkSize);
    this._offset = 0;
    this._level = level;
    this._strategy = strategy;
    this.once("end", this.close);
    Object.defineProperty(this, "_closed", {
        get: function() {
            return !_this._handle;
        },
        configurable: true,
        enumerable: true
    });
}
__default7.inherits(Zlib1, Transform);
Zlib1.prototype.params = function(level, strategy, callback) {
    if (level < zlib.Z_MIN_LEVEL || level > zlib.Z_MAX_LEVEL) {
        throw new RangeError("Invalid compression level: " + level);
    }
    if (strategy != zlib.Z_FILTERED && strategy != zlib.Z_HUFFMAN_ONLY && strategy != zlib.Z_RLE && strategy != zlib.Z_FIXED && strategy != zlib.Z_DEFAULT_STRATEGY) {
        throw new TypeError("Invalid strategy: " + strategy);
    }
    if (this._level !== level || this._strategy !== strategy) {
        var self = this;
        this.flush(Z_SYNC_FLUSH1, function() {
            ok(self._handle, "zlib binding closed");
            self._handle.params(level, strategy);
            if (!self._hadError) {
                self._level = level;
                self._strategy = strategy;
                if (callback) callback();
            }
        });
    } else {
        process.nextTick(callback);
    }
};
Zlib1.prototype.reset = function() {
    ok(this._handle, "zlib binding closed");
    return this._handle.reset();
};
Zlib1.prototype._flush = function(callback) {
    this._transform(Buffer1.alloc(0), "", callback);
};
Zlib1.prototype.flush = function(kind, callback) {
    var _this2 = this;
    var ws = this._writableState;
    if (typeof kind === "function" || kind === undefined && !callback) {
        callback = kind;
        kind = Z_FULL_FLUSH1;
    }
    if (ws.ended) {
        if (callback) process.nextTick(callback);
    } else if (ws.ending) {
        if (callback) this.once("end", callback);
    } else if (ws.needDrain) {
        if (callback) {
            this.once("drain", function() {
                return _this2.flush(kind, callback);
            });
        }
    } else {
        this._flushFlag = kind;
        this.write(Buffer1.alloc(0), "", callback);
    }
};
Zlib1.prototype.close = function(callback) {
    _close(this, callback);
    process.nextTick(emitCloseNT1, this);
};
function _close(engine, callback) {
    if (callback) process.nextTick(callback);
    if (!engine._handle) return;
    engine._handle.close();
    engine._handle = null;
}
function emitCloseNT1(self) {
    self.emit("close");
}
Zlib1.prototype._transform = function(chunk, encoding, cb) {
    var flushFlag;
    var ws = this._writableState;
    var ending = ws.ending || ws.ended;
    var last = ending && (!chunk || ws.length === chunk.length);
    if (chunk !== null && !Buffer1.isBuffer(chunk)) {
        return cb(new Error("invalid input"));
    }
    if (!this._handle) return cb(new Error("zlib binding closed"));
    if (last) flushFlag = this._finishFlushFlag;
    else {
        flushFlag = this._flushFlag;
        if (chunk.length >= ws.length) {
            this._flushFlag = this._opts.flush || Z_NO_FLUSH1;
        }
    }
    this._processChunk(chunk, flushFlag, cb);
};
Zlib1.prototype._processChunk = function(chunk, flushFlag, cb) {
    var availInBefore = chunk && chunk.length;
    var availOutBefore = this._chunkSize - this._offset;
    var inOff = 0;
    var self = this;
    var async = typeof cb === "function";
    if (!async) {
        var buffers = [];
        var nread = 0;
        var error26;
        this.on("error", function(er) {
            error26 = er;
        });
        ok(this._handle, "zlib binding closed");
        do {
            var res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
        }while (!this._hadError && callback(res[0], res[1]))
        if (this._hadError) {
            throw error26;
        }
        if (nread >= kMaxLength) {
            _close(this);
            throw new RangeError(kRangeErrorMessage);
        }
        var buf = Buffer1.concat(buffers, nread);
        _close(this);
        return buf;
    }
    ok(this._handle, "zlib binding closed");
    var req30 = this._handle.write(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
    req30.buffer = chunk;
    req30.callback = callback;
    function callback(availInAfter, availOutAfter) {
        if (this) {
            this.buffer = null;
            this.callback = null;
        }
        if (self._hadError) return;
        var have = availOutBefore - availOutAfter;
        ok(have >= 0, "have should not go down");
        if (have > 0) {
            var out = self._buffer.slice(self._offset, self._offset + have);
            self._offset += have;
            if (async) {
                self.push(out);
            } else {
                buffers.push(out);
                nread += out.length;
            }
        }
        if (availOutAfter === 0 || self._offset >= self._chunkSize) {
            availOutBefore = self._chunkSize;
            self._offset = 0;
            self._buffer = Buffer1.allocUnsafe(self._chunkSize);
        }
        if (availOutAfter === 0) {
            inOff += availInBefore - availInAfter;
            availInBefore = availInAfter;
            if (!async) return true;
            var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);
            newReq.callback = callback;
            newReq.buffer = chunk;
            return;
        }
        if (!async) return false;
        cb();
    }
};
__default7.inherits(Deflate1, Zlib1);
__default7.inherits(Inflate1, Zlib1);
__default7.inherits(Gzip, Zlib1);
__default7.inherits(Gunzip, Zlib1);
__default7.inherits(DeflateRaw, Zlib1);
__default7.inherits(InflateRaw, Zlib1);
__default7.inherits(Unzip, Zlib1);
class Options {
    constructor(){
        notImplemented();
    }
}
class BrotliOptions {
    constructor(){
        notImplemented();
    }
}
class BrotliCompress {
    constructor(){
        notImplemented();
    }
}
class BrotliDecompress {
    constructor(){
        notImplemented();
    }
}
class ZlibBase {
    constructor(){
        notImplemented();
    }
}
function createBrotliCompress() {
    notImplemented();
}
function createBrotliDecompress() {
    notImplemented();
}
function brotliCompress() {
    notImplemented();
}
function brotliCompressSync() {
    notImplemented();
}
function brotliDecompress() {
    notImplemented();
}
function brotliDecompressSync() {
    notImplemented();
}
const __default61 = {
    Options,
    BrotliOptions,
    BrotliCompress,
    BrotliDecompress,
    Deflate: Deflate1,
    DeflateRaw,
    Gunzip,
    Gzip,
    Inflate: Inflate1,
    InflateRaw,
    Unzip,
    ZlibBase,
    constants: zlib,
    codes: codes1,
    createBrotliCompress,
    createBrotliDecompress,
    createDeflate,
    createDeflateRaw,
    createGunzip,
    createGzip,
    createInflate,
    createInflateRaw,
    createUnzip,
    brotliCompress,
    brotliCompressSync,
    brotliDecompress,
    brotliDecompressSync,
    deflate: deflate1,
    deflateSync,
    deflateRaw: deflateRaw1,
    deflateRawSync,
    gunzip,
    gunzipSync,
    gzip: gzip1,
    gzipSync,
    inflate: inflate1,
    inflateSync,
    inflateRaw: inflateRaw1,
    inflateRawSync,
    unzip,
    unzipSync
};
const __default62 = {
    _http_agent: __default19,
    _http_outgoing: __default21,
    _stream_duplex: Duplex,
    _stream_passthrough: PassThrough,
    _stream_readable: Readable,
    _stream_transform: Transform,
    _stream_writable: Writable,
    assert: __default22,
    "assert/strict": strict,
    async_hooks: __default18,
    buffer: __default6,
    crypto: __default37,
    console,
    constants: __default33,
    "child_process": __default23,
    cluster: __default24,
    dgram: __default38,
    dns: __default16,
    domain: __default39,
    events: EventEmitter,
    fs: __default31,
    "fs/promises": promises,
    http: __default40,
    http2: __default41,
    https: __default42,
    inspector: __default43,
    "internal/errors": __default8,
    "internal/fs/utils": __default30,
    "internal/http": __default20,
    "internal/readline/utils": __default44,
    "internal/streams/add-abort-signal": __default9,
    "internal/streams/buffer_list": BufferList,
    "internal/streams/state": __default11,
    "internal/test/binding": __default45,
    "internal/timers": __default14,
    "internal/util/inspect": __default1,
    "internal/util": __default2,
    net: __default17,
    os: __default32,
    "path/posix": __default26,
    "path/win32": __default25,
    path: __default27,
    "perf_hooks": __default46,
    process: process1,
    get punycode () {
        process1.emitWarning("The `punycode` module is deprecated. Please use a userland " + "alternative instead.", "DeprecationWarning", "DEP0040");
        return __default47;
    },
    querystring: __default28,
    readline: __default48,
    repl: __default49,
    stream: Stream,
    "stream/consumers": __default50,
    "stream/promises": __default13,
    "stream/web": __default51,
    "string_decoder": __default12,
    sys: __default7,
    timers: __default15,
    "timers/promises": __default52,
    tls: __default55,
    tty: __default56,
    url: __default29,
    "util/types": __default3,
    util: __default7,
    v8: __default57,
    vm: __default58,
    wasi: __default60,
    workerThreads: __default59,
    zlib: __default61
};
const callerPath = `const callerCallsite = require("caller-callsite");
const re = /^file:/;

module.exports = () => {
  const fileUrl = callerCallsite().getFileName();
  return fileUrl.replace(re, "");
};
`;
const __default63 = {
    "caller-path": callerPath
};
const { hasOwn: hasOwn1  } = Object;
const encodedSepRegEx = /%2F|%2C/i;
function throwInvalidSubpath(subpath, packageJSONUrl, internal, base25) {
    const reason = `request is not a valid subpath for the "${internal ? "imports" : "exports"}" resolution of ${fileURLToPath(packageJSONUrl)}`;
    throw new ERR_INVALID_MODULE_SPECIFIER(subpath, reason, base25 && fileURLToPath(base25));
}
function throwInvalidPackageTarget(subpath, target, packageJSONUrl, internal, base26) {
    if (typeof target === "object" && target !== null) {
        target = JSON.stringify(target, null, "");
    } else {
        target = `${target}`;
    }
    throw new ERR_INVALID_PACKAGE_TARGET(fileURLToPath(new URL(".", packageJSONUrl)), subpath, target, internal, base26 && fileURLToPath(base26));
}
function throwImportNotDefined(specifier, packageJSONUrl, base27) {
    throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier, packageJSONUrl && fileURLToPath(new URL(".", packageJSONUrl)), fileURLToPath(base27));
}
function throwExportsNotFound(subpath, packageJSONUrl, base28) {
    throw new ERR_PACKAGE_PATH_NOT_EXPORTED(subpath, fileURLToPath(new URL(".", packageJSONUrl)), base28 && fileURLToPath(base28));
}
function patternKeyCompare(a51, b51) {
    const aPatternIndex = a51.indexOf("*");
    const bPatternIndex = b51.indexOf("*");
    const baseLenA = aPatternIndex === -1 ? a51.length : aPatternIndex + 1;
    const baseLenB = bPatternIndex === -1 ? b51.length : bPatternIndex + 1;
    if (baseLenA > baseLenB) return -1;
    if (baseLenB > baseLenA) return 1;
    if (aPatternIndex === -1) return 1;
    if (bPatternIndex === -1) return -1;
    if (a51.length > b51.length) return -1;
    if (b51.length > a51.length) return 1;
    return 0;
}
function fileExists(url16) {
    try {
        const info5 = Deno.statSync(url16);
        return info5.isFile;
    } catch  {
        return false;
    }
}
function tryStatSync(path123) {
    try {
        const info6 = Deno.statSync(path123);
        return {
            isDirectory: info6.isDirectory
        };
    } catch  {
        return {
            isDirectory: false
        };
    }
}
function legacyMainResolve(packageJSONUrl, packageConfig, base29) {
    let guess;
    if (packageConfig.main !== undefined) {
        if (fileExists(guess = new URL(`./${packageConfig.main}`, packageJSONUrl))) {
            return guess;
        } else if (fileExists(guess = new URL(`./${packageConfig.main}.js`, packageJSONUrl))) {} else if (fileExists(guess = new URL(`./${packageConfig.main}.json`, packageJSONUrl))) {} else if (fileExists(guess = new URL(`./${packageConfig.main}.node`, packageJSONUrl))) {} else if (fileExists(guess = new URL(`./${packageConfig.main}/index.js`, packageJSONUrl))) {} else if (fileExists(guess = new URL(`./${packageConfig.main}/index.json`, packageJSONUrl))) {} else if (fileExists(guess = new URL(`./${packageConfig.main}/index.node`, packageJSONUrl))) {} else guess = undefined;
        if (guess) {
            return guess;
        }
    }
    if (fileExists(guess = new URL("./index.js", packageJSONUrl))) {} else if (fileExists(guess = new URL("./index.json", packageJSONUrl))) {} else if (fileExists(guess = new URL("./index.node", packageJSONUrl))) {} else guess = undefined;
    if (guess) {
        return guess;
    }
    throw new ERR_MODULE_NOT_FOUND(fileURLToPath(new URL(".", packageJSONUrl)), fileURLToPath(base29));
}
function parsePackageName(specifier, base30) {
    let separatorIndex = specifier.indexOf("/");
    let validPackageName = true;
    let isScoped = false;
    if (specifier[0] === "@") {
        isScoped = true;
        if (separatorIndex === -1 || specifier.length === 0) {
            validPackageName = false;
        } else {
            separatorIndex = specifier.indexOf("/", separatorIndex + 1);
        }
    }
    const packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
    for(let i249 = 0; i249 < packageName.length; i249++){
        if (packageName[i249] === "%" || packageName[i249] === "\\") {
            validPackageName = false;
            break;
        }
    }
    if (!validPackageName) {
        throw new ERR_INVALID_MODULE_SPECIFIER(specifier, "is not a valid package name", fileURLToPath(base30));
    }
    const packageSubpath = "." + (separatorIndex === -1 ? "" : specifier.slice(separatorIndex));
    return {
        packageName,
        packageSubpath,
        isScoped
    };
}
function packageResolve(specifier, base31, conditions) {
    const { packageName , packageSubpath , isScoped  } = parsePackageName(specifier, base31);
    const packageConfig = getPackageScopeConfig(base31);
    if (packageConfig.exists) {
        const packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);
        if (packageConfig.name === packageName && packageConfig.exports !== undefined && packageConfig.exports !== null) {
            return packageExportsResolve(packageJSONUrl.toString(), packageSubpath, packageConfig, base31, conditions);
        }
    }
    let packageJSONUrl = new URL("./node_modules/" + packageName + "/package.json", base31);
    let packageJSONPath = fileURLToPath(packageJSONUrl);
    let lastPath;
    do {
        const stat4 = tryStatSync(packageJSONPath.slice(0, packageJSONPath.length - 13));
        if (!stat4.isDirectory) {
            lastPath = packageJSONPath;
            packageJSONUrl = new URL((isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json", packageJSONUrl);
            packageJSONPath = fileURLToPath(packageJSONUrl);
            continue;
        }
        const packageConfig = getPackageConfig(packageJSONPath, specifier, base31);
        if (packageConfig.exports !== undefined && packageConfig.exports !== null) {
            return packageExportsResolve(packageJSONUrl.toString(), packageSubpath, packageConfig, base31, conditions);
        }
        if (packageSubpath === ".") {
            return legacyMainResolve(packageJSONUrl, packageConfig, base31);
        }
        return new URL(packageSubpath, packageJSONUrl);
    }while (packageJSONPath.length !== lastPath.length)
    throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath(base31));
}
const invalidSegmentRegEx = /(^|\\|\/)(\.\.?|node_modules)(\\|\/|$)/;
const patternRegEx = /\*/g;
function resolvePackageTargetString(target, subpath, match12, packageJSONUrl, base32, pattern, internal, conditions) {
    if (subpath !== "" && !pattern && target[target.length - 1] !== "/") {
        throwInvalidPackageTarget(match12, target, packageJSONUrl, internal, base32);
    }
    if (!target.startsWith("./")) {
        if (internal && !target.startsWith("../") && !target.startsWith("/")) {
            let isURL = false;
            try {
                new URL(target);
                isURL = true;
            } catch  {}
            if (!isURL) {
                const exportTarget = pattern ? target.replace(patternRegEx, ()=>subpath
                ) : target + subpath;
                return packageResolve(exportTarget, packageJSONUrl, conditions);
            }
        }
        throwInvalidPackageTarget(match12, target, packageJSONUrl, internal, base32);
    }
    if (invalidSegmentRegEx.test(target.slice(2))) {
        throwInvalidPackageTarget(match12, target, packageJSONUrl, internal, base32);
    }
    const resolved = new URL(target, packageJSONUrl);
    const resolvedPath = resolved.pathname;
    const packagePath = new URL(".", packageJSONUrl).pathname;
    if (!resolvedPath.startsWith(packagePath)) {
        throwInvalidPackageTarget(match12, target, packageJSONUrl, internal, base32);
    }
    if (subpath === "") return resolved;
    if (invalidSegmentRegEx.test(subpath)) {
        const request3 = pattern ? match12.replace("*", ()=>subpath
        ) : match12 + subpath;
        throwInvalidSubpath(request3, packageJSONUrl, internal, base32);
    }
    if (pattern) {
        return new URL(resolved.href.replace(patternRegEx, ()=>subpath
        ));
    }
    return new URL(subpath, resolved);
}
function isArrayIndex1(key) {
    const keyNum = +key;
    if (`${keyNum}` !== key) return false;
    return keyNum >= 0 && keyNum < 4294967295;
}
function resolvePackageTarget(packageJSONUrl, target, subpath, packageSubpath, base33, pattern, internal, conditions) {
    if (typeof target === "string") {
        return resolvePackageTargetString(target, subpath, packageSubpath, packageJSONUrl, base33, pattern, internal, conditions);
    } else if (Array.isArray(target)) {
        if (target.length === 0) {
            return undefined;
        }
        let lastException;
        for(let i250 = 0; i250 < target.length; i250++){
            const targetItem = target[i250];
            let resolved;
            try {
                resolved = resolvePackageTarget(packageJSONUrl, targetItem, subpath, packageSubpath, base33, pattern, internal, conditions);
            } catch (e52) {
                lastException = e52;
                if (e52 instanceof NodeError && e52.code === "ERR_INVALID_PACKAGE_TARGET") {
                    continue;
                }
                throw e52;
            }
            if (resolved === undefined) {
                continue;
            }
            if (resolved === null) {
                lastException = null;
                continue;
            }
            return resolved;
        }
        if (lastException === undefined || lastException === null) {
            return undefined;
        }
        throw lastException;
    } else if (typeof target === "object" && target !== null) {
        const keys = Object.getOwnPropertyNames(target);
        for(let i251 = 0; i251 < keys.length; i251++){
            const key = keys[i251];
            if (isArrayIndex1(key)) {
                throw new ERR_INVALID_PACKAGE_CONFIG(fileURLToPath(packageJSONUrl), base33, '"exports" cannot contain numeric property keys.');
            }
        }
        for(let i1102 = 0; i1102 < keys.length; i1102++){
            const key = keys[i1102];
            if (key === "default" || conditions.has(key)) {
                const conditionalTarget = target[key];
                const resolved = resolvePackageTarget(packageJSONUrl, conditionalTarget, subpath, packageSubpath, base33, pattern, internal, conditions);
                if (resolved === undefined) {
                    continue;
                }
                return resolved;
            }
        }
        return undefined;
    } else if (target === null) {
        return undefined;
    }
    throwInvalidPackageTarget(packageSubpath, target, packageJSONUrl, internal, base33);
}
function packageExportsResolve(packageJSONUrl, packageSubpath, packageConfig, base34, conditions) {
    let exports = packageConfig.exports;
    if (isConditionalExportsMainSugar(exports, packageJSONUrl, base34)) {
        exports = {
            ".": exports
        };
    }
    if (hasOwn1(exports, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
        const target = exports[packageSubpath];
        const resolved = resolvePackageTarget(packageJSONUrl, target, "", packageSubpath, base34, false, false, conditions);
        if (resolved === null || resolved === undefined) {
            throwExportsNotFound(packageSubpath, packageJSONUrl, base34);
        }
        return resolved;
    }
    let bestMatch = "";
    let bestMatchSubpath = "";
    const keys = Object.getOwnPropertyNames(exports);
    for(let i252 = 0; i252 < keys.length; i252++){
        const key = keys[i252];
        const patternIndex = key.indexOf("*");
        if (patternIndex !== -1 && packageSubpath.startsWith(key.slice(0, patternIndex))) {
            if (packageSubpath.endsWith("/")) {}
            const patternTrailer = key.slice(patternIndex + 1);
            if (packageSubpath.length >= key.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
                bestMatch = key;
                bestMatchSubpath = packageSubpath.slice(patternIndex, packageSubpath.length - patternTrailer.length);
            }
        }
    }
    if (bestMatch) {
        const target = exports[bestMatch];
        const resolved = resolvePackageTarget(packageJSONUrl, target, bestMatchSubpath, bestMatch, base34, true, false, conditions);
        if (resolved === null || resolved === undefined) {
            throwExportsNotFound(packageSubpath, packageJSONUrl, base34);
        }
        return resolved;
    }
    throwExportsNotFound(packageSubpath, packageJSONUrl, base34);
}
const packageJSONCache = new Map();
function getPackageConfig(path124, specifier, base35) {
    const existing = packageJSONCache.get(path124);
    if (existing !== undefined) {
        return existing;
    }
    let source;
    try {
        source = new TextDecoder().decode(Deno.readFileSync(path124));
    } catch  {}
    if (source === undefined) {
        const packageConfig = {
            pjsonPath: path124,
            exists: false,
            main: undefined,
            name: undefined,
            type: "none",
            exports: undefined,
            imports: undefined
        };
        packageJSONCache.set(path124, packageConfig);
        return packageConfig;
    }
    let packageJSON;
    try {
        packageJSON = JSON.parse(source);
    } catch (error27) {
        throw new ERR_INVALID_PACKAGE_CONFIG(path124, (base35 ? `"${specifier}" from ` : "") + fileURLToPath(base35 || specifier), error27.message);
    }
    let { imports: imports1 , main , name: name75 , type: type56  } = packageJSON;
    const { exports  } = packageJSON;
    if (typeof imports1 !== "object" || imports1 === null) imports1 = undefined;
    if (typeof main !== "string") main = undefined;
    if (typeof name75 !== "string") name75 = undefined;
    if (type56 !== "module" && type56 !== "commonjs") type56 = "none";
    const packageConfig = {
        pjsonPath: path124,
        exists: true,
        main,
        name: name75,
        type: type56,
        exports,
        imports: imports1
    };
    packageJSONCache.set(path124, packageConfig);
    return packageConfig;
}
function getPackageScopeConfig(resolved) {
    let packageJSONUrl = new URL("./package.json", resolved);
    while(true){
        const packageJSONPath = packageJSONUrl.pathname;
        if (packageJSONPath.endsWith("node_modules/package.json")) {
            break;
        }
        const packageConfig = getPackageConfig(fileURLToPath(packageJSONUrl), resolved);
        if (packageConfig.exists) return packageConfig;
        const lastPackageJSONUrl = packageJSONUrl;
        packageJSONUrl = new URL("../package.json", packageJSONUrl);
        if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) break;
    }
    const packageJSONPath = fileURLToPath(packageJSONUrl);
    const packageConfig = {
        pjsonPath: packageJSONPath,
        exists: false,
        main: undefined,
        name: undefined,
        type: "none",
        exports: undefined,
        imports: undefined
    };
    packageJSONCache.set(packageJSONPath, packageConfig);
    return packageConfig;
}
function packageImportsResolve(name76, base36, conditions) {
    if (name76 === "#" || name76.startsWith("#/") || name76.startsWith("/")) {
        const reason = "is not a valid internal imports specifier name";
        throw new ERR_INVALID_MODULE_SPECIFIER(name76, reason, fileURLToPath(base36));
    }
    let packageJSONUrl;
    const packageConfig = getPackageScopeConfig(base36);
    if (packageConfig.exists) {
        packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);
        const imports2 = packageConfig.imports;
        if (imports2) {
            if (hasOwn1(imports2, name76) && !name76.includes("*")) {
                const resolved = resolvePackageTarget(packageJSONUrl.toString(), imports2[name76], "", name76, base36, false, true, conditions);
                if (resolved !== null && resolved !== undefined) {
                    return resolved;
                }
            } else {
                let bestMatch = "";
                let bestMatchSubpath = "";
                const keys = Object.getOwnPropertyNames(imports2);
                for(let i253 = 0; i253 < keys.length; i253++){
                    const key = keys[i253];
                    const patternIndex = key.indexOf("*");
                    if (patternIndex !== -1 && name76.startsWith(key.slice(0, patternIndex))) {
                        const patternTrailer = key.slice(patternIndex + 1);
                        if (name76.length >= key.length && name76.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
                            bestMatch = key;
                            bestMatchSubpath = name76.slice(patternIndex, name76.length - patternTrailer.length);
                        }
                    }
                }
                if (bestMatch) {
                    const target = imports2[bestMatch];
                    const resolved = resolvePackageTarget(packageJSONUrl.toString(), target, bestMatchSubpath, bestMatch, base36, true, true, conditions);
                    if (resolved !== null && resolved !== undefined) {
                        return resolved;
                    }
                }
            }
        }
    }
    throwImportNotDefined(name76, packageJSONUrl, base36);
}
function isConditionalExportsMainSugar(exports, packageJSONUrl, base37) {
    if (typeof exports === "string" || Array.isArray(exports)) return true;
    if (typeof exports !== "object" || exports === null) return false;
    const keys = Object.getOwnPropertyNames(exports);
    let isConditionalSugar = false;
    let i254 = 0;
    for(let j = 0; j < keys.length; j++){
        const key = keys[j];
        const curIsConditionalSugar = key === "" || key[0] !== ".";
        if ((i254++) === 0) {
            isConditionalSugar = curIsConditionalSugar;
        } else if (isConditionalSugar !== curIsConditionalSugar) {
            const message = "\"exports\" cannot contain some keys starting with '.' and some not." + " The exports object must either be an object of package subpath keys" + " or an object of main entry condition name keys only.";
            throw new ERR_INVALID_PACKAGE_CONFIG(fileURLToPath(packageJSONUrl), base37, message);
        }
    }
    return isConditionalSugar;
}
const { hasOwn: hasOwn2  } = Object;
const CHAR_FORWARD_SLASH2 = "/".charCodeAt(0);
const CHAR_BACKWARD_SLASH = "\\".charCodeAt(0);
const CHAR_COLON = ":".charCodeAt(0);
const relativeResolveCache = Object.create(null);
let requireDepth = 0;
let statCache = null;
function stat1(filename) {
    filename = toNamespacedPath2(filename);
    if (statCache !== null) {
        const result = statCache.get(filename);
        if (result !== undefined) return result;
    }
    try {
        const info7 = Deno.statSync(filename);
        const result = info7.isFile ? 0 : 1;
        if (statCache !== null) statCache.set(filename, result);
        return result;
    } catch (e53) {
        if (e53 instanceof Deno.errors.PermissionDenied) {
            throw new Error("CJS loader requires --allow-read.");
        }
        return -1;
    }
}
function updateChildren(parent, child, scan) {
    const children = parent && parent.children;
    if (children && !(scan && children.includes(child))) {
        children.push(child);
    }
}
function finalizeEsmResolution(resolved, parentPath, pkgPath) {
    if (encodedSepRegEx.test(resolved)) {
        throw new ERR_INVALID_MODULE_SPECIFIER(resolved, 'must not include encoded "/" or "\\" characters', parentPath);
    }
    const filename = fileURLToPath(resolved);
    const actual = tryFile(filename, false);
    if (actual) {
        return actual;
    }
    throw new ERR_MODULE_NOT_FOUND(filename, resolve2(pkgPath, "package.json"));
}
function createEsmNotFoundErr(request4, path125) {
    const err178 = new Error(`Cannot find module '${request4}'`);
    err178.code = "MODULE_NOT_FOUND";
    if (path125) {
        err178.path = path125;
    }
    return err178;
}
function trySelfParentPath(parent) {
    if (!parent) return undefined;
    if (parent.filename) {
        return parent.filename;
    } else if (parent.id === "<repl>" || parent.id === "internal/preload") {
        try {
            return process.cwd() + sep2;
        } catch  {
            return undefined;
        }
    }
    return undefined;
}
function trySelf(parentPath, request5) {
    if (!parentPath) return false;
    const { data: pkg , path: pkgPath  } = readPackageScope(parentPath) || {
        data: {},
        path: ""
    };
    if (!pkg || pkg.exports === undefined) return false;
    if (typeof pkg.name !== "string") return false;
    let expansion;
    if (request5 === pkg.name) {
        expansion = ".";
    } else if (request5.startsWith(`${pkg.name}/`)) {
        expansion = "." + request5.slice(pkg.name.length);
    } else {
        return false;
    }
    try {
        return finalizeEsmResolution(packageExportsResolve(pathToFileURL(pkgPath + "/package.json").toString(), expansion, pkg, pathToFileURL(parentPath).toString(), cjsConditions).toString(), parentPath, pkgPath);
    } catch (e54) {
        if (e54 instanceof NodeError && e54.code === "ERR_MODULE_NOT_FOUND") {
            throw createEsmNotFoundErr(request5, pkgPath + "/package.json");
        }
        throw e54;
    }
}
class Module {
    id;
    exports;
    parent;
    filename;
    loaded;
    children;
    paths;
    path;
    constructor(id = "", parent){
        this.id = id;
        this.exports = {};
        this.parent = parent || null;
        updateChildren(parent || null, this, false);
        this.filename = null;
        this.loaded = false;
        this.children = [];
        this.paths = [];
        this.path = dirname2(id);
    }
    static builtinModules = [];
    static _extensions = Object.create(null);
    static _cache = Object.create(null);
    static _pathCache = Object.create(null);
    static globalPaths = [];
    static wrapper = [
        "(function (exports, require, module, __filename, __dirname, setTimeout, clearTimeout, setInterval, clearInterval) { (function (exports, require, module, __filename, __dirname) {",
        "\n}).call(this, exports, require, module, __filename, __dirname); })", 
    ];
    require(id) {
        if (id === "") {
            throw new Error(`id '${id}' must be a non-empty string`);
        }
        requireDepth++;
        try {
            return Module._load(id, this, false);
        } finally{
            requireDepth--;
        }
    }
    load(filename) {
        assert1(!this.loaded);
        this.filename = filename;
        this.paths = Module._nodeModulePaths(dirname2(filename));
        const extension = findLongestRegisteredExtension(filename);
        Module._extensions[extension](this, filename);
        this.loaded = true;
    }
    _compile(content, filename) {
        const compiledWrapper = wrapSafe(filename, content, this);
        const dirname6 = dirname2(filename);
        const require = makeRequireFunction(this);
        const exports = this.exports;
        const thisValue = exports;
        if (requireDepth === 0) {
            statCache = new Map();
        }
        const result = compiledWrapper.call(thisValue, exports, require, this, filename, dirname6, setTimeout2, clearTimeout1, setInterval, clearInterval);
        if (requireDepth === 0) {
            statCache = null;
        }
        return result;
    }
    static _resolveLookupPaths(request6, parent) {
        if (request6.charAt(0) !== "." || request6.length > 1 && request6.charAt(1) !== "." && request6.charAt(1) !== "/" && (!isWindows || request6.charAt(1) !== "\\")) {
            let paths = modulePaths;
            if (parent !== null && parent.paths && parent.paths.length) {
                paths = parent.paths.concat(paths);
            }
            return paths.length > 0 ? paths : null;
        }
        if (!parent || !parent.id || !parent.filename) {
            return [
                "."
            ].concat(Module._nodeModulePaths("."), modulePaths);
        }
        return [
            dirname2(parent.filename)
        ];
    }
    static _resolveFilename(request7, parent, isMain, options) {
        if (request7.startsWith("node:") || nativeModuleCanBeRequiredByUsers(request7)) {
            return request7;
        }
        let paths;
        if (typeof options === "object" && options !== null) {
            if (Array.isArray(options.paths)) {
                const isRelative = request7.startsWith("./") || request7.startsWith("../") || isWindows && request7.startsWith(".\\") || request7.startsWith("..\\");
                if (isRelative) {
                    paths = options.paths;
                } else {
                    const fakeParent = new Module("", null);
                    paths = [];
                    for(let i255 = 0; i255 < options.paths.length; i255++){
                        const path210 = options.paths[i255];
                        fakeParent.paths = Module._nodeModulePaths(path210);
                        const lookupPaths = Module._resolveLookupPaths(request7, fakeParent);
                        for(let j = 0; j < lookupPaths.length; j++){
                            if (!paths.includes(lookupPaths[j])) {
                                paths.push(lookupPaths[j]);
                            }
                        }
                    }
                }
            } else if (options.paths === undefined) {
                paths = Module._resolveLookupPaths(request7, parent);
            } else {
                throw new Error("options.paths is invalid");
            }
        } else {
            paths = Module._resolveLookupPaths(request7, parent);
        }
        if (parent?.filename) {
            if (request7[0] === "#") {
                const pkg = readPackageScope(parent.filename) || {
                    path: "",
                    data: {}
                };
                if (pkg.data?.imports != null) {
                    try {
                        return finalizeEsmResolution(packageImportsResolve(request7, pathToFileURL(parent.filename).toString(), cjsConditions).toString(), parent.filename, pkg.path);
                    } catch (e55) {
                        if (e55 instanceof NodeError && e55.code === "ERR_MODULE_NOT_FOUND") {
                            throw createEsmNotFoundErr(request7);
                        }
                        throw e55;
                    }
                }
            }
        }
        const parentPath = trySelfParentPath(parent);
        const selfResolved = trySelf(parentPath, request7);
        if (selfResolved) {
            const cacheKey = request7 + "\x00" + (paths.length === 1 ? paths[0] : paths.join("\x00"));
            Module._pathCache[cacheKey] = selfResolved;
            return selfResolved;
        }
        const filename = Module._findPath(request7, paths, isMain);
        if (!filename) {
            const requireStack = [];
            for(let cursor = parent; cursor; cursor = cursor.parent){
                requireStack.push(cursor.filename || cursor.id);
            }
            let message = `Cannot find module '${request7}'`;
            if (requireStack.length > 0) {
                message = message + "\nRequire stack:\n- " + requireStack.join("\n- ");
            }
            const err179 = new Error(message);
            err179.code = "MODULE_NOT_FOUND";
            err179.requireStack = requireStack;
            throw err179;
        }
        return filename;
    }
    static _findPath(request8, paths, isMain) {
        const absoluteRequest = isAbsolute2(request8);
        if (absoluteRequest) {
            paths = [
                ""
            ];
        } else if (!paths || paths.length === 0) {
            return false;
        }
        const cacheKey = request8 + "\x00" + (paths.length === 1 ? paths[0] : paths.join("\x00"));
        const entry = Module._pathCache[cacheKey];
        if (entry) {
            return entry;
        }
        let exts;
        let trailingSlash = request8.length > 0 && request8.charCodeAt(request8.length - 1) === CHAR_FORWARD_SLASH2;
        if (!trailingSlash) {
            trailingSlash = /(?:^|\/)\.?\.$/.test(request8);
        }
        for(let i256 = 0; i256 < paths.length; i256++){
            const curPath = paths[i256];
            if (curPath && stat1(curPath) < 1) continue;
            const basePath = resolveExports(curPath, request8, absoluteRequest);
            let filename;
            const rc = stat1(basePath);
            if (!trailingSlash) {
                if (rc === 0) {
                    filename = toRealPath(basePath);
                }
                if (!filename) {
                    if (exts === undefined) exts = Object.keys(Module._extensions);
                    filename = tryExtensions(basePath, exts, isMain);
                }
            }
            if (!filename && rc === 1) {
                if (exts === undefined) exts = Object.keys(Module._extensions);
                filename = tryPackage(basePath, exts, isMain, request8);
            }
            if (filename) {
                Module._pathCache[cacheKey] = filename;
                return filename;
            }
        }
        return false;
    }
    static _load(request9, parent, isMain) {
        let relResolveCacheIdentifier;
        if (parent) {
            relResolveCacheIdentifier = `${parent.path}\x00${request9}`;
            const filename = relativeResolveCache[relResolveCacheIdentifier];
            if (filename !== undefined) {
                const cachedModule = Module._cache[filename];
                if (cachedModule !== undefined) {
                    updateChildren(parent, cachedModule, true);
                    if (!cachedModule.loaded) {
                        return getExportsForCircularRequire(cachedModule);
                    }
                    return cachedModule.exports;
                }
                delete relativeResolveCache[relResolveCacheIdentifier];
            }
        }
        const filename = Module._resolveFilename(request9, parent, isMain);
        if (filename.startsWith("node:")) {
            const id = filename.slice(5);
            const module = loadNativeModule(id, id);
            return module?.exports;
        }
        const cachedModule = Module._cache[filename];
        if (cachedModule !== undefined) {
            updateChildren(parent, cachedModule, true);
            if (!cachedModule.loaded) {
                return getExportsForCircularRequire(cachedModule);
            }
            return cachedModule.exports;
        }
        const mod67 = loadNativeModule(filename, request9);
        if (mod67) return mod67.exports;
        const upstreamMod = loadUpstreamModule(filename, parent, request9);
        if (upstreamMod) return upstreamMod.exports;
        const module = new Module(filename, parent);
        if (isMain) {
            process.mainModule = module;
            module.id = ".";
        }
        Module._cache[filename] = module;
        if (parent !== undefined) {
            relativeResolveCache[relResolveCacheIdentifier] = filename;
        }
        let threw = true;
        try {
            module.load(filename);
            threw = false;
        } finally{
            if (threw) {
                delete Module._cache[filename];
                if (parent !== undefined) {
                    delete relativeResolveCache[relResolveCacheIdentifier];
                }
            } else if (module.exports && Object.getPrototypeOf(module.exports) === CircularRequirePrototypeWarningProxy) {
                Object.setPrototypeOf(module.exports, PublicObjectPrototype);
            }
        }
        return module.exports;
    }
    static wrap(script) {
        script = script.replace(/^#!.*?\n/, "");
        return `${Module.wrapper[0]}${script}${Module.wrapper[1]}`;
    }
    static _nodeModulePaths(from) {
        if (isWindows) {
            from = resolve2(from);
            if (from.charCodeAt(from.length - 1) === CHAR_BACKWARD_SLASH && from.charCodeAt(from.length - 2) === CHAR_COLON) {
                return [
                    from + "node_modules"
                ];
            }
            const paths = [];
            for(let i257 = from.length - 1, p32 = 0, last = from.length; i257 >= 0; --i257){
                const code71 = from.charCodeAt(i257);
                if (code71 === CHAR_BACKWARD_SLASH || code71 === CHAR_FORWARD_SLASH2 || code71 === CHAR_COLON) {
                    if (p32 !== nmLen) paths.push(from.slice(0, last) + "\\node_modules");
                    last = i257;
                    p32 = 0;
                } else if (p32 !== -1) {
                    if (nmChars[p32] === code71) {
                        ++p32;
                    } else {
                        p32 = -1;
                    }
                }
            }
            return paths;
        } else {
            from = resolve2(from);
            if (from === "/") return [
                "/node_modules"
            ];
            const paths = [];
            for(let i258 = from.length - 1, p33 = 0, last = from.length; i258 >= 0; --i258){
                const code72 = from.charCodeAt(i258);
                if (code72 === CHAR_FORWARD_SLASH2) {
                    if (p33 !== nmLen) paths.push(from.slice(0, last) + "/node_modules");
                    last = i258;
                    p33 = 0;
                } else if (p33 !== -1) {
                    if (nmChars[p33] === code72) {
                        ++p33;
                    } else {
                        p33 = -1;
                    }
                }
            }
            paths.push("/node_modules");
            return paths;
        }
    }
    static createRequire(filename) {
        let filepath;
        if (filename instanceof URL || typeof filename === "string" && !isAbsolute2(filename)) {
            try {
                filepath = fileURLToPath(filename);
            } catch (err180) {
                if (err180 instanceof Deno.errors.InvalidData && err180.message.includes("invalid url scheme")) {
                    throw new Error(`${createRequire.name} only supports 'file://' URLs for the 'filename' parameter`);
                } else {
                    throw err180;
                }
            }
        } else if (typeof filename !== "string") {
            throw new Error("filename should be a string");
        } else {
            filepath = filename;
        }
        return createRequireFromPath(filepath);
    }
    static _initPaths() {
        const homeDir = Deno.env.get("HOME");
        const nodePath = Deno.env.get("NODE_PATH");
        let paths = [];
        if (homeDir) {
            paths.unshift(resolve2(homeDir, ".node_libraries"));
            paths.unshift(resolve2(homeDir, ".node_modules"));
        }
        if (nodePath) {
            paths = nodePath.split(delimiter2).filter(function pathsFilterCB(path310) {
                return !!path310;
            }).concat(paths);
        }
        modulePaths = paths;
        Module.globalPaths = modulePaths.slice(0);
    }
    static _preloadModules(requests) {
        if (!Array.isArray(requests)) {
            return;
        }
        const parent = new Module("internal/preload", null);
        try {
            parent.paths = Module._nodeModulePaths(Deno.cwd());
        } catch (e56) {
            if (!(e56 instanceof Error) || e56.code !== "ENOENT") {
                throw e56;
            }
        }
        for(let n54 = 0; n54 < requests.length; n54++){
            parent.require(requests[n54]);
        }
    }
}
const nativeModulePolyfill = new Map();
function createNativeModule(id, exports) {
    const mod68 = new Module(id);
    mod68.exports = exports;
    mod68.loaded = true;
    return mod68;
}
const m = {
    _cache: Module._cache,
    _extensions: Module._extensions,
    _findPath: Module._findPath,
    _initPaths: Module._initPaths,
    _load: Module._load,
    _nodeModulePaths: Module._nodeModulePaths,
    _pathCache: Module._pathCache,
    _preloadModules: Module._preloadModules,
    _resolveFilename: Module._resolveFilename,
    _resolveLookupPaths: Module._resolveLookupPaths,
    builtinModules: Module.builtinModules,
    createRequire: Module.createRequire,
    globalPaths: Module.globalPaths,
    Module,
    wrap: Module.wrap
};
Object.setPrototypeOf(m, Module);
__default62.module = m;
function loadNativeModule(_filename, request10) {
    if (nativeModulePolyfill.has(request10)) {
        return nativeModulePolyfill.get(request10);
    }
    const mod69 = __default62[request10];
    if (mod69) {
        const nodeMod = createNativeModule(request10, mod69);
        nativeModulePolyfill.set(request10, nodeMod);
        return nodeMod;
    }
    return undefined;
}
function nativeModuleCanBeRequiredByUsers(request11) {
    return hasOwn2(__default62, request11);
}
Module.builtinModules.push(...Object.keys(__default62));
const upstreamModules = new Map();
function loadUpstreamModule(filename, parent, request12) {
    if (typeof __default63[request12] !== "undefined") {
        if (!upstreamModules.has(filename)) {
            upstreamModules.set(filename, createUpstreamModule(filename, parent, __default63[request12]));
        }
        return upstreamModules.get(filename);
    }
}
function createUpstreamModule(filename, parent, content) {
    const mod70 = new Module(filename, parent);
    mod70.filename = filename;
    mod70.paths = Module._nodeModulePaths(dirname2(filename));
    mod70._compile(content, filename);
    mod70.loaded = true;
    return mod70;
}
let modulePaths = [];
const packageJsonCache = new Map();
function readPackage(requestPath) {
    const jsonPath = resolve2(requestPath, "package.json");
    const existing = packageJsonCache.get(jsonPath);
    if (existing !== undefined) {
        return existing;
    }
    let json1;
    try {
        json1 = new TextDecoder().decode(Deno.readFileSync(toNamespacedPath2(jsonPath)));
    } catch  {}
    if (json1 === undefined) {
        packageJsonCache.set(jsonPath, null);
        return null;
    }
    try {
        const parsed = JSON.parse(json1);
        const filtered = {
            name: parsed.name,
            main: parsed.main,
            path: jsonPath,
            exports: parsed.exports,
            imports: parsed.imports,
            type: parsed.type
        };
        packageJsonCache.set(jsonPath, filtered);
        return filtered;
    } catch (e57) {
        const err181 = e57 instanceof Error ? e57 : new Error("[non-error thrown]");
        err181.path = jsonPath;
        err181.message = "Error parsing " + jsonPath + ": " + err181.message;
        throw e57;
    }
}
function readPackageScope(checkPath) {
    const rootSeparatorIndex = checkPath.indexOf(sep2);
    let separatorIndex;
    while((separatorIndex = checkPath.lastIndexOf(sep2)) > rootSeparatorIndex){
        checkPath = checkPath.slice(0, separatorIndex);
        if (checkPath.endsWith(sep2 + "node_modules")) return false;
        const pjson = readPackage(checkPath);
        if (pjson) {
            return {
                path: checkPath,
                data: pjson
            };
        }
    }
    return false;
}
function readPackageMain(requestPath) {
    const pkg = readPackage(requestPath);
    return pkg ? pkg.main : undefined;
}
function readPackageExports(requestPath) {
    const pkg = readPackage(requestPath);
    return pkg ? pkg.exports : undefined;
}
function tryPackage(requestPath, exts, isMain, _originalPath) {
    const pkg = readPackageMain(requestPath);
    if (!pkg) {
        return tryExtensions(resolve2(requestPath, "index"), exts, isMain);
    }
    const filename = resolve2(requestPath, pkg);
    let actual = tryFile(filename, isMain) || tryExtensions(filename, exts, isMain) || tryExtensions(resolve2(filename, "index"), exts, isMain);
    if (actual === false) {
        actual = tryExtensions(resolve2(requestPath, "index"), exts, isMain);
        if (!actual) {
            const err182 = new Error(`Cannot find module '${filename}'. ` + 'Please verify that the package.json has a valid "main" entry');
            err182.code = "MODULE_NOT_FOUND";
            throw err182;
        }
    }
    return actual;
}
function tryFile(requestPath, _isMain) {
    const rc = stat1(requestPath);
    return rc === 0 && toRealPath(requestPath);
}
function toRealPath(requestPath) {
    return Deno.realPathSync(requestPath);
}
function tryExtensions(p34, exts, isMain) {
    for(let i259 = 0; i259 < exts.length; i259++){
        const filename = tryFile(p34 + exts[i259], isMain);
        if (filename) {
            return filename;
        }
    }
    return false;
}
function findLongestRegisteredExtension(filename) {
    const name77 = basename2(filename);
    let currentExtension;
    let index20;
    let startIndex = 0;
    while((index20 = name77.indexOf(".", startIndex)) !== -1){
        startIndex = index20 + 1;
        if (index20 === 0) continue;
        currentExtension = name77.slice(index20);
        if (Module._extensions[currentExtension]) return currentExtension;
    }
    return ".js";
}
function isConditionalDotExportSugar(exports, _basePath) {
    if (typeof exports === "string") return true;
    if (Array.isArray(exports)) return true;
    if (typeof exports !== "object") return false;
    let isConditional = false;
    let firstCheck = true;
    for (const key of Object.keys(exports)){
        const curIsConditional = key[0] !== ".";
        if (firstCheck) {
            firstCheck = false;
            isConditional = curIsConditional;
        } else if (isConditional !== curIsConditional) {
            throw new Error('"exports" cannot ' + "contain some keys starting with '.' and some not. The exports " + "object must either be an object of package subpath keys or an " + "object of main entry condition name keys only.");
        }
    }
    return isConditional;
}
function applyExports(basePath, expansion) {
    const mappingKey = `.${expansion}`;
    let pkgExports = readPackageExports(basePath);
    if (pkgExports === undefined || pkgExports === null) {
        return resolve2(basePath, mappingKey);
    }
    if (isConditionalDotExportSugar(pkgExports, basePath)) {
        pkgExports = {
            ".": pkgExports
        };
    }
    if (typeof pkgExports === "object") {
        if (hasOwn2(pkgExports, mappingKey)) {
            const mapping = pkgExports[mappingKey];
            return resolveExportsTarget(pathToFileURL(basePath + "/"), mapping, "", basePath, mappingKey);
        }
        if (mappingKey === ".") return basePath;
        let dirMatch = "";
        for (const candidateKey of Object.keys(pkgExports)){
            if (candidateKey[candidateKey.length - 1] !== "/") continue;
            if (candidateKey.length > dirMatch.length && mappingKey.startsWith(candidateKey)) {
                dirMatch = candidateKey;
            }
        }
        if (dirMatch !== "") {
            const mapping = pkgExports[dirMatch];
            const subpath = mappingKey.slice(dirMatch.length);
            return resolveExportsTarget(pathToFileURL(basePath + "/"), mapping, subpath, basePath, mappingKey);
        }
    }
    if (mappingKey === ".") return basePath;
    const e58 = new Error(`Package exports for '${basePath}' do not define ` + `a '${mappingKey}' subpath`);
    e58.code = "MODULE_NOT_FOUND";
    throw e58;
}
const EXPORTS_PATTERN = /^((?:@[^/\\%]+\/)?[^./\\%][^/\\%]*)(\/.*)?$/;
function resolveExports(nmPath, request13, absoluteRequest) {
    if (!absoluteRequest) {
        const [, name78, expansion = ""] = request13.match(EXPORTS_PATTERN) || [];
        if (!name78) {
            return resolve2(nmPath, request13);
        }
        const basePath = resolve2(nmPath, name78);
        return applyExports(basePath, expansion);
    }
    return resolve2(nmPath, request13);
}
const cjsConditions = new Set([
    "deno",
    "require",
    "node"
]);
function resolveExportsTarget(pkgPath, target, subpath, basePath, mappingKey) {
    if (typeof target === "string") {
        if (target.startsWith("./") && (subpath.length === 0 || target.endsWith("/"))) {
            const resolvedTarget = new URL(target, pkgPath);
            const pkgPathPath = pkgPath.pathname;
            const resolvedTargetPath = resolvedTarget.pathname;
            if (resolvedTargetPath.startsWith(pkgPathPath) && resolvedTargetPath.indexOf("/node_modules/", pkgPathPath.length - 1) === -1) {
                const resolved = new URL(subpath, resolvedTarget);
                const resolvedPath = resolved.pathname;
                if (resolvedPath.startsWith(resolvedTargetPath) && resolvedPath.indexOf("/node_modules/", pkgPathPath.length - 1) === -1) {
                    return fileURLToPath(resolved);
                }
            }
        }
    } else if (Array.isArray(target)) {
        for (const targetValue of target){
            if (Array.isArray(targetValue)) continue;
            try {
                return resolveExportsTarget(pkgPath, targetValue, subpath, basePath, mappingKey);
            } catch (e59) {
                if (!(e59 instanceof Error) || e59.code !== "MODULE_NOT_FOUND") {
                    throw e59;
                }
            }
        }
    } else if (typeof target === "object" && target !== null) {
        for (const key of Object.keys(target)){
            if (key !== "default" && !cjsConditions.has(key)) {
                continue;
            }
            if (hasOwn2(target, key)) {
                try {
                    return resolveExportsTarget(pkgPath, target[key], subpath, basePath, mappingKey);
                } catch (e60) {
                    if (!(e60 instanceof Error) || e60.code !== "MODULE_NOT_FOUND") {
                        throw e60;
                    }
                }
            }
        }
    }
    let e61;
    if (mappingKey !== ".") {
        e61 = new Error(`Package exports for '${basePath}' do not define a ` + `valid '${mappingKey}' target${subpath ? " for " + subpath : ""}`);
    } else {
        e61 = new Error(`No valid exports main found for '${basePath}'`);
    }
    e61.code = "MODULE_NOT_FOUND";
    throw e61;
}
const nmChars = [
    115,
    101,
    108,
    117,
    100,
    111,
    109,
    95,
    101,
    100,
    111,
    110
];
const nmLen = nmChars.length;
function emitCircularRequireWarning(prop) {
    console.error(`Accessing non-existent property '${String(prop)}' of module exports inside circular dependency`);
}
const CircularRequirePrototypeWarningProxy = new Proxy({}, {
    get (target, prop) {
        if (prop in target) return target[prop];
        emitCircularRequireWarning(prop);
        return undefined;
    },
    getOwnPropertyDescriptor (target, prop) {
        if (hasOwn2(target, prop)) {
            return Object.getOwnPropertyDescriptor(target, prop);
        }
        emitCircularRequireWarning(prop);
        return undefined;
    }
});
const PublicObjectPrototype = globalThis.Object.prototype;
function getExportsForCircularRequire(module) {
    if (module.exports && Object.getPrototypeOf(module.exports) === PublicObjectPrototype && !module.exports.__esModule) {
        Object.setPrototypeOf(module.exports, CircularRequirePrototypeWarningProxy);
    }
    return module.exports;
}
function enrichCJSError(error28) {
    if (error28 instanceof SyntaxError) {
        if (error28.message.includes("Cannot use import statement outside a module") || error28.message.includes("Unexpected token 'export'")) {
            console.error('To load an ES module, set "type": "module" in the package.json or use ' + "the .mjs extension.");
        }
    }
}
function wrapSafe(filename, content, cjsModuleInstance) {
    const wrapper = Module.wrap(content);
    const [f3, err183] = core.evalContext(wrapper, filename);
    if (err183) {
        if (process.mainModule === cjsModuleInstance) {
            enrichCJSError(err183.thrown);
        }
        throw err183.thrown;
    }
    return f3;
}
Module._extensions[".js"] = (module, filename)=>{
    if (filename.endsWith(".js")) {
        const pkg = readPackageScope(filename);
        if (pkg !== false && pkg.data && pkg.data.type === "module") {
            throw new Error("Importing ESM module");
        }
    }
    const content = new TextDecoder().decode(Deno.readFileSync(filename));
    module._compile(content, filename);
};
Module._extensions[".mjs"] = ()=>{
    throw new Error("Importing ESM module");
};
Module._extensions[".json"] = (module, filename)=>{
    const content = new TextDecoder().decode(Deno.readFileSync(filename));
    try {
        module.exports = JSON.parse(stripBOM(content));
    } catch (err184) {
        const e62 = err184 instanceof Error ? err184 : new Error("[non-error thrown]");
        e62.message = `${filename}: ${e62.message}`;
        throw e62;
    }
};
function createRequireFromPath(filename) {
    const trailingSlash = filename.endsWith("/") || isWindows && filename.endsWith("\\");
    const proxyPath = trailingSlash ? join4(filename, "noop.js") : filename;
    const m1 = new Module(proxyPath);
    m1.filename = proxyPath;
    m1.paths = Module._nodeModulePaths(m1.path);
    return makeRequireFunction(m1);
}
function makeRequireFunction(mod71) {
    const require = function require(path4) {
        return mod71.require(path4);
    };
    function resolve21(request14, options) {
        return Module._resolveFilename(request14, mod71, false, options);
    }
    require.resolve = resolve21;
    function paths(request15) {
        return Module._resolveLookupPaths(request15, mod71);
    }
    resolve21.paths = paths;
    require.main = process.mainModule;
    require.extensions = Module._extensions;
    require.cache = Module._cache;
    return require;
}
function stripBOM(content) {
    if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
    }
    return content;
}
Module.builtinModules;
const createRequire = Module.createRequire;
const importMeta = {
    url: "file:///Users/jeffhykin/repos/nix-version/node_modules/meilisearch/dist/bundles/meilisearch.esm.min.js",
    main: import.meta.main
};
const require1 = createRequire(importMeta.url);
const t = require1("crypto");
var e = function(t1, n1) {
    return (e = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(t2, e1) {
        t2.__proto__ = e1;
    } || function(t3, e2) {
        for(var n2 in e2)Object.prototype.hasOwnProperty.call(e2, n2) && (t3[n2] = e2[n2]);
    })(t1, n1);
};
function n(t4, n3) {
    if ("function" != typeof n3 && null !== n3) throw new TypeError("Class extends value " + String(n3) + " is not a constructor or null");
    function r1() {
        this.constructor = t4;
    }
    e(t4, n3), t4.prototype = null === n3 ? Object.create(n3) : (r1.prototype = n3.prototype, new r1);
}
var r = function() {
    return (r = Object.assign || function(t5) {
        for(var e3, n4 = 1, r2 = arguments.length; n4 < r2; n4++)for(var i1103 in e3 = arguments[n4])Object.prototype.hasOwnProperty.call(e3, i1103) && (t5[i1103] = e3[i1103]);
        return t5;
    }).apply(this, arguments);
};
function i2(t6, e4, n5, r3) {
    return new (n5 || (n5 = Promise))(function(i260, s1) {
        function o1(t7) {
            try {
                c1(r3.next(t7));
            } catch (t8) {
                s1(t8);
            }
        }
        function u1(t9) {
            try {
                c1(r3.throw(t9));
            } catch (t10) {
                s1(t10);
            }
        }
        function c1(t11) {
            var e5;
            t11.done ? i260(t11.value) : (e5 = t11.value, e5 instanceof n5 ? e5 : new n5(function(t12) {
                t12(e5);
            })).then(o1, u1);
        }
        c1((r3 = r3.apply(t6, e4 || [])).next());
    });
}
function s(t13, e6) {
    var n6, r4, i3, s2, o2 = {
        label: 0,
        sent: function() {
            if (1 & i3[0]) throw i3[1];
            return i3[1];
        },
        trys: [],
        ops: []
    };
    return s2 = {
        next: u2(0),
        throw: u2(1),
        return: u2(2)
    }, "function" == typeof Symbol && (s2[Symbol.iterator] = function() {
        return this;
    }), s2;
    function u2(s3) {
        return function(u3) {
            return (function(s4) {
                if (n6) throw new TypeError("Generator is already executing.");
                for(; o2;)try {
                    if (n6 = 1, r4 && (i3 = 2 & s4[0] ? r4.return : s4[0] ? r4.throw || ((i3 = r4.return) && i3.call(r4), 0) : r4.next) && !(i3 = i3.call(r4, s4[1])).done) return i3;
                    switch(r4 = 0, i3 && (s4 = [
                        2 & s4[0],
                        i3.value
                    ]), s4[0]){
                        case 0:
                        case 1:
                            i3 = s4;
                            break;
                        case 4:
                            return o2.label++, {
                                value: s4[1],
                                done: !1
                            };
                        case 5:
                            o2.label++, r4 = s4[1], s4 = [
                                0
                            ];
                            continue;
                        case 7:
                            s4 = o2.ops.pop(), o2.trys.pop();
                            continue;
                        default:
                            if (!(i3 = o2.trys, (i3 = i3.length > 0 && i3[i3.length - 1]) || 6 !== s4[0] && 2 !== s4[0])) {
                                o2 = 0;
                                continue;
                            }
                            if (3 === s4[0] && (!i3 || s4[1] > i3[0] && s4[1] < i3[3])) {
                                o2.label = s4[1];
                                break;
                            }
                            if (6 === s4[0] && o2.label < i3[1]) {
                                o2.label = i3[1], i3 = s4;
                                break;
                            }
                            if (i3 && o2.label < i3[2]) {
                                o2.label = i3[2], o2.ops.push(s4);
                                break;
                            }
                            i3[2] && o2.ops.pop(), o2.trys.pop();
                            continue;
                    }
                    s4 = e6.call(t13, o2);
                } catch (t14) {
                    s4 = [
                        6,
                        t14
                    ], r4 = 0;
                } finally{
                    n6 = i3 = 0;
                }
                if (5 & s4[0]) throw s4[1];
                return {
                    value: s4[0] ? s4[1] : void 0,
                    done: !0
                };
            })([
                s3,
                u3
            ]);
        };
    }
}
var o = function(t15) {
    function e7(n7, r5, i4, s5) {
        var o3, u4, c2, a1 = this;
        return (a1 = t15.call(this, n7) || this).name = "MeiliSearchCommunicationError", a1.type = "MeiliSearchCommunicationError", r5 instanceof Response && (a1.message = r5.statusText, a1.statusCode = r5.status), r5 instanceof Error && (a1.errno = r5.errno, a1.code = r5.code), s5 ? (a1.stack = s5, a1.stack = null === (o3 = a1.stack) || void 0 === o3 ? void 0 : o3.replace(/(TypeError|FetchError)/, a1.name), a1.stack = null === (u4 = a1.stack) || void 0 === u4 ? void 0 : u4.replace("Failed to fetch", "request to ".concat(i4, " failed, reason: connect ECONNREFUSED")), a1.stack = null === (c2 = a1.stack) || void 0 === c2 ? void 0 : c2.replace("Not Found", "Not Found: ".concat(i4))) : Error.captureStackTrace && Error.captureStackTrace(a1, e7), a1;
    }
    return n(e7, t15), e7;
}(Error), u = function(t16) {
    function e8(e9, n8) {
        var r6 = t16.call(this, e9.message) || this;
        return r6.name = "MeiliSearchApiError", r6.code = e9.code, r6.type = e9.type, r6.link = e9.link, r6.message = e9.message, r6.httpStatus = n8, Object.setPrototypeOf(r6, u.prototype), Error.captureStackTrace && Error.captureStackTrace(r6, u), r6;
    }
    return n(e8, t16), e8;
}(Error);
function c(t17) {
    return i2(this, void 0, void 0, function() {
        var e10;
        return s(this, function(n9) {
            switch(n9.label){
                case 0:
                    if (t17.ok) return [
                        3,
                        5
                    ];
                    e10 = void 0, n9.label = 1;
                case 1:
                    return n9.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]), [
                        4,
                        t17.json()
                    ];
                case 2:
                    return e10 = n9.sent(), [
                        3,
                        4
                    ];
                case 3:
                    throw n9.sent(), new o(t17.statusText, t17, t17.url);
                case 4:
                    throw new u(e10, t17.status);
                case 5:
                    return [
                        2,
                        t17
                    ];
            }
        });
    });
}
function a(t18, e11, n10) {
    if ("MeiliSearchApiError" !== t18.type) throw new o(t18.message, t18, n10, e11);
    throw t18;
}
var h = function(t19) {
    function e12(n11) {
        var r7 = t19.call(this, n11) || this;
        return r7.name = "MeiliSearchError", r7.type = "MeiliSearchError", Error.captureStackTrace && Error.captureStackTrace(r7, e12), r7;
    }
    return n(e12, t19), e12;
}(Error), d = function(t20) {
    function e13(n12) {
        var r8 = t20.call(this, n12) || this;
        return r8.name = "MeiliSearchTimeOutError", r8.type = r8.constructor.name, Error.captureStackTrace && Error.captureStackTrace(r8, e13), r8;
    }
    return n(e13, t20), e13;
}(Error);
function l(t21) {
    return Object.entries(t21).reduce(function(t22, e14) {
        var n13 = e14[0], r9 = e14[1];
        return void 0 !== r9 && (t22[n13] = r9), t22;
    }, {});
}
function p(t23) {
    return i2(this, void 0, void 0, function() {
        return s(this, function(e15) {
            switch(e15.label){
                case 0:
                    return [
                        4,
                        new Promise(function(e16) {
                            return setTimeout(e16, t23);
                        })
                    ];
                case 1:
                    return [
                        2,
                        e15.sent()
                    ];
            }
        });
    });
}
function f(t24) {
    return t24.startsWith("https://") || t24.startsWith("http://") ? t24 : "http://".concat(t24);
}
function v(t25) {
    return t25.endsWith("/") || (t25 += "/"), t25;
}
var y = function() {
    function t26(t27) {
        this.headers = Object.assign({}, t27.headers || {}), this.headers["Content-Type"] = "application/json", t27.apiKey && (this.headers.Authorization = "Bearer ".concat(t27.apiKey));
        try {
            var e17 = function(t28) {
                try {
                    return v(t28 = f(t28));
                } catch (t) {
                    throw new h("The provided host is not valid.");
                }
            }(t27.host);
            this.url = new URL(e17);
        } catch (t) {
            throw new h("The provided host is not valid.");
        }
    }
    return t26.prototype.request = function(t29) {
        var e18 = t29.method, n14 = t29.url, o4 = t29.params, u5 = t29.body, h1 = t29.config;
        return i2(this, void 0, void 0, function() {
            var t30, i5, d1, l1, p1;
            return s(this, function(s6) {
                switch(s6.label){
                    case 0:
                        t30 = new URL(n14, this.url), o4 && (i5 = new URLSearchParams, Object.keys(o4).filter(function(t31) {
                            return null !== o4[t31];
                        }).map(function(t32) {
                            return i5.set(t32, o4[t32]);
                        }), t30.search = i5.toString()), s6.label = 1;
                    case 1:
                        return s6.trys.push([
                            1,
                            4,
                            ,
                            5
                        ]), [
                            4,
                            fetch(t30.toString(), r(r({}, h1), {
                                method: e18,
                                body: JSON.stringify(u5),
                                headers: this.headers
                            })).then(function(t33) {
                                return c(t33);
                            })
                        ];
                    case 2:
                        return [
                            4,
                            s6.sent().text()
                        ];
                    case 3:
                        d1 = s6.sent();
                        try {
                            return [
                                2,
                                JSON.parse(d1)
                            ];
                        } catch (t) {
                            return [
                                2
                            ];
                        }
                        return [
                            3,
                            5
                        ];
                    case 4:
                        return l1 = s6.sent(), p1 = l1.stack, a(l1, p1, t30.toString()), [
                            3,
                            5
                        ];
                    case 5:
                        return [
                            2
                        ];
                }
            });
        });
    }, t26.prototype.get = function(t34, e19, n15) {
        return i2(this, void 0, void 0, function() {
            return s(this, function(r10) {
                switch(r10.label){
                    case 0:
                        return [
                            4,
                            this.request({
                                method: "GET",
                                url: t34,
                                params: e19,
                                config: n15
                            })
                        ];
                    case 1:
                        return [
                            2,
                            r10.sent()
                        ];
                }
            });
        });
    }, t26.prototype.post = function(t35, e20, n16, r11) {
        return i2(this, void 0, void 0, function() {
            return s(this, function(i6) {
                switch(i6.label){
                    case 0:
                        return [
                            4,
                            this.request({
                                method: "POST",
                                url: t35,
                                body: e20,
                                params: n16,
                                config: r11
                            })
                        ];
                    case 1:
                        return [
                            2,
                            i6.sent()
                        ];
                }
            });
        });
    }, t26.prototype.put = function(t36, e21, n17, r12) {
        return i2(this, void 0, void 0, function() {
            return s(this, function(i7) {
                switch(i7.label){
                    case 0:
                        return [
                            4,
                            this.request({
                                method: "PUT",
                                url: t36,
                                body: e21,
                                params: n17,
                                config: r12
                            })
                        ];
                    case 1:
                        return [
                            2,
                            i7.sent()
                        ];
                }
            });
        });
    }, t26.prototype.patch = function(t37, e22, n18, r13) {
        return i2(this, void 0, void 0, function() {
            return s(this, function(i8) {
                switch(i8.label){
                    case 0:
                        return [
                            4,
                            this.request({
                                method: "PATCH",
                                url: t37,
                                body: e22,
                                params: n18,
                                config: r13
                            })
                        ];
                    case 1:
                        return [
                            2,
                            i8.sent()
                        ];
                }
            });
        });
    }, t26.prototype.delete = function(t38, e23, n19, r14) {
        return i2(this, void 0, void 0, function() {
            return s(this, function(i9) {
                switch(i9.label){
                    case 0:
                        return [
                            4,
                            this.request({
                                method: "DELETE",
                                url: t38,
                                body: e23,
                                params: n19,
                                config: r14
                            })
                        ];
                    case 1:
                        return [
                            2,
                            i9.sent()
                        ];
                }
            });
        });
    }, t26;
}(), b = function() {
    function t39(t40) {
        this.httpRequest = new y(t40);
    }
    return t39.prototype.getClientTask = function(t41) {
        return i2(this, void 0, void 0, function() {
            var e24;
            return s(this, function(n20) {
                switch(n20.label){
                    case 0:
                        return e24 = "tasks/".concat(t41), [
                            4,
                            this.httpRequest.get(e24)
                        ];
                    case 1:
                        return [
                            2,
                            n20.sent()
                        ];
                }
            });
        });
    }, t39.prototype.getClientTasks = function() {
        return i2(this, void 0, void 0, function() {
            return s(this, function(t42) {
                switch(t42.label){
                    case 0:
                        return "tasks", [
                            4,
                            this.httpRequest.get("tasks")
                        ];
                    case 1:
                        return [
                            2,
                            t42.sent()
                        ];
                }
            });
        });
    }, t39.prototype.getIndexTask = function(t43, e25) {
        return i2(this, void 0, void 0, function() {
            var n21;
            return s(this, function(r15) {
                switch(r15.label){
                    case 0:
                        return n21 = "indexes/".concat(t43, "/tasks/").concat(e25), [
                            4,
                            this.httpRequest.get(n21)
                        ];
                    case 1:
                        return [
                            2,
                            r15.sent()
                        ];
                }
            });
        });
    }, t39.prototype.getIndexTasks = function(t44) {
        return i2(this, void 0, void 0, function() {
            var e26;
            return s(this, function(n22) {
                switch(n22.label){
                    case 0:
                        return e26 = "indexes/".concat(t44, "/tasks"), [
                            4,
                            this.httpRequest.get(e26)
                        ];
                    case 1:
                        return [
                            2,
                            n22.sent()
                        ];
                }
            });
        });
    }, t39.prototype.waitForClientTask = function(t45, e27) {
        var n23 = void 0 === e27 ? {} : e27, r16 = n23.timeOutMs, o5 = void 0 === r16 ? 5000 : r16, u6 = n23.intervalMs, c3 = void 0 === u6 ? 50 : u6;
        return i2(this, void 0, void 0, function() {
            var e28, n24;
            return s(this, function(r17) {
                switch(r17.label){
                    case 0:
                        e28 = Date.now(), r17.label = 1;
                    case 1:
                        return Date.now() - e28 < o5 ? [
                            4,
                            this.getClientTask(t45)
                        ] : [
                            3,
                            4
                        ];
                    case 2:
                        return n24 = r17.sent(), [
                            "enqueued",
                            "processing"
                        ].includes(n24.status) ? [
                            4,
                            p(c3)
                        ] : [
                            2,
                            n24
                        ];
                    case 3:
                        return r17.sent(), [
                            3,
                            1
                        ];
                    case 4:
                        throw new d("timeout of ".concat(o5, "ms has exceeded on process ").concat(t45, " when waiting a task to be resolved."));
                }
            });
        });
    }, t39.prototype.waitForClientTasks = function(t46, e29) {
        var n25 = void 0 === e29 ? {} : e29, r18 = n25.timeOutMs, o6 = void 0 === r18 ? 5000 : r18, u7 = n25.intervalMs, c4 = void 0 === u7 ? 50 : u7;
        return i2(this, void 0, void 0, function() {
            var e30, n26, r19, i10, u8;
            return s(this, function(s7) {
                switch(s7.label){
                    case 0:
                        e30 = [], n26 = 0, r19 = t46, s7.label = 1;
                    case 1:
                        return n26 < r19.length ? (i10 = r19[n26], [
                            4,
                            this.waitForClientTask(i10, {
                                timeOutMs: o6,
                                intervalMs: c4
                            })
                        ]) : [
                            3,
                            4
                        ];
                    case 2:
                        u8 = s7.sent(), e30.push(u8), s7.label = 3;
                    case 3:
                        return n26++, [
                            3,
                            1
                        ];
                    case 4:
                        return [
                            2,
                            {
                                results: e30
                            }
                        ];
                }
            });
        });
    }, t39.prototype.waitForIndexTask = function(t47, e31, n27) {
        var r20 = void 0 === n27 ? {} : n27, o7 = r20.timeOutMs, u9 = void 0 === o7 ? 5000 : o7, c5 = r20.intervalMs, a2 = void 0 === c5 ? 50 : c5;
        return i2(this, void 0, void 0, function() {
            var n28, r21;
            return s(this, function(i11) {
                switch(i11.label){
                    case 0:
                        n28 = Date.now(), i11.label = 1;
                    case 1:
                        return Date.now() - n28 < u9 ? [
                            4,
                            this.getIndexTask(t47, e31)
                        ] : [
                            3,
                            4
                        ];
                    case 2:
                        return r21 = i11.sent(), [
                            "enqueued",
                            "processing"
                        ].includes(r21.status) ? [
                            4,
                            p(a2)
                        ] : [
                            2,
                            r21
                        ];
                    case 3:
                        return i11.sent(), [
                            3,
                            1
                        ];
                    case 4:
                        throw new d("timeout of ".concat(u9, "ms has exceeded on process ").concat(e31, " when waiting for pending update to resolve."));
                }
            });
        });
    }, t39;
}(), w = function() {
    function t48(t49, e32, n29) {
        this.uid = e32, this.primaryKey = n29, this.httpRequest = new y(t49), this.tasks = new b(t49);
    }
    return t48.prototype.search = function(t50, e33, n30) {
        return i2(this, void 0, void 0, function() {
            var i12;
            return s(this, function(s8) {
                switch(s8.label){
                    case 0:
                        return i12 = "indexes/".concat(this.uid, "/search"), [
                            4,
                            this.httpRequest.post(i12, l(r(r({}, e33), {
                                q: t50
                            })), void 0, n30)
                        ];
                    case 1:
                        return [
                            2,
                            s8.sent()
                        ];
                }
            });
        });
    }, t48.prototype.searchGet = function(t51, e34, n31) {
        var o8, u10, c6, a3, d2;
        return i2(this, void 0, void 0, function() {
            var i13, p2, f1;
            return s(this, function(s9) {
                switch(s9.label){
                    case 0:
                        return i13 = "indexes/".concat(this.uid, "/search"), p2 = function(t52) {
                            if ("string" == typeof t52) return t52;
                            if (Array.isArray(t52)) throw new h("The filter query parameter should be in string format when using searchGet");
                        }, f1 = r(r({
                            q: t51
                        }, e34), {
                            filter: p2(null == e34 ? void 0 : e34.filter),
                            sort: null === (o8 = null == e34 ? void 0 : e34.sort) || void 0 === o8 ? void 0 : o8.join(","),
                            facetsDistribution: null === (u10 = null == e34 ? void 0 : e34.facetsDistribution) || void 0 === u10 ? void 0 : u10.join(","),
                            attributesToRetrieve: null === (c6 = null == e34 ? void 0 : e34.attributesToRetrieve) || void 0 === c6 ? void 0 : c6.join(","),
                            attributesToCrop: null === (a3 = null == e34 ? void 0 : e34.attributesToCrop) || void 0 === a3 ? void 0 : a3.join(","),
                            attributesToHighlight: null === (d2 = null == e34 ? void 0 : e34.attributesToHighlight) || void 0 === d2 ? void 0 : d2.join(",")
                        }), [
                            4,
                            this.httpRequest.get(i13, l(f1), n31)
                        ];
                    case 1:
                        return [
                            2,
                            s9.sent()
                        ];
                }
            });
        });
    }, t48.prototype.getRawInfo = function() {
        return i2(this, void 0, void 0, function() {
            var t53, e35;
            return s(this, function(n32) {
                switch(n32.label){
                    case 0:
                        return t53 = "indexes/".concat(this.uid), [
                            4,
                            this.httpRequest.get(t53)
                        ];
                    case 1:
                        return e35 = n32.sent(), this.primaryKey = e35.primaryKey, [
                            2,
                            e35
                        ];
                }
            });
        });
    }, t48.prototype.fetchInfo = function() {
        return i2(this, void 0, void 0, function() {
            return s(this, function(t54) {
                switch(t54.label){
                    case 0:
                        return [
                            4,
                            this.getRawInfo()
                        ];
                    case 1:
                        return t54.sent(), [
                            2,
                            this
                        ];
                }
            });
        });
    }, t48.prototype.fetchPrimaryKey = function() {
        return i2(this, void 0, void 0, function() {
            var t55;
            return s(this, function(e36) {
                switch(e36.label){
                    case 0:
                        return t55 = this, [
                            4,
                            this.getRawInfo()
                        ];
                    case 1:
                        return t55.primaryKey = e36.sent().primaryKey, [
                            2,
                            this.primaryKey
                        ];
                }
            });
        });
    }, t48.create = function(t56, e37, n33) {
        return void 0 === e37 && (e37 = {}), i2(this, void 0, void 0, function() {
            return s(this, function(i) {
                return "indexes", [
                    2,
                    new y(n33).post("indexes", r(r({}, e37), {
                        uid: t56
                    }))
                ];
            });
        });
    }, t48.prototype.update = function(t57) {
        return i2(this, void 0, void 0, function() {
            var e38;
            return s(this, function(n34) {
                switch(n34.label){
                    case 0:
                        return e38 = "indexes/".concat(this.uid), [
                            4,
                            this.httpRequest.put(e38, t57)
                        ];
                    case 1:
                        return [
                            2,
                            n34.sent()
                        ];
                }
            });
        });
    }, t48.prototype.delete = function() {
        return i2(this, void 0, void 0, function() {
            var t58;
            return s(this, function(e39) {
                switch(e39.label){
                    case 0:
                        return t58 = "indexes/".concat(this.uid), [
                            4,
                            this.httpRequest.delete(t58)
                        ];
                    case 1:
                        return [
                            2,
                            e39.sent()
                        ];
                }
            });
        });
    }, t48.prototype.getTasks = function() {
        return i2(this, void 0, void 0, function() {
            return s(this, function(t59) {
                switch(t59.label){
                    case 0:
                        return [
                            4,
                            this.tasks.getIndexTasks(this.uid)
                        ];
                    case 1:
                        return [
                            2,
                            t59.sent()
                        ];
                }
            });
        });
    }, t48.prototype.getTask = function(t60) {
        return i2(this, void 0, void 0, function() {
            return s(this, function(e40) {
                switch(e40.label){
                    case 0:
                        return [
                            4,
                            this.tasks.getIndexTask(this.uid, t60)
                        ];
                    case 1:
                        return [
                            2,
                            e40.sent()
                        ];
                }
            });
        });
    }, t48.prototype.waitForTasks = function(t61, e41) {
        var n35 = void 0 === e41 ? {} : e41, r22 = n35.timeOutMs, o9 = void 0 === r22 ? 5000 : r22, u11 = n35.intervalMs, c7 = void 0 === u11 ? 50 : u11;
        return i2(this, void 0, void 0, function() {
            return s(this, function(e42) {
                switch(e42.label){
                    case 0:
                        return [
                            4,
                            this.tasks.waitForClientTasks(t61, {
                                timeOutMs: o9,
                                intervalMs: c7
                            })
                        ];
                    case 1:
                        return [
                            2,
                            e42.sent()
                        ];
                }
            });
        });
    }, t48.prototype.waitForTask = function(t62, e43) {
        var n36 = void 0 === e43 ? {} : e43, r23 = n36.timeOutMs, o10 = void 0 === r23 ? 5000 : r23, u12 = n36.intervalMs, c8 = void 0 === u12 ? 50 : u12;
        return i2(this, void 0, void 0, function() {
            return s(this, function(e44) {
                switch(e44.label){
                    case 0:
                        return [
                            4,
                            this.tasks.waitForClientTask(t62, {
                                timeOutMs: o10,
                                intervalMs: c8
                            })
                        ];
                    case 1:
                        return [
                            2,
                            e44.sent()
                        ];
                }
            });
        });
    }, t48.prototype.getStats = function() {
        return i2(this, void 0, void 0, function() {
            var t63;
            return s(this, function(e45) {
                switch(e45.label){
                    case 0:
                        return t63 = "indexes/".concat(this.uid, "/stats"), [
                            4,
                            this.httpRequest.get(t63)
                        ];
                    case 1:
                        return [
                            2,
                            e45.sent()
                        ];
                }
            });
        });
    }, t48.prototype.getDocuments = function(t64) {
        return i2(this, void 0, void 0, function() {
            var e46, n37;
            return s(this, function(i14) {
                switch(i14.label){
                    case 0:
                        return e46 = "indexes/".concat(this.uid, "/documents"), void 0 !== t64 && Array.isArray(t64.attributesToRetrieve) && (n37 = t64.attributesToRetrieve.join(",")), [
                            4,
                            this.httpRequest.get(e46, r(r({}, t64), void 0 !== n37 ? {
                                attributesToRetrieve: n37
                            } : {}))
                        ];
                    case 1:
                        return [
                            2,
                            i14.sent()
                        ];
                }
            });
        });
    }, t48.prototype.getDocument = function(t65) {
        return i2(this, void 0, void 0, function() {
            var e47;
            return s(this, function(n38) {
                switch(n38.label){
                    case 0:
                        return e47 = "indexes/".concat(this.uid, "/documents/").concat(t65), [
                            4,
                            this.httpRequest.get(e47)
                        ];
                    case 1:
                        return [
                            2,
                            n38.sent()
                        ];
                }
            });
        });
    }, t48.prototype.addDocuments = function(t66, e48) {
        return i2(this, void 0, void 0, function() {
            var n39;
            return s(this, function(r24) {
                switch(r24.label){
                    case 0:
                        return n39 = "indexes/".concat(this.uid, "/documents"), [
                            4,
                            this.httpRequest.post(n39, t66, e48)
                        ];
                    case 1:
                        return [
                            2,
                            r24.sent()
                        ];
                }
            });
        });
    }, t48.prototype.addDocumentsInBatches = function(t67, e49, n40) {
        return void 0 === e49 && (e49 = 1000), i2(this, void 0, void 0, function() {
            var r25, i15, o11, u13;
            return s(this, function(s10) {
                switch(s10.label){
                    case 0:
                        r25 = [], i15 = 0, s10.label = 1;
                    case 1:
                        return i15 < t67.length ? (u13 = (o11 = r25).push, [
                            4,
                            this.addDocuments(t67.slice(i15, i15 + e49), n40)
                        ]) : [
                            3,
                            4
                        ];
                    case 2:
                        u13.apply(o11, [
                            s10.sent()
                        ]), s10.label = 3;
                    case 3:
                        return i15 += e49, [
                            3,
                            1
                        ];
                    case 4:
                        return [
                            2,
                            r25
                        ];
                }
            });
        });
    }, t48.prototype.updateDocuments = function(t68, e50) {
        return i2(this, void 0, void 0, function() {
            var n41;
            return s(this, function(r26) {
                switch(r26.label){
                    case 0:
                        return n41 = "indexes/".concat(this.uid, "/documents"), [
                            4,
                            this.httpRequest.put(n41, t68, e50)
                        ];
                    case 1:
                        return [
                            2,
                            r26.sent()
                        ];
                }
            });
        });
    }, t48.prototype.updateDocumentsInBatches = function(t69, e51, n42) {
        return void 0 === e51 && (e51 = 1000), i2(this, void 0, void 0, function() {
            var r27, i16, o12, u14;
            return s(this, function(s11) {
                switch(s11.label){
                    case 0:
                        r27 = [], i16 = 0, s11.label = 1;
                    case 1:
                        return i16 < t69.length ? (u14 = (o12 = r27).push, [
                            4,
                            this.updateDocuments(t69.slice(i16, i16 + e51), n42)
                        ]) : [
                            3,
                            4
                        ];
                    case 2:
                        u14.apply(o12, [
                            s11.sent()
                        ]), s11.label = 3;
                    case 3:
                        return i16 += e51, [
                            3,
                            1
                        ];
                    case 4:
                        return [
                            2,
                            r27
                        ];
                }
            });
        });
    }, t48.prototype.deleteDocument = function(t70) {
        return i2(this, void 0, void 0, function() {
            var e52;
            return s(this, function(n43) {
                switch(n43.label){
                    case 0:
                        return e52 = "indexes/".concat(this.uid, "/documents/").concat(t70), [
                            4,
                            this.httpRequest.delete(e52)
                        ];
                    case 1:
                        return [
                            2,
                            n43.sent()
                        ];
                }
            });
        });
    }, t48.prototype.deleteDocuments = function(t71) {
        return i2(this, void 0, void 0, function() {
            var e53;
            return s(this, function(n44) {
                switch(n44.label){
                    case 0:
                        return e53 = "indexes/".concat(this.uid, "/documents/delete-batch"), [
                            4,
                            this.httpRequest.post(e53, t71)
                        ];
                    case 1:
                        return [
                            2,
                            n44.sent()
                        ];
                }
            });
        });
    }, t48.prototype.deleteAllDocuments = function() {
        return i2(this, void 0, void 0, function() {
            var t72;
            return s(this, function(e54) {
                switch(e54.label){
                    case 0:
                        return t72 = "indexes/".concat(this.uid, "/documents"), [
                            4,
                            this.httpRequest.delete(t72)
                        ];
                    case 1:
                        return [
                            2,
                            e54.sent()
                        ];
                }
            });
        });
    }, t48.prototype.getSettings = function() {
        return i2(this, void 0, void 0, function() {
            var t73;
            return s(this, function(e55) {
                switch(e55.label){
                    case 0:
                        return t73 = "indexes/".concat(this.uid, "/settings"), [
                            4,
                            this.httpRequest.get(t73)
                        ];
                    case 1:
                        return [
                            2,
                            e55.sent()
                        ];
                }
            });
        });
    }, t48.prototype.updateSettings = function(t74) {
        return i2(this, void 0, void 0, function() {
            var e56;
            return s(this, function(n45) {
                switch(n45.label){
                    case 0:
                        return e56 = "indexes/".concat(this.uid, "/settings"), [
                            4,
                            this.httpRequest.post(e56, t74)
                        ];
                    case 1:
                        return [
                            2,
                            n45.sent()
                        ];
                }
            });
        });
    }, t48.prototype.resetSettings = function() {
        return i2(this, void 0, void 0, function() {
            var t75;
            return s(this, function(e57) {
                switch(e57.label){
                    case 0:
                        return t75 = "indexes/".concat(this.uid, "/settings"), [
                            4,
                            this.httpRequest.delete(t75)
                        ];
                    case 1:
                        return [
                            2,
                            e57.sent()
                        ];
                }
            });
        });
    }, t48.prototype.getSynonyms = function() {
        return i2(this, void 0, void 0, function() {
            var t76;
            return s(this, function(e58) {
                switch(e58.label){
                    case 0:
                        return t76 = "indexes/".concat(this.uid, "/settings/synonyms"), [
                            4,
                            this.httpRequest.get(t76)
                        ];
                    case 1:
                        return [
                            2,
                            e58.sent()
                        ];
                }
            });
        });
    }, t48.prototype.updateSynonyms = function(t77) {
        return i2(this, void 0, void 0, function() {
            var e59;
            return s(this, function(n46) {
                switch(n46.label){
                    case 0:
                        return e59 = "indexes/".concat(this.uid, "/settings/synonyms"), [
                            4,
                            this.httpRequest.post(e59, t77)
                        ];
                    case 1:
                        return [
                            2,
                            n46.sent()
                        ];
                }
            });
        });
    }, t48.prototype.resetSynonyms = function() {
        return i2(this, void 0, void 0, function() {
            var t78;
            return s(this, function(e60) {
                switch(e60.label){
                    case 0:
                        return t78 = "indexes/".concat(this.uid, "/settings/synonyms"), [
                            4,
                            this.httpRequest.delete(t78)
                        ];
                    case 1:
                        return [
                            2,
                            e60.sent()
                        ];
                }
            });
        });
    }, t48.prototype.getStopWords = function() {
        return i2(this, void 0, void 0, function() {
            var t79;
            return s(this, function(e61) {
                switch(e61.label){
                    case 0:
                        return t79 = "indexes/".concat(this.uid, "/settings/stop-words"), [
                            4,
                            this.httpRequest.get(t79)
                        ];
                    case 1:
                        return [
                            2,
                            e61.sent()
                        ];
                }
            });
        });
    }, t48.prototype.updateStopWords = function(t80) {
        return i2(this, void 0, void 0, function() {
            var e62;
            return s(this, function(n47) {
                switch(n47.label){
                    case 0:
                        return e62 = "indexes/".concat(this.uid, "/settings/stop-words"), [
                            4,
                            this.httpRequest.post(e62, t80)
                        ];
                    case 1:
                        return [
                            2,
                            n47.sent()
                        ];
                }
            });
        });
    }, t48.prototype.resetStopWords = function() {
        return i2(this, void 0, void 0, function() {
            var t81;
            return s(this, function(e63) {
                switch(e63.label){
                    case 0:
                        return t81 = "indexes/".concat(this.uid, "/settings/stop-words"), [
                            4,
                            this.httpRequest.delete(t81)
                        ];
                    case 1:
                        return [
                            2,
                            e63.sent()
                        ];
                }
            });
        });
    }, t48.prototype.getRankingRules = function() {
        return i2(this, void 0, void 0, function() {
            var t82;
            return s(this, function(e64) {
                switch(e64.label){
                    case 0:
                        return t82 = "indexes/".concat(this.uid, "/settings/ranking-rules"), [
                            4,
                            this.httpRequest.get(t82)
                        ];
                    case 1:
                        return [
                            2,
                            e64.sent()
                        ];
                }
            });
        });
    }, t48.prototype.updateRankingRules = function(t83) {
        return i2(this, void 0, void 0, function() {
            var e65;
            return s(this, function(n48) {
                switch(n48.label){
                    case 0:
                        return e65 = "indexes/".concat(this.uid, "/settings/ranking-rules"), [
                            4,
                            this.httpRequest.post(e65, t83)
                        ];
                    case 1:
                        return [
                            2,
                            n48.sent()
                        ];
                }
            });
        });
    }, t48.prototype.resetRankingRules = function() {
        return i2(this, void 0, void 0, function() {
            var t84;
            return s(this, function(e66) {
                switch(e66.label){
                    case 0:
                        return t84 = "indexes/".concat(this.uid, "/settings/ranking-rules"), [
                            4,
                            this.httpRequest.delete(t84)
                        ];
                    case 1:
                        return [
                            2,
                            e66.sent()
                        ];
                }
            });
        });
    }, t48.prototype.getDistinctAttribute = function() {
        return i2(this, void 0, void 0, function() {
            var t85;
            return s(this, function(e67) {
                switch(e67.label){
                    case 0:
                        return t85 = "indexes/".concat(this.uid, "/settings/distinct-attribute"), [
                            4,
                            this.httpRequest.get(t85)
                        ];
                    case 1:
                        return [
                            2,
                            e67.sent()
                        ];
                }
            });
        });
    }, t48.prototype.updateDistinctAttribute = function(t86) {
        return i2(this, void 0, void 0, function() {
            var e68;
            return s(this, function(n49) {
                switch(n49.label){
                    case 0:
                        return e68 = "indexes/".concat(this.uid, "/settings/distinct-attribute"), [
                            4,
                            this.httpRequest.post(e68, t86)
                        ];
                    case 1:
                        return [
                            2,
                            n49.sent()
                        ];
                }
            });
        });
    }, t48.prototype.resetDistinctAttribute = function() {
        return i2(this, void 0, void 0, function() {
            var t87;
            return s(this, function(e69) {
                switch(e69.label){
                    case 0:
                        return t87 = "indexes/".concat(this.uid, "/settings/distinct-attribute"), [
                            4,
                            this.httpRequest.delete(t87)
                        ];
                    case 1:
                        return [
                            2,
                            e69.sent()
                        ];
                }
            });
        });
    }, t48.prototype.getFilterableAttributes = function() {
        return i2(this, void 0, void 0, function() {
            var t88;
            return s(this, function(e70) {
                switch(e70.label){
                    case 0:
                        return t88 = "indexes/".concat(this.uid, "/settings/filterable-attributes"), [
                            4,
                            this.httpRequest.get(t88)
                        ];
                    case 1:
                        return [
                            2,
                            e70.sent()
                        ];
                }
            });
        });
    }, t48.prototype.updateFilterableAttributes = function(t89) {
        return i2(this, void 0, void 0, function() {
            var e71;
            return s(this, function(n50) {
                switch(n50.label){
                    case 0:
                        return e71 = "indexes/".concat(this.uid, "/settings/filterable-attributes"), [
                            4,
                            this.httpRequest.post(e71, t89)
                        ];
                    case 1:
                        return [
                            2,
                            n50.sent()
                        ];
                }
            });
        });
    }, t48.prototype.resetFilterableAttributes = function() {
        return i2(this, void 0, void 0, function() {
            var t90;
            return s(this, function(e72) {
                switch(e72.label){
                    case 0:
                        return t90 = "indexes/".concat(this.uid, "/settings/filterable-attributes"), [
                            4,
                            this.httpRequest.delete(t90)
                        ];
                    case 1:
                        return [
                            2,
                            e72.sent()
                        ];
                }
            });
        });
    }, t48.prototype.getSortableAttributes = function() {
        return i2(this, void 0, void 0, function() {
            var t91;
            return s(this, function(e73) {
                switch(e73.label){
                    case 0:
                        return t91 = "indexes/".concat(this.uid, "/settings/sortable-attributes"), [
                            4,
                            this.httpRequest.get(t91)
                        ];
                    case 1:
                        return [
                            2,
                            e73.sent()
                        ];
                }
            });
        });
    }, t48.prototype.updateSortableAttributes = function(t92) {
        return i2(this, void 0, void 0, function() {
            var e74;
            return s(this, function(n51) {
                switch(n51.label){
                    case 0:
                        return e74 = "indexes/".concat(this.uid, "/settings/sortable-attributes"), [
                            4,
                            this.httpRequest.post(e74, t92)
                        ];
                    case 1:
                        return [
                            2,
                            n51.sent()
                        ];
                }
            });
        });
    }, t48.prototype.resetSortableAttributes = function() {
        return i2(this, void 0, void 0, function() {
            var t93;
            return s(this, function(e75) {
                switch(e75.label){
                    case 0:
                        return t93 = "indexes/".concat(this.uid, "/settings/sortable-attributes"), [
                            4,
                            this.httpRequest.delete(t93)
                        ];
                    case 1:
                        return [
                            2,
                            e75.sent()
                        ];
                }
            });
        });
    }, t48.prototype.getSearchableAttributes = function() {
        return i2(this, void 0, void 0, function() {
            var t94;
            return s(this, function(e76) {
                switch(e76.label){
                    case 0:
                        return t94 = "indexes/".concat(this.uid, "/settings/searchable-attributes"), [
                            4,
                            this.httpRequest.get(t94)
                        ];
                    case 1:
                        return [
                            2,
                            e76.sent()
                        ];
                }
            });
        });
    }, t48.prototype.updateSearchableAttributes = function(t95) {
        return i2(this, void 0, void 0, function() {
            var e77;
            return s(this, function(n52) {
                switch(n52.label){
                    case 0:
                        return e77 = "indexes/".concat(this.uid, "/settings/searchable-attributes"), [
                            4,
                            this.httpRequest.post(e77, t95)
                        ];
                    case 1:
                        return [
                            2,
                            n52.sent()
                        ];
                }
            });
        });
    }, t48.prototype.resetSearchableAttributes = function() {
        return i2(this, void 0, void 0, function() {
            var t96;
            return s(this, function(e78) {
                switch(e78.label){
                    case 0:
                        return t96 = "indexes/".concat(this.uid, "/settings/searchable-attributes"), [
                            4,
                            this.httpRequest.delete(t96)
                        ];
                    case 1:
                        return [
                            2,
                            e78.sent()
                        ];
                }
            });
        });
    }, t48.prototype.getDisplayedAttributes = function() {
        return i2(this, void 0, void 0, function() {
            var t97;
            return s(this, function(e79) {
                switch(e79.label){
                    case 0:
                        return t97 = "indexes/".concat(this.uid, "/settings/displayed-attributes"), [
                            4,
                            this.httpRequest.get(t97)
                        ];
                    case 1:
                        return [
                            2,
                            e79.sent()
                        ];
                }
            });
        });
    }, t48.prototype.updateDisplayedAttributes = function(t98) {
        return i2(this, void 0, void 0, function() {
            var e80;
            return s(this, function(n53) {
                switch(n53.label){
                    case 0:
                        return e80 = "indexes/".concat(this.uid, "/settings/displayed-attributes"), [
                            4,
                            this.httpRequest.post(e80, t98)
                        ];
                    case 1:
                        return [
                            2,
                            n53.sent()
                        ];
                }
            });
        });
    }, t48.prototype.resetDisplayedAttributes = function() {
        return i2(this, void 0, void 0, function() {
            var t99;
            return s(this, function(e81) {
                switch(e81.label){
                    case 0:
                        return t99 = "indexes/".concat(this.uid, "/settings/displayed-attributes"), [
                            4,
                            this.httpRequest.delete(t99)
                        ];
                    case 1:
                        return [
                            2,
                            e81.sent()
                        ];
                }
            });
        });
    }, t48.prototype.getTypoTolerance = function() {
        return i2(this, void 0, void 0, function() {
            var t100;
            return s(this, function(e82) {
                switch(e82.label){
                    case 0:
                        return t100 = "indexes/".concat(this.uid, "/settings/typo-tolerance"), [
                            4,
                            this.httpRequest.get(t100)
                        ];
                    case 1:
                        return [
                            2,
                            e82.sent()
                        ];
                }
            });
        });
    }, t48.prototype.updateTypoTolerance = function(t101) {
        return i2(this, void 0, void 0, function() {
            var e83;
            return s(this, function(n54) {
                switch(n54.label){
                    case 0:
                        return e83 = "indexes/".concat(this.uid, "/settings/typo-tolerance"), [
                            4,
                            this.httpRequest.post(e83, t101)
                        ];
                    case 1:
                        return [
                            2,
                            n54.sent()
                        ];
                }
            });
        });
    }, t48.prototype.resetTypoTolerance = function() {
        return i2(this, void 0, void 0, function() {
            var t102;
            return s(this, function(e84) {
                switch(e84.label){
                    case 0:
                        return t102 = "indexes/".concat(this.uid, "/settings/typo-tolerance"), [
                            4,
                            this.httpRequest.delete(t102)
                        ];
                    case 1:
                        return [
                            2,
                            e84.sent()
                        ];
                }
            });
        });
    }, t48;
}(), g = function() {
    function t103(t104) {
        this.config = t104, this.httpRequest = new y(t104), this.tasks = new b(t104);
    }
    return t103.prototype.index = function(t105) {
        return new w(this.config, t105);
    }, t103.prototype.getIndex = function(t106) {
        return i2(this, void 0, void 0, function() {
            return s(this, function(e) {
                return [
                    2,
                    new w(this.config, t106).fetchInfo()
                ];
            });
        });
    }, t103.prototype.getRawIndex = function(t107) {
        return i2(this, void 0, void 0, function() {
            return s(this, function(e) {
                return [
                    2,
                    new w(this.config, t107).getRawInfo()
                ];
            });
        });
    }, t103.prototype.getIndexes = function() {
        return i2(this, void 0, void 0, function() {
            var t108, e85 = this;
            return s(this, function(n55) {
                switch(n55.label){
                    case 0:
                        return [
                            4,
                            this.getRawIndexes()
                        ];
                    case 1:
                        return t108 = n55.sent(), [
                            2,
                            t108.map(function(t109) {
                                return new w(e85.config, t109.uid, t109.primaryKey);
                            })
                        ];
                }
            });
        });
    }, t103.prototype.getRawIndexes = function() {
        return i2(this, void 0, void 0, function() {
            return s(this, function(t110) {
                switch(t110.label){
                    case 0:
                        return "indexes", [
                            4,
                            this.httpRequest.get("indexes")
                        ];
                    case 1:
                        return [
                            2,
                            t110.sent()
                        ];
                }
            });
        });
    }, t103.prototype.createIndex = function(t111, e86) {
        return void 0 === e86 && (e86 = {}), i2(this, void 0, void 0, function() {
            return s(this, function(n56) {
                switch(n56.label){
                    case 0:
                        return [
                            4,
                            w.create(t111, e86, this.config)
                        ];
                    case 1:
                        return [
                            2,
                            n56.sent()
                        ];
                }
            });
        });
    }, t103.prototype.updateIndex = function(t112, e87) {
        return void 0 === e87 && (e87 = {}), i2(this, void 0, void 0, function() {
            return s(this, function(n57) {
                switch(n57.label){
                    case 0:
                        return [
                            4,
                            new w(this.config, t112).update(e87)
                        ];
                    case 1:
                        return [
                            2,
                            n57.sent()
                        ];
                }
            });
        });
    }, t103.prototype.deleteIndex = function(t113) {
        return i2(this, void 0, void 0, function() {
            return s(this, function(e88) {
                switch(e88.label){
                    case 0:
                        return [
                            4,
                            new w(this.config, t113).delete()
                        ];
                    case 1:
                        return [
                            2,
                            e88.sent()
                        ];
                }
            });
        });
    }, t103.prototype.deleteIndexIfExists = function(t114) {
        return i2(this, void 0, void 0, function() {
            var e89;
            return s(this, function(n58) {
                switch(n58.label){
                    case 0:
                        return n58.trys.push([
                            0,
                            2,
                            ,
                            3
                        ]), [
                            4,
                            this.deleteIndex(t114)
                        ];
                    case 1:
                        return n58.sent(), [
                            2,
                            !0
                        ];
                    case 2:
                        if ("index_not_found" === (e89 = n58.sent()).code) return [
                            2,
                            !1
                        ];
                        throw e89;
                    case 3:
                        return [
                            2
                        ];
                }
            });
        });
    }, t103.prototype.getTasks = function() {
        return i2(this, void 0, void 0, function() {
            return s(this, function(t115) {
                switch(t115.label){
                    case 0:
                        return [
                            4,
                            this.tasks.getClientTasks()
                        ];
                    case 1:
                        return [
                            2,
                            t115.sent()
                        ];
                }
            });
        });
    }, t103.prototype.getTask = function(t116) {
        return i2(this, void 0, void 0, function() {
            return s(this, function(e90) {
                switch(e90.label){
                    case 0:
                        return [
                            4,
                            this.tasks.getClientTask(t116)
                        ];
                    case 1:
                        return [
                            2,
                            e90.sent()
                        ];
                }
            });
        });
    }, t103.prototype.waitForTasks = function(t117, e91) {
        var n59 = void 0 === e91 ? {} : e91, r28 = n59.timeOutMs, o13 = void 0 === r28 ? 5000 : r28, u15 = n59.intervalMs, c9 = void 0 === u15 ? 50 : u15;
        return i2(this, void 0, void 0, function() {
            return s(this, function(e92) {
                switch(e92.label){
                    case 0:
                        return [
                            4,
                            this.tasks.waitForClientTasks(t117, {
                                timeOutMs: o13,
                                intervalMs: c9
                            })
                        ];
                    case 1:
                        return [
                            2,
                            e92.sent()
                        ];
                }
            });
        });
    }, t103.prototype.waitForTask = function(t118, e93) {
        var n60 = void 0 === e93 ? {} : e93, r29 = n60.timeOutMs, o14 = void 0 === r29 ? 5000 : r29, u16 = n60.intervalMs, c10 = void 0 === u16 ? 50 : u16;
        return i2(this, void 0, void 0, function() {
            return s(this, function(e94) {
                switch(e94.label){
                    case 0:
                        return [
                            4,
                            this.tasks.waitForClientTask(t118, {
                                timeOutMs: o14,
                                intervalMs: c10
                            })
                        ];
                    case 1:
                        return [
                            2,
                            e94.sent()
                        ];
                }
            });
        });
    }, t103.prototype.getKeys = function() {
        return i2(this, void 0, void 0, function() {
            return s(this, function(t119) {
                switch(t119.label){
                    case 0:
                        return "keys", [
                            4,
                            this.httpRequest.get("keys")
                        ];
                    case 1:
                        return [
                            2,
                            t119.sent()
                        ];
                }
            });
        });
    }, t103.prototype.getKey = function(t120) {
        return i2(this, void 0, void 0, function() {
            var e95;
            return s(this, function(n61) {
                switch(n61.label){
                    case 0:
                        return e95 = "keys/".concat(t120), [
                            4,
                            this.httpRequest.get(e95)
                        ];
                    case 1:
                        return [
                            2,
                            n61.sent()
                        ];
                }
            });
        });
    }, t103.prototype.createKey = function(t121) {
        return i2(this, void 0, void 0, function() {
            return s(this, function(e96) {
                switch(e96.label){
                    case 0:
                        return "keys", [
                            4,
                            this.httpRequest.post("keys", t121)
                        ];
                    case 1:
                        return [
                            2,
                            e96.sent()
                        ];
                }
            });
        });
    }, t103.prototype.updateKey = function(t122, e97) {
        return i2(this, void 0, void 0, function() {
            var n62;
            return s(this, function(r30) {
                switch(r30.label){
                    case 0:
                        return n62 = "keys/".concat(t122), [
                            4,
                            this.httpRequest.patch(n62, e97)
                        ];
                    case 1:
                        return [
                            2,
                            r30.sent()
                        ];
                }
            });
        });
    }, t103.prototype.deleteKey = function(t123) {
        return i2(this, void 0, void 0, function() {
            var e98;
            return s(this, function(n63) {
                switch(n63.label){
                    case 0:
                        return e98 = "keys/".concat(t123), [
                            4,
                            this.httpRequest.delete(e98)
                        ];
                    case 1:
                        return [
                            2,
                            n63.sent()
                        ];
                }
            });
        });
    }, t103.prototype.health = function() {
        return i2(this, void 0, void 0, function() {
            return s(this, function(t124) {
                switch(t124.label){
                    case 0:
                        return "health", [
                            4,
                            this.httpRequest.get("health")
                        ];
                    case 1:
                        return [
                            2,
                            t124.sent()
                        ];
                }
            });
        });
    }, t103.prototype.isHealthy = function() {
        return i2(this, void 0, void 0, function() {
            return s(this, function(t125) {
                switch(t125.label){
                    case 0:
                        return t125.trys.push([
                            0,
                            2,
                            ,
                            3
                        ]), [
                            4,
                            this.httpRequest.get("health")
                        ];
                    case 1:
                        return t125.sent(), [
                            2,
                            !0
                        ];
                    case 2:
                        return t125.sent(), [
                            2,
                            !1
                        ];
                    case 3:
                        return [
                            2
                        ];
                }
            });
        });
    }, t103.prototype.getStats = function() {
        return i2(this, void 0, void 0, function() {
            return s(this, function(t126) {
                switch(t126.label){
                    case 0:
                        return "stats", [
                            4,
                            this.httpRequest.get("stats")
                        ];
                    case 1:
                        return [
                            2,
                            t126.sent()
                        ];
                }
            });
        });
    }, t103.prototype.getVersion = function() {
        return i2(this, void 0, void 0, function() {
            return s(this, function(t127) {
                switch(t127.label){
                    case 0:
                        return "version", [
                            4,
                            this.httpRequest.get("version")
                        ];
                    case 1:
                        return [
                            2,
                            t127.sent()
                        ];
                }
            });
        });
    }, t103.prototype.createDump = function() {
        return i2(this, void 0, void 0, function() {
            return s(this, function(t128) {
                switch(t128.label){
                    case 0:
                        return "dumps", [
                            4,
                            this.httpRequest.post("dumps")
                        ];
                    case 1:
                        return [
                            2,
                            t128.sent()
                        ];
                }
            });
        });
    }, t103.prototype.getDumpStatus = function(t129) {
        return i2(this, void 0, void 0, function() {
            var e99;
            return s(this, function(n64) {
                switch(n64.label){
                    case 0:
                        return e99 = "dumps/".concat(t129, "/status"), [
                            4,
                            this.httpRequest.get(e99)
                        ];
                    case 1:
                        return [
                            2,
                            n64.sent()
                        ];
                }
            });
        });
    }, t103.prototype.generateTenantToken = function(t, e) {
        var n65 = new Error;
        throw new Error("Meilisearch: failed to generate a tenant token. Generation of a token only works in a node environment \n ".concat(n65.stack, "."));
    }, t103;
}();
function m1(t130) {
    return Buffer.from(JSON.stringify(t130)).toString("base64");
}
function k(t131) {
    var e100 = t131.searchRules, n66 = t131.apiKey, r31 = t131.expiresAt;
    return (function(t132) {
        var e101 = t132.searchRules, n67 = t132.apiKey, r32 = t132.expiresAt, i17 = new Error;
        if (r32 && (!(r32 instanceof Date) || r32.getTime() < Date.now())) throw new Error("Meilisearch: When the expiresAt field in the token generation has a value, it must be a date set in the future and not in the past. \n ".concat(i17.stack, "."));
        if (e101 && "object" != typeof e101 && !Array.isArray(e101)) throw new Error("Meilisearch: The search rules added in the token generation must be of type array or object. \n ".concat(i17.stack, "."));
        if (!n67 || "string" != typeof n67) throw new Error("Meilisearch: The API key used for the token generation must exist and be of type string. \n ".concat(i17.stack, "."));
    })(t131), m1({
        searchRules: e100,
        apiKeyPrefix: n66.substring(0, 8),
        exp: null == r31 ? void 0 : r31.getTime()
    }).replace(/=/g, "");
}
var R1 = function() {
    function e102(t133) {
        this.config = t133;
    }
    return e102.prototype.generateTenantToken = function(e103, n68) {
        var r33 = (null == n68 ? void 0 : n68.apiKey) || this.config.apiKey || "", i18 = null == n68 ? void 0 : n68.expiresAt, s12 = m1({
            alg: "HS256",
            typ: "JWT"
        }).replace(/=/g, ""), o15 = k({
            searchRules: e103,
            apiKey: r33,
            expiresAt: i18
        }), u17 = function(e104, n69, r34) {
            return t.createHmac("sha256", e104).update("".concat(n69, ".").concat(r34)).digest("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
        }(r33, s12, o15);
        return "".concat(s12, ".").concat(o15, ".").concat(u17);
    }, e102;
}(), x = function(t134) {
    function e105(e106) {
        var n70 = t134.call(this, e106) || this;
        return n70.tokens = new R1(e106), n70;
    }
    return n(e105, t134), e105.prototype.generateTenantToken = function(e107, n71) {
        return "undefined" == typeof window ? this.tokens.generateTenantToken(e107, n71) : t134.prototype.generateTenantToken.call(this, e107, n71);
    }, e105;
}(g);
export { y as HttpRequests, w as Index, x as MeiliSearch, u as MeiliSearchApiError, o as MeiliSearchCommunicationError, h as MeiliSearchError, d as MeiliSearchTimeOutError, f as addProtocolIfNotPresent, v as addTrailingSlash, x as default, a as httpErrorHandler, c as httpResponseErrorHandler, l as removeUndefinedFromObject, p as sleep };

